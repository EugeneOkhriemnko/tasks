/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.3.0 (NJsonSchema v10.4.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class AuthApiBase {
  authToken = "";
  protected constructor() {}

  setAuthToken(token: string) {
    this.authToken = token;
  }

  protected transformOptions(options: any): Promise<any> {
    options.headers['authorization'] =  `Bearer ${this.authToken}`;
    return Promise.resolve(options);
  }
}

export class AuthorizationClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  exchange(): Promise<void> {
    let url_ = this.baseUrl + "/connect/token";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processExchange(_response);
      });
  }

  protected processExchange(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class ExternalSignInClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param authenticationType (optional)
   * @return Success
   */
  signIn(authenticationType: string | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/externalsignin?";
    if (authenticationType !== undefined && authenticationType !== null)
      url_ +=
        "authenticationType=" +
        encodeURIComponent("" + authenticationType) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSignIn(_response);
      });
  }

  protected processSignIn(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param returnUrl (optional)
   * @return Success
   */
  signInCallback(returnUrl: string | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/externalsignin/callback?";
    if (returnUrl !== undefined && returnUrl !== null)
      url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSignInCallback(_response);
      });
  }

  protected processSignInCallback(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @return Success
   */
  getExternalLoginProviders(): Promise<void> {
    let url_ = this.baseUrl + "/externalsignin/providers";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetExternalLoginProviders(_response);
      });
  }

  protected processGetExternalLoginProviders(
    response: Response
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class AssetEntryClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * SearchAsync for AssetEntries by AssetEntrySearchCriteria
   * @param body (optional)
   * @return Success
   */
  search(
    body: AssetEntrySearchCriteria | undefined
  ): Promise<AssetEntrySearchResult> {
    let url_ = this.baseUrl + "/api/platform/assetentries/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearch(_response);
      });
  }

  protected processSearch(response: Response): Promise<AssetEntrySearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = AssetEntrySearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<AssetEntrySearchResult>(<any>null);
  }

  /**
   * Get asset details by id
   * @param idQuery (optional)
   * @return Success
   */
  get(idQuery: string | null | undefined, idPath: string): Promise<AssetEntry> {
    let url_ = this.baseUrl + "/api/platform/assetentries/{id}?";
    if (idPath === undefined || idPath === null)
      throw new Error("The parameter 'idPath' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
    if (idQuery !== undefined && idQuery !== null)
      url_ += "id=" + encodeURIComponent("" + idQuery) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGet(_response);
      });
  }

  protected processGet(response: Response): Promise<AssetEntry> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = AssetEntry.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<AssetEntry>(<any>null);
  }

  /**
   * Create / Update asset entry
   * @param body (optional)
   * @return Success
   */
  update(body: AssetEntry | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/platform/assetentries";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdate(_response);
      });
  }

  protected processUpdate(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete asset entries by ids
   * @param ids (optional)
   * @return Success
   */
  delete(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/platform/assetentries?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDelete(_response);
      });
  }

  protected processDelete(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class AssetsClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * This method used to upload files on local disk storage in special uploads folder
   * @return Success
   */
  uploadAssetToLocalFileSystem(): Promise<BlobInfo[]> {
    let url_ = this.baseUrl + "/api/platform/assets/localstorage";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUploadAssetToLocalFileSystem(_response);
      });
  }

  protected processUploadAssetToLocalFileSystem(
    response: Response
  ): Promise<BlobInfo[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(BlobInfo.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<BlobInfo[]>(<any>null);
  }

  /**
   * Upload assets to the folder
   * @param folderUrl (optional) Parent folder url (relative or absolute).
   * @param url (optional) Url for uploaded remote resource (optional)
   * @param name (optional) File name
   * @param uploadedFile (optional) Upload File
   * @return Success
   */
  uploadAsset(
    folderUrl: string | null | undefined,
    url: string | null | undefined,
    name: string | null | undefined,
    uploadedFile: string | undefined
  ): Promise<BlobInfo[]> {
    let url_ = this.baseUrl + "/api/platform/assets?";
    if (folderUrl !== undefined && folderUrl !== null)
      url_ += "folderUrl=" + encodeURIComponent("" + folderUrl) + "&";
    if (url !== undefined && url !== null)
      url_ += "url=" + encodeURIComponent("" + url) + "&";
    if (name !== undefined && name !== null)
      url_ += "name=" + encodeURIComponent("" + name) + "&";
    if (uploadedFile === null)
      throw new Error("The parameter 'uploadedFile' cannot be null.");
    else if (uploadedFile !== undefined)
      url_ += "uploadedFile=" + encodeURIComponent("" + uploadedFile) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUploadAsset(_response);
      });
  }

  protected processUploadAsset(response: Response): Promise<BlobInfo[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(BlobInfo.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<BlobInfo[]>(<any>null);
  }

  /**
   * Delete blobs by urls
   * @param urls (optional)
   * @return Success
   */
  deleteBlobs(urls: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/platform/assets?";
    if (urls !== undefined && urls !== null)
      urls &&
        urls.forEach((item) => {
          url_ += "urls=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteBlobs(_response);
      });
  }

  protected processDeleteBlobs(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * SearchAsync asset folders and blobs
   * @param folderUrl (optional)
   * @param keyword (optional)
   * @return Success
   */
  searchAssetItems(
    folderUrl: string | null | undefined,
    keyword: string | null | undefined
  ): Promise<BlobEntrySearchResult> {
    let url_ = this.baseUrl + "/api/platform/assets?";
    if (folderUrl !== undefined && folderUrl !== null)
      url_ += "folderUrl=" + encodeURIComponent("" + folderUrl) + "&";
    if (keyword !== undefined && keyword !== null)
      url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchAssetItems(_response);
      });
  }

  protected processSearchAssetItems(
    response: Response
  ): Promise<BlobEntrySearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = BlobEntrySearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<BlobEntrySearchResult>(<any>null);
  }

  /**
   * Create new blob folder
   * @param body (optional)
   * @return Success
   */
  createBlobFolder(body: BlobFolder | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/platform/assets/folder";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateBlobFolder(_response);
      });
  }

  protected processCreateBlobFolder(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException("Bad Request", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class ChangeLogClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Force set changes last modified date
   * @param scope (optional)
   * @return Success
   */
  forceChanges(scope: string | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/changes/force?";
    if (scope !== undefined && scope !== null)
      url_ += "Scope=" + encodeURIComponent("" + scope) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processForceChanges(_response);
      });
  }

  protected processForceChanges(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @return Success
   */
  resetPlatformCache(): Promise<void> {
    let url_ = this.baseUrl + "/api/platform-cache/reset";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processResetPlatformCache(_response);
      });
  }

  protected processResetPlatformCache(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
       * Get last modified date for given scope
      Used for signal of what something changed and for cache invalidation in external platform clients
       * @param scope (optional) 
       * @return Success
       */
  getLastModifiedDate(
    scope: string | null | undefined
  ): Promise<LastModifiedResponse> {
    let url_ = this.baseUrl + "/api/changes/lastmodifieddate?";
    if (scope !== undefined && scope !== null)
      url_ += "scope=" + encodeURIComponent("" + scope) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetLastModifiedDate(_response);
      });
  }

  protected processGetLastModifiedDate(
    response: Response
  ): Promise<LastModifiedResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = LastModifiedResponse.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<LastModifiedResponse>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getChangedEntities(
    body: ChangedEntitiesRequest | undefined
  ): Promise<ChangedEntitiesResponse> {
    let url_ = this.baseUrl + "/api/changes/changed-entities";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetChangedEntities(_response);
      });
  }

  protected processGetChangedEntities(
    response: Response
  ): Promise<ChangedEntitiesResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ChangedEntitiesResponse.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ChangedEntitiesResponse>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  resetChangedEntities(body: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/changes/changed-entities/reset";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processResetChangedEntities(_response);
      });
  }

  protected processResetChangedEntities(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  searchChanges(
    body: ChangeLogSearchCriteria | undefined
  ): Promise<ChangeLogSearchResult> {
    let url_ = this.baseUrl + "/api/platform/changelog/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchChanges(_response);
      });
  }

  protected processSearchChanges(
    response: Response
  ): Promise<ChangeLogSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ChangeLogSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ChangeLogSearchResult>(<any>null);
  }

  /**
   * @param start (optional)
   * @param end (optional)
   * @return Success
   */
  searchTypeChangeHistory(
    type: string | null,
    start: Date | null | undefined,
    end: Date | null | undefined
  ): Promise<OperationLog[]> {
    let url_ = this.baseUrl + "/api/platform/changelog/{type}/changes?";
    if (type === undefined || type === null)
      throw new Error("The parameter 'type' must be defined.");
    url_ = url_.replace("{type}", encodeURIComponent("" + type));
    if (start !== undefined && start !== null)
      url_ +=
        "start=" + encodeURIComponent(start ? "" + start.toJSON() : "") + "&";
    if (end !== undefined && end !== null)
      url_ += "end=" + encodeURIComponent(end ? "" + end.toJSON() : "") + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchTypeChangeHistory(_response);
      });
  }

  protected processSearchTypeChangeHistory(
    response: Response
  ): Promise<OperationLog[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(OperationLog.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<OperationLog[]>(<any>null);
  }
}

export class DiagnosticsClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  getSystemInfo(): Promise<SystemInfo> {
    let url_ = this.baseUrl + "/api/platform/diagnostics/systeminfo";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetSystemInfo(_response);
      });
  }

  protected processGetSystemInfo(response: Response): Promise<SystemInfo> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SystemInfo.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<SystemInfo>(<any>null);
  }

  /**
   * Get installed modules with errors
   * @return Success
   */
  getModulesErrors(): Promise<ModuleDescriptor[]> {
    let url_ = this.baseUrl + "/api/platform/diagnostics/errors";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetModulesErrors(_response);
      });
  }

  protected processGetModulesErrors(
    response: Response
  ): Promise<ModuleDescriptor[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ModuleDescriptor.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ModuleDescriptor[]>(<any>null);
  }
}

export class DynamicPropertiesClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Get object types which support dynamic properties
   * @return Success
   */
  getObjectTypes(): Promise<string[]> {
    let url_ = this.baseUrl + "/api/platform/dynamic/types";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetObjectTypes(_response);
      });
  }

  protected processGetObjectTypes(response: Response): Promise<string[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(item);
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<string[]>(<any>null);
  }

  /**
   * Get dynamic properties registered for object type
   * @param body (optional)
   * @return Success
   */
  searchDynamicProperties(
    body: DynamicPropertySearchCriteria | undefined
  ): Promise<DynamicPropertySearchResult> {
    let url_ = this.baseUrl + "/api/platform/dynamic/properties/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchDynamicProperties(_response);
      });
  }

  protected processSearchDynamicProperties(
    response: Response
  ): Promise<DynamicPropertySearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DynamicPropertySearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DynamicPropertySearchResult>(<any>null);
  }

  /**
   * Add new dynamic property
   * @param body (optional)
   * @return Success
   */
  createProperty(body: DynamicProperty | undefined): Promise<DynamicProperty> {
    let url_ = this.baseUrl + "/api/platform/dynamic/properties";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateProperty(_response);
      });
  }

  protected processCreateProperty(
    response: Response
  ): Promise<DynamicProperty> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DynamicProperty.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DynamicProperty>(<any>null);
  }

  /**
   * Update existing dynamic property
   * @param body (optional)
   * @return Success
   */
  updateProperty(body: DynamicProperty | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/platform/dynamic/properties";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateProperty(_response);
      });
  }

  protected processUpdateProperty(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete dynamic property
   * @param propertyIds (optional)
   * @return Success
   */
  deleteProperty(propertyIds: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/platform/dynamic/properties?";
    if (propertyIds !== undefined && propertyIds !== null)
      propertyIds &&
        propertyIds.forEach((item) => {
          url_ += "propertyIds=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteProperty(_response);
      });
  }

  protected processDeleteProperty(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Does nothing. Just a way to expose DynamicObjectProperty thru Swagger.
   * @return Success
   */
  exposeDynamicObjectProperty(): Promise<DynamicObjectProperty> {
    let url_ = this.baseUrl + "/api/platform/dynamic";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processExposeDynamicObjectProperty(_response);
      });
  }

  protected processExposeDynamicObjectProperty(
    response: Response
  ): Promise<DynamicObjectProperty> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DynamicObjectProperty.fromJS(resultData200);
        return result200;
      });
    } else if (status === 204) {
      return response.text().then((_responseText) => {
        return throwException("Success", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DynamicObjectProperty>(<any>null);
  }

  /**
   * Get dictionary items
   * @param body (optional)
   * @return Success
   */
  searchDictionaryItems(
    body: DynamicPropertyDictionaryItemSearchCriteria | undefined
  ): Promise<DynamicPropertyDictionaryItemSearchResult> {
    let url_ = this.baseUrl + "/api/platform/dynamic/dictionaryitems/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchDictionaryItems(_response);
      });
  }

  protected processSearchDictionaryItems(
    response: Response
  ): Promise<DynamicPropertyDictionaryItemSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 =
          DynamicPropertyDictionaryItemSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DynamicPropertyDictionaryItemSearchResult>(
      <any>null
    );
  }

  /**
   * Add or update dictionary items
   * @param body (optional)
   * @return Success
   */
  saveDictionaryItems(
    body: DynamicPropertyDictionaryItem[] | null | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/platform/dynamic/dictionaryitems";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSaveDictionaryItems(_response);
      });
  }

  protected processSaveDictionaryItems(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete dictionary items
   * @param ids (optional) IDs of dictionary items to delete.
   * @return Success
   */
  deleteDictionaryItem(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/platform/dynamic/dictionaryitems?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteDictionaryItem(_response);
      });
  }

  protected processDeleteDictionaryItem(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class JobsClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Get background job status
   * @param id Job ID.
   * @return Success
   */
  getStatus(id: string | null): Promise<Job> {
    let url_ = this.baseUrl + "/api/platform/jobs/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetStatus(_response);
      });
  }

  protected processGetStatus(response: Response): Promise<Job> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Job.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Job>(<any>null);
  }
}

export class ModulesClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Reload  modules
   * @return Success
   */
  reloadModules(): Promise<void> {
    let url_ = this.baseUrl + "/api/platform/modules/reload";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processReloadModules(_response);
      });
  }

  protected processReloadModules(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get installed modules
   * @return Success
   */
  getModules(): Promise<ModuleDescriptor[]> {
    let url_ = this.baseUrl + "/api/platform/modules";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetModules(_response);
      });
  }

  protected processGetModules(response: Response): Promise<ModuleDescriptor[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ModuleDescriptor.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ModuleDescriptor[]>(<any>null);
  }

  /**
   * Get all dependent modules for module
   * @param body (optional) modules descriptors
   * @return Success
   */
  getDependingModules(
    body: ModuleDescriptor[] | null | undefined
  ): Promise<ModuleDescriptor[]> {
    let url_ = this.baseUrl + "/api/platform/modules/getdependents";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetDependingModules(_response);
      });
  }

  protected processGetDependingModules(
    response: Response
  ): Promise<ModuleDescriptor[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ModuleDescriptor.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ModuleDescriptor[]>(<any>null);
  }

  /**
   * Returns a flat expanded  list of modules that depend on passed modules
   * @param body (optional) modules descriptors
   * @return Success
   */
  getMissingDependencies(
    body: ModuleDescriptor[] | null | undefined
  ): Promise<ModuleDescriptor[]> {
    let url_ = this.baseUrl + "/api/platform/modules/getmissingdependencies";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetMissingDependencies(_response);
      });
  }

  protected processGetMissingDependencies(
    response: Response
  ): Promise<ModuleDescriptor[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ModuleDescriptor.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ModuleDescriptor[]>(<any>null);
  }

  /**
   * Upload module package for installation or update
   * @return Success
   */
  uploadModuleArchive(): Promise<ModuleDescriptor> {
    let url_ = this.baseUrl + "/api/platform/modules/localstorage";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUploadModuleArchive(_response);
      });
  }

  protected processUploadModuleArchive(
    response: Response
  ): Promise<ModuleDescriptor> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ModuleDescriptor.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ModuleDescriptor>(<any>null);
  }

  /**
   * Install modules
   * @param body (optional) modules for install
   * @return Success
   */
  installModules(
    body: ModuleDescriptor[] | null | undefined
  ): Promise<ModulePushNotification> {
    let url_ = this.baseUrl + "/api/platform/modules/install";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processInstallModules(_response);
      });
  }

  protected processInstallModules(
    response: Response
  ): Promise<ModulePushNotification> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ModulePushNotification.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ModulePushNotification>(<any>null);
  }

  /**
   * Uninstall module
   * @param body (optional) modules
   * @return Success
   */
  uninstallModule(
    body: ModuleDescriptor[] | null | undefined
  ): Promise<ModulePushNotification> {
    let url_ = this.baseUrl + "/api/platform/modules/uninstall";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUninstallModule(_response);
      });
  }

  protected processUninstallModule(
    response: Response
  ): Promise<ModulePushNotification> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ModulePushNotification.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ModulePushNotification>(<any>null);
  }

  /**
   * Restart web application
   * @return Success
   */
  restart(): Promise<void> {
    let url_ = this.baseUrl + "/api/platform/modules/restart";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processRestart(_response);
      });
  }

  protected processRestart(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Auto-install modules with specified groups
   * @return Success
   */
  tryToAutoInstallModules(): Promise<ModuleAutoInstallPushNotification> {
    let url_ = this.baseUrl + "/api/platform/modules/autoinstall";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processTryToAutoInstallModules(_response);
      });
  }

  protected processTryToAutoInstallModules(
    response: Response
  ): Promise<ModuleAutoInstallPushNotification> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ModuleAutoInstallPushNotification.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ModuleAutoInstallPushNotification>(<any>null);
  }
}

export class OAuthAppsClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  new(): Promise<OpenIddictApplicationDescriptor> {
    let url_ = this.baseUrl + "/api/platform/oauthapps/new";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processNew(_response);
      });
  }

  protected processNew(
    response: Response
  ): Promise<OpenIddictApplicationDescriptor> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = OpenIddictApplicationDescriptor.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<OpenIddictApplicationDescriptor>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  save(
    body: OpenIddictApplicationDescriptor | undefined
  ): Promise<OpenIddictApplicationDescriptor> {
    let url_ = this.baseUrl + "/api/platform/oauthapps";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSave(_response);
      });
  }

  protected processSave(
    response: Response
  ): Promise<OpenIddictApplicationDescriptor> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = OpenIddictApplicationDescriptor.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<OpenIddictApplicationDescriptor>(<any>null);
  }

  /**
   * @param clientIds (optional)
   * @return Success
   */
  delete(clientIds: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/platform/oauthapps?";
    if (clientIds !== undefined && clientIds !== null)
      clientIds &&
        clientIds.forEach((item) => {
          url_ += "clientIds=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDelete(_response);
      });
  }

  protected processDelete(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  search(
    body: OAuthAppSearchCriteria | undefined
  ): Promise<OAuthAppSearchResult> {
    let url_ = this.baseUrl + "/api/platform/oauthapps/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearch(_response);
      });
  }

  protected processSearch(response: Response): Promise<OAuthAppSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = OAuthAppSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<OAuthAppSearchResult>(<any>null);
  }
}


export class PushNotificationClient extends AuthApiBase {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
      super();
      this.http = http ? http : <any>window;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * SearchAsync push notifications
   * @param body (optional) SearchAsync parameters.
   * @return Success
   */
  searchPushNotification(body: PushNotificationSearchCriteria | undefined): Promise<PushNotificationSearchResult> {
      let url_ = this.baseUrl + "/api/platform/pushnotifications";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_ = <RequestInit>{
          body: content_,
          method: "POST",
          headers: {
              "Content-Type": "application/json-patch+json",
              "Accept": "application/json"
          }
      };

      return this.transformOptions(options_).then(transformedOptions_ => {
          return this.http.fetch(url_, transformedOptions_);
      }).then((_response: Response) => {
          return this.processSearchPushNotification(_response);
      });
  }

  protected processSearchPushNotification(response: Response): Promise<PushNotificationSearchResult> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
      if (status === 200) {
          return response.text().then((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PushNotificationSearchResult.fromJS(resultData200);
          return result200;
          });
      } else if (status === 401) {
          return response.text().then((_responseText) => {
          return throwException("Unauthorized", status, _responseText, _headers);
          });
      } else if (status === 403) {
          return response.text().then((_responseText) => {
          return throwException("Forbidden", status, _responseText, _headers);
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<PushNotificationSearchResult>(<any>null);
  }

  /**
   * Mark all notifications as read
   * @return Success
   */
  markAllAsRead(): Promise<PushNotificationSearchResult> {
      let url_ = this.baseUrl + "/api/platform/pushnotifications/markAllAsRead";
      url_ = url_.replace(/[?&]$/, "");

      let options_ = <RequestInit>{
          method: "POST",
          headers: {
              "Accept": "application/json"
          }
      };

      return this.transformOptions(options_).then(transformedOptions_ => {
          return this.http.fetch(url_, transformedOptions_);
      }).then((_response: Response) => {
          return this.processMarkAllAsRead(_response);
      });
  }

  protected processMarkAllAsRead(response: Response): Promise<PushNotificationSearchResult> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
      if (status === 200) {
          return response.text().then((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PushNotificationSearchResult.fromJS(resultData200);
          return result200;
          });
      } else if (status === 401) {
          return response.text().then((_responseText) => {
          return throwException("Unauthorized", status, _responseText, _headers);
          });
      } else if (status === 403) {
          return response.text().then((_responseText) => {
          return throwException("Forbidden", status, _responseText, _headers);
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<PushNotificationSearchResult>(<any>null);
  }
}
export class SecurityClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Sign in with user name and password
   * @param body (optional) Login request.
   * @return Success
   */
  login(body: LoginRequest | undefined): Promise<SignInResult> {
    let url_ = this.baseUrl + "/api/platform/security/login";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processLogin(_response);
      });
  }

  protected processLogin(response: Response): Promise<SignInResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SignInResult.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<SignInResult>(<any>null);
  }

  /**
   * Sign out
   * @return Success
   */
  logout(): Promise<void> {
    let url_ = this.baseUrl + "/api/platform/security/logout";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processLogout(_response);
      });
  }

  protected processLogout(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get current user details
   * @return Success
   */
  getCurrentUser(): Promise<UserDetail> {
    let url_ = this.baseUrl + "/api/platform/security/currentuser";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetCurrentUser(_response);
      });
  }

  protected processGetCurrentUser(response: Response): Promise<UserDetail> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UserDetail.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<UserDetail>(<any>null);
  }

  /**
   * @return Success
   */
  userinfo(): Promise<Claim[]> {
    let url_ = this.baseUrl + "/api/platform/security/userinfo";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUserinfo(_response);
      });
  }

  protected processUserinfo(response: Response): Promise<Claim[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(Claim.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Claim[]>(<any>null);
  }

  /**
   * Get all registered permissions
   * @return Success
   */
  getAllRegisteredPermissions(): Promise<Permission[]> {
    let url_ = this.baseUrl + "/api/platform/security/permissions";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetAllRegisteredPermissions(_response);
      });
  }

  protected processGetAllRegisteredPermissions(
    response: Response
  ): Promise<Permission[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Permission.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Permission[]>(<any>null);
  }

  /**
   * SearchAsync roles by keyword
   * @param body (optional) SearchAsync parameters.
   * @return Success
   */
  searchRoles(body: RoleSearchCriteria | undefined): Promise<RoleSearchResult> {
    let url_ = this.baseUrl + "/api/platform/security/roles/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchRoles(_response);
      });
  }

  protected processSearchRoles(response: Response): Promise<RoleSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = RoleSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<RoleSearchResult>(<any>null);
  }

  /**
   * Get role by ID
   * @return Success
   */
  getRole(roleName: string | null): Promise<Role> {
    let url_ = this.baseUrl + "/api/platform/security/roles/{roleName}";
    if (roleName === undefined || roleName === null)
      throw new Error("The parameter 'roleName' must be defined.");
    url_ = url_.replace("{roleName}", encodeURIComponent("" + roleName));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetRole(_response);
      });
  }

  protected processGetRole(response: Response): Promise<Role> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Role.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Role>(<any>null);
  }

  /**
   * Delete roles by ID
   * @param ids (optional) An array of role IDs.
   * @return Success
   */
  deleteRoles(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/platform/security/roles?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteRoles(_response);
      });
  }

  protected processDeleteRoles(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Update an existing role or create new
   * @param body (optional)
   * @return Success
   */
  updateRole(body: Role | undefined): Promise<SecurityResult> {
    let url_ = this.baseUrl + "/api/platform/security/roles";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateRole(_response);
      });
  }

  protected processUpdateRole(response: Response): Promise<SecurityResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SecurityResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<SecurityResult>(<any>null);
  }

  /**
   * SearchAsync users by keyword
   * @param body (optional) Search criteria.
   * @return Success
   */
  searchUsers(body: UserSearchCriteria | undefined): Promise<UserSearchResult> {
    let url_ = this.baseUrl + "/api/platform/security/users/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchUsers(_response);
      });
  }

  protected processSearchUsers(response: Response): Promise<UserSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UserSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<UserSearchResult>(<any>null);
  }

  /**
   * Get user details by user name
   * @return Success
   */
  getUserByName(userName: string | null): Promise<ApplicationUser> {
    let url_ = this.baseUrl + "/api/platform/security/users/{userName}";
    if (userName === undefined || userName === null)
      throw new Error("The parameter 'userName' must be defined.");
    url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetUserByName(_response);
      });
  }

  protected processGetUserByName(response: Response): Promise<ApplicationUser> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ApplicationUser.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ApplicationUser>(<any>null);
  }

  /**
   * Get user details by user ID
   * @return Success
   */
  getUserById(id: string | null): Promise<ApplicationUser> {
    let url_ = this.baseUrl + "/api/platform/security/users/id/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetUserById(_response);
      });
  }

  protected processGetUserById(response: Response): Promise<ApplicationUser> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ApplicationUser.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ApplicationUser>(<any>null);
  }

  /**
   * Get user details by user email
   * @return Success
   */
  getUserByEmail(email: string | null): Promise<ApplicationUser> {
    let url_ = this.baseUrl + "/api/platform/security/users/email/{email}";
    if (email === undefined || email === null)
      throw new Error("The parameter 'email' must be defined.");
    url_ = url_.replace("{email}", encodeURIComponent("" + email));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetUserByEmail(_response);
      });
  }

  protected processGetUserByEmail(
    response: Response
  ): Promise<ApplicationUser> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ApplicationUser.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ApplicationUser>(<any>null);
  }

  /**
   * Get user details by external login provider
   * @return Success
   */
  getUserByLogin(
    loginProvider: string | null,
    providerKey: string | null
  ): Promise<ApplicationUser> {
    let url_ =
      this.baseUrl +
      "/api/platform/security/users/login/external/{loginProvider}/{providerKey}";
    if (loginProvider === undefined || loginProvider === null)
      throw new Error("The parameter 'loginProvider' must be defined.");
    url_ = url_.replace(
      "{loginProvider}",
      encodeURIComponent("" + loginProvider)
    );
    if (providerKey === undefined || providerKey === null)
      throw new Error("The parameter 'providerKey' must be defined.");
    url_ = url_.replace("{providerKey}", encodeURIComponent("" + providerKey));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetUserByLogin(_response);
      });
  }

  protected processGetUserByLogin(
    response: Response
  ): Promise<ApplicationUser> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ApplicationUser.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ApplicationUser>(<any>null);
  }

  /**
   * Create new user
   * @param body (optional)
   * @return Success
   */
  create(body: ApplicationUser | undefined): Promise<SecurityResult> {
    let url_ = this.baseUrl + "/api/platform/security/users/create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreate(_response);
      });
  }

  protected processCreate(response: Response): Promise<SecurityResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SecurityResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<SecurityResult>(<any>null);
  }

  /**
   * Change password for current user.
   * @param body (optional) Old and new passwords.
   * @return Success
   */
  changeCurrentUserPassword(
    body: ChangePasswordRequest | undefined
  ): Promise<SecurityResult> {
    let url_ =
      this.baseUrl + "/api/platform/security/currentuser/changepassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processChangeCurrentUserPassword(_response);
      });
  }

  protected processChangeCurrentUserPassword(
    response: Response
  ): Promise<SecurityResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SecurityResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException("Bad Request", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<SecurityResult>(<any>null);
  }

  /**
   * Change password
   * @param userName user name
   * @param body (optional) Old and new passwords.
   * @return Success
   */
  changePassword(
    userName: string | null,
    body: ChangePasswordRequest | undefined
  ): Promise<SecurityResult> {
    let url_ =
      this.baseUrl + "/api/platform/security/users/{userName}/changepassword";
    if (userName === undefined || userName === null)
      throw new Error("The parameter 'userName' must be defined.");
    url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processChangePassword(_response);
      });
  }

  protected processChangePassword(response: Response): Promise<SecurityResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SecurityResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException("Bad Request", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<SecurityResult>(<any>null);
  }

  /**
   * Reset password confirmation
   * @param body (optional) Password reset information containing new password.
   * @return Success
   */
  resetPassword(
    userName: string | null,
    body: ResetPasswordConfirmRequest | undefined
  ): Promise<SecurityResult> {
    let url_ =
      this.baseUrl + "/api/platform/security/users/{userName}/resetpassword";
    if (userName === undefined || userName === null)
      throw new Error("The parameter 'userName' must be defined.");
    url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processResetPassword(_response);
      });
  }

  protected processResetPassword(response: Response): Promise<SecurityResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SecurityResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<SecurityResult>(<any>null);
  }

  /**
   * Reset password confirmation
   * @param body (optional) New password.
   * @return Success
   */
  resetPasswordByToken(
    userId: string | null,
    body: ResetPasswordConfirmRequest | undefined
  ): Promise<SecurityResult> {
    let url_ =
      this.baseUrl +
      "/api/platform/security/users/{userId}/resetpasswordconfirm";
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processResetPasswordByToken(_response);
      });
  }

  protected processResetPasswordByToken(
    response: Response
  ): Promise<SecurityResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SecurityResult.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<SecurityResult>(<any>null);
  }

  /**
   * Validate password reset token
   * @param body (optional)
   * @return Success
   */
  validatePasswordResetToken(
    userId: string | null,
    body: ValidatePasswordResetTokenRequest | undefined
  ): Promise<boolean> {
    let url_ =
      this.baseUrl +
      "/api/platform/security/users/{userId}/validatepasswordresettoken";
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processValidatePasswordResetToken(_response);
      });
  }

  protected processValidatePasswordResetToken(
    response: Response
  ): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<boolean>(<any>null);
  }

  /**
   * Send email with instructions on how to reset user password.
   * @return Success
   */
  requestPasswordReset(loginOrEmail: string | null): Promise<void> {
    let url_ =
      this.baseUrl +
      "/api/platform/security/users/{loginOrEmail}/requestpasswordreset";
    if (loginOrEmail === undefined || loginOrEmail === null)
      throw new Error("The parameter 'loginOrEmail' must be defined.");
    url_ = url_.replace(
      "{loginOrEmail}",
      encodeURIComponent("" + loginOrEmail)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processRequestPasswordReset(_response);
      });
  }

  protected processRequestPasswordReset(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  validatePassword(body: string | null | undefined): Promise<IdentityResult> {
    let url_ = this.baseUrl + "/api/platform/security/validatepassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processValidatePassword(_response);
      });
  }

  protected processValidatePassword(
    response: Response
  ): Promise<IdentityResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = IdentityResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<IdentityResult>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  validateUserPassword(
    body: ChangePasswordRequest | undefined
  ): Promise<IdentityResult> {
    let url_ = this.baseUrl + "/api/platform/security/validateuserpassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processValidateUserPassword(_response);
      });
  }

  protected processValidateUserPassword(
    response: Response
  ): Promise<IdentityResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = IdentityResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<IdentityResult>(<any>null);
  }

  /**
   * Update user details by user ID
   * @param body (optional) User details.
   * @return Success
   */
  update(body: ApplicationUser | undefined): Promise<SecurityResult> {
    let url_ = this.baseUrl + "/api/platform/security/users";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdate(_response);
      });
  }

  protected processUpdate(response: Response): Promise<SecurityResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SecurityResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<SecurityResult>(<any>null);
  }

  /**
   * Delete users by name
   * @param names (optional) An array of user names.
   * @return Success
   */
  delete(names: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/platform/security/users?";
    if (names !== undefined && names !== null)
      names &&
        names.forEach((item) => {
          url_ += "names=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDelete(_response);
      });
  }

  protected processDelete(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Checks if user locked
   * @param id User id
   * @return Success
   */
  isUserLocked(id: string | null): Promise<UserLockedResult> {
    let url_ = this.baseUrl + "/api/platform/security/users/{id}/locked";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processIsUserLocked(_response);
      });
  }

  protected processIsUserLocked(response: Response): Promise<UserLockedResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UserLockedResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<UserLockedResult>(<any>null);
  }

  /**
   * Lock user
   * @param id >User id
   * @return Success
   */
  lockUser(id: string | null): Promise<SecurityResult> {
    let url_ = this.baseUrl + "/api/platform/security/users/{id}/lock";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processLockUser(_response);
      });
  }

  protected processLockUser(response: Response): Promise<SecurityResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SecurityResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<SecurityResult>(<any>null);
  }

  /**
   * Unlock user
   * @param id >User id
   * @return Success
   */
  unlockUser(id: string | null): Promise<SecurityResult> {
    let url_ = this.baseUrl + "/api/platform/security/users/{id}/unlock";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUnlockUser(_response);
      });
  }

  protected processUnlockUser(response: Response): Promise<SecurityResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SecurityResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<SecurityResult>(<any>null);
  }

  /**
   * @return Success
   */
  getUserApiKeys(id: string | null): Promise<UserApiKey[]> {
    let url_ = this.baseUrl + "/api/platform/security/users/{id}/apikeys";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetUserApiKeys(_response);
      });
  }

  protected processGetUserApiKeys(response: Response): Promise<UserApiKey[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(UserApiKey.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<UserApiKey[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  saveUserApiKey(body: UserApiKey | undefined): Promise<UserApiKey[]> {
    let url_ = this.baseUrl + "/api/platform/security/users/apikeys";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSaveUserApiKey(_response);
      });
  }

  protected processSaveUserApiKey(response: Response): Promise<UserApiKey[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(UserApiKey.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<UserApiKey[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateUserApiKey(body: UserApiKey | undefined): Promise<UserApiKey[]> {
    let url_ = this.baseUrl + "/api/platform/security/users/apikeys";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateUserApiKey(_response);
      });
  }

  protected processUpdateUserApiKey(response: Response): Promise<UserApiKey[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(UserApiKey.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<UserApiKey[]>(<any>null);
  }

  /**
   * @param ids (optional)
   * @return Success
   */
  deleteUserApiKeys(ids: string[] | null | undefined): Promise<UserApiKey[]> {
    let url_ = this.baseUrl + "/api/platform/security/users/apikeys?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteUserApiKeys(_response);
      });
  }

  protected processDeleteUserApiKeys(
    response: Response
  ): Promise<UserApiKey[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(UserApiKey.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<UserApiKey[]>(<any>null);
  }

  /**
   * Verify user email
   * @return Success
   */
  sendVerificationEmail(userId: string | null): Promise<void> {
    let url_ =
      this.baseUrl +
      "/api/platform/security/users/{userId}/sendVerificationEmail";
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSendVerificationEmail(_response);
      });
  }

  protected processSendVerificationEmail(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class SettingClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Get all settings
   * @return Success
   */
  getAllGlobalSettings(): Promise<ObjectSettingEntry> {
    let url_ = this.baseUrl + "/api/platform/settings";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetAllGlobalSettings(_response);
      });
  }

  protected processGetAllGlobalSettings(
    response: Response
  ): Promise<ObjectSettingEntry> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ObjectSettingEntry.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ObjectSettingEntry>(<any>null);
  }

  /**
   * Update settings values
   * @param body (optional)
   * @return Success
   */
  update(body: ObjectSettingEntry[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/platform/settings";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdate(_response);
      });
  }

  protected processUpdate(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get settings registered by specific module
   * @param id Module ID.
   * @return Success
   */
  getGlobalModuleSettings(id: string | null): Promise<ObjectSettingEntry[]> {
    let url_ = this.baseUrl + "/api/platform/settings/modules/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetGlobalModuleSettings(_response);
      });
  }

  protected processGetGlobalModuleSettings(
    response: Response
  ): Promise<ObjectSettingEntry[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ObjectSettingEntry.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ObjectSettingEntry[]>(<any>null);
  }

  /**
   * Get setting details by name
   * @param name Setting system name.
   * @return Success
   */
  getGlobalSetting(name: string | null): Promise<ObjectSettingEntry> {
    let url_ = this.baseUrl + "/api/platform/settings/{name}";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetGlobalSetting(_response);
      });
  }

  protected processGetGlobalSetting(
    response: Response
  ): Promise<ObjectSettingEntry> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ObjectSettingEntry.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ObjectSettingEntry>(<any>null);
  }

  /**
   * Get UI customization setting
   * @return Success
   */
  getUICustomizationSetting(): Promise<ObjectSettingEntry> {
    let url_ = this.baseUrl + "/api/platform/settings/ui/customization";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetUICustomizationSetting(_response);
      });
  }

  protected processGetUICustomizationSetting(
    response: Response
  ): Promise<ObjectSettingEntry> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ObjectSettingEntry.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ObjectSettingEntry>(<any>null);
  }
}

export class BulkActionsClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Attempts to cancel running task.
   * @param jobId (optional) The job id.
   * @return Success
   */
  cancel(jobId: string | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/bulk/actions?";
    if (jobId !== undefined && jobId !== null)
      url_ += "jobId=" + encodeURIComponent("" + jobId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCancel(_response);
      });
  }

  protected processCancel(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Gets the list of all registered actions.
   * @return Success
   */
  getRegisteredActions(): Promise<IBulkActionProvider[]> {
    let url_ = this.baseUrl + "/api/bulk/actions";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetRegisteredActions(_response);
      });
  }

  protected processGetRegisteredActions(
    response: Response
  ): Promise<IBulkActionProvider[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(IBulkActionProvider.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<IBulkActionProvider[]>(<any>null);
  }

  /**
   * Starts bulk action background job.
   * @param body (optional) Execution context.
   * @return Success
   */
  run(
    body: BulkActionContext | undefined
  ): Promise<BulkActionPushNotification> {
    let url_ = this.baseUrl + "/api/bulk/actions";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processRun(_response);
      });
  }

  protected processRun(
    response: Response
  ): Promise<BulkActionPushNotification> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = BulkActionPushNotification.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<BulkActionPushNotification>(<any>null);
  }

  /**
   * Gets action initialization data (could be used to initialize UI).
   * @param body (optional) Context for which we want initialization data.
   * @return Success
   */
  getActionData(body: BulkActionContext | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/bulk/actions/data";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetActionData(_response);
      });
  }

  protected processGetActionData(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class CartModuleClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  getCart(
    storeId: string | null,
    customerId: string | null,
    cartName: string | null,
    currency: string | null,
    cultureName: string | null
  ): Promise<ShoppingCart> {
    let url_ =
      this.baseUrl +
      "/api/carts/{storeId}/{customerId}/{cartName}/{currency}/{cultureName}/current";
    if (storeId === undefined || storeId === null)
      throw new Error("The parameter 'storeId' must be defined.");
    url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
    if (customerId === undefined || customerId === null)
      throw new Error("The parameter 'customerId' must be defined.");
    url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
    if (cartName === undefined || cartName === null)
      throw new Error("The parameter 'cartName' must be defined.");
    url_ = url_.replace("{cartName}", encodeURIComponent("" + cartName));
    if (currency === undefined || currency === null)
      throw new Error("The parameter 'currency' must be defined.");
    url_ = url_.replace("{currency}", encodeURIComponent("" + currency));
    if (cultureName === undefined || cultureName === null)
      throw new Error("The parameter 'cultureName' must be defined.");
    url_ = url_.replace("{cultureName}", encodeURIComponent("" + cultureName));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetCart(_response);
      });
  }

  protected processGetCart(response: Response): Promise<ShoppingCart> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ShoppingCart.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ShoppingCart>(<any>null);
  }

  /**
   * @return Success
   */
  getCartItemsCount(cartId: string | null): Promise<number> {
    let url_ = this.baseUrl + "/api/carts/{cartId}/itemscount";
    if (cartId === undefined || cartId === null)
      throw new Error("The parameter 'cartId' must be defined.");
    url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetCartItemsCount(_response);
      });
  }

  protected processGetCartItemsCount(response: Response): Promise<number> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<number>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addItemToCart(
    cartId: string | null,
    body: CartLineItem | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/carts/{cartId}/items";
    if (cartId === undefined || cartId === null)
      throw new Error("The parameter 'cartId' must be defined.");
    url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processAddItemToCart(_response);
      });
  }

  protected processAddItemToCart(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param lineItemId (optional)
   * @param quantity (optional)
   * @return Success
   */
  changeCartItem(
    cartId: string | null,
    lineItemId: string | null | undefined,
    quantity: number | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/carts/{cartId}/items?";
    if (cartId === undefined || cartId === null)
      throw new Error("The parameter 'cartId' must be defined.");
    url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
    if (lineItemId !== undefined && lineItemId !== null)
      url_ += "lineItemId=" + encodeURIComponent("" + lineItemId) + "&";
    if (quantity === null)
      throw new Error("The parameter 'quantity' cannot be null.");
    else if (quantity !== undefined)
      url_ += "quantity=" + encodeURIComponent("" + quantity) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "PUT",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processChangeCartItem(_response);
      });
  }

  protected processChangeCartItem(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @return Success
   */
  clearCart(cartId: string | null): Promise<void> {
    let url_ = this.baseUrl + "/api/carts/{cartId}/items";
    if (cartId === undefined || cartId === null)
      throw new Error("The parameter 'cartId' must be defined.");
    url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processClearCart(_response);
      });
  }

  protected processClearCart(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @return Success
   */
  removeCartItem(
    cartId: string | null,
    lineItemId: string | null
  ): Promise<number> {
    let url_ = this.baseUrl + "/api/carts/{cartId}/items/{lineItemId}";
    if (cartId === undefined || cartId === null)
      throw new Error("The parameter 'cartId' must be defined.");
    url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
    if (lineItemId === undefined || lineItemId === null)
      throw new Error("The parameter 'lineItemId' must be defined.");
    url_ = url_.replace("{lineItemId}", encodeURIComponent("" + lineItemId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processRemoveCartItem(_response);
      });
  }

  protected processRemoveCartItem(response: Response): Promise<number> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<number>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  mergeWithCart(
    cartId: string | null,
    body: ShoppingCart | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/carts/{cartId}";
    if (cartId === undefined || cartId === null)
      throw new Error("The parameter 'cartId' must be defined.");
    url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PATCH",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processMergeWithCart(_response);
      });
  }

  protected processMergeWithCart(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get shopping cart by id
   * @param cartId Shopping cart id
   * @return Success
   */
  getCartById(cartId: string | null): Promise<ShoppingCart> {
    let url_ = this.baseUrl + "/api/carts/{cartId}";
    if (cartId === undefined || cartId === null)
      throw new Error("The parameter 'cartId' must be defined.");
    url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetCartById(_response);
      });
  }

  protected processGetCartById(response: Response): Promise<ShoppingCart> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ShoppingCart.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ShoppingCart>(<any>null);
  }

  /**
   * @return Success
   */
  getAvailableShippingRates(cartId: string | null): Promise<ShippingRate[]> {
    let url_ = this.baseUrl + "/api/carts/{cartId}/availshippingrates";
    if (cartId === undefined || cartId === null)
      throw new Error("The parameter 'cartId' must be defined.");
    url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetAvailableShippingRates(_response);
      });
  }

  protected processGetAvailableShippingRates(
    response: Response
  ): Promise<ShippingRate[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ShippingRate.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ShippingRate[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getAvailableShippingRatesByContext(
    body: ShippingEvaluationContext | undefined
  ): Promise<ShippingRate[]> {
    let url_ = this.baseUrl + "/api/carts/availshippingrates";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetAvailableShippingRatesByContext(_response);
      });
  }

  protected processGetAvailableShippingRatesByContext(
    response: Response
  ): Promise<ShippingRate[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ShippingRate.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ShippingRate[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAvailablePaymentMethods(cartId: string | null): Promise<PaymentMethod[]> {
    let url_ = this.baseUrl + "/api/carts/{cartId}/availpaymentmethods";
    if (cartId === undefined || cartId === null)
      throw new Error("The parameter 'cartId' must be defined.");
    url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetAvailablePaymentMethods(_response);
      });
  }

  protected processGetAvailablePaymentMethods(
    response: Response
  ): Promise<PaymentMethod[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(PaymentMethod.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentMethod[]>(<any>null);
  }

  /**
   * @return Success
   */
  addCartCoupon(
    cartId: string | null,
    couponCode: string | null
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/carts/{cartId}/coupons/{couponCode}";
    if (cartId === undefined || cartId === null)
      throw new Error("The parameter 'cartId' must be defined.");
    url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
    if (couponCode === undefined || couponCode === null)
      throw new Error("The parameter 'couponCode' must be defined.");
    url_ = url_.replace("{couponCode}", encodeURIComponent("" + couponCode));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processAddCartCoupon(_response);
      });
  }

  protected processAddCartCoupon(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @return Success
   */
  removeCartCoupon(
    cartId: string | null,
    couponCode: string | null
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/carts/{cartId}/coupons/{couponCode}";
    if (cartId === undefined || cartId === null)
      throw new Error("The parameter 'cartId' must be defined.");
    url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
    if (couponCode === undefined || couponCode === null)
      throw new Error("The parameter 'couponCode' must be defined.");
    url_ = url_.replace("{couponCode}", encodeURIComponent("" + couponCode));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processRemoveCartCoupon(_response);
      });
  }

  protected processRemoveCartCoupon(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addOrUpdateCartShipment(
    cartId: string | null,
    body: CartShipment | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/carts/{cartId}/shipments";
    if (cartId === undefined || cartId === null)
      throw new Error("The parameter 'cartId' must be defined.");
    url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processAddOrUpdateCartShipment(_response);
      });
  }

  protected processAddOrUpdateCartShipment(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addOrUpdateCartPayment(
    cartId: string | null,
    body: Payment | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/carts/{cartId}/payments";
    if (cartId === undefined || cartId === null)
      throw new Error("The parameter 'cartId' must be defined.");
    url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processAddOrUpdateCartPayment(_response);
      });
  }

  protected processAddOrUpdateCartPayment(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Search shopping carts by given criteria
   * @param body (optional) Shopping cart search criteria
   * @return Success
   */
  searchShoppingCart(
    body: ShoppingCartSearchCriteria | undefined
  ): Promise<ShoppingCartSearchResult> {
    let url_ = this.baseUrl + "/api/carts/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchShoppingCart(_response);
      });
  }

  protected processSearchShoppingCart(
    response: Response
  ): Promise<ShoppingCartSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ShoppingCartSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ShoppingCartSearchResult>(<any>null);
  }

  /**
   * Create shopping cart
   * @param body (optional) Shopping cart model
   * @return Success
   */
  create(body: ShoppingCart | undefined): Promise<ShoppingCart> {
    let url_ = this.baseUrl + "/api/carts";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreate(_response);
      });
  }

  protected processCreate(response: Response): Promise<ShoppingCart> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ShoppingCart.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ShoppingCart>(<any>null);
  }

  /**
   * Update shopping cart
   * @param body (optional) Shopping cart model
   * @return Success
   */
  updateShoppingCart(body: ShoppingCart | undefined): Promise<ShoppingCart> {
    let url_ = this.baseUrl + "/api/carts";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateShoppingCart(_response);
      });
  }

  protected processUpdateShoppingCart(
    response: Response
  ): Promise<ShoppingCart> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ShoppingCart.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ShoppingCart>(<any>null);
  }

  /**
   * Delete shopping carts by ids
   * @param ids (optional) Array of shopping cart ids
   * @return Success
   */
  deleteCarts(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/carts?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteCarts(_response);
      });
  }

  protected processDeleteCarts(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Calculates totals for cart.
   * @param body (optional) Shopping cart model
   * @return Success
   */
  recalculateTotals(body: ShoppingCart | undefined): Promise<ShoppingCart> {
    let url_ = this.baseUrl + "/api/carts/recalculate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processRecalculateTotals(_response);
      });
  }

  protected processRecalculateTotals(
    response: Response
  ): Promise<ShoppingCart> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ShoppingCart.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ShoppingCart>(<any>null);
  }
}

export class CatalogModuleAssociationsClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Returns list of associations for specified product
   * @param productId Owner product id
   * @return Success
   */
  getAllAssociations(productId: string | null): Promise<ProductAssociation[]> {
    let url_ = this.baseUrl + "/api/catalog/products/associations/{productId}";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetAllAssociations(_response);
      });
  }

  protected processGetAllAssociations(
    response: Response
  ): Promise<ProductAssociation[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ProductAssociation.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ProductAssociation[]>(<any>null);
  }

  /**
   * Updates the specified association
   * @param body (optional) The association
   * @return Success
   */
  updateAssociations(
    body: ProductAssociation[] | null | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/catalog/products/associations";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateAssociations(_response);
      });
  }

  protected processUpdateAssociations(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Deletes specified associations
   * @param ids (optional) associations to delete ids
   * @return Success
   */
  delete(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/catalog/products/associations?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDelete(_response);
      });
  }

  protected processDelete(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Returns associations by search criteria
   * @param body (optional)
   * @return Success
   */
  search(
    body: ProductAssociationSearchCriteria | undefined
  ): Promise<ProductAssociationSearchResult> {
    let url_ = this.baseUrl + "/api/catalog/products/associations/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearch(_response);
      });
  }

  protected processSearch(
    response: Response
  ): Promise<ProductAssociationSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ProductAssociationSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ProductAssociationSearchResult>(<any>null);
  }
}

export class CatalogModuleCatalogsClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  searchCatalogs(
    body: CatalogSearchCriteria | undefined
  ): Promise<CatalogSearchResult> {
    let url_ = this.baseUrl + "/api/catalog/catalogs/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchCatalogs(_response);
      });
  }

  protected processSearchCatalogs(
    response: Response
  ): Promise<CatalogSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CatalogSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CatalogSearchResult>(<any>null);
  }

  /**
   * Gets Catalog by id.
   * @param id The Catalog id.
   * @return Success
   */
  getCatalog(id: string | null): Promise<Catalog> {
    let url_ = this.baseUrl + "/api/catalog/catalogs/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetCatalog(_response);
      });
  }

  protected processGetCatalog(response: Response): Promise<Catalog> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Catalog.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Catalog>(<any>null);
  }

  /**
   * Deletes catalog by id.
   * @param id Catalog id.
   * @return Success
   */
  deleteCatalog(id: string | null): Promise<void> {
    let url_ = this.baseUrl + "/api/catalog/catalogs/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteCatalog(_response);
      });
  }

  protected processDeleteCatalog(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Gets the template for a new catalog.
   * @return Success
   */
  getNewCatalog(): Promise<Catalog> {
    let url_ = this.baseUrl + "/api/catalog/catalogs/getnew";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetNewCatalog(_response);
      });
  }

  protected processGetNewCatalog(response: Response): Promise<Catalog> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Catalog.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Catalog>(<any>null);
  }

  /**
   * Gets the template for a new virtual catalog.
   * @return Success
   */
  getNewVirtualCatalog(): Promise<Catalog> {
    let url_ = this.baseUrl + "/api/catalog/catalogs/getnewvirtual";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetNewVirtualCatalog(_response);
      });
  }

  protected processGetNewVirtualCatalog(response: Response): Promise<Catalog> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Catalog.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Catalog>(<any>null);
  }

  /**
   * Creates the specified catalog.
   * @param body (optional) The catalog to create
   * @return Success
   */
  createCatalog(body: Catalog | undefined): Promise<Catalog> {
    let url_ = this.baseUrl + "/api/catalog/catalogs";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateCatalog(_response);
      });
  }

  protected processCreateCatalog(response: Response): Promise<Catalog> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Catalog.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Catalog>(<any>null);
  }

  /**
   * Updates the specified catalog.
   * @param body (optional) The catalog.
   * @return Success
   */
  updateCatalog(body: Catalog | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/catalog/catalogs";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateCatalog(_response);
      });
  }

  protected processUpdateCatalog(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class CatalogModuleCategoriesClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Gets category by id.
   * @param id Category id.
   * @return Success
   */
  getCategory(id: string | null): Promise<Category> {
    let url_ = this.baseUrl + "/api/catalog/categories/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetCategory(_response);
      });
  }

  protected processGetCategory(response: Response): Promise<Category> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Category.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Category>(<any>null);
  }

  /**
   * Gets categories by ids
   * @param ids (optional) Categories ids
   * @param respGroup (optional) Response group.
   * @return Success
   */
  getCategoriesByIds(
    ids: string[] | null | undefined,
    respGroup: string | null | undefined
  ): Promise<Category[]> {
    let url_ = this.baseUrl + "/api/catalog/categories?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    if (respGroup !== undefined && respGroup !== null)
      url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetCategoriesByIds(_response);
      });
  }

  protected processGetCategoriesByIds(response: Response): Promise<Category[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Category.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Category[]>(<any>null);
  }

  /**
   * Creates or updates the specified category.
   * @param body (optional) The category.
   * @return Success
   */
  createOrUpdateCategory(body: Category | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/catalog/categories";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateOrUpdateCategory(_response);
      });
  }

  protected processCreateOrUpdateCategory(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Deletes the specified categories by id.
   * @param ids (optional) The categories ids.
   * @return Success
   */
  deleteCategory(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/catalog/categories?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteCategory(_response);
      });
  }

  protected processDeleteCategory(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get categories by plenty ids
   * @param respGroup (optional) Response group
   * @param body (optional) Categories ids
   * @return Success
   */
  getCategoriesByPlentyIds(
    respGroup: string | null | undefined,
    body: string[] | null | undefined
  ): Promise<Category[]> {
    let url_ = this.baseUrl + "/api/catalog/categories/plenty?";
    if (respGroup !== undefined && respGroup !== null)
      url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetCategoriesByPlentyIds(_response);
      });
  }

  protected processGetCategoriesByPlentyIds(
    response: Response
  ): Promise<Category[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Category.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Category[]>(<any>null);
  }

  /**
   * Gets the template for a new category.
   * @param catalogId The catalog id.
   * @param parentCategoryId (optional) The parent category id. (Optional)
   * @return Success
   */
  getNewCategory(
    catalogId: string | null,
    parentCategoryId: string | null | undefined
  ): Promise<Category> {
    let url_ =
      this.baseUrl + "/api/catalog/{catalogId}/categories/newcategory?";
    if (catalogId === undefined || catalogId === null)
      throw new Error("The parameter 'catalogId' must be defined.");
    url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
    if (parentCategoryId !== undefined && parentCategoryId !== null)
      url_ +=
        "parentCategoryId=" + encodeURIComponent("" + parentCategoryId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetNewCategory(_response);
      });
  }

  protected processGetNewCategory(response: Response): Promise<Category> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Category.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Category>(<any>null);
  }
}

export class CatalogModuleIndexedSearchClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  searchProducts(
    body: ProductIndexedSearchCriteria | undefined
  ): Promise<ProductIndexedSearchResult> {
    let url_ = this.baseUrl + "/api/catalog/search/products";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchProducts(_response);
      });
  }

  protected processSearchProducts(
    response: Response
  ): Promise<ProductIndexedSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ProductIndexedSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ProductIndexedSearchResult>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  searchCategories(
    body: CategoryIndexedSearchCriteria | undefined
  ): Promise<CategoryIndexedSearchResult> {
    let url_ = this.baseUrl + "/api/catalog/search/categories";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchCategories(_response);
      });
  }

  protected processSearchCategories(
    response: Response
  ): Promise<CategoryIndexedSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CategoryIndexedSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CategoryIndexedSearchResult>(<any>null);
  }
}

export class CatalogModuleListEntryClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Searches for the items by complex criteria.
   * @param body (optional) The search criteria.
   * @return Success
   */
  listItemsSearch(
    body: CatalogListEntrySearchCriteria | undefined
  ): Promise<ListEntrySearchResult> {
    let url_ = this.baseUrl + "/api/catalog/listentries";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processListItemsSearch(_response);
      });
  }

  protected processListItemsSearch(
    response: Response
  ): Promise<ListEntrySearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ListEntrySearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ListEntrySearchResult>(<any>null);
  }

  /**
   * Creates links for categories or items to parent categories and catalogs.
   * @param body (optional) The links.
   * @return Success
   */
  createLinks(body: CategoryLink[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/catalog/listentrylinks";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateLinks(_response);
      });
  }

  protected processCreateLinks(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Bulk create links to categories and items
   * @param body (optional)
   * @return Success
   */
  bulkCreateLinks(body: BulkLinkCreationRequest | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/catalog/listentrylinks/bulkcreate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processBulkCreateLinks(_response);
      });
  }

  protected processBulkCreateLinks(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Unlinks the linked categories or items from parent categories and catalogs.
   * @param body (optional) The links.
   * @return Success
   */
  deleteLinks(body: CategoryLink[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/catalog/listentrylinks/delete";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteLinks(_response);
      });
  }

  protected processDeleteLinks(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Move categories or products to another location.
   * @param body (optional) Move operation request
   * @return Success
   */
  move(body: ListEntriesMoveRequest | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/catalog/listentries/move";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processMove(_response);
      });
  }

  protected processMove(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Bulk delete by the search criteria.
   * @param body (optional)
   * @return Success
   */
  delete(body: CatalogListEntrySearchCriteria | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/catalog/listentries/delete";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDelete(_response);
      });
  }

  protected processDelete(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class CatalogModuleProductsClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Gets product by id.
   * @param id Item id.
   * @param respGroup (optional) Response group.
   * @return Success
   */
  getProductById(
    id: string | null,
    respGroup: string | null | undefined
  ): Promise<CatalogProduct> {
    let url_ = this.baseUrl + "/api/catalog/products/{id}?";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (respGroup !== undefined && respGroup !== null)
      url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetProductById(_response);
      });
  }

  protected processGetProductById(response: Response): Promise<CatalogProduct> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CatalogProduct.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CatalogProduct>(<any>null);
  }

  /**
   * Gets products by ids
   * @param ids (optional) Item ids
   * @param respGroup (optional) Response group.
   * @return Success
   */
  getProductByIds(
    ids: string[] | null | undefined,
    respGroup: string | null | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/catalog/products?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    if (respGroup !== undefined && respGroup !== null)
      url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetProductByIds(_response);
      });
  }

  protected processGetProductByIds(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Create/Update the specified product.
   * @param body (optional) The product.
   * @return Success
   */
  saveProduct(body: CatalogProduct | undefined): Promise<CatalogProduct> {
    let url_ = this.baseUrl + "/api/catalog/products";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSaveProduct(_response);
      });
  }

  protected processSaveProduct(response: Response): Promise<CatalogProduct> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return throwException("Success", status, _responseText, _headers);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CatalogProduct.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CatalogProduct>(<any>null);
  }

  /**
   * Deletes the specified items by id.
   * @param ids (optional) The items ids.
   * @return Success
   */
  deleteProduct(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/catalog/products?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteProduct(_response);
      });
  }

  protected processDeleteProduct(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Gets products by plenty ids
   * @param respGroup (optional) Response group.
   * @param body (optional) Item ids
   * @return Success
   */
  getProductByPlentyIds(
    respGroup: string | null | undefined,
    body: string[] | null | undefined
  ): Promise<CatalogProduct[]> {
    let url_ = this.baseUrl + "/api/catalog/products/plenty?";
    if (respGroup !== undefined && respGroup !== null)
      url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetProductByPlentyIds(_response);
      });
  }

  protected processGetProductByPlentyIds(
    response: Response
  ): Promise<CatalogProduct[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(CatalogProduct.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CatalogProduct[]>(<any>null);
  }

  /**
   * Gets the template for a new product (outside of category).
   * @param catalogId The catalog id.
   * @return Success
   */
  getNewProductByCatalog(catalogId: string | null): Promise<CatalogProduct> {
    let url_ = this.baseUrl + "/api/catalog/{catalogId}/products/getnew";
    if (catalogId === undefined || catalogId === null)
      throw new Error("The parameter 'catalogId' must be defined.");
    url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetNewProductByCatalog(_response);
      });
  }

  protected processGetNewProductByCatalog(
    response: Response
  ): Promise<CatalogProduct> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CatalogProduct.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CatalogProduct>(<any>null);
  }

  /**
   * Gets the template for a new product (inside category).
   * @param catalogId The catalog id.
   * @param categoryId The category id.
   * @return Success
   */
  getNewProductByCatalogAndCategory(
    catalogId: string | null,
    categoryId: string | null
  ): Promise<CatalogProduct> {
    let url_ =
      this.baseUrl +
      "/api/catalog/{catalogId}/categories/{categoryId}/products/getnew";
    if (catalogId === undefined || catalogId === null)
      throw new Error("The parameter 'catalogId' must be defined.");
    url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
    if (categoryId === undefined || categoryId === null)
      throw new Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetNewProductByCatalogAndCategory(_response);
      });
  }

  protected processGetNewProductByCatalogAndCategory(
    response: Response
  ): Promise<CatalogProduct> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CatalogProduct.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CatalogProduct>(<any>null);
  }

  /**
   * Gets the template for a new variation.
   * @param productId The parent product id.
   * @return Success
   */
  getNewVariation(productId: string | null): Promise<CatalogProduct> {
    let url_ =
      this.baseUrl + "/api/catalog/products/{productId}/getnewvariation";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetNewVariation(_response);
      });
  }

  protected processGetNewVariation(
    response: Response
  ): Promise<CatalogProduct> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CatalogProduct.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CatalogProduct>(<any>null);
  }

  /**
   * @return Success
   */
  cloneProduct(productId: string | null): Promise<CatalogProduct> {
    let url_ = this.baseUrl + "/api/catalog/products/{productId}/clone";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCloneProduct(_response);
      });
  }

  protected processCloneProduct(response: Response): Promise<CatalogProduct> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CatalogProduct.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CatalogProduct>(<any>null);
  }

  /**
   * Create/Update the specified products.
   * @param body (optional) The products.
   * @return Success
   */
  saveProducts(body: CatalogProduct[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/catalog/products/batch";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSaveProducts(_response);
      });
  }

  protected processSaveProducts(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class CatalogModulePropertiesClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Gets property metainformation by id.
   * @param propertyId The property id.
   * @return Success
   */
  getProperty(propertyId: string | null): Promise<Property> {
    let url_ = this.baseUrl + "/api/catalog/properties/{propertyId}";
    if (propertyId === undefined || propertyId === null)
      throw new Error("The parameter 'propertyId' must be defined.");
    url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetProperty(_response);
      });
  }

  protected processGetProperty(response: Response): Promise<Property> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Property.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Property>(<any>null);
  }

  /**
   * Gets the template for a new catalog property.
   * @param catalogId The catalog id.
   * @return Success
   */
  getNewCatalogProperty(catalogId: string | null): Promise<Property> {
    let url_ = this.baseUrl + "/api/catalog/{catalogId}/properties/getnew";
    if (catalogId === undefined || catalogId === null)
      throw new Error("The parameter 'catalogId' must be defined.");
    url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetNewCatalogProperty(_response);
      });
  }

  protected processGetNewCatalogProperty(
    response: Response
  ): Promise<Property> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Property.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Property>(<any>null);
  }

  /**
   * Gets the template for a new category property.
   * @param categoryId The category id.
   * @return Success
   */
  getNewCategoryProperty(categoryId: string | null): Promise<Property> {
    let url_ =
      this.baseUrl + "/api/catalog/categories/{categoryId}/properties/getnew";
    if (categoryId === undefined || categoryId === null)
      throw new Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetNewCategoryProperty(_response);
      });
  }

  protected processGetNewCategoryProperty(
    response: Response
  ): Promise<Property> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Property.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Property>(<any>null);
  }

  /**
   * Creates or updates the specified property.
   * @param body (optional) The property.
   * @return Success
   */
  saveProperty(body: Property | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/catalog/properties";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSaveProperty(_response);
      });
  }

  protected processSaveProperty(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Deletes property by id.
   * @param id (optional) The property id.
   * @param doDeleteValues (optional) Flag indicating to remove property values from objects as well
   * @return Success
   */
  deleteProperty(
    id: string | null | undefined,
    doDeleteValues: boolean | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/catalog/properties?";
    if (id !== undefined && id !== null)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    if (doDeleteValues === null)
      throw new Error("The parameter 'doDeleteValues' cannot be null.");
    else if (doDeleteValues !== undefined)
      url_ += "doDeleteValues=" + encodeURIComponent("" + doDeleteValues) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteProperty(_response);
      });
  }

  protected processDeleteProperty(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Validate name for Product-level (unmanaged) property
   * @param body (optional)
   * @return Success
   */
  validateName(
    body: PropertyValidationRequest | undefined
  ): Promise<ValidationResult> {
    let url_ = this.baseUrl + "/api/catalog/properties/validate-name";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processValidateName(_response);
      });
  }

  protected processValidateName(response: Response): Promise<ValidationResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ValidationResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ValidationResult>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  validatePropertyName(
    body: CategoryPropertyValidationRequest | undefined
  ): Promise<ValidationResult> {
    let url_ = this.baseUrl + "/api/catalog/properties/validate-property-name";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processValidatePropertyName(_response);
      });
  }

  protected processValidatePropertyName(
    response: Response
  ): Promise<ValidationResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ValidationResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ValidationResult>(<any>null);
  }
}

export class CatalogModulePropertyDictionaryItemsClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Search property dictionary items
   * @param body (optional) The search criteria
   * @return Success
   */
  searchPropertyDictionaryItems(
    body: PropertyDictionaryItemSearchCriteria | undefined
  ): Promise<PropertyDictionaryItemSearchResult> {
    let url_ = this.baseUrl + "/api/catalog/dictionaryitems/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchPropertyDictionaryItems(_response);
      });
  }

  protected processSearchPropertyDictionaryItems(
    response: Response
  ): Promise<PropertyDictionaryItemSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PropertyDictionaryItemSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PropertyDictionaryItemSearchResult>(<any>null);
  }

  /**
   * Creates or updates the specified property dictionary items
   * @param body (optional)
   * @return Success
   */
  saveChanges(
    body: PropertyDictionaryItem[] | null | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/catalog/dictionaryitems";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSaveChanges(_response);
      });
  }

  protected processSaveChanges(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete property dictionary items by ids
   * @param ids (optional) The identifiers of objects that needed to be deleted
   * @return Success
   */
  deletePropertyDictionaryItems(
    ids: string[] | null | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/catalog/dictionaryitems?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeletePropertyDictionaryItems(_response);
      });
  }

  protected processDeletePropertyDictionaryItems(
    response: Response
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class ExportImportClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Start catalog data export process.
   * @param body (optional) The export configuration.
   * @return Success
   */
  doExport(body: CsvExportInfo | undefined): Promise<ExportNotification> {
    let url_ = this.baseUrl + "/api/catalogcsvimport/export";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDoExport(_response);
      });
  }

  protected processDoExport(response: Response): Promise<ExportNotification> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ExportNotification.fromJS(resultData200);
        return result200;
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ExportNotification>(<any>null);
  }

  /**
   * Gets the CSV mapping configuration.
   * @param fileUrl (optional) The file URL.
   * @param delimiter (optional) The CSV delimiter.
   * @return Success
   */
  getMappingConfiguration(
    fileUrl: string | null | undefined,
    delimiter: string | null | undefined
  ): Promise<CsvProductMappingConfiguration> {
    let url_ =
      this.baseUrl + "/api/catalogcsvimport/import/mappingconfiguration?";
    if (fileUrl !== undefined && fileUrl !== null)
      url_ += "fileUrl=" + encodeURIComponent("" + fileUrl) + "&";
    if (delimiter !== undefined && delimiter !== null)
      url_ += "delimiter=" + encodeURIComponent("" + delimiter) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetMappingConfiguration(_response);
      });
  }

  protected processGetMappingConfiguration(
    response: Response
  ): Promise<CsvProductMappingConfiguration> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CsvProductMappingConfiguration.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CsvProductMappingConfiguration>(<any>null);
  }

  /**
   * Start catalog data import process.
   * @param body (optional) The import data configuration.
   * @return Success
   */
  doImport(
    body: CsvImportInfo | undefined
  ): Promise<CatalogCsvImportNotification> {
    let url_ = this.baseUrl + "/api/catalogcsvimport/import";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDoImport(_response);
      });
  }

  protected processDoImport(
    response: Response
  ): Promise<CatalogCsvImportNotification> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CatalogCsvImportNotification.fromJS(resultData200);
        return result200;
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CatalogCsvImportNotification>(<any>null);
  }
}

export class PersonalizationModuleClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * GET: api/personalization/taggeditem/{id}
   * @return Success
   */
  getTaggedItem(id: string | null): Promise<TaggedItem> {
    let url_ = this.baseUrl + "/api/personalization/taggeditem/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetTaggedItem(_response);
      });
  }

  protected processGetTaggedItem(response: Response): Promise<TaggedItem> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = TaggedItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<TaggedItem>(<any>null);
  }

  /**
   * GET: api/personalization/taggeditem/{id}/tags/count
   * @return Success
   */
  getTagsCount(id: string | null): Promise<number> {
    let url_ = this.baseUrl + "/api/personalization/taggeditem/{id}/tags/count";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetTagsCount(_response);
      });
  }

  protected processGetTagsCount(response: Response): Promise<number> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<number>(<any>null);
  }

  /**
   * PUT: api/personalization/taggeditem
   * @param body (optional)
   * @return Success
   */
  updateTaggedItem(body: TaggedItem | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/personalization/taggeditem";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateTaggedItem(_response);
      });
  }

  protected processUpdateTaggedItem(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * POST: api/personalization/search
   * @param body (optional)
   * @return Success
   */
  search(
    body: TaggedItemSearchCriteria | undefined
  ): Promise<TaggedItemSearchResult> {
    let url_ = this.baseUrl + "/api/personalization/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearch(_response);
      });
  }

  protected processSearch(response: Response): Promise<TaggedItemSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = TaggedItemSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<TaggedItemSearchResult>(<any>null);
  }

  /**
   * PUT: api/personalization/outlines/synchronize
   * @return Success
   */
  runOutlinesSynchronization(): Promise<TaggedItemOutlineSyncPushNotification> {
    let url_ = this.baseUrl + "/api/personalization/outlines/synchronize";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processRunOutlinesSynchronization(_response);
      });
  }

  protected processRunOutlinesSynchronization(
    response: Response
  ): Promise<TaggedItemOutlineSyncPushNotification> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = TaggedItemOutlineSyncPushNotification.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<TaggedItemOutlineSyncPushNotification>(<any>null);
  }

  /**
   * PUT: api/personalization/outlines/synchronization/cancel
   * @param body (optional)
   * @return Success
   */
  cancelSynchronization(
    body: TaggedItemOutlinesSynchronizationRequest | undefined
  ): Promise<void> {
    let url_ =
      this.baseUrl + "/api/personalization/outlines/synchronization/cancel";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCancelSynchronization(_response);
      });
  }

  protected processCancelSynchronization(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class ContentClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  getStoreContentStats(storeId: string | null): Promise<ContentStatistic> {
    let url_ = this.baseUrl + "/api/content/{storeId}/stats";
    if (storeId === undefined || storeId === null)
      throw new Error("The parameter 'storeId' must be defined.");
    url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetStoreContentStats(_response);
      });
  }

  protected processGetStoreContentStats(
    response: Response
  ): Promise<ContentStatistic> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ContentStatistic.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ContentStatistic>(<any>null);
  }

  /**
   * @param urls (optional)
   * @return Success
   */
  deleteContent(
    contentType: string | null,
    storeId: string | null,
    urls: string[] | null | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}?";
    if (contentType === undefined || contentType === null)
      throw new Error("The parameter 'contentType' must be defined.");
    url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
    if (storeId === undefined || storeId === null)
      throw new Error("The parameter 'storeId' must be defined.");
    url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
    if (urls !== undefined && urls !== null)
      urls &&
        urls.forEach((item) => {
          url_ += "urls=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteContent(_response);
      });
  }

  protected processDeleteContent(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param relativeUrl (optional)
   * @return Success
   */
  getContentItemDataStream(
    contentType: string | null,
    storeId: string | null,
    relativeUrl: string | null | undefined
  ): Promise<string> {
    let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}?";
    if (contentType === undefined || contentType === null)
      throw new Error("The parameter 'contentType' must be defined.");
    url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
    if (storeId === undefined || storeId === null)
      throw new Error("The parameter 'storeId' must be defined.");
    url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
    if (relativeUrl !== undefined && relativeUrl !== null)
      url_ += "relativeUrl=" + encodeURIComponent("" + relativeUrl) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetContentItemDataStream(_response);
      });
  }

  protected processGetContentItemDataStream(
    response: Response
  ): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<string>(<any>null);
  }

  /**
   * @param folderUrl (optional)
   * @param url (optional)
   * @return Success
   */
  uploadContent(
    contentType: string | null,
    storeId: string | null,
    folderUrl: string | null | undefined,
    url: string | null | undefined
  ): Promise<ContentItem[]> {
    let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}?";
    if (contentType === undefined || contentType === null)
      throw new Error("The parameter 'contentType' must be defined.");
    url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
    if (storeId === undefined || storeId === null)
      throw new Error("The parameter 'storeId' must be defined.");
    url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
    if (folderUrl !== undefined && folderUrl !== null)
      url_ += "folderUrl=" + encodeURIComponent("" + folderUrl) + "&";
    if (url !== undefined && url !== null)
      url_ += "url=" + encodeURIComponent("" + url) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUploadContent(_response);
      });
  }

  protected processUploadContent(response: Response): Promise<ContentItem[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ContentItem.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ContentItem[]>(<any>null);
  }

  /**
   * @param folderUrl (optional)
   * @param keyword (optional)
   * @return Success
   */
  searchContent(
    contentType: string | null,
    storeId: string | null,
    folderUrl: string | null | undefined,
    keyword: string | null | undefined
  ): Promise<ContentItem[]> {
    let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}/search?";
    if (contentType === undefined || contentType === null)
      throw new Error("The parameter 'contentType' must be defined.");
    url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
    if (storeId === undefined || storeId === null)
      throw new Error("The parameter 'storeId' must be defined.");
    url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
    if (folderUrl !== undefined && folderUrl !== null)
      url_ += "folderUrl=" + encodeURIComponent("" + folderUrl) + "&";
    if (keyword !== undefined && keyword !== null)
      url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchContent(_response);
      });
  }

  protected processSearchContent(response: Response): Promise<ContentItem[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ContentItem.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ContentItem[]>(<any>null);
  }

  /**
   * @param oldUrl (optional)
   * @param newUrl (optional)
   * @return Success
   */
  moveContent(
    contentType: string | null,
    storeId: string | null,
    oldUrl: string | null | undefined,
    newUrl: string | null | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}/move?";
    if (contentType === undefined || contentType === null)
      throw new Error("The parameter 'contentType' must be defined.");
    url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
    if (storeId === undefined || storeId === null)
      throw new Error("The parameter 'storeId' must be defined.");
    url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
    if (oldUrl !== undefined && oldUrl !== null)
      url_ += "oldUrl=" + encodeURIComponent("" + oldUrl) + "&";
    if (newUrl !== undefined && newUrl !== null)
      url_ += "newUrl=" + encodeURIComponent("" + newUrl) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processMoveContent(_response);
      });
  }

  protected processMoveContent(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param srcPath (optional)
   * @param destPath (optional)
   * @return Success
   */
  copyContent(
    srcPath: string | null | undefined,
    destPath: string | null | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/content/copy?";
    if (srcPath !== undefined && srcPath !== null)
      url_ += "srcPath=" + encodeURIComponent("" + srcPath) + "&";
    if (destPath !== undefined && destPath !== null)
      url_ += "destPath=" + encodeURIComponent("" + destPath) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCopyContent(_response);
      });
  }

  protected processCopyContent(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param archivePath (optional)
   * @param destPath (optional)
   * @return Success
   */
  unpack(
    contentType: string | null,
    storeId: string | null,
    archivePath: string | null | undefined,
    destPath: string | null | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}/unpack?";
    if (contentType === undefined || contentType === null)
      throw new Error("The parameter 'contentType' must be defined.");
    url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
    if (storeId === undefined || storeId === null)
      throw new Error("The parameter 'storeId' must be defined.");
    url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
    if (archivePath !== undefined && archivePath !== null)
      url_ += "archivePath=" + encodeURIComponent("" + archivePath) + "&";
    if (destPath !== undefined && destPath !== null)
      url_ += "destPath=" + encodeURIComponent("" + destPath) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUnpack(_response);
      });
  }

  protected processUnpack(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createContentFolder(
    contentType: string | null,
    storeId: string | null,
    body: ContentFolder | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}/folder";
    if (contentType === undefined || contentType === null)
      throw new Error("The parameter 'contentType' must be defined.");
    url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
    if (storeId === undefined || storeId === null)
      throw new Error("The parameter 'storeId' must be defined.");
    url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateContentFolder(_response);
      });
  }

  protected processCreateContentFolder(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class MenuClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  getLists(storeId: string | null): Promise<MenuLinkList[]> {
    let url_ = this.baseUrl + "/api/cms/{storeId}/menu";
    if (storeId === undefined || storeId === null)
      throw new Error("The parameter 'storeId' must be defined.");
    url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetLists(_response);
      });
  }

  protected processGetLists(response: Response): Promise<MenuLinkList[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(MenuLinkList.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<MenuLinkList[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateMenuLinkList(
    storeId: string,
    body: MenuLinkList | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/cms/{storeId}/menu";
    if (storeId === undefined || storeId === null)
      throw new Error("The parameter 'storeId' must be defined.");
    url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateMenuLinkList(_response);
      });
  }

  protected processUpdateMenuLinkList(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param listIds (optional)
   * @return Success
   */
  deleteMenuLinkLists(
    listIds: string[] | null | undefined,
    storeId: string
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/cms/{storeId}/menu?";
    if (storeId === undefined || storeId === null)
      throw new Error("The parameter 'storeId' must be defined.");
    url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
    if (listIds !== undefined && listIds !== null)
      listIds &&
        listIds.forEach((item) => {
          url_ += "listIds=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteMenuLinkLists(_response);
      });
  }

  protected processDeleteMenuLinkLists(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @return Success
   */
  getList(
    storeId: string | null,
    listId: string | null
  ): Promise<MenuLinkList> {
    let url_ = this.baseUrl + "/api/cms/{storeId}/menu/{listId}";
    if (storeId === undefined || storeId === null)
      throw new Error("The parameter 'storeId' must be defined.");
    url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
    if (listId === undefined || listId === null)
      throw new Error("The parameter 'listId' must be defined.");
    url_ = url_.replace("{listId}", encodeURIComponent("" + listId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetList(_response);
      });
  }

  protected processGetList(response: Response): Promise<MenuLinkList> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = MenuLinkList.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<MenuLinkList>(<any>null);
  }

  /**
   * @param name (optional)
   * @param language (optional)
   * @param id (optional)
   * @return Success
   */
  checkName(
    storeId: string | null,
    name: string | null | undefined,
    language: string | null | undefined,
    id: string | null | undefined
  ): Promise<boolean> {
    let url_ = this.baseUrl + "/api/cms/{storeId}/menu/checkname?";
    if (storeId === undefined || storeId === null)
      throw new Error("The parameter 'storeId' must be defined.");
    url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
    if (name !== undefined && name !== null)
      url_ += "name=" + encodeURIComponent("" + name) + "&";
    if (language !== undefined && language !== null)
      url_ += "language=" + encodeURIComponent("" + language) + "&";
    if (id !== undefined && id !== null)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCheckName(_response);
      });
  }

  protected processCheckName(response: Response): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<boolean>(<any>null);
  }
}

export class CommerceClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Batch create or update seo infos
   * @param body (optional)
   * @return Success
   */
  batchUpdateSeoInfos(body: SeoInfo[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/seoinfos/batchupdate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processBatchUpdateSeoInfos(_response);
      });
  }

  protected processBatchUpdateSeoInfos(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param objectId (optional)
   * @param objectType (optional)
   * @return Success
   */
  getSeoDuplicates(
    objectId: string | null | undefined,
    objectType: string | null | undefined
  ): Promise<SeoInfo[]> {
    let url_ = this.baseUrl + "/api/seoinfos/duplicates?";
    if (objectId !== undefined && objectId !== null)
      url_ += "objectId=" + encodeURIComponent("" + objectId) + "&";
    if (objectType !== undefined && objectType !== null)
      url_ += "objectType=" + encodeURIComponent("" + objectType) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetSeoDuplicates(_response);
      });
  }

  protected processGetSeoDuplicates(response: Response): Promise<SeoInfo[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(SeoInfo.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<SeoInfo[]>(<any>null);
  }

  /**
   * Find all SEO records for object by slug
   * @param slug slug
   * @return Success
   */
  getSeoInfoBySlug(slug: string | null): Promise<SeoInfo[]> {
    let url_ = this.baseUrl + "/api/seoinfos/{slug}";
    if (slug === undefined || slug === null)
      throw new Error("The parameter 'slug' must be defined.");
    url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetSeoInfoBySlug(_response);
      });
  }

  protected processGetSeoInfoBySlug(response: Response): Promise<SeoInfo[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(SeoInfo.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<SeoInfo[]>(<any>null);
  }

  /**
   * Return all currencies registered in the system
   * @return Success
   */
  getAllCurrencies(): Promise<Currency[]> {
    let url_ = this.baseUrl + "/api/currencies";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetAllCurrencies(_response);
      });
  }

  protected processGetAllCurrencies(response: Response): Promise<Currency[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Currency.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Currency[]>(<any>null);
  }

  /**
   * Create a existing currency
   * @param body (optional) currency
   * @return Success
   */
  createCurrency(body: Currency | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/currencies";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateCurrency(_response);
      });
  }

  protected processCreateCurrency(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Update a existing currency
   * @param body (optional) currency
   * @return Success
   */
  updateCurrency(body: Currency | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/currencies";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateCurrency(_response);
      });
  }

  protected processUpdateCurrency(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete currencies
   * @param codes (optional) currency codes
   * @return Success
   */
  deleteCurrencies(codes: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/currencies?";
    if (codes !== undefined && codes !== null)
      codes &&
        codes.forEach((item) => {
          url_ += "codes=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteCurrencies(_response);
      });
  }

  protected processDeleteCurrencies(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Return all package types registered in the system
   * @return Success
   */
  getAllPackageTypes(): Promise<PackageType[]> {
    let url_ = this.baseUrl + "/api/packageTypes";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetAllPackageTypes(_response);
      });
  }

  protected processGetAllPackageTypes(
    response: Response
  ): Promise<PackageType[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(PackageType.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PackageType[]>(<any>null);
  }

  /**
   * Update a existing package type
   * @param body (optional) package type
   * @return Success
   */
  updatePackageType(body: PackageType | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/packageTypes";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdatePackageType(_response);
      });
  }

  protected processUpdatePackageType(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Create new package type
   * @param body (optional) package type
   * @return Success
   */
  createPackageType(body: PackageType | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/packageTypes";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreatePackageType(_response);
      });
  }

  protected processCreatePackageType(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete package types
   * @param ids (optional) package type ids
   * @return Success
   */
  deletePackageTypes(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/packageTypes?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeletePackageTypes(_response);
      });
  }

  protected processDeletePackageTypes(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Validate address (reserved for future) and also required for expose Address in OpenAPI swagger docs
   * @param body (optional)
   * @return Success
   */
  validateAddress(body: Address | undefined): Promise<boolean> {
    let url_ = this.baseUrl + "/api";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processValidateAddress(_response);
      });
  }

  protected processValidateAddress(response: Response): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<boolean>(<any>null);
  }
}

export class CustomerModuleClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Get organizations
   * @return Success
   */
  listOrganizations(): Promise<Organization[]> {
    let url_ = this.baseUrl + "/api/members/organizations";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processListOrganizations(_response);
      });
  }

  protected processListOrganizations(
    response: Response
  ): Promise<Organization[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Organization.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Organization[]>(<any>null);
  }

  /**
   * Get members
   * @param body (optional) concrete instance of SearchCriteria type type will be created by using PolymorphicMemberSearchCriteriaJsonConverter
   * @return Success
   */
  searchMember(
    body: MembersSearchCriteria | undefined
  ): Promise<MemberSearchResult> {
    let url_ = this.baseUrl + "/api/members/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchMember(_response);
      });
  }

  protected processSearchMember(
    response: Response
  ): Promise<MemberSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = MemberSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<MemberSearchResult>(<any>null);
  }

  /**
   * Get member
   * @param id member id
   * @param responseGroup (optional) response group
   * @param memberType (optional) member type
   * @return Success
   */
  getMemberById(
    id: string | null,
    responseGroup: string | null | undefined,
    memberType: string | null | undefined
  ): Promise<Member> {
    let url_ = this.baseUrl + "/api/members/{id}?";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (responseGroup !== undefined && responseGroup !== null)
      url_ += "responseGroup=" + encodeURIComponent("" + responseGroup) + "&";
    if (memberType !== undefined && memberType !== null)
      url_ += "memberType=" + encodeURIComponent("" + memberType) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetMemberById(_response);
      });
  }

  protected processGetMemberById(response: Response): Promise<Member> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Member.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Member>(<any>null);
  }

  /**
   * @param ids (optional)
   * @param responseGroup (optional)
   * @param memberTypes (optional)
   * @return Success
   */
  getMembersByIds(
    ids: string[] | null | undefined,
    responseGroup: string | null | undefined,
    memberTypes: string[] | null | undefined
  ): Promise<Member[]> {
    let url_ = this.baseUrl + "/api/members?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    if (responseGroup !== undefined && responseGroup !== null)
      url_ += "responseGroup=" + encodeURIComponent("" + responseGroup) + "&";
    if (memberTypes !== undefined && memberTypes !== null)
      memberTypes &&
        memberTypes.forEach((item) => {
          url_ += "memberTypes=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetMembersByIds(_response);
      });
  }

  protected processGetMembersByIds(response: Response): Promise<Member[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(Member.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Member[]>(<any>null);
  }

  /**
   * Create new member (can be any object inherited from Member type)
   * @param body (optional) concrete instance of abstract member type will be created by using PolymorphicMemberJsonConverter
   * @return Success
   */
  createMember(body: Member | undefined): Promise<Member> {
    let url_ = this.baseUrl + "/api/members";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateMember(_response);
      });
  }

  protected processCreateMember(response: Response): Promise<Member> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Member.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Member>(<any>null);
  }

  /**
   * Update member
   * @param body (optional) concrete instance of abstract member type will be created by using PolymorphicMemberJsonConverter
   * @return Success
   */
  updateMember(body: Member | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/members";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateMember(_response);
      });
  }

  protected processUpdateMember(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete members
   * @param ids (optional) An array of members ids
   * @return Success
   */
  deleteMembers(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/members?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteMembers(_response);
      });
  }

  protected processDeleteMembers(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Bulk create new members (can be any objects inherited from Member type)
   * @param body (optional) Array of concrete instances of abstract member type will be created by using PolymorphicMemberJsonConverter
   * @return Success
   */
  bulkCreateMembers(body: Member[] | null | undefined): Promise<Member[]> {
    let url_ = this.baseUrl + "/api/members/bulk";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processBulkCreateMembers(_response);
      });
  }

  protected processBulkCreateMembers(response: Response): Promise<Member[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(Member.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Member[]>(<any>null);
  }

  /**
   * Bulk update members
   * @param body (optional) Array of concrete instances of abstract member type will be created by using PolymorphicMemberJsonConverter
   * @return Success
   */
  bulkUpdateMembers(body: Member[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/members/bulk";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processBulkUpdateMembers(_response);
      });
  }

  protected processBulkUpdateMembers(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Bulk delete members
   * @param body (optional) concrete instance of SearchCriteria type will be created by using PolymorphicMemberSearchCriteriaJsonConverter
   * @return Success
   */
  bulkDeleteMembersBySearchCriteria(
    body: MembersSearchCriteria | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/members/delete";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processBulkDeleteMembersBySearchCriteria(_response);
      });
  }

  protected processBulkDeleteMembersBySearchCriteria(
    response: Response
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Create contact
   * @param body (optional)
   * @return Success
   */
  createContact(body: Contact | undefined): Promise<Contact> {
    let url_ = this.baseUrl + "/api/contacts";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateContact(_response);
      });
  }

  protected processCreateContact(response: Response): Promise<Contact> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Contact.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Contact>(<any>null);
  }

  /**
   * Update contact
   * @param body (optional)
   * @return Success
   */
  updateContact(body: Contact | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/contacts";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateContact(_response);
      });
  }

  protected processUpdateContact(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete contacts
   * @param ids (optional) An array of contacts ids
   * @return Success
   */
  deleteContacts(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/contacts?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteContacts(_response);
      });
  }

  protected processDeleteContacts(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get plenty contacts
   * @param ids (optional) contact IDs
   * @return Success
   */
  getContactsByIds(ids: string[] | null | undefined): Promise<Contact[]> {
    let url_ = this.baseUrl + "/api/contacts?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetContactsByIds(_response);
      });
  }

  protected processGetContactsByIds(response: Response): Promise<Contact[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(Contact.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Contact[]>(<any>null);
  }

  /**
   * Bulk create contacts
   * @param body (optional)
   * @return Success
   */
  bulkCreateContacts(body: Contact[] | null | undefined): Promise<Contact[]> {
    let url_ = this.baseUrl + "/api/contacts/bulk";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processBulkCreateContacts(_response);
      });
  }

  protected processBulkCreateContacts(response: Response): Promise<Contact[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(Contact.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Contact[]>(<any>null);
  }

  /**
   * Bulk update contact
   * @param body (optional)
   * @return Success
   */
  bulkUpdateContacts(body: Contact[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/contacts/bulk";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processBulkUpdateContacts(_response);
      });
  }

  protected processBulkUpdateContacts(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Create organization
   * @param body (optional)
   * @return Success
   */
  createOrganization(body: Organization | undefined): Promise<Organization> {
    let url_ = this.baseUrl + "/api/organizations";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateOrganization(_response);
      });
  }

  protected processCreateOrganization(
    response: Response
  ): Promise<Organization> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Organization.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Organization>(<any>null);
  }

  /**
   * Update organization
   * @param body (optional)
   * @return Success
   */
  updateOrganization(body: Organization | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/organizations";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateOrganization(_response);
      });
  }

  protected processUpdateOrganization(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete organizations
   * @param ids (optional) An array of organizations ids
   * @return Success
   */
  deleteOrganizations(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/organizations?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteOrganizations(_response);
      });
  }

  protected processDeleteOrganizations(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get plenty organizations
   * @param ids (optional) Organization ids
   * @return Success
   */
  getOrganizationsByIds(
    ids: string[] | null | undefined
  ): Promise<Organization[]> {
    let url_ = this.baseUrl + "/api/organizations?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetOrganizationsByIds(_response);
      });
  }

  protected processGetOrganizationsByIds(
    response: Response
  ): Promise<Organization[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Organization.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Organization[]>(<any>null);
  }

  /**
   * Bulk create organizations
   * @param body (optional)
   * @return Success
   */
  bulkCreateOrganizations(
    body: Organization[] | null | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/organizations/bulk";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processBulkCreateOrganizations(_response);
      });
  }

  protected processBulkCreateOrganizations(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Bulk update organization
   * @param body (optional)
   * @return Success
   */
  bulkUpdateOrganizations(
    body: Organization[] | null | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/organizations/bulk";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processBulkUpdateOrganizations(_response);
      });
  }

  protected processBulkUpdateOrganizations(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get organization
   * @param id Organization id
   * @return Success
   */
  getOrganizationById(id: string | null): Promise<Organization> {
    let url_ = this.baseUrl + "/api/organizations/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetOrganizationById(_response);
      });
  }

  protected processGetOrganizationById(
    response: Response
  ): Promise<Organization> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Organization.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Organization>(<any>null);
  }

  /**
   * Search organizations
   * @param body (optional) concrete instance of SearchCriteria type type will be created by using PolymorphicMemberSearchCriteriaJsonConverter
   * @return Success
   */
  searchOrganizations(
    body: MembersSearchCriteria | undefined
  ): Promise<OrganizationSearchResult> {
    let url_ = this.baseUrl + "/api/organizations/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchOrganizations(_response);
      });
  }

  protected processSearchOrganizations(
    response: Response
  ): Promise<OrganizationSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = OrganizationSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<OrganizationSearchResult>(<any>null);
  }

  /**
   * Get contact
   * @param id Contact ID
   * @return Success
   */
  getContactById(id: string | null): Promise<Contact> {
    let url_ = this.baseUrl + "/api/contacts/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetContactById(_response);
      });
  }

  protected processGetContactById(response: Response): Promise<Contact> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Contact.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Contact>(<any>null);
  }

  /**
   * Search contacts
   * @param body (optional) concrete instance of SearchCriteria type type will be created by using PolymorphicMemberSearchCriteriaJsonConverter
   * @return Success
   */
  searchContacts(
    body: MembersSearchCriteria | undefined
  ): Promise<ContactSearchResult> {
    let url_ = this.baseUrl + "/api/contacts/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchContacts(_response);
      });
  }

  protected processSearchContacts(
    response: Response
  ): Promise<ContactSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ContactSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ContactSearchResult>(<any>null);
  }

  /**
   * Get vendor
   * @param id Vendor ID
   * @return Success
   */
  getVendorById(id: string | null): Promise<Vendor> {
    let url_ = this.baseUrl + "/api/vendors/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetVendorById(_response);
      });
  }

  protected processGetVendorById(response: Response): Promise<Vendor> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Vendor.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Vendor>(<any>null);
  }

  /**
   * Get plenty vendors
   * @param ids (optional) Vendors IDs
   * @return Success
   */
  getVendorsByIds(ids: string[] | null | undefined): Promise<Vendor[]> {
    let url_ = this.baseUrl + "/api/vendors?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetVendorsByIds(_response);
      });
  }

  protected processGetVendorsByIds(response: Response): Promise<Vendor[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(Vendor.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Vendor[]>(<any>null);
  }

  /**
   * Search vendors
   * @param body (optional) concrete instance of SearchCriteria type type will be created by using PolymorphicMemberSearchCriteriaJsonConverter
   * @return Success
   */
  searchVendors(
    body: MembersSearchCriteria | undefined
  ): Promise<VendorSearchResult> {
    let url_ = this.baseUrl + "/api/vendors/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchVendors(_response);
      });
  }

  protected processSearchVendors(
    response: Response
  ): Promise<VendorSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = VendorSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<VendorSearchResult>(<any>null);
  }

  /**
   * @param memberId (optional)
   * @param body (optional)
   * @return Success
   */
  updateAddesses(
    memberId: string | null | undefined,
    body: CustomerAddress[] | null | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/addresses?";
    if (memberId !== undefined && memberId !== null)
      url_ += "memberId=" + encodeURIComponent("" + memberId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateAddesses(_response);
      });
  }

  protected processUpdateAddesses(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Create employee
   * @param body (optional)
   * @return Success
   */
  createEmployee(body: Employee | undefined): Promise<Employee> {
    let url_ = this.baseUrl + "/api/employees";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateEmployee(_response);
      });
  }

  protected processCreateEmployee(response: Response): Promise<Employee> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Employee.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Employee>(<any>null);
  }

  /**
   * Get plenty employees
   * @param ids (optional) contact IDs
   * @return Success
   */
  getEmployeesByIds(ids: string[] | null | undefined): Promise<Employee[]> {
    let url_ = this.baseUrl + "/api/employees?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetEmployeesByIds(_response);
      });
  }

  protected processGetEmployeesByIds(response: Response): Promise<Employee[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Employee.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Employee[]>(<any>null);
  }

  /**
   * Create employee
   * @param body (optional)
   * @return Success
   */
  bulkCreateEmployees(
    body: Employee[] | null | undefined
  ): Promise<Employee[]> {
    let url_ = this.baseUrl + "/api/employees/bulk";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processBulkCreateEmployees(_response);
      });
  }

  protected processBulkCreateEmployees(
    response: Response
  ): Promise<Employee[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Employee.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Employee[]>(<any>null);
  }

  /**
   * Get all member organizations
   * @param idQuery (optional) member Id
   * @return Success
   */
  getMemberOrganizations(
    idQuery: string | null | undefined,
    idPath: string
  ): Promise<Organization[]> {
    let url_ = this.baseUrl + "/api/members/{id}/organizations?";
    if (idPath === undefined || idPath === null)
      throw new Error("The parameter 'idPath' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
    if (idQuery !== undefined && idQuery !== null)
      url_ += "id=" + encodeURIComponent("" + idQuery) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetMemberOrganizations(_response);
      });
  }

  protected processGetMemberOrganizations(
    response: Response
  ): Promise<Organization[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Organization.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Organization[]>(<any>null);
  }
}

export class AssociationsClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  searchAssociation(
    body: AssociationSearchCriteria | undefined
  ): Promise<AssociationSearchResult> {
    let url_ = this.baseUrl + "/api/dynamicassociations/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchAssociation(_response);
      });
  }

  protected processSearchAssociation(
    response: Response
  ): Promise<AssociationSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = AssociationSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<AssociationSearchResult>(<any>null);
  }

  /**
   * @return Success
   */
  getAssociationById(id: string | null): Promise<Association> {
    let url_ = this.baseUrl + "/api/dynamicassociations/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetAssociationById(_response);
      });
  }

  protected processGetAssociationById(
    response: Response
  ): Promise<Association> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Association.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Association>(<any>null);
  }

  /**
   * @return Success
   */
  getNewAssociation(): Promise<Association> {
    let url_ = this.baseUrl + "/api/dynamicassociations/new";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetNewAssociation(_response);
      });
  }

  protected processGetNewAssociation(response: Response): Promise<Association> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Association.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Association>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  saveAssociations(
    body: Association[] | null | undefined
  ): Promise<Association[]> {
    let url_ = this.baseUrl + "/api/dynamicassociations";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSaveAssociations(_response);
      });
  }

  protected processSaveAssociations(
    response: Response
  ): Promise<Association[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Association.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Association[]>(<any>null);
  }

  /**
   * @param ids (optional)
   * @return Success
   */
  deleteAssociation(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/dynamicassociations?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteAssociation(_response);
      });
  }

  protected processDeleteAssociation(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  evaluateDynamicAssociations(
    body: AssociationEvaluationContext | undefined
  ): Promise<string[]> {
    let url_ = this.baseUrl + "/api/dynamicassociations/evaluate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processEvaluateDynamicAssociations(_response);
      });
  }

  protected processEvaluateDynamicAssociations(
    response: Response
  ): Promise<string[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(item);
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<string[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  previewDynamicAssociations(
    body: AssociationConditionEvaluationRequest | undefined
  ): Promise<string[]> {
    let url_ = this.baseUrl + "/api/dynamicassociations/preview";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processPreviewDynamicAssociations(_response);
      });
  }

  protected processPreviewDynamicAssociations(
    response: Response
  ): Promise<string[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(item);
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<string[]>(<any>null);
  }
}

export class ExportClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Gets the list of types ready to be exported
   * @return Success
   */
  getExportedKnownTypes(): Promise<ExportedTypeDefinition[]> {
    let url_ = this.baseUrl + "/api/export/knowntypes";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetExportedKnownTypes(_response);
      });
  }

  protected processGetExportedKnownTypes(
    response: Response
  ): Promise<ExportedTypeDefinition[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ExportedTypeDefinition.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ExportedTypeDefinition[]>(<any>null);
  }

  /**
   * Gets the list of available export providers
   * @return Success
   */
  getExportProviders(): Promise<IExportProvider[]> {
    let url_ = this.baseUrl + "/api/export/providers";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetExportProviders(_response);
      });
  }

  protected processGetExportProviders(
    response: Response
  ): Promise<IExportProvider[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(IExportProvider.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<IExportProvider[]>(<any>null);
  }

  /**
   * Provides generic viewable entities collection based on the request
   * @param body (optional) Data request
   * @return Success
   */
  getData(
    body: ExportDataRequest | undefined
  ): Promise<ExportableSearchResult> {
    let url_ = this.baseUrl + "/api/export/data";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetData(_response);
      });
  }

  protected processGetData(
    response: Response
  ): Promise<ExportableSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ExportableSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ExportableSearchResult>(<any>null);
  }

  /**
   * Starts export task
   * @param body (optional) Export task description
   * @return Success
   */
  runExport(
    body: ExportDataRequest | undefined
  ): Promise<PlatformExportPushNotification> {
    let url_ = this.baseUrl + "/api/export/run";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processRunExport(_response);
      });
  }

  protected processRunExport(
    response: Response
  ): Promise<PlatformExportPushNotification> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PlatformExportPushNotification.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PlatformExportPushNotification>(<any>null);
  }

  /**
   * Attempts to cancel export task
   * @param body (optional) Cancellation request with task id
   * @return Success
   */
  cancelExport(body: ExportCancellationRequest | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/export/task/cancel";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCancelExport(_response);
      });
  }

  protected processCancelExport(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Downloads file by its name
   * @return Success
   */
  downloadExportFile(fileName: string | null): Promise<void> {
    let url_ = this.baseUrl + "/api/export/download/{fileName}";
    if (fileName === undefined || fileName === null)
      throw new Error("The parameter 'fileName' must be defined.");
    url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDownloadExportFile(_response);
      });
  }

  protected processDownloadExportFile(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class ThumbnailsOptionsClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createThumbnailOption(
    body: ThumbnailOption | undefined
  ): Promise<ThumbnailOption> {
    let url_ = this.baseUrl + "/api/image/thumbnails/options";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateThumbnailOption(_response);
      });
  }

  protected processCreateThumbnailOption(
    response: Response
  ): Promise<ThumbnailOption> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ThumbnailOption.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ThumbnailOption>(<any>null);
  }

  /**
   * @param ids (optional)
   * @return Success
   */
  deleteThumbnailOption(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/image/thumbnails/options?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteThumbnailOption(_response);
      });
  }

  protected processDeleteThumbnailOption(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateThumbnailOption(body: ThumbnailOption | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/image/thumbnails/options";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateThumbnailOption(_response);
      });
  }

  protected processUpdateThumbnailOption(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @return Success
   */
  getThumbnailOption(id: string | null): Promise<ThumbnailOption> {
    let url_ = this.baseUrl + "/api/image/thumbnails/options/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetThumbnailOption(_response);
      });
  }

  protected processGetThumbnailOption(
    response: Response
  ): Promise<ThumbnailOption> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ThumbnailOption.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ThumbnailOption>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  searchThumbnailOption(
    body: ThumbnailOptionSearchCriteria | undefined
  ): Promise<ThumbnailOptionSearchResult> {
    let url_ = this.baseUrl + "/api/image/thumbnails/options/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchThumbnailOption(_response);
      });
  }

  protected processSearchThumbnailOption(
    response: Response
  ): Promise<ThumbnailOptionSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ThumbnailOptionSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ThumbnailOptionSearchResult>(<any>null);
  }
}

export class ThumbnailsTasksClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createThumbnailTask(body: ThumbnailTask | undefined): Promise<ThumbnailTask> {
    let url_ = this.baseUrl + "/api/image/thumbnails/tasks";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateThumbnailTask(_response);
      });
  }

  protected processCreateThumbnailTask(
    response: Response
  ): Promise<ThumbnailTask> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ThumbnailTask.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ThumbnailTask>(<any>null);
  }

  /**
   * @param ids (optional)
   * @return Success
   */
  deleteThumbnailTask(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/image/thumbnails/tasks?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteThumbnailTask(_response);
      });
  }

  protected processDeleteThumbnailTask(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateThumbnailTask(body: ThumbnailTask | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/image/thumbnails/tasks";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateThumbnailTask(_response);
      });
  }

  protected processUpdateThumbnailTask(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @return Success
   */
  getThumbnailTask(id: string | null): Promise<ThumbnailTask> {
    let url_ = this.baseUrl + "/api/image/thumbnails/tasks/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetThumbnailTask(_response);
      });
  }

  protected processGetThumbnailTask(
    response: Response
  ): Promise<ThumbnailTask> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ThumbnailTask.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ThumbnailTask>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  searchThumbnailTask(
    body: ThumbnailTaskSearchCriteria | undefined
  ): Promise<ThumbnailTaskSearchResult> {
    let url_ = this.baseUrl + "/api/image/thumbnails/tasks/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchThumbnailTask(_response);
      });
  }

  protected processSearchThumbnailTask(
    response: Response
  ): Promise<ThumbnailTaskSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ThumbnailTaskSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ThumbnailTaskSearchResult>(<any>null);
  }

  /**
   * @return Success
   */
  cancel(jobId: string | null): Promise<void> {
    let url_ = this.baseUrl + "/api/image/thumbnails/tasks/{jobId}/cancel";
    if (jobId === undefined || jobId === null)
      throw new Error("The parameter 'jobId' must be defined.");
    url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCancel(_response);
      });
  }

  protected processCancel(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  run(
    body: ThumbnailsTaskRunRequest | undefined
  ): Promise<ThumbnailProcessNotification> {
    let url_ = this.baseUrl + "/api/image/thumbnails/tasks/run";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processRun(_response);
      });
  }

  protected processRun(
    response: Response
  ): Promise<ThumbnailProcessNotification> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ThumbnailProcessNotification.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ThumbnailProcessNotification>(<any>null);
  }
}

export class InventoryModuleClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Search inventories by given criteria
   * @param body (optional)
   * @return Success
   */
  searchInventories(
    body: InventorySearchCriteria | undefined
  ): Promise<InventoryInfoSearchResult> {
    let url_ = this.baseUrl + "/api/inventories/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchInventories(_response);
      });
  }

  protected processSearchInventories(
    response: Response
  ): Promise<InventoryInfoSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = InventoryInfoSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<InventoryInfoSearchResult>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  searchInventory(
    body: InventorySearchCriteria | undefined
  ): Promise<InventoryInfoSearchResult> {
    let url_ = this.baseUrl + "/api/inventory/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchInventory(_response);
      });
  }

  protected processSearchInventory(
    response: Response
  ): Promise<InventoryInfoSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = InventoryInfoSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<InventoryInfoSearchResult>(<any>null);
  }

  /**
   * Search inventories by given criteria
   * @param body (optional)
   * @return Success
   */
  searchProductInventories(
    body: ProductInventorySearchCriteria | undefined
  ): Promise<InventoryInfoSearchResult> {
    let url_ = this.baseUrl + "/api/inventory/product/inventories/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchProductInventories(_response);
      });
  }

  protected processSearchProductInventories(
    response: Response
  ): Promise<InventoryInfoSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = InventoryInfoSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<InventoryInfoSearchResult>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  searchProductInventory(
    body: ProductInventorySearchCriteria | undefined
  ): Promise<InventoryInfoSearchResult> {
    let url_ = this.baseUrl + "/api/inventory/product/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchProductInventory(_response);
      });
  }

  protected processSearchProductInventory(
    response: Response
  ): Promise<InventoryInfoSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = InventoryInfoSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<InventoryInfoSearchResult>(<any>null);
  }

  /**
   * Search fulfillment centers registered in the system
   * @param body (optional)
   * @return Success
   */
  searchFulfillmentCenters(
    body: FulfillmentCenterSearchCriteria | undefined
  ): Promise<FulfillmentCenterSearchResult> {
    let url_ = this.baseUrl + "/api/inventory/fulfillmentcenters/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchFulfillmentCenters(_response);
      });
  }

  protected processSearchFulfillmentCenters(
    response: Response
  ): Promise<FulfillmentCenterSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = FulfillmentCenterSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FulfillmentCenterSearchResult>(<any>null);
  }

  /**
   * Get fulfillment center by id
   * @param id fulfillment center id
   * @return Success
   */
  getFulfillmentCenter(id: string | null): Promise<FulfillmentCenter> {
    let url_ = this.baseUrl + "/api/inventory/fulfillmentcenters/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetFulfillmentCenter(_response);
      });
  }

  protected processGetFulfillmentCenter(
    response: Response
  ): Promise<FulfillmentCenter> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = FulfillmentCenter.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FulfillmentCenter>(<any>null);
  }

  /**
   * Get fulfillment centers by ids
   * @param body (optional) fulfillment center ids
   * @return Success
   */
  getFulfillmentCenters(
    body: string[] | null | undefined
  ): Promise<FulfillmentCenter[]> {
    let url_ = this.baseUrl + "/api/inventory/fulfillmentcenters/plenty";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetFulfillmentCenters(_response);
      });
  }

  protected processGetFulfillmentCenters(
    response: Response
  ): Promise<FulfillmentCenter[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(FulfillmentCenter.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FulfillmentCenter[]>(<any>null);
  }

  /**
   * Save fulfillment center
   * @param body (optional) fulfillment center
   * @return Success
   */
  saveFulfillmentCenter(
    body: FulfillmentCenter | undefined
  ): Promise<FulfillmentCenter> {
    let url_ = this.baseUrl + "/api/inventory/fulfillmentcenters";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSaveFulfillmentCenter(_response);
      });
  }

  protected processSaveFulfillmentCenter(
    response: Response
  ): Promise<FulfillmentCenter> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = FulfillmentCenter.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FulfillmentCenter>(<any>null);
  }

  /**
   * Delete fulfillment centers registered in the system
   * @param ids (optional)
   * @return Success
   */
  deleteInventoryFulfillmentCenters(
    ids: string[] | null | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/inventory/fulfillmentcenters?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteInventoryFulfillmentCenters(_response);
      });
  }

  protected processDeleteInventoryFulfillmentCenters(
    response: Response
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Save fulfillment centers
   * @param body (optional) fulfillment centers
   * @return Success
   */
  saveFulfillmentCenters(
    body: FulfillmentCenter[] | null | undefined
  ): Promise<FulfillmentCenter[]> {
    let url_ = this.baseUrl + "/api/inventory/fulfillmentcenters/batch";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSaveFulfillmentCenters(_response);
      });
  }

  protected processSaveFulfillmentCenters(
    response: Response
  ): Promise<FulfillmentCenter[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(FulfillmentCenter.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FulfillmentCenter[]>(<any>null);
  }

  /**
   * @param ids (optional)
   * @return Success
   */
  deleteFulfillmentCenters(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/fulfillment/centers?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteFulfillmentCenters(_response);
      });
  }

  protected processDeleteFulfillmentCenters(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get inventories of products
   * @param ids (optional) Products ids
   * @param fulfillmentCenterIds (optional) The fulfillment centers that will be used to filter product inventories
   * @return Success
   */
  getProductsInventories(
    ids: string[] | null | undefined,
    fulfillmentCenterIds: string[] | null | undefined
  ): Promise<InventoryInfo[]> {
    let url_ = this.baseUrl + "/api/inventory/products?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    if (fulfillmentCenterIds !== undefined && fulfillmentCenterIds !== null)
      fulfillmentCenterIds &&
        fulfillmentCenterIds.forEach((item) => {
          url_ += "fulfillmentCenterIds=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetProductsInventories(_response);
      });
  }

  protected processGetProductsInventories(
    response: Response
  ): Promise<InventoryInfo[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(InventoryInfo.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<InventoryInfo[]>(<any>null);
  }

  /**
   * Get inventories of products
   * @param fulfillmentCenterIds (optional) The fulfillment centers that will be used to filter product inventories
   * @param body (optional) Products ids
   * @return Success
   */
  getProductsInventoriesByPlentyIds(
    fulfillmentCenterIds: string[] | null | undefined,
    body: string[] | null | undefined
  ): Promise<InventoryInfo[]> {
    let url_ = this.baseUrl + "/api/inventory/products/plenty?";
    if (fulfillmentCenterIds !== undefined && fulfillmentCenterIds !== null)
      fulfillmentCenterIds &&
        fulfillmentCenterIds.forEach((item) => {
          url_ += "fulfillmentCenterIds=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetProductsInventoriesByPlentyIds(_response);
      });
  }

  protected processGetProductsInventoriesByPlentyIds(
    response: Response
  ): Promise<InventoryInfo[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(InventoryInfo.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<InventoryInfo[]>(<any>null);
  }

  /**
   * Get inventories of product
   * @param productId Product id
   * @return Success
   */
  getProductInventories(productId: string | null): Promise<InventoryInfo[]> {
    let url_ = this.baseUrl + "/api/inventory/products/{productId}";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetProductInventories(_response);
      });
  }

  protected processGetProductInventories(
    response: Response
  ): Promise<InventoryInfo[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(InventoryInfo.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<InventoryInfo[]>(<any>null);
  }

  /**
   * Update inventory
   * @param body (optional) Inventory to update
   * @return Success
   */
  updateProductInventory(
    productId: string,
    body: InventoryInfo | undefined
  ): Promise<InventoryInfo> {
    let url_ = this.baseUrl + "/api/inventory/products/{productId}";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateProductInventory(_response);
      });
  }

  protected processUpdateProductInventory(
    response: Response
  ): Promise<InventoryInfo> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = InventoryInfo.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<InventoryInfo>(<any>null);
  }

  /**
   * Upsert inventories
   * @param body (optional) Inventories to upsert
   * @return Success
   */
  upsertProductInventories(
    body: InventoryInfo[] | null | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/inventory/plenty";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpsertProductInventories(_response);
      });
  }

  protected processUpsertProductInventories(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class MarketingModuleDynamicContentClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Search content places list entries by given criteria
   * @param body (optional) criteria
   * @return Success
   */
  dynamicContentPlaceListEntriesSearch(
    body: DynamicContentPlaceSearchCriteria | undefined
  ): Promise<DynamicContentListEntrySearchResult> {
    let url_ = this.baseUrl + "/api/marketing/contentplaces/listentries/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDynamicContentPlaceListEntriesSearch(_response);
      });
  }

  protected processDynamicContentPlaceListEntriesSearch(
    response: Response
  ): Promise<DynamicContentListEntrySearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DynamicContentListEntrySearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DynamicContentListEntrySearchResult>(<any>null);
  }

  /**
   * Search dynamic content places by given criteria
   * @param body (optional) criteria
   * @return Success
   */
  dynamicContentPlacesSearch(
    body: DynamicContentPlaceSearchCriteria | undefined
  ): Promise<DynamicContentPlaceSearchResult> {
    let url_ = this.baseUrl + "/api/marketing/contentplaces/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDynamicContentPlacesSearch(_response);
      });
  }

  protected processDynamicContentPlacesSearch(
    response: Response
  ): Promise<DynamicContentPlaceSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DynamicContentPlaceSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DynamicContentPlaceSearchResult>(<any>null);
  }

  /**
   * Search content places list entries by given criteria
   * @param body (optional) criteria
   * @return Success
   */
  dynamicContentItemsEntriesSearch(
    body: DynamicContentItemSearchCriteria | undefined
  ): Promise<DynamicContentListEntrySearchResult> {
    let url_ = this.baseUrl + "/api/marketing/contentitems/listentries/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDynamicContentItemsEntriesSearch(_response);
      });
  }

  protected processDynamicContentItemsEntriesSearch(
    response: Response
  ): Promise<DynamicContentListEntrySearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DynamicContentListEntrySearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DynamicContentListEntrySearchResult>(<any>null);
  }

  /**
   * Search dynamic content items by given criteria
   * @param body (optional) criteria
   * @return Success
   */
  dynamicContentItemsSearch(
    body: DynamicContentItemSearchCriteria | undefined
  ): Promise<DynamicContentItemSearchResult> {
    let url_ = this.baseUrl + "/api/marketing/contentitems/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDynamicContentItemsSearch(_response);
      });
  }

  protected processDynamicContentItemsSearch(
    response: Response
  ): Promise<DynamicContentItemSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DynamicContentItemSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DynamicContentItemSearchResult>(<any>null);
  }

  /**
   * Search dynamic content items by given criteria
   * @param body (optional) criteria
   * @return Success
   */
  dynamicContentPublicationsSearch(
    body: DynamicContentPublicationSearchCriteria | undefined
  ): Promise<DynamicContentPublicationSearchResult> {
    let url_ = this.baseUrl + "/api/marketing/contentpublications/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDynamicContentPublicationsSearch(_response);
      });
  }

  protected processDynamicContentPublicationsSearch(
    response: Response
  ): Promise<DynamicContentPublicationSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DynamicContentPublicationSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DynamicContentPublicationSearchResult>(<any>null);
  }

  /**
   * Get dynamic content for given placeholders
   * @param body (optional)
   * @return Success
   */
  evaluateDynamicContent(
    body: DynamicContentEvaluationContext | undefined
  ): Promise<DynamicContentItem[]> {
    let url_ = this.baseUrl + "/api/marketing/contentitems/evaluate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processEvaluateDynamicContent(_response);
      });
  }

  protected processEvaluateDynamicContent(
    response: Response
  ): Promise<DynamicContentItem[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(DynamicContentItem.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DynamicContentItem[]>(<any>null);
  }

  /**
   * Find dynamic content item object by id
   * @param id content item id
   * @return Success
   */
  getDynamicContentById(id: string | null): Promise<DynamicContentItem> {
    let url_ = this.baseUrl + "/api/marketing/contentitems/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetDynamicContentById(_response);
      });
  }

  protected processGetDynamicContentById(
    response: Response
  ): Promise<DynamicContentItem> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DynamicContentItem.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DynamicContentItem>(<any>null);
  }

  /**
   * Add new dynamic content item object to marketing system
   * @param body (optional) dynamic content object that needs to be added to the dynamic content system
   * @return Success
   */
  createDynamicContent(
    body: DynamicContentItem | undefined
  ): Promise<DynamicContentItem> {
    let url_ = this.baseUrl + "/api/marketing/contentitems";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateDynamicContent(_response);
      });
  }

  protected processCreateDynamicContent(
    response: Response
  ): Promise<DynamicContentItem> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DynamicContentItem.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DynamicContentItem>(<any>null);
  }

  /**
   * Update a existing dynamic content item object
   * @param body (optional) dynamic content object that needs to be updated in the dynamic content system
   * @return Success
   */
  updateDynamicContent(body: DynamicContentItem | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/marketing/contentitems";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateDynamicContent(_response);
      });
  }

  protected processUpdateDynamicContent(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete a dynamic content item objects
   * @param ids (optional) content item object ids for delete in the dynamic content system
   * @return Success
   */
  deleteDynamicContents(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/marketing/contentitems?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteDynamicContents(_response);
      });
  }

  protected processDeleteDynamicContents(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Find dynamic content place object by id
   * @param id place id
   * @return Success
   */
  getDynamicContentPlaceById(id: string | null): Promise<DynamicContentPlace> {
    let url_ = this.baseUrl + "/api/marketing/contentplaces/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetDynamicContentPlaceById(_response);
      });
  }

  protected processGetDynamicContentPlaceById(
    response: Response
  ): Promise<DynamicContentPlace> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DynamicContentPlace.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DynamicContentPlace>(<any>null);
  }

  /**
   * Add new dynamic content place object to marketing system
   * @param body (optional) dynamic content place object that needs to be added to the dynamic content system
   * @return Success
   */
  createDynamicContentPlace(
    body: DynamicContentPlace | undefined
  ): Promise<DynamicContentPlace> {
    let url_ = this.baseUrl + "/api/marketing/contentplaces";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateDynamicContentPlace(_response);
      });
  }

  protected processCreateDynamicContentPlace(
    response: Response
  ): Promise<DynamicContentPlace> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DynamicContentPlace.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DynamicContentPlace>(<any>null);
  }

  /**
   * Update a existing dynamic content place object
   * @param body (optional) dynamic content place object that needs to be updated in the dynamic content system
   * @return Success
   */
  updateDynamicContentPlace(
    body: DynamicContentPlace | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/marketing/contentplaces";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateDynamicContentPlace(_response);
      });
  }

  protected processUpdateDynamicContentPlace(
    response: Response
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete a dynamic content place objects
   * @param ids (optional) content place object ids for delete from dynamic content system
   * @return Success
   */
  deleteDynamicContentPlaces(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/marketing/contentplaces?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteDynamicContentPlaces(_response);
      });
  }

  protected processDeleteDynamicContentPlaces(
    response: Response
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get new dynamic content publication object
   * @return Success
   */
  getNewDynamicPublication(): Promise<DynamicContentPublication> {
    let url_ = this.baseUrl + "/api/marketing/contentpublications/new";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetNewDynamicPublication(_response);
      });
  }

  protected processGetNewDynamicPublication(
    response: Response
  ): Promise<DynamicContentPublication> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DynamicContentPublication.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DynamicContentPublication>(<any>null);
  }

  /**
   * Find dynamic content publication object by id
   * @param id publication id
   * @return Success
   */
  getDynamicContentPublicationById(
    id: string | null
  ): Promise<DynamicContentPublication> {
    let url_ = this.baseUrl + "/api/marketing/contentpublications/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetDynamicContentPublicationById(_response);
      });
  }

  protected processGetDynamicContentPublicationById(
    response: Response
  ): Promise<DynamicContentPublication> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DynamicContentPublication.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DynamicContentPublication>(<any>null);
  }

  /**
   * Add new dynamic content publication object to marketing system
   * @param body (optional) dynamic content publication object that needs to be added to the dynamic content system
   * @return Success
   */
  createDynamicContentPublication(
    body: DynamicContentPublication | undefined
  ): Promise<DynamicContentPublication> {
    let url_ = this.baseUrl + "/api/marketing/contentpublications";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateDynamicContentPublication(_response);
      });
  }

  protected processCreateDynamicContentPublication(
    response: Response
  ): Promise<DynamicContentPublication> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DynamicContentPublication.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DynamicContentPublication>(<any>null);
  }

  /**
   * Update a existing dynamic content publication object
   * @param body (optional) dynamic content publication object that needs to be updated in the dynamic content system
   * @return Success
   */
  updateDynamicContentPublication(
    body: DynamicContentPublication | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/marketing/contentpublications";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateDynamicContentPublication(_response);
      });
  }

  protected processUpdateDynamicContentPublication(
    response: Response
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete a dynamic content publication objects
   * @param ids (optional) content publication object ids for delete from dynamic content system
   * @return Success
   */
  deleteDynamicContentPublications(
    ids: string[] | null | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/marketing/contentpublications?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteDynamicContentPublications(_response);
      });
  }

  protected processDeleteDynamicContentPublications(
    response: Response
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Find dynamic content folder by id
   * @param id folder id
   * @return Success
   */
  getDynamicContentFolderById(
    id: string | null
  ): Promise<DynamicContentFolder> {
    let url_ = this.baseUrl + "/api/marketing/contentfolders/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetDynamicContentFolderById(_response);
      });
  }

  protected processGetDynamicContentFolderById(
    response: Response
  ): Promise<DynamicContentFolder> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DynamicContentFolder.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DynamicContentFolder>(<any>null);
  }

  /**
   * Add new dynamic content folder
   * @param body (optional) dynamic content folder that needs to be added
   * @return Success
   */
  createDynamicContentFolder(
    body: DynamicContentFolder | undefined
  ): Promise<DynamicContentFolder> {
    let url_ = this.baseUrl + "/api/marketing/contentfolders";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateDynamicContentFolder(_response);
      });
  }

  protected processCreateDynamicContentFolder(
    response: Response
  ): Promise<DynamicContentFolder> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DynamicContentFolder.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DynamicContentFolder>(<any>null);
  }

  /**
   * Update a existing dynamic content folder
   * @param body (optional) dynamic content folder that needs to be updated
   * @return Success
   */
  updateDynamicContentFolder(
    body: DynamicContentFolder | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/marketing/contentfolders";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateDynamicContentFolder(_response);
      });
  }

  protected processUpdateDynamicContentFolder(
    response: Response
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete a dynamic content folders
   * @param ids (optional) folders ids for delete
   * @return Success
   */
  deleteDynamicContentFolders(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/marketing/contentfolders?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteDynamicContentFolders(_response);
      });
  }

  protected processDeleteDynamicContentFolders(
    response: Response
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class MarketingModulePromotionClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Search dynamic content places by given criteria
   * @param body (optional) criteria
   * @return Success
   */
  promotionsSearch(
    body: PromotionSearchCriteria | undefined
  ): Promise<PromotionSearchResult> {
    let url_ = this.baseUrl + "/api/marketing/promotions/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processPromotionsSearch(_response);
      });
  }

  protected processPromotionsSearch(
    response: Response
  ): Promise<PromotionSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PromotionSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PromotionSearchResult>(<any>null);
  }

  /**
   * Evaluate promotions
   * @param body (optional) Promotion evaluation context
   * @return Success
   */
  evaluatePromotions(
    body: PromotionEvaluationContext | undefined
  ): Promise<PromotionReward[]> {
    let url_ = this.baseUrl + "/api/marketing/promotions/evaluate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processEvaluatePromotions(_response);
      });
  }

  protected processEvaluatePromotions(
    response: Response
  ): Promise<PromotionReward[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(PromotionReward.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PromotionReward[]>(<any>null);
  }

  /**
   * Find promotion object by id
   * @param id promotion id
   * @return Success
   */
  getPromotionById(id: string | null): Promise<Promotion> {
    let url_ = this.baseUrl + "/api/marketing/promotions/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetPromotionById(_response);
      });
  }

  protected processGetPromotionById(response: Response): Promise<Promotion> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Promotion.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Promotion>(<any>null);
  }

  /**
   * Get new dynamic promotion object
   * @return Success
   */
  getNewDynamicPromotion(): Promise<Promotion> {
    let url_ = this.baseUrl + "/api/marketing/promotions/new";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetNewDynamicPromotion(_response);
      });
  }

  protected processGetNewDynamicPromotion(
    response: Response
  ): Promise<Promotion> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Promotion.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Promotion>(<any>null);
  }

  /**
   * Add new dynamic promotion object to marketing system
   * @param body (optional) dynamic promotion object that needs to be added to the marketing system
   * @return Success
   */
  createPromotion(body: Promotion | undefined): Promise<Promotion> {
    let url_ = this.baseUrl + "/api/marketing/promotions";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreatePromotion(_response);
      });
  }

  protected processCreatePromotion(response: Response): Promise<Promotion> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Promotion.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Promotion>(<any>null);
  }

  /**
   * Update a existing dynamic promotion object in marketing system
   * @param body (optional) >dynamic promotion object that needs to be updated in the marketing system
   * @return Success
   */
  updatePromotions(body: Promotion | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/marketing/promotions";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdatePromotions(_response);
      });
  }

  protected processUpdatePromotions(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete promotions objects
   * @param ids (optional) promotions object ids for delete in the marketing system
   * @return Success
   */
  deletePromotions(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/marketing/promotions?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeletePromotions(_response);
      });
  }

  protected processDeletePromotions(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  searchCoupons(
    body: CouponSearchCriteria | undefined
  ): Promise<CouponSearchResult> {
    let url_ = this.baseUrl + "/api/marketing/promotions/coupons/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchCoupons(_response);
      });
  }

  protected processSearchCoupons(
    response: Response
  ): Promise<CouponSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CouponSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CouponSearchResult>(<any>null);
  }

  /**
   * @return Success
   */
  getCoupon(id: string | null): Promise<Coupon> {
    let url_ = this.baseUrl + "/api/marketing/promotions/coupons/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetCoupon(_response);
      });
  }

  protected processGetCoupon(response: Response): Promise<Coupon> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Coupon.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Coupon>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addCoupons(body: Coupon[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/marketing/promotions/coupons/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processAddCoupons(_response);
      });
  }

  protected processAddCoupons(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param ids (optional)
   * @return Success
   */
  deleteCoupons(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/marketing/promotions/coupons/delete?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteCoupons(_response);
      });
  }

  protected processDeleteCoupons(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  importCoupons(body: ImportRequest | undefined): Promise<ImportNotification> {
    let url_ = this.baseUrl + "/api/marketing/promotions/coupons/import";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processImportCoupons(_response);
      });
  }

  protected processImportCoupons(
    response: Response
  ): Promise<ImportNotification> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ImportNotification.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ImportNotification>(<any>null);
  }
}

export class NotificationsClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Get all registered notification types by criteria
   * @param body (optional) criteria for search(keyword, skip, take and etc.)
   * @return Success
   */
  getNotifications(
    body: NotificationSearchCriteria | undefined
  ): Promise<NotificationSearchResult> {
    let url_ = this.baseUrl + "/api/notifications";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetNotifications(_response);
      });
  }

  protected processGetNotifications(
    response: Response
  ): Promise<NotificationSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = NotificationSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<NotificationSearchResult>(<any>null);
  }

  /**
   * Get notification by type
   * @param type Notification type of template
   * @param tenantId (optional) Tenant id of template
   * @param tenantType (optional) Tenant type id of template
   * @return Success
   */
  getNotificationByTypeId(
    type: string | null,
    tenantId: string | null | undefined,
    tenantType: string | null | undefined
  ): Promise<Notification> {
    let url_ = this.baseUrl + "/api/notifications/{type}?";
    if (type === undefined || type === null)
      throw new Error("The parameter 'type' must be defined.");
    url_ = url_.replace("{type}", encodeURIComponent("" + type));
    if (tenantId !== undefined && tenantId !== null)
      url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
    if (tenantType !== undefined && tenantType !== null)
      url_ += "tenantType=" + encodeURIComponent("" + tenantType) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetNotificationByTypeId(_response);
      });
  }

  protected processGetNotificationByTypeId(
    response: Response
  ): Promise<Notification> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Notification.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Notification>(<any>null);
  }

  /**
   * Update notification with templates
   * @param body (optional) Notification
   * @return Success
   */
  updateNotification(
    type: string,
    body: Notification | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/notifications/{type}";
    if (type === undefined || type === null)
      throw new Error("The parameter 'type' must be defined.");
    url_ = url_.replace("{type}", encodeURIComponent("" + type));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateNotification(_response);
      });
  }

  protected processUpdateNotification(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Render content
   * @param body (optional) request of Notification Template with text and data
   * @return Success
   */
  renderingTemplate(
    language: string | null,
    type: string,
    body: NotificationTemplateRequest | undefined
  ): Promise<void> {
    let url_ =
      this.baseUrl +
      "/api/notifications/{type}/templates/{language}/rendercontent";
    if (language === undefined || language === null)
      throw new Error("The parameter 'language' must be defined.");
    url_ = url_.replace("{language}", encodeURIComponent("" + language));
    if (type === undefined || type === null)
      throw new Error("The parameter 'type' must be defined.");
    url_ = url_.replace("{type}", encodeURIComponent("" + type));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processRenderingTemplate(_response);
      });
  }

  protected processRenderingTemplate(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Sending notification
   * @param body (optional)
   * @return Success
   */
  sendNotification(
    body: Notification | undefined
  ): Promise<NotificationSendResult> {
    let url_ = this.baseUrl + "/api/notifications/send";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSendNotification(_response);
      });
  }

  protected processSendNotification(
    response: Response
  ): Promise<NotificationSendResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = NotificationSendResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<NotificationSendResult>(<any>null);
  }

  /**
   * Schedule sending notification
   * @param body (optional)
   * @return Success
   */
  scheduleSendNotification(body: Notification | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/notifications/schedule";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processScheduleSendNotification(_response);
      });
  }

  protected processScheduleSendNotification(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Sending notification
   * @param body (optional) Notification request
   * @return Success
   */
  sendNotificationByRequest(
    body: NotificationRequest | undefined
  ): Promise<NotificationSendResult> {
    let url_ =
      this.baseUrl + "/api/platform/notification/template/sendnotification";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSendNotificationByRequest(_response);
      });
  }

  protected processSendNotificationByRequest(
    response: Response
  ): Promise<NotificationSendResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = NotificationSendResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<NotificationSendResult>(<any>null);
  }

  /**
   * Get all notification journal
   * @param body (optional)
   * @return Success
   */
  getNotificationJournal(
    body: NotificationMessageSearchCriteria | undefined
  ): Promise<NotificationMessageSearchResult> {
    let url_ = this.baseUrl + "/api/notifications/journal";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetNotificationJournal(_response);
      });
  }

  protected processGetNotificationJournal(
    response: Response
  ): Promise<NotificationMessageSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = NotificationMessageSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<NotificationMessageSearchResult>(<any>null);
  }

  /**
   * @return Success
   */
  getObjectNotificationJournal(
    id: string | null
  ): Promise<NotificationMessage> {
    let url_ = this.baseUrl + "/api/notifications/journal/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetObjectNotificationJournal(_response);
      });
  }

  protected processGetObjectNotificationJournal(
    response: Response
  ): Promise<NotificationMessage> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = NotificationMessage.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<NotificationMessage>(<any>null);
  }
}

export class OrderModuleClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Search customer orders by given criteria
   * @param body (optional) criteria
   * @return Success
   */
  searchCustomerOrder(
    body: CustomerOrderSearchCriteria | undefined
  ): Promise<CustomerOrderSearchResult> {
    let url_ = this.baseUrl + "/api/order/customerOrders/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchCustomerOrder(_response);
      });
  }

  protected processSearchCustomerOrder(
    response: Response
  ): Promise<CustomerOrderSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CustomerOrderSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CustomerOrderSearchResult>(<any>null);
  }

  /**
   * Find customer order by number
   * @param number customer order number
   * @param respGroup (optional)
   * @return Success
   */
  getByNumber(
    number: string | null,
    respGroup: string | null | undefined
  ): Promise<CustomerOrder> {
    let url_ = this.baseUrl + "/api/order/customerOrders/number/{number}?";
    if (number === undefined || number === null)
      throw new Error("The parameter 'number' must be defined.");
    url_ = url_.replace("{number}", encodeURIComponent("" + number));
    if (respGroup !== undefined && respGroup !== null)
      url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetByNumber(_response);
      });
  }

  protected processGetByNumber(response: Response): Promise<CustomerOrder> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CustomerOrder.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CustomerOrder>(<any>null);
  }

  /**
   * Find customer order by id
   * @param id customer order id
   * @param respGroup (optional)
   * @return Success
   */
  getById(
    id: string | null,
    respGroup: string | null | undefined
  ): Promise<CustomerOrder> {
    let url_ = this.baseUrl + "/api/order/customerOrders/{id}?";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (respGroup !== undefined && respGroup !== null)
      url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetById(_response);
      });
  }

  protected processGetById(response: Response): Promise<CustomerOrder> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CustomerOrder.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CustomerOrder>(<any>null);
  }

  /**
   * Calculate order totals after changes
   * @param body (optional) Customer order
   * @return Success
   */
  calculateTotals(body: CustomerOrder | undefined): Promise<CustomerOrder> {
    let url_ = this.baseUrl + "/api/order/customerOrders/recalculate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCalculateTotals(_response);
      });
  }

  protected processCalculateTotals(response: Response): Promise<CustomerOrder> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CustomerOrder.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CustomerOrder>(<any>null);
  }

  /**
   * Register customer order payment in external payment system
   * @param orderId customer order id
   * @param paymentId payment id
   * @param body (optional) banking card information
   * @return Success
   */
  processOrderPayments(
    orderId: string | null,
    paymentId: string | null,
    body: BankCardInfo | undefined
  ): Promise<ProcessPaymentRequestResult> {
    let url_ =
      this.baseUrl +
      "/api/order/customerOrders/{orderId}/processPayment/{paymentId}";
    if (orderId === undefined || orderId === null)
      throw new Error("The parameter 'orderId' must be defined.");
    url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
    if (paymentId === undefined || paymentId === null)
      throw new Error("The parameter 'paymentId' must be defined.");
    url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processProcessOrderPayments(_response);
      });
  }

  protected processProcessOrderPayments(
    response: Response
  ): Promise<ProcessPaymentRequestResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ProcessPaymentRequestResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ProcessPaymentRequestResult>(<any>null);
  }

  /**
   * Create new customer order based on shopping cart.
   * @param cartId shopping cart id
   * @return Success
   */
  createOrderFromCart(cartId: string | null): Promise<CustomerOrder> {
    let url_ = this.baseUrl + "/api/order/customerOrders/{cartId}";
    if (cartId === undefined || cartId === null)
      throw new Error("The parameter 'cartId' must be defined.");
    url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateOrderFromCart(_response);
      });
  }

  protected processCreateOrderFromCart(
    response: Response
  ): Promise<CustomerOrder> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CustomerOrder.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CustomerOrder>(<any>null);
  }

  /**
   * Add new customer order to system
   * @param body (optional) customer order
   * @return Success
   */
  createOrder(body: CustomerOrder | undefined): Promise<CustomerOrder> {
    let url_ = this.baseUrl + "/api/order/customerOrders";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateOrder(_response);
      });
  }

  protected processCreateOrder(response: Response): Promise<CustomerOrder> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CustomerOrder.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CustomerOrder>(<any>null);
  }

  /**
   * Update a existing customer order
   * @param body (optional) customer order
   * @return Success
   */
  updateOrder(body: CustomerOrder | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/order/customerOrders";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateOrder(_response);
      });
  }

  protected processUpdateOrder(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete a whole customer orders
   * @param ids (optional) customer order ids for delete
   * @return Success
   */
  deleteOrdersByIds(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/order/customerOrders?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteOrdersByIds(_response);
      });
  }

  protected processDeleteOrdersByIds(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get new shipment for specified customer order
   * @param id customer order id
   * @return Success
   */
  getNewShipment(id: string | null): Promise<OrderShipment> {
    let url_ = this.baseUrl + "/api/order/customerOrders/{id}/shipments/new";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetNewShipment(_response);
      });
  }

  protected processGetNewShipment(response: Response): Promise<OrderShipment> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = OrderShipment.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<OrderShipment>(<any>null);
  }

  /**
   * Get new payment for specified customer order
   * @param id customer order id
   * @return Success
   */
  getNewPayment(id: string | null): Promise<PaymentIn> {
    let url_ = this.baseUrl + "/api/order/customerOrders/{id}/payments/new";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetNewPayment(_response);
      });
  }

  protected processGetNewPayment(response: Response): Promise<PaymentIn> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PaymentIn.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentIn>(<any>null);
  }

  /**
   * Get a some order statistic information for Commerce manager dashboard
   * @param start (optional) start interval date
   * @param end (optional) end interval date
   * @return Success
   */
  getDashboardStatistics(
    start: Date | null | undefined,
    end: Date | null | undefined
  ): Promise<DashboardStatisticsResult> {
    let url_ = this.baseUrl + "/api/order/dashboardStatistics?";
    if (start !== undefined && start !== null)
      url_ +=
        "start=" + encodeURIComponent(start ? "" + start.toJSON() : "") + "&";
    if (end !== undefined && end !== null)
      url_ += "end=" + encodeURIComponent(end ? "" + end.toJSON() : "") + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetDashboardStatistics(_response);
      });
  }

  protected processGetDashboardStatistics(
    response: Response
  ): Promise<DashboardStatisticsResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DashboardStatisticsResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<DashboardStatisticsResult>(<any>null);
  }

  /**
   * Payment callback operation used by external payment services to inform post process payment in our system
   * @param body (optional) payment callback parameters
   * @return Success
   */
  postProcessPayment(
    body: PaymentCallbackParameters | undefined
  ): Promise<PostProcessPaymentRequestResult> {
    let url_ = this.baseUrl + "/api/paymentcallback";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processPostProcessPayment(_response);
      });
  }

  protected processPostProcessPayment(
    response: Response
  ): Promise<PostProcessPaymentRequestResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PostProcessPaymentRequestResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PostProcessPaymentRequestResult>(<any>null);
  }

  /**
   * @return OK
   */
  getInvoicePdf(orderNumber: string | null): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/order/customerOrders/invoice/{orderNumber}";
    if (orderNumber === undefined || orderNumber === null)
      throw new Error("The parameter 'orderNumber' must be defined.");
    url_ = url_.replace("{orderNumber}", encodeURIComponent("" + orderNumber));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "application/octet-stream",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetInvoicePdf(_response);
      });
  }

  protected processGetInvoicePdf(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(<any>null);
  }

  /**
   * @return Success
   */
  getOrderChanges(id: string | null): Promise<OperationLog[]> {
    let url_ = this.baseUrl + "/api/order/customerOrders/{id}/changes";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetOrderChanges(_response);
      });
  }

  protected processGetOrderChanges(
    response: Response
  ): Promise<OperationLog[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(OperationLog.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<OperationLog[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  searchOrderChanges(
    body: CustomerOrderHistorySearchCriteria | undefined
  ): Promise<ChangeLogSearchResult> {
    let url_ = this.baseUrl + "/api/order/customerOrders/searchChanges";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchOrderChanges(_response);
      });
  }

  protected processSearchOrderChanges(
    response: Response
  ): Promise<ChangeLogSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ChangeLogSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ChangeLogSearchResult>(<any>null);
  }

  /**
   * @return Success
   */
  getOrderFullTextSearchEnabled(): Promise<void> {
    let url_ = this.baseUrl + "/api/order/customerOrders/indexed/searchEnabled";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetOrderFullTextSearchEnabled(_response);
      });
  }

  protected processGetOrderFullTextSearchEnabled(
    response: Response
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  searchCustomerOrderIndexed(
    body: CustomerOrderIndexedSearchCriteria | undefined
  ): Promise<CustomerOrderSearchResult> {
    let url_ = this.baseUrl + "/api/order/customerOrders/indexed/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchCustomerOrderIndexed(_response);
      });
  }

  protected processSearchCustomerOrderIndexed(
    response: Response
  ): Promise<CustomerOrderSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CustomerOrderSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CustomerOrderSearchResult>(<any>null);
  }
}

export class OrderModulePaymentsClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Search  order payments by given criteria
   * @param body (optional) criteria
   * @return Success
   */
  searchOrderPayments(
    body: PaymentSearchCriteria | undefined
  ): Promise<PaymentSearchResult> {
    let url_ = this.baseUrl + "/api/order/payments/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchOrderPayments(_response);
      });
  }

  protected processSearchOrderPayments(
    response: Response
  ): Promise<PaymentSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PaymentSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentSearchResult>(<any>null);
  }

  /**
   * Find  order payment by id
   * @param id order payment id
   * @param respGroup (optional)
   * @return Success
   */
  getById(
    id: string | null,
    respGroup: string | null | undefined
  ): Promise<PaymentIn> {
    let url_ = this.baseUrl + "/api/order/payments/{id}?";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (respGroup !== undefined && respGroup !== null)
      url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetById(_response);
      });
  }

  protected processGetById(response: Response): Promise<PaymentIn> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PaymentIn.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentIn>(<any>null);
  }

  /**
   * Create or update order payment
   * @param body (optional) payment
   * @return Success
   */
  createPayment(body: PaymentIn | undefined): Promise<CustomerOrder> {
    let url_ = this.baseUrl + "/api/order/payments";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreatePayment(_response);
      });
  }

  protected processCreatePayment(response: Response): Promise<CustomerOrder> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CustomerOrder.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CustomerOrder>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updatePayment(body: PaymentIn | undefined): Promise<CustomerOrder> {
    let url_ = this.baseUrl + "/api/order/payments";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdatePayment(_response);
      });
  }

  protected processUpdatePayment(response: Response): Promise<CustomerOrder> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CustomerOrder.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CustomerOrder>(<any>null);
  }

  /**
   * Delete an order payment
   * @param ids (optional) order payment ids
   * @return Success
   */
  deleteOrderPaymentsByIds(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/order/payments?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteOrderPaymentsByIds(_response);
      });
  }

  protected processDeleteOrderPaymentsByIds(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class PaymentModuleClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  getRegisteredPaymentMethods(): Promise<PaymentMethod> {
    let url_ = this.baseUrl + "/api/payment";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetRegisteredPaymentMethods(_response);
      });
  }

  protected processGetRegisteredPaymentMethods(
    response: Response
  ): Promise<PaymentMethod> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PaymentMethod.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentMethod>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updatePaymentMethod(body: PaymentMethod | undefined): Promise<PaymentMethod> {
    let url_ = this.baseUrl + "/api/payment";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdatePaymentMethod(_response);
      });
  }

  protected processUpdatePaymentMethod(
    response: Response
  ): Promise<PaymentMethod> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PaymentMethod.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentMethod>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  searchPaymentMethods(
    body: PaymentMethodsSearchCriteria | undefined
  ): Promise<PaymentMethodsSearchResult> {
    let url_ = this.baseUrl + "/api/payment/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchPaymentMethods(_response);
      });
  }

  protected processSearchPaymentMethods(
    response: Response
  ): Promise<PaymentMethodsSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PaymentMethodsSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentMethodsSearchResult>(<any>null);
  }

  /**
   * @return Success
   */
  getPaymentMethodById(id: string | null): Promise<PaymentMethod> {
    let url_ = this.baseUrl + "/api/payment/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetPaymentMethodById(_response);
      });
  }

  protected processGetPaymentMethodById(
    response: Response
  ): Promise<PaymentMethod> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PaymentMethod.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentMethod>(<any>null);
  }
}

export class PricingModuleClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Evaluate prices by given context
   * @param body (optional) Pricing evaluation context
   * @return Success
   */
  evaluatePrices(body: PriceEvaluationContext | undefined): Promise<Price[]> {
    let url_ = this.baseUrl + "/api/pricing/evaluate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processEvaluatePrices(_response);
      });
  }

  protected processEvaluatePrices(response: Response): Promise<Price[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(Price.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Price[]>(<any>null);
  }

  /**
   * Evaluate pricelists by given context
   * @param body (optional) Pricing evaluation context
   * @return Success
   */
  evaluatePriceLists(
    body: PriceEvaluationContext | undefined
  ): Promise<Pricelist[]> {
    let url_ = this.baseUrl + "/api/pricing/pricelists/evaluate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processEvaluatePriceLists(_response);
      });
  }

  protected processEvaluatePriceLists(
    response: Response
  ): Promise<Pricelist[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Pricelist.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Pricelist[]>(<any>null);
  }

  /**
   * Get pricelist assignment
   * @param id Pricelist assignment id
   * @return Success
   */
  getPricelistAssignmentById(id: string | null): Promise<PricelistAssignment> {
    let url_ = this.baseUrl + "/api/pricing/assignments/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetPricelistAssignmentById(_response);
      });
  }

  protected processGetPricelistAssignmentById(
    response: Response
  ): Promise<PricelistAssignment> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PricelistAssignment.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PricelistAssignment>(<any>null);
  }

  /**
   * Get a new pricelist assignment
   * @return Success
   */
  getNewPricelistAssignments(): Promise<PricelistAssignment> {
    let url_ = this.baseUrl + "/api/pricing/assignments/new";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetNewPricelistAssignments(_response);
      });
  }

  protected processGetNewPricelistAssignments(
    response: Response
  ): Promise<PricelistAssignment> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PricelistAssignment.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PricelistAssignment>(<any>null);
  }

  /**
   * Get pricelists
   * @param currencies (optional)
   * @param responseGroup (optional)
   * @param objectType (optional) Search object type
   * @param objectTypes (optional)
   * @param objectIds (optional)
   * @param keyword (optional) Search phrase
   * @param searchPhrase (optional) Property is left for backward compatibility
   * @param languageCode (optional) Search phrase language
   * @param sort (optional)
   * @param sortInfos (optional)
   * @param skip (optional)
   * @param take (optional)
   * @return Success
   */
  searchPricelists(
    currencies: string[] | null | undefined,
    responseGroup: string | null | undefined,
    objectType: string | null | undefined,
    objectTypes: string[] | null | undefined,
    objectIds: string[] | null | undefined,
    keyword: string | null | undefined,
    searchPhrase: string | null | undefined,
    languageCode: string | null | undefined,
    sort: string | null | undefined,
    sortInfos: SortInfo[] | null | undefined,
    skip: number | undefined,
    take: number | undefined
  ): Promise<PricelistSearchResult> {
    let url_ = this.baseUrl + "/api/pricing/pricelists?";
    if (currencies !== undefined && currencies !== null)
      currencies &&
        currencies.forEach((item) => {
          url_ += "Currencies=" + encodeURIComponent("" + item) + "&";
        });
    if (responseGroup !== undefined && responseGroup !== null)
      url_ += "ResponseGroup=" + encodeURIComponent("" + responseGroup) + "&";
    if (objectType !== undefined && objectType !== null)
      url_ += "ObjectType=" + encodeURIComponent("" + objectType) + "&";
    if (objectTypes !== undefined && objectTypes !== null)
      objectTypes &&
        objectTypes.forEach((item) => {
          url_ += "ObjectTypes=" + encodeURIComponent("" + item) + "&";
        });
    if (objectIds !== undefined && objectIds !== null)
      objectIds &&
        objectIds.forEach((item) => {
          url_ += "ObjectIds=" + encodeURIComponent("" + item) + "&";
        });
    if (keyword !== undefined && keyword !== null)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (searchPhrase !== undefined && searchPhrase !== null)
      url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
    if (languageCode !== undefined && languageCode !== null)
      url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
    if (sort !== undefined && sort !== null)
      url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
    if (sortInfos !== undefined && sortInfos !== null)
      sortInfos &&
        sortInfos.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                "SortInfos[" +
                index +
                "]." +
                attr +
                "=" +
                encodeURIComponent("" + (<any>item)[attr]) +
                "&";
            }
        });
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.");
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
    if (take === null) throw new Error("The parameter 'take' cannot be null.");
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchPricelists(_response);
      });
  }

  protected processSearchPricelists(
    response: Response
  ): Promise<PricelistSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PricelistSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PricelistSearchResult>(<any>null);
  }

  /**
   * Create pricelist
   * @param body (optional)
   * @return Success
   */
  createPriceList(body: Pricelist | undefined): Promise<Pricelist> {
    let url_ = this.baseUrl + "/api/pricing/pricelists";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreatePriceList(_response);
      });
  }

  protected processCreatePriceList(response: Response): Promise<Pricelist> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Pricelist.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Pricelist>(<any>null);
  }

  /**
   * Update pricelist
   * @param body (optional)
   * @return Success
   */
  updatePriceList(body: Pricelist | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/pricing/pricelists";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdatePriceList(_response);
      });
  }

  protected processUpdatePriceList(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete pricelists
   * @param ids (optional) An array of pricelist ids
   * @return Success
   */
  deletePricelists(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/pricing/pricelists?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeletePricelists(_response);
      });
  }

  protected processDeletePricelists(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Search pricelist assignments
   * @param priceListId (optional)
   * @param catalogIds (optional)
   * @param priceListIds (optional)
   * @param responseGroup (optional)
   * @param objectType (optional) Search object type
   * @param objectTypes (optional)
   * @param objectIds (optional)
   * @param keyword (optional) Search phrase
   * @param searchPhrase (optional) Property is left for backward compatibility
   * @param languageCode (optional) Search phrase language
   * @param sort (optional)
   * @param sortInfos (optional)
   * @param skip (optional)
   * @param take (optional)
   * @return Success
   */
  searchPricelistAssignments(
    priceListId: string | null | undefined,
    catalogIds: string[] | null | undefined,
    priceListIds: string[] | null | undefined,
    responseGroup: string | null | undefined,
    objectType: string | null | undefined,
    objectTypes: string[] | null | undefined,
    objectIds: string[] | null | undefined,
    keyword: string | null | undefined,
    searchPhrase: string | null | undefined,
    languageCode: string | null | undefined,
    sort: string | null | undefined,
    sortInfos: SortInfo[] | null | undefined,
    skip: number | undefined,
    take: number | undefined
  ): Promise<PricelistAssignmentSearchResult> {
    let url_ = this.baseUrl + "/api/pricing/assignments?";
    if (priceListId !== undefined && priceListId !== null)
      url_ += "PriceListId=" + encodeURIComponent("" + priceListId) + "&";
    if (catalogIds !== undefined && catalogIds !== null)
      catalogIds &&
        catalogIds.forEach((item) => {
          url_ += "CatalogIds=" + encodeURIComponent("" + item) + "&";
        });
    if (priceListIds !== undefined && priceListIds !== null)
      priceListIds &&
        priceListIds.forEach((item) => {
          url_ += "PriceListIds=" + encodeURIComponent("" + item) + "&";
        });
    if (responseGroup !== undefined && responseGroup !== null)
      url_ += "ResponseGroup=" + encodeURIComponent("" + responseGroup) + "&";
    if (objectType !== undefined && objectType !== null)
      url_ += "ObjectType=" + encodeURIComponent("" + objectType) + "&";
    if (objectTypes !== undefined && objectTypes !== null)
      objectTypes &&
        objectTypes.forEach((item) => {
          url_ += "ObjectTypes=" + encodeURIComponent("" + item) + "&";
        });
    if (objectIds !== undefined && objectIds !== null)
      objectIds &&
        objectIds.forEach((item) => {
          url_ += "ObjectIds=" + encodeURIComponent("" + item) + "&";
        });
    if (keyword !== undefined && keyword !== null)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (searchPhrase !== undefined && searchPhrase !== null)
      url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
    if (languageCode !== undefined && languageCode !== null)
      url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
    if (sort !== undefined && sort !== null)
      url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
    if (sortInfos !== undefined && sortInfos !== null)
      sortInfos &&
        sortInfos.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                "SortInfos[" +
                index +
                "]." +
                attr +
                "=" +
                encodeURIComponent("" + (<any>item)[attr]) +
                "&";
            }
        });
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.");
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
    if (take === null) throw new Error("The parameter 'take' cannot be null.");
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchPricelistAssignments(_response);
      });
  }

  protected processSearchPricelistAssignments(
    response: Response
  ): Promise<PricelistAssignmentSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PricelistAssignmentSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PricelistAssignmentSearchResult>(<any>null);
  }

  /**
   * Create pricelist assignment
   * @param body (optional) PricelistAssignment
   * @return Success
   */
  createPricelistAssignment(
    body: PricelistAssignment | undefined
  ): Promise<PricelistAssignment> {
    let url_ = this.baseUrl + "/api/pricing/assignments";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreatePricelistAssignment(_response);
      });
  }

  protected processCreatePricelistAssignment(
    response: Response
  ): Promise<PricelistAssignment> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PricelistAssignment.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PricelistAssignment>(<any>null);
  }

  /**
   * Update pricelist assignment
   * @param body (optional) PricelistAssignment
   * @return Success
   */
  updatePriceListAssignment(
    body: PricelistAssignment | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/pricing/assignments";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdatePriceListAssignment(_response);
      });
  }

  protected processUpdatePriceListAssignment(
    response: Response
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete pricelist assignments
   * @param ids (optional) An array of pricelist assignment ids
   * @return Success
   */
  deleteAssignments(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/pricing/assignments?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteAssignments(_response);
      });
  }

  protected processDeleteAssignments(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Search product prices
   * @param groupByProducts (optional)
   * @param priceListId (optional)
   * @param priceListIds (optional)
   * @param productId (optional)
   * @param productIds (optional)
   * @param modifiedSince (optional)
   * @param responseGroup (optional)
   * @param objectType (optional) Search object type
   * @param objectTypes (optional)
   * @param objectIds (optional)
   * @param keyword (optional) Search phrase
   * @param searchPhrase (optional) Property is left for backward compatibility
   * @param languageCode (optional) Search phrase language
   * @param sort (optional)
   * @param sortInfos (optional)
   * @param skip (optional)
   * @param take (optional)
   * @return Success
   */
  searchProductPricesGet(
    groupByProducts: boolean | undefined,
    priceListId: string | null | undefined,
    priceListIds: string[] | null | undefined,
    productId: string | null | undefined,
    productIds: string[] | null | undefined,
    modifiedSince: Date | null | undefined,
    responseGroup: string | null | undefined,
    objectType: string | null | undefined,
    objectTypes: string[] | null | undefined,
    objectIds: string[] | null | undefined,
    keyword: string | null | undefined,
    searchPhrase: string | null | undefined,
    languageCode: string | null | undefined,
    sort: string | null | undefined,
    sortInfos: SortInfo[] | null | undefined,
    skip: number | undefined,
    take: number | undefined
  ): Promise<ProductPriceSearchResult> {
    let url_ = this.baseUrl + "/api/catalog/products/prices/search?";
    if (groupByProducts === null)
      throw new Error("The parameter 'groupByProducts' cannot be null.");
    else if (groupByProducts !== undefined)
      url_ +=
        "GroupByProducts=" + encodeURIComponent("" + groupByProducts) + "&";
    if (priceListId !== undefined && priceListId !== null)
      url_ += "PriceListId=" + encodeURIComponent("" + priceListId) + "&";
    if (priceListIds !== undefined && priceListIds !== null)
      priceListIds &&
        priceListIds.forEach((item) => {
          url_ += "PriceListIds=" + encodeURIComponent("" + item) + "&";
        });
    if (productId !== undefined && productId !== null)
      url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
    if (productIds !== undefined && productIds !== null)
      productIds &&
        productIds.forEach((item) => {
          url_ += "ProductIds=" + encodeURIComponent("" + item) + "&";
        });
    if (modifiedSince !== undefined && modifiedSince !== null)
      url_ +=
        "ModifiedSince=" +
        encodeURIComponent(modifiedSince ? "" + modifiedSince.toJSON() : "") +
        "&";
    if (responseGroup !== undefined && responseGroup !== null)
      url_ += "ResponseGroup=" + encodeURIComponent("" + responseGroup) + "&";
    if (objectType !== undefined && objectType !== null)
      url_ += "ObjectType=" + encodeURIComponent("" + objectType) + "&";
    if (objectTypes !== undefined && objectTypes !== null)
      objectTypes &&
        objectTypes.forEach((item) => {
          url_ += "ObjectTypes=" + encodeURIComponent("" + item) + "&";
        });
    if (objectIds !== undefined && objectIds !== null)
      objectIds &&
        objectIds.forEach((item) => {
          url_ += "ObjectIds=" + encodeURIComponent("" + item) + "&";
        });
    if (keyword !== undefined && keyword !== null)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (searchPhrase !== undefined && searchPhrase !== null)
      url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
    if (languageCode !== undefined && languageCode !== null)
      url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
    if (sort !== undefined && sort !== null)
      url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
    if (sortInfos !== undefined && sortInfos !== null)
      sortInfos &&
        sortInfos.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                "SortInfos[" +
                index +
                "]." +
                attr +
                "=" +
                encodeURIComponent("" + (<any>item)[attr]) +
                "&";
            }
        });
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.");
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
    if (take === null) throw new Error("The parameter 'take' cannot be null.");
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchProductPricesGet(_response);
      });
  }

  protected processSearchProductPricesGet(
    response: Response
  ): Promise<ProductPriceSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ProductPriceSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ProductPriceSearchResult>(<any>null);
  }

  /**
   * Search product prices
   * @param body (optional)
   * @return Success
   */
  searchProductPricesPost(
    body: PricesSearchCriteria | undefined
  ): Promise<ProductPriceSearchResult> {
    let url_ = this.baseUrl + "/api/catalog/products/prices/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchProductPricesPost(_response);
      });
  }

  protected processSearchProductPricesPost(
    response: Response
  ): Promise<ProductPriceSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ProductPriceSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ProductPriceSearchResult>(<any>null);
  }

  /**
   * Evaluate  product prices
   * @param productId Product id
   * @return Success
   */
  evaluateProductPrices(productId: string | null): Promise<Price[]> {
    let url_ = this.baseUrl + "/api/products/{productId}/prices";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processEvaluateProductPrices(_response);
      });
  }

  protected processEvaluateProductPrices(response: Response): Promise<Price[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(Price.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Price[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateProductPrices(
    productId: string,
    body: ProductPrice | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/products/{productId}/prices";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateProductPrices(_response);
      });
  }

  protected processUpdateProductPrices(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Evaluate product prices for demand catalog
   * @param productId Product id
   * @param catalogId Catalog id
   * @return Success
   */
  evaluateProductPricesForCatalog(
    productId: string | null,
    catalogId: string | null
  ): Promise<Price[]> {
    let url_ =
      this.baseUrl + "/api/products/{productId}/{catalogId}/pricesWidget";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    if (catalogId === undefined || catalogId === null)
      throw new Error("The parameter 'catalogId' must be defined.");
    url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processEvaluateProductPricesForCatalog(_response);
      });
  }

  protected processEvaluateProductPricesForCatalog(
    response: Response
  ): Promise<Price[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(Price.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Price[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateProductsPrices(body: ProductPrice[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/products/prices";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateProductsPrices(_response);
      });
  }

  protected processUpdateProductsPrices(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get all price lists for product
   * @param productId Product id
   * @return Success
   */
  getProductPriceLists(productId: string | null): Promise<Pricelist[]> {
    let url_ = this.baseUrl + "/api/catalog/products/{productId}/pricelists";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetProductPriceLists(_response);
      });
  }

  protected processGetProductPriceLists(
    response: Response
  ): Promise<Pricelist[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Pricelist.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Pricelist[]>(<any>null);
  }

  /**
   * Get pricelist
   * @param id Pricelist id
   * @return Success
   */
  getPriceListById(id: string | null): Promise<Pricelist> {
    let url_ = this.baseUrl + "/api/pricing/pricelists/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetPriceListById(_response);
      });
  }

  protected processGetPriceListById(response: Response): Promise<Pricelist> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Pricelist.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Pricelist>(<any>null);
  }

  /**
   * Delete pricelist assignments
   * @param priceListId (optional)
   * @param catalogIds (optional)
   * @param priceListIds (optional)
   * @param responseGroup (optional)
   * @param objectType (optional) Search object type
   * @param objectTypes (optional)
   * @param objectIds (optional)
   * @param keyword (optional) Search phrase
   * @param searchPhrase (optional) Property is left for backward compatibility
   * @param languageCode (optional) Search phrase language
   * @param sort (optional)
   * @param sortInfos (optional)
   * @param skip (optional)
   * @param take (optional)
   * @return Success
   */
  deleteFilteredAssignments(
    priceListId: string | null | undefined,
    catalogIds: string[] | null | undefined,
    priceListIds: string[] | null | undefined,
    responseGroup: string | null | undefined,
    objectType: string | null | undefined,
    objectTypes: string[] | null | undefined,
    objectIds: string[] | null | undefined,
    keyword: string | null | undefined,
    searchPhrase: string | null | undefined,
    languageCode: string | null | undefined,
    sort: string | null | undefined,
    sortInfos: SortInfo[] | null | undefined,
    skip: number | undefined,
    take: number | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/pricing/filteredAssignments?";
    if (priceListId !== undefined && priceListId !== null)
      url_ += "PriceListId=" + encodeURIComponent("" + priceListId) + "&";
    if (catalogIds !== undefined && catalogIds !== null)
      catalogIds &&
        catalogIds.forEach((item) => {
          url_ += "CatalogIds=" + encodeURIComponent("" + item) + "&";
        });
    if (priceListIds !== undefined && priceListIds !== null)
      priceListIds &&
        priceListIds.forEach((item) => {
          url_ += "PriceListIds=" + encodeURIComponent("" + item) + "&";
        });
    if (responseGroup !== undefined && responseGroup !== null)
      url_ += "ResponseGroup=" + encodeURIComponent("" + responseGroup) + "&";
    if (objectType !== undefined && objectType !== null)
      url_ += "ObjectType=" + encodeURIComponent("" + objectType) + "&";
    if (objectTypes !== undefined && objectTypes !== null)
      objectTypes &&
        objectTypes.forEach((item) => {
          url_ += "ObjectTypes=" + encodeURIComponent("" + item) + "&";
        });
    if (objectIds !== undefined && objectIds !== null)
      objectIds &&
        objectIds.forEach((item) => {
          url_ += "ObjectIds=" + encodeURIComponent("" + item) + "&";
        });
    if (keyword !== undefined && keyword !== null)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (searchPhrase !== undefined && searchPhrase !== null)
      url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
    if (languageCode !== undefined && languageCode !== null)
      url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
    if (sort !== undefined && sort !== null)
      url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
    if (sortInfos !== undefined && sortInfos !== null)
      sortInfos &&
        sortInfos.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                "SortInfos[" +
                index +
                "]." +
                attr +
                "=" +
                encodeURIComponent("" + (<any>item)[attr]) +
                "&";
            }
        });
    if (skip === null) throw new Error("The parameter 'skip' cannot be null.");
    else if (skip !== undefined)
      url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
    if (take === null) throw new Error("The parameter 'take' cannot be null.");
    else if (take !== undefined)
      url_ += "Take=" + encodeURIComponent("" + take) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteFilteredAssignments(_response);
      });
  }

  protected processDeleteFilteredAssignments(
    response: Response
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete all prices for specified product in specified price list
   * @param productIds (optional)
   * @return Success
   */
  deleteProductPrices(
    pricelistId: string | null,
    productIds: string[] | null | undefined
  ): Promise<void> {
    let url_ =
      this.baseUrl + "/api/pricing/pricelists/{pricelistId}/products/prices?";
    if (pricelistId === undefined || pricelistId === null)
      throw new Error("The parameter 'pricelistId' must be defined.");
    url_ = url_.replace("{pricelistId}", encodeURIComponent("" + pricelistId));
    if (productIds !== undefined && productIds !== null)
      productIds &&
        productIds.forEach((item) => {
          url_ += "productIds=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteProductPrices(_response);
      });
  }

  protected processDeleteProductPrices(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete price by ids
   * @param priceIds (optional)
   * @return Success
   */
  deleteProductPrice(priceIds: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/pricing/products/prices?";
    if (priceIds !== undefined && priceIds !== null)
      priceIds &&
        priceIds.forEach((item) => {
          url_ += "priceIds=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteProductPrice(_response);
      });
  }

  protected processDeleteProductPrice(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class QuoteModuleClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  search(
    body: QuoteRequestSearchCriteria | undefined
  ): Promise<QuoteRequestSearchResult> {
    let url_ = this.baseUrl + "/api/quote/requests/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearch(_response);
      });
  }

  protected processSearch(
    response: Response
  ): Promise<QuoteRequestSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = QuoteRequestSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<QuoteRequestSearchResult>(<any>null);
  }

  getById(id: string | null): Promise<void> {
    let url_ = this.baseUrl + "/api/quote/requests/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetById(_response);
      });
  }

  protected processGetById(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: QuoteRequest | undefined): Promise<QuoteRequest> {
    let url_ = this.baseUrl + "/api/quote/requests";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreate(_response);
      });
  }

  protected processCreate(response: Response): Promise<QuoteRequest> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = QuoteRequest.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<QuoteRequest>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: QuoteRequest | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/quote/requests";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdate(_response);
      });
  }

  protected processUpdate(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param ids (optional)
   * @return Success
   */
  delete(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/quote/requests?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDelete(_response);
      });
  }

  protected processDelete(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  calculateTotals(body: QuoteRequest | undefined): Promise<QuoteRequest> {
    let url_ = this.baseUrl + "/api/quote/requests/recalculate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCalculateTotals(_response);
      });
  }

  protected processCalculateTotals(response: Response): Promise<QuoteRequest> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = QuoteRequest.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<QuoteRequest>(<any>null);
  }

  /**
   * @return Success
   */
  getShipmentMethods(id: string | null): Promise<ShipmentMethod[]> {
    let url_ = this.baseUrl + "/api/quote/requests/{id}/shipmentmethods";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetShipmentMethods(_response);
      });
  }

  protected processGetShipmentMethods(
    response: Response
  ): Promise<ShipmentMethod[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ShipmentMethod.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ShipmentMethod[]>(<any>null);
  }
}

export class SearchIndexationModuleClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  getAllIndexes(): Promise<IndexState[]> {
    let url_ = this.baseUrl + "/api/search/indexes";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetAllIndexes(_response);
      });
  }

  protected processGetAllIndexes(response: Response): Promise<IndexState[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(IndexState.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<IndexState[]>(<any>null);
  }

  /**
   * Get search index for specified document type and document id.
   * @return Success
   */
  getDocumentIndex(
    documentType: string | null,
    documentId: string | null
  ): Promise<IndexDocument[]> {
    let url_ =
      this.baseUrl + "/api/search/indexes/index/{documentType}/{documentId}";
    if (documentType === undefined || documentType === null)
      throw new Error("The parameter 'documentType' must be defined.");
    url_ = url_.replace(
      "{documentType}",
      encodeURIComponent("" + documentType)
    );
    if (documentId === undefined || documentId === null)
      throw new Error("The parameter 'documentId' must be defined.");
    url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetDocumentIndex(_response);
      });
  }

  protected processGetDocumentIndex(
    response: Response
  ): Promise<IndexDocument[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(IndexDocument.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<IndexDocument[]>(<any>null);
  }

  /**
   * Run indexation process for specified options
   * @param body (optional)
   * @return Success
   */
  indexDocuments(
    body: IndexingOptions[] | null | undefined
  ): Promise<IndexProgressPushNotification> {
    let url_ = this.baseUrl + "/api/search/indexes/index";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processIndexDocuments(_response);
      });
  }

  protected processIndexDocuments(
    response: Response
  ): Promise<IndexProgressPushNotification> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = IndexProgressPushNotification.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<IndexProgressPushNotification>(<any>null);
  }

  /**
   * @return Success
   */
  cancelIndexationProcess(taskId: string | null): Promise<void> {
    let url_ = this.baseUrl + "/api/search/indexes/tasks/{taskId}/cancel";
    if (taskId === undefined || taskId === null)
      throw new Error("The parameter 'taskId' must be defined.");
    url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCancelIndexationProcess(_response);
      });
  }

  protected processCancelIndexationProcess(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class ShippingModuleClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  getRegisteredShippingMethods(): Promise<ShippingMethod> {
    let url_ = this.baseUrl + "/api/shipping";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetRegisteredShippingMethods(_response);
      });
  }

  protected processGetRegisteredShippingMethods(
    response: Response
  ): Promise<ShippingMethod> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ShippingMethod.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ShippingMethod>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateShippingMethod(
    body: ShippingMethod | undefined
  ): Promise<ShippingMethod> {
    let url_ = this.baseUrl + "/api/shipping";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateShippingMethod(_response);
      });
  }

  protected processUpdateShippingMethod(
    response: Response
  ): Promise<ShippingMethod> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ShippingMethod.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ShippingMethod>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  searchShippingMethods(
    body: ShippingMethodsSearchCriteria | undefined
  ): Promise<ShippingMethodsSearchResult> {
    let url_ = this.baseUrl + "/api/shipping/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchShippingMethods(_response);
      });
  }

  protected processSearchShippingMethods(
    response: Response
  ): Promise<ShippingMethodsSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ShippingMethodsSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ShippingMethodsSearchResult>(<any>null);
  }

  /**
   * @return Success
   */
  getShippingMethodById(id: string | null): Promise<ShippingMethod> {
    let url_ = this.baseUrl + "/api/shipping/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetShippingMethodById(_response);
      });
  }

  protected processGetShippingMethodById(
    response: Response
  ): Promise<ShippingMethod> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ShippingMethod.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ShippingMethod>(<any>null);
  }
}

export class SitemapsModuleApiClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  searchSitemaps(
    body: SitemapSearchCriteria | undefined
  ): Promise<SitemapSearchResult> {
    let url_ = this.baseUrl + "/api/sitemaps/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchSitemaps(_response);
      });
  }

  protected processSearchSitemaps(
    response: Response
  ): Promise<SitemapSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SitemapSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<SitemapSearchResult>(<any>null);
  }

  /**
   * @return Success
   */
  getSitemapById(id: string | null): Promise<Sitemap> {
    let url_ = this.baseUrl + "/api/sitemaps/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetSitemapById(_response);
      });
  }

  protected processGetSitemapById(response: Response): Promise<Sitemap> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Sitemap.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Sitemap>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addSitemap(body: Sitemap | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/sitemaps";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processAddSitemap(_response);
      });
  }

  protected processAddSitemap(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateSitemap(body: Sitemap | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/sitemaps";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateSitemap(_response);
      });
  }

  protected processUpdateSitemap(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param ids (optional)
   * @return Success
   */
  deleteSitemap(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/sitemaps?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteSitemap(_response);
      });
  }

  protected processDeleteSitemap(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  searchSitemapItems(
    body: SitemapItemSearchCriteria | undefined
  ): Promise<SitemapItemsSearchResult> {
    let url_ = this.baseUrl + "/api/sitemaps/items/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchSitemapItems(_response);
      });
  }

  protected processSearchSitemapItems(
    response: Response
  ): Promise<SitemapItemsSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SitemapItemsSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<SitemapItemsSearchResult>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addSitemapItems(
    sitemapId: string | null,
    body: SitemapItem[] | null | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/sitemaps/{sitemapId}/items";
    if (sitemapId === undefined || sitemapId === null)
      throw new Error("The parameter 'sitemapId' must be defined.");
    url_ = url_.replace("{sitemapId}", encodeURIComponent("" + sitemapId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processAddSitemapItems(_response);
      });
  }

  protected processAddSitemapItems(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param itemIds (optional)
   * @return Success
   */
  removeSitemapItems(itemIds: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/sitemaps/items?";
    if (itemIds !== undefined && itemIds !== null)
      itemIds &&
        itemIds.forEach((item) => {
          url_ += "itemIds=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processRemoveSitemapItems(_response);
      });
  }

  protected processRemoveSitemapItems(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param storeId (optional)
   * @return Success
   */
  getSitemapsSchema(storeId: string | null | undefined): Promise<string[]> {
    let url_ = this.baseUrl + "/api/sitemaps/schema?";
    if (storeId !== undefined && storeId !== null)
      url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetSitemapsSchema(_response);
      });
  }

  protected processGetSitemapsSchema(response: Response): Promise<string[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(item);
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<string[]>(<any>null);
  }

  /**
   * @param storeId (optional)
   * @param baseUrl (optional)
   * @param sitemapUrl (optional)
   * @return OK
   */
  generateSitemap(
    storeId: string | null | undefined,
    baseUrl: string | null | undefined,
    sitemapUrl: string | null | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/sitemaps/generate?";
    if (storeId !== undefined && storeId !== null)
      url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
    if (baseUrl !== undefined && baseUrl !== null)
      url_ += "baseUrl=" + encodeURIComponent("" + baseUrl) + "&";
    if (sitemapUrl !== undefined && sitemapUrl !== null)
      url_ += "sitemapUrl=" + encodeURIComponent("" + sitemapUrl) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "application/octet-stream",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGenerateSitemap(_response);
      });
  }

  protected processGenerateSitemap(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(<any>null);
  }

  /**
   * @param storeId (optional)
   * @param baseUrl (optional)
   * @return Success
   */
  downloadSitemap(
    storeId: string | null | undefined,
    baseUrl: string | null | undefined
  ): Promise<SitemapDownloadNotification> {
    let url_ = this.baseUrl + "/api/sitemaps/download?";
    if (storeId !== undefined && storeId !== null)
      url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
    if (baseUrl !== undefined && baseUrl !== null)
      url_ += "baseUrl=" + encodeURIComponent("" + baseUrl) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDownloadSitemap(_response);
      });
  }

  protected processDownloadSitemap(
    response: Response
  ): Promise<SitemapDownloadNotification> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SitemapDownloadNotification.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<SitemapDownloadNotification>(<any>null);
  }
}

export class StoreModuleClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Search stores
   * @param body (optional)
   * @return Success
   */
  searchStores(
    body: StoreSearchCriteria | undefined
  ): Promise<StoreSearchResult> {
    let url_ = this.baseUrl + "/api/stores/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchStores(_response);
      });
  }

  protected processSearchStores(
    response: Response
  ): Promise<StoreSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = StoreSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<StoreSearchResult>(<any>null);
  }

  /**
   * Get all stores
   * @return Success
   */
  getStores(): Promise<Store[]> {
    let url_ = this.baseUrl + "/api/stores";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetStores(_response);
      });
  }

  protected processGetStores(response: Response): Promise<Store[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(Store.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Store[]>(<any>null);
  }

  /**
   * Create store
   * @param body (optional) Store
   * @return Success
   */
  createStore(body: Store | undefined): Promise<Store> {
    let url_ = this.baseUrl + "/api/stores";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateStore(_response);
      });
  }

  protected processCreateStore(response: Response): Promise<Store> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Store.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Store>(<any>null);
  }

  /**
   * Update store
   * @param body (optional) Store
   * @return Success
   */
  updateStore(body: Store | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/stores";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateStore(_response);
      });
  }

  protected processUpdateStore(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete stores
   * @param ids (optional) Ids of store that needed to delete
   * @return Success
   */
  deleteStore(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/stores?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteStore(_response);
      });
  }

  protected processDeleteStore(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get store by id
   * @param id Store id
   * @return Success
   */
  getStoreById(id: string | null): Promise<Store> {
    let url_ = this.baseUrl + "/api/stores/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetStoreById(_response);
      });
  }

  protected processGetStoreById(response: Response): Promise<Store> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Store.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Store>(<any>null);
  }

  /**
   * Send dynamic notification (contains custom list of properties) to store or administrator email
   * @param body (optional)
   * @return Success
   */
  sendDynamicNotificationAnStoreEmail(
    body: SendDynamicNotificationRequest | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/stores/send/dynamicnotification";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSendDynamicNotificationAnStoreEmail(_response);
      });
  }

  protected processSendDynamicNotificationAnStoreEmail(
    response: Response
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Check if given contact has login on behalf permission
   * @param storeId Store ID
   * @param id Contact ID
   * @return Success
   */
  getLoginOnBehalfInfo(
    storeId: string | null,
    id: string | null
  ): Promise<LoginOnBehalfInfo> {
    let url_ =
      this.baseUrl + "/api/stores/{storeId}/accounts/{id}/loginonbehalf";
    if (storeId === undefined || storeId === null)
      throw new Error("The parameter 'storeId' must be defined.");
    url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetLoginOnBehalfInfo(_response);
      });
  }

  protected processGetLoginOnBehalfInfo(
    response: Response
  ): Promise<LoginOnBehalfInfo> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = LoginOnBehalfInfo.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<LoginOnBehalfInfo>(<any>null);
  }

  /**
   * Returns list of stores which user can sign in
   * @return Success
   */
  getUserAllowedStores(userId: string | null): Promise<Store[]> {
    let url_ = this.baseUrl + "/api/stores/allowed/{userId}";
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetUserAllowedStores(_response);
      });
  }

  protected processGetUserAllowedStores(response: Response): Promise<Store[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(Store.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Store[]>(<any>null);
  }
}

export class SubscriptionModuleClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Search subscriptions by given criteria
   * @param body (optional) criteria
   * @return Success
   */
  searchSubscriptions(
    body: SubscriptionSearchCriteria | undefined
  ): Promise<SubscriptionSearchResult> {
    let url_ = this.baseUrl + "/api/subscriptions/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchSubscriptions(_response);
      });
  }

  protected processSearchSubscriptions(
    response: Response
  ): Promise<SubscriptionSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SubscriptionSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<SubscriptionSearchResult>(<any>null);
  }

  /**
   * @param respGroup (optional)
   * @return Success
   */
  getSubscriptionById(
    id: string | null,
    respGroup: string | null | undefined
  ): Promise<Subscription> {
    let url_ = this.baseUrl + "/api/subscriptions/{id}?";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (respGroup !== undefined && respGroup !== null)
      url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetSubscriptionById(_response);
      });
  }

  protected processGetSubscriptionById(
    response: Response
  ): Promise<Subscription> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Subscription.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Subscription>(<any>null);
  }

  /**
   * @param ids (optional)
   * @param respGroup (optional)
   * @return Success
   */
  getSubscriptionByIds(
    ids: string[] | null | undefined,
    respGroup: string | null | undefined
  ): Promise<Subscription[]> {
    let url_ = this.baseUrl + "/api/subscriptions?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    if (respGroup !== undefined && respGroup !== null)
      url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetSubscriptionByIds(_response);
      });
  }

  protected processGetSubscriptionByIds(
    response: Response
  ): Promise<Subscription[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Subscription.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Subscription[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createSubscription(body: Subscription | undefined): Promise<Subscription> {
    let url_ = this.baseUrl + "/api/subscriptions";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateSubscription(_response);
      });
  }

  protected processCreateSubscription(
    response: Response
  ): Promise<Subscription> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Subscription.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Subscription>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateSubscription(body: Subscription | undefined): Promise<Subscription> {
    let url_ = this.baseUrl + "/api/subscriptions";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateSubscription(_response);
      });
  }

  protected processUpdateSubscription(
    response: Response
  ): Promise<Subscription> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Subscription.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Subscription>(<any>null);
  }

  /**
   * Delete subscriptions
   * @param ids (optional) subscriptions' ids for delete
   * @return Success
   */
  deleteSubscriptionsByIds(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/subscriptions?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteSubscriptionsByIds(_response);
      });
  }

  protected processDeleteSubscriptionsByIds(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createReccurentOrderForSubscription(
    body: Subscription | undefined
  ): Promise<CustomerOrder> {
    let url_ = this.baseUrl + "/api/subscriptions/order";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateReccurentOrderForSubscription(_response);
      });
  }

  protected processCreateReccurentOrderForSubscription(
    response: Response
  ): Promise<CustomerOrder> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CustomerOrder.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<CustomerOrder>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  cancelSubscription(
    body: SubscriptionCancelRequest | undefined
  ): Promise<Subscription> {
    let url_ = this.baseUrl + "/api/subscriptions/cancel";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCancelSubscription(_response);
      });
  }

  protected processCancelSubscription(
    response: Response
  ): Promise<Subscription> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Subscription.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<Subscription>(<any>null);
  }

  /**
   * @return Success
   */
  getPaymentPlanById(id: string | null): Promise<PaymentPlan> {
    let url_ = this.baseUrl + "/api/subscriptions/plans/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetPaymentPlanById(_response);
      });
  }

  protected processGetPaymentPlanById(
    response: Response
  ): Promise<PaymentPlan> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PaymentPlan.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentPlan>(<any>null);
  }

  /**
   * @param ids (optional)
   * @return Success
   */
  getPaymentPlanByIds(
    ids: string[] | null | undefined
  ): Promise<PaymentPlan[]> {
    let url_ = this.baseUrl + "/api/subscriptions/plans?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetPaymentPlanByIds(_response);
      });
  }

  protected processGetPaymentPlanByIds(
    response: Response
  ): Promise<PaymentPlan[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(PaymentPlan.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentPlan[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createPaymentPlan(body: PaymentPlan | undefined): Promise<PaymentPlan> {
    let url_ = this.baseUrl + "/api/subscriptions/plans";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreatePaymentPlan(_response);
      });
  }

  protected processCreatePaymentPlan(response: Response): Promise<PaymentPlan> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PaymentPlan.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentPlan>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updatePaymentPlan(body: PaymentPlan | undefined): Promise<PaymentPlan> {
    let url_ = this.baseUrl + "/api/subscriptions/plans";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdatePaymentPlan(_response);
      });
  }

  protected processUpdatePaymentPlan(response: Response): Promise<PaymentPlan> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PaymentPlan.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentPlan>(<any>null);
  }

  /**
   * Delete payment plans
   * @param ids (optional) plans' ids for delete
   * @return Success
   */
  deletePlansByIds(ids: string[] | null | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/subscriptions/plans?";
    if (ids !== undefined && ids !== null)
      ids &&
        ids.forEach((item) => {
          url_ += "ids=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {},
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeletePlansByIds(_response);
      });
  }

  protected processDeletePlansByIds(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Gets plans by plenty ids
   * @param body (optional) Item ids
   * @return Success
   */
  getPaymentPlansByPlentyIds(
    body: string[] | null | undefined
  ): Promise<PaymentPlan[]> {
    let url_ = this.baseUrl + "/api/subscriptions/plans/plenty";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetPaymentPlansByPlentyIds(_response);
      });
  }

  protected processGetPaymentPlansByPlentyIds(
    response: Response
  ): Promise<PaymentPlan[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(PaymentPlan.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaymentPlan[]>(<any>null);
  }
}

export class TaxModuleClient extends AuthApiBase {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    super();
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  searchTaxProviders(
    body: TaxProviderSearchCriteria | undefined
  ): Promise<TaxProviderSearchResult> {
    let url_ = this.baseUrl + "/api/taxes/search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processSearchTaxProviders(_response);
      });
  }

  protected processSearchTaxProviders(
    response: Response
  ): Promise<TaxProviderSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = TaxProviderSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<TaxProviderSearchResult>(<any>null);
  }

  /**
   * @return Success
   */
  getTaxProviderById(id: string | null): Promise<TaxProviderSearchResult> {
    let url_ = this.baseUrl + "/api/taxes/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetTaxProviderById(_response);
      });
  }

  protected processGetTaxProviderById(
    response: Response
  ): Promise<TaxProviderSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = TaxProviderSearchResult.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<TaxProviderSearchResult>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateTaxProvider(body: TaxProvider | undefined): Promise<TaxProvider> {
    let url_ = this.baseUrl + "/api/taxes";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateTaxProvider(_response);
      });
  }

  protected processUpdateTaxProvider(response: Response): Promise<TaxProvider> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = TaxProvider.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<TaxProvider>(<any>null);
  }

  /**
   * Evaluate and return all tax rates for specified store and evaluation context
   * @param body (optional)
   * @return Success
   */
  evaluateTaxes(
    storeId: string | null,
    body: TaxEvaluationContext | undefined
  ): Promise<TaxRate[]> {
    let url_ = this.baseUrl + "/api/taxes/{storeId}/evaluate";
    if (storeId === undefined || storeId === null)
      throw new Error("The parameter 'storeId' must be defined.");
    url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processEvaluateTaxes(_response);
      });
  }

  protected processEvaluateTaxes(response: Response): Promise<TaxRate[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(TaxRate.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<TaxRate[]>(<any>null);
  }
}

export class TenantIdentity implements ITenantIdentity {
  id?: string | undefined;
  type?: string | undefined;
  readonly isEmpty?: boolean;
  readonly isValid?: boolean;

  constructor(data?: ITenantIdentity) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.type = _data["type"];
      (<any>this).isEmpty = _data["isEmpty"];
      (<any>this).isValid = _data["isValid"];
    }
  }

  static fromJS(data: any): TenantIdentity {
    data = typeof data === "object" ? data : {};
    let result = new TenantIdentity();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["type"] = this.type;
    data["isEmpty"] = this.isEmpty;
    data["isValid"] = this.isValid;
    return data;
  }
}

export interface ITenantIdentity {
  id?: string | undefined;
  type?: string | undefined;
  isEmpty?: boolean;
  isValid?: boolean;
}

export enum SortDirection {
  Ascending = "Ascending",
  Descending = "Descending",
}

export class SortInfo implements ISortInfo {
  sortColumn?: string | undefined;
  sortDirection?: SortDirection;

  constructor(data?: ISortInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.sortColumn = _data["sortColumn"];
      this.sortDirection = _data["sortDirection"];
    }
  }

  static fromJS(data: any): SortInfo {
    data = typeof data === "object" ? data : {};
    let result = new SortInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["sortColumn"] = this.sortColumn;
    data["sortDirection"] = this.sortDirection;
    return data;
  }
}

export interface ISortInfo {
  sortColumn?: string | undefined;
  sortDirection?: SortDirection;
}

export class AssetEntrySearchCriteria implements IAssetEntrySearchCriteria {
  tenants?: TenantIdentity[] | undefined;
  group?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IAssetEntrySearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["tenants"])) {
        this.tenants = [] as any;
        for (let item of _data["tenants"])
          this.tenants!.push(TenantIdentity.fromJS(item));
      }
      this.group = _data["group"];
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): AssetEntrySearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new AssetEntrySearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.tenants)) {
      data["tenants"] = [];
      for (let item of this.tenants) data["tenants"].push(item.toJSON());
    }
    data["group"] = this.group;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IAssetEntrySearchCriteria {
  tenants?: TenantIdentity[] | undefined;
  group?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class BlobInfo implements IBlobInfo {
  /** Relative url */
  key?: string | undefined;
  size?: number;
  contentType?: string | undefined;
  type?: string | undefined;
  name?: string | undefined;
  url?: string | undefined;
  relativeUrl?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IBlobInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.key = _data["key"];
      this.size = _data["size"];
      this.contentType = _data["contentType"];
      this.type = _data["type"];
      this.name = _data["name"];
      this.url = _data["url"];
      this.relativeUrl = _data["relativeUrl"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): BlobInfo {
    data = typeof data === "object" ? data : {};
    let result = new BlobInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["key"] = this.key;
    data["size"] = this.size;
    data["contentType"] = this.contentType;
    data["type"] = this.type;
    data["name"] = this.name;
    data["url"] = this.url;
    data["relativeUrl"] = this.relativeUrl;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IBlobInfo {
  /** Relative url */
  key?: string | undefined;
  size?: number;
  contentType?: string | undefined;
  type?: string | undefined;
  name?: string | undefined;
  url?: string | undefined;
  relativeUrl?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class AssetEntry implements IAssetEntry {
  /** Asset language */
  languageCode?: string | undefined;
  tenant?: TenantIdentity;
  blobInfo?: BlobInfo;
  /** User defined grouping (optional) */
  group?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IAssetEntry) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.languageCode = _data["languageCode"];
      this.tenant = _data["tenant"]
        ? TenantIdentity.fromJS(_data["tenant"])
        : <any>undefined;
      this.blobInfo = _data["blobInfo"]
        ? BlobInfo.fromJS(_data["blobInfo"])
        : <any>undefined;
      this.group = _data["group"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): AssetEntry {
    data = typeof data === "object" ? data : {};
    let result = new AssetEntry();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["languageCode"] = this.languageCode;
    data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
    data["blobInfo"] = this.blobInfo ? this.blobInfo.toJSON() : <any>undefined;
    data["group"] = this.group;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IAssetEntry {
  /** Asset language */
  languageCode?: string | undefined;
  tenant?: TenantIdentity;
  blobInfo?: BlobInfo;
  /** User defined grouping (optional) */
  group?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class AssetEntrySearchResult implements IAssetEntrySearchResult {
  totalCount?: number;
  results?: AssetEntry[] | undefined;

  constructor(data?: IAssetEntrySearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(AssetEntry.fromJS(item));
      }
    }
  }

  static fromJS(data: any): AssetEntrySearchResult {
    data = typeof data === "object" ? data : {};
    let result = new AssetEntrySearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IAssetEntrySearchResult {
  totalCount?: number;
  results?: AssetEntry[] | undefined;
}

export class BlobEntry implements IBlobEntry {
  type?: string | undefined;
  name?: string | undefined;
  url?: string | undefined;
  relativeUrl?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IBlobEntry) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data["type"];
      this.name = _data["name"];
      this.url = _data["url"];
      this.relativeUrl = _data["relativeUrl"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): BlobEntry {
    data = typeof data === "object" ? data : {};
    let result = new BlobEntry();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["type"] = this.type;
    data["name"] = this.name;
    data["url"] = this.url;
    data["relativeUrl"] = this.relativeUrl;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IBlobEntry {
  type?: string | undefined;
  name?: string | undefined;
  url?: string | undefined;
  relativeUrl?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class BlobEntrySearchResult implements IBlobEntrySearchResult {
  totalCount?: number;
  results?: BlobEntry[] | undefined;

  constructor(data?: IBlobEntrySearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(BlobEntry.fromJS(item));
      }
    }
  }

  static fromJS(data: any): BlobEntrySearchResult {
    data = typeof data === "object" ? data : {};
    let result = new BlobEntrySearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IBlobEntrySearchResult {
  totalCount?: number;
  results?: BlobEntry[] | undefined;
}

export class BlobFolder implements IBlobFolder {
  parentUrl?: string | undefined;
  type?: string | undefined;
  name?: string | undefined;
  url?: string | undefined;
  relativeUrl?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IBlobFolder) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.parentUrl = _data["parentUrl"];
      this.type = _data["type"];
      this.name = _data["name"];
      this.url = _data["url"];
      this.relativeUrl = _data["relativeUrl"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): BlobFolder {
    data = typeof data === "object" ? data : {};
    let result = new BlobFolder();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["parentUrl"] = this.parentUrl;
    data["type"] = this.type;
    data["name"] = this.name;
    data["url"] = this.url;
    data["relativeUrl"] = this.relativeUrl;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IBlobFolder {
  parentUrl?: string | undefined;
  type?: string | undefined;
  name?: string | undefined;
  url?: string | undefined;
  relativeUrl?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class LastModifiedResponse implements ILastModifiedResponse {
  scope?: string | undefined;
  lastModifiedDate?: Date;

  constructor(data?: ILastModifiedResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.scope = _data["scope"];
      this.lastModifiedDate = _data["lastModifiedDate"]
        ? new Date(_data["lastModifiedDate"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): LastModifiedResponse {
    data = typeof data === "object" ? data : {};
    let result = new LastModifiedResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["scope"] = this.scope;
    data["lastModifiedDate"] = this.lastModifiedDate
      ? this.lastModifiedDate.toISOString()
      : <any>undefined;
    return data;
  }
}

export interface ILastModifiedResponse {
  scope?: string | undefined;
  lastModifiedDate?: Date;
}

export class ChangedEntitiesRequest implements IChangedEntitiesRequest {
  entityNames?: string[] | undefined;
  modifiedSince?: Date;

  constructor(data?: IChangedEntitiesRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["entityNames"])) {
        this.entityNames = [] as any;
        for (let item of _data["entityNames"]) this.entityNames!.push(item);
      }
      this.modifiedSince = _data["modifiedSince"]
        ? new Date(_data["modifiedSince"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): ChangedEntitiesRequest {
    data = typeof data === "object" ? data : {};
    let result = new ChangedEntitiesRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.entityNames)) {
      data["entityNames"] = [];
      for (let item of this.entityNames) data["entityNames"].push(item);
    }
    data["modifiedSince"] = this.modifiedSince
      ? this.modifiedSince.toISOString()
      : <any>undefined;
    return data;
  }
}

export interface IChangedEntitiesRequest {
  entityNames?: string[] | undefined;
  modifiedSince?: Date;
}

export class ChangedEntity implements IChangedEntity {
  name?: string | undefined;
  modifiedDate?: Date;

  constructor(data?: IChangedEntity) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): ChangedEntity {
    data = typeof data === "object" ? data : {};
    let result = new ChangedEntity();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    return data;
  }
}

export interface IChangedEntity {
  name?: string | undefined;
  modifiedDate?: Date;
}

export class ChangedEntitiesResponse implements IChangedEntitiesResponse {
  entities?: ChangedEntity[] | undefined;

  constructor(data?: IChangedEntitiesResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["entities"])) {
        this.entities = [] as any;
        for (let item of _data["entities"])
          this.entities!.push(ChangedEntity.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ChangedEntitiesResponse {
    data = typeof data === "object" ? data : {};
    let result = new ChangedEntitiesResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.entities)) {
      data["entities"] = [];
      for (let item of this.entities) data["entities"].push(item.toJSON());
    }
    return data;
  }
}

export interface IChangedEntitiesResponse {
  entities?: ChangedEntity[] | undefined;
}

export enum EntryState {
  Detached = "Detached",
  Unchanged = "Unchanged",
  Added = "Added",
  Deleted = "Deleted",
  Modified = "Modified",
}

export class ChangeLogSearchCriteria implements IChangeLogSearchCriteria {
  operationTypes?: EntryState[] | undefined;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IChangeLogSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["operationTypes"])) {
        this.operationTypes = [] as any;
        for (let item of _data["operationTypes"])
          this.operationTypes!.push(item);
      }
      this.startDate = _data["startDate"]
        ? new Date(_data["startDate"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? new Date(_data["endDate"].toString())
        : <any>undefined;
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): ChangeLogSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new ChangeLogSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.operationTypes)) {
      data["operationTypes"] = [];
      for (let item of this.operationTypes) data["operationTypes"].push(item);
    }
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IChangeLogSearchCriteria {
  operationTypes?: EntryState[] | undefined;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class OperationLog implements IOperationLog {
  objectType?: string | undefined;
  objectId?: string | undefined;
  operationType?: EntryState;
  detail?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IOperationLog) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.objectType = _data["objectType"];
      this.objectId = _data["objectId"];
      this.operationType = _data["operationType"];
      this.detail = _data["detail"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): OperationLog {
    data = typeof data === "object" ? data : {};
    let result = new OperationLog();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["objectType"] = this.objectType;
    data["objectId"] = this.objectId;
    data["operationType"] = this.operationType;
    data["detail"] = this.detail;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IOperationLog {
  objectType?: string | undefined;
  objectId?: string | undefined;
  operationType?: EntryState;
  detail?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class ChangeLogSearchResult implements IChangeLogSearchResult {
  totalCount?: number;
  results?: OperationLog[] | undefined;

  constructor(data?: IChangeLogSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(OperationLog.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ChangeLogSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new ChangeLogSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IChangeLogSearchResult {
  totalCount?: number;
  results?: OperationLog[] | undefined;
}

export class License implements ILicense {
  type?: string | undefined;
  customerName?: string | undefined;
  customerEmail?: string | undefined;
  expirationDate?: Date;
  rawLicense?: string | undefined;

  constructor(data?: ILicense) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data["type"];
      this.customerName = _data["customerName"];
      this.customerEmail = _data["customerEmail"];
      this.expirationDate = _data["expirationDate"]
        ? new Date(_data["expirationDate"].toString())
        : <any>undefined;
      this.rawLicense = _data["rawLicense"];
    }
  }

  static fromJS(data: any): License {
    data = typeof data === "object" ? data : {};
    let result = new License();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["type"] = this.type;
    data["customerName"] = this.customerName;
    data["customerEmail"] = this.customerEmail;
    data["expirationDate"] = this.expirationDate
      ? this.expirationDate.toISOString()
      : <any>undefined;
    data["rawLicense"] = this.rawLicense;
    return data;
  }
}

export interface ILicense {
  type?: string | undefined;
  customerName?: string | undefined;
  customerEmail?: string | undefined;
  expirationDate?: Date;
  rawLicense?: string | undefined;
}

export class SemanticVersion implements ISemanticVersion {
  /** Major version X (X.y.z) */
  readonly major?: number;
  /** Minor version Y (x.Y.z) */
  readonly minor?: number;
  /** Patch version Z (x.y.Z) */
  readonly patch?: number;
  readonly prerelease?: string | undefined;

  constructor(data?: ISemanticVersion) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).major = _data["major"];
      (<any>this).minor = _data["minor"];
      (<any>this).patch = _data["patch"];
      (<any>this).prerelease = _data["prerelease"];
    }
  }

  static fromJS(data: any): SemanticVersion {
    data = typeof data === "object" ? data : {};
    let result = new SemanticVersion();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["major"] = this.major;
    data["minor"] = this.minor;
    data["patch"] = this.patch;
    data["prerelease"] = this.prerelease;
    return data;
  }
}

export interface ISemanticVersion {
  /** Major version X (X.y.z) */
  major?: number;
  /** Minor version Y (x.Y.z) */
  minor?: number;
  /** Patch version Z (x.y.Z) */
  patch?: number;
  prerelease?: string | undefined;
}

export class ModuleIdentity implements IModuleIdentity {
  id?: string | undefined;
  version?: SemanticVersion;

  constructor(data?: IModuleIdentity) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.version = _data["version"]
        ? SemanticVersion.fromJS(_data["version"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ModuleIdentity {
    data = typeof data === "object" ? data : {};
    let result = new ModuleIdentity();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["version"] = this.version ? this.version.toJSON() : <any>undefined;
    return data;
  }
}

export interface IModuleIdentity {
  id?: string | undefined;
  version?: SemanticVersion;
}

export class ModuleDescriptor implements IModuleDescriptor {
  version?: string | undefined;
  platformVersion?: string | undefined;
  title?: string | undefined;
  description?: string | undefined;
  authors?: string[] | undefined;
  owners?: string[] | undefined;
  licenseUrl?: string | undefined;
  projectUrl?: string | undefined;
  iconUrl?: string | undefined;
  requireLicenseAcceptance?: boolean;
  releaseNotes?: string | undefined;
  copyright?: string | undefined;
  tags?: string | undefined;
  groups?: string[] | undefined;
  dependencies?: ModuleIdentity[] | undefined;
  validationErrors?: string[] | undefined;
  isRemovable?: boolean;
  isInstalled?: boolean;
  installedVersion?: ModuleIdentity;
  id?: string | undefined;

  constructor(data?: IModuleDescriptor) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.version = _data["version"];
      this.platformVersion = _data["platformVersion"];
      this.title = _data["title"];
      this.description = _data["description"];
      if (Array.isArray(_data["authors"])) {
        this.authors = [] as any;
        for (let item of _data["authors"]) this.authors!.push(item);
      }
      if (Array.isArray(_data["owners"])) {
        this.owners = [] as any;
        for (let item of _data["owners"]) this.owners!.push(item);
      }
      this.licenseUrl = _data["licenseUrl"];
      this.projectUrl = _data["projectUrl"];
      this.iconUrl = _data["iconUrl"];
      this.requireLicenseAcceptance = _data["requireLicenseAcceptance"];
      this.releaseNotes = _data["releaseNotes"];
      this.copyright = _data["copyright"];
      this.tags = _data["tags"];
      if (Array.isArray(_data["groups"])) {
        this.groups = [] as any;
        for (let item of _data["groups"]) this.groups!.push(item);
      }
      if (Array.isArray(_data["dependencies"])) {
        this.dependencies = [] as any;
        for (let item of _data["dependencies"])
          this.dependencies!.push(ModuleIdentity.fromJS(item));
      }
      if (Array.isArray(_data["validationErrors"])) {
        this.validationErrors = [] as any;
        for (let item of _data["validationErrors"])
          this.validationErrors!.push(item);
      }
      this.isRemovable = _data["isRemovable"];
      this.isInstalled = _data["isInstalled"];
      this.installedVersion = _data["installedVersion"]
        ? ModuleIdentity.fromJS(_data["installedVersion"])
        : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): ModuleDescriptor {
    data = typeof data === "object" ? data : {};
    let result = new ModuleDescriptor();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["version"] = this.version;
    data["platformVersion"] = this.platformVersion;
    data["title"] = this.title;
    data["description"] = this.description;
    if (Array.isArray(this.authors)) {
      data["authors"] = [];
      for (let item of this.authors) data["authors"].push(item);
    }
    if (Array.isArray(this.owners)) {
      data["owners"] = [];
      for (let item of this.owners) data["owners"].push(item);
    }
    data["licenseUrl"] = this.licenseUrl;
    data["projectUrl"] = this.projectUrl;
    data["iconUrl"] = this.iconUrl;
    data["requireLicenseAcceptance"] = this.requireLicenseAcceptance;
    data["releaseNotes"] = this.releaseNotes;
    data["copyright"] = this.copyright;
    data["tags"] = this.tags;
    if (Array.isArray(this.groups)) {
      data["groups"] = [];
      for (let item of this.groups) data["groups"].push(item);
    }
    if (Array.isArray(this.dependencies)) {
      data["dependencies"] = [];
      for (let item of this.dependencies)
        data["dependencies"].push(item.toJSON());
    }
    if (Array.isArray(this.validationErrors)) {
      data["validationErrors"] = [];
      for (let item of this.validationErrors)
        data["validationErrors"].push(item);
    }
    data["isRemovable"] = this.isRemovable;
    data["isInstalled"] = this.isInstalled;
    data["installedVersion"] = this.installedVersion
      ? this.installedVersion.toJSON()
      : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface IModuleDescriptor {
  version?: string | undefined;
  platformVersion?: string | undefined;
  title?: string | undefined;
  description?: string | undefined;
  authors?: string[] | undefined;
  owners?: string[] | undefined;
  licenseUrl?: string | undefined;
  projectUrl?: string | undefined;
  iconUrl?: string | undefined;
  requireLicenseAcceptance?: boolean;
  releaseNotes?: string | undefined;
  copyright?: string | undefined;
  tags?: string | undefined;
  groups?: string[] | undefined;
  dependencies?: ModuleIdentity[] | undefined;
  validationErrors?: string[] | undefined;
  isRemovable?: boolean;
  isInstalled?: boolean;
  installedVersion?: ModuleIdentity;
  id?: string | undefined;
}

export class SystemInfo implements ISystemInfo {
  platformVersion?: string | undefined;
  license?: License;
  installedModules?: ModuleDescriptor[] | undefined;
  version?: string | undefined;
  is64BitOperatingSystem?: boolean;
  is64BitProcess?: boolean;

  constructor(data?: ISystemInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.platformVersion = _data["platformVersion"];
      this.license = _data["license"]
        ? License.fromJS(_data["license"])
        : <any>undefined;
      if (Array.isArray(_data["installedModules"])) {
        this.installedModules = [] as any;
        for (let item of _data["installedModules"])
          this.installedModules!.push(ModuleDescriptor.fromJS(item));
      }
      this.version = _data["version"];
      this.is64BitOperatingSystem = _data["is64BitOperatingSystem"];
      this.is64BitProcess = _data["is64BitProcess"];
    }
  }

  static fromJS(data: any): SystemInfo {
    data = typeof data === "object" ? data : {};
    let result = new SystemInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["platformVersion"] = this.platformVersion;
    data["license"] = this.license ? this.license.toJSON() : <any>undefined;
    if (Array.isArray(this.installedModules)) {
      data["installedModules"] = [];
      for (let item of this.installedModules)
        data["installedModules"].push(item.toJSON());
    }
    data["version"] = this.version;
    data["is64BitOperatingSystem"] = this.is64BitOperatingSystem;
    data["is64BitProcess"] = this.is64BitProcess;
    return data;
  }
}

export interface ISystemInfo {
  platformVersion?: string | undefined;
  license?: License;
  installedModules?: ModuleDescriptor[] | undefined;
  version?: string | undefined;
  is64BitOperatingSystem?: boolean;
  is64BitProcess?: boolean;
}

export class DynamicPropertySearchCriteria
  implements IDynamicPropertySearchCriteria
{
  readonly typeName?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IDynamicPropertySearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).typeName = _data["typeName"];
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): DynamicPropertySearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new DynamicPropertySearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["typeName"] = this.typeName;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IDynamicPropertySearchCriteria {
  typeName?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export enum DynamicPropertyValueType {
  Undefined = "Undefined",
  ShortText = "ShortText",
  LongText = "LongText",
  Integer = "Integer",
  Decimal = "Decimal",
  DateTime = "DateTime",
  Boolean = "Boolean",
  Html = "Html",
  Image = "Image",
}

export class DynamicPropertyName implements IDynamicPropertyName {
  /** Language ID, e.g. en-US. */
  locale?: string | undefined;
  name?: string | undefined;

  constructor(data?: IDynamicPropertyName) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.locale = _data["locale"];
      this.name = _data["name"];
    }
  }

  static fromJS(data: any): DynamicPropertyName {
    data = typeof data === "object" ? data : {};
    let result = new DynamicPropertyName();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["locale"] = this.locale;
    data["name"] = this.name;
    return data;
  }
}

export interface IDynamicPropertyName {
  /** Language ID, e.g. en-US. */
  locale?: string | undefined;
  name?: string | undefined;
}

export class DynamicProperty implements IDynamicProperty {
  name?: string | undefined;
  /** dynamic property description */
  description?: string | undefined;
  objectType?: string | undefined;
  /** Defines whether a property supports multiple values. */
  isArray?: boolean;
  /** Dictionary has a predefined set of values. User can select one or more of them and cannot enter arbitrary values. */
  isDictionary?: boolean;
  /** For multilingual properties user can enter different values for each of registered languages. */
  isMultilingual?: boolean;
  isRequired?: boolean;
  displayOrder?: number | undefined;
  valueType?: DynamicPropertyValueType;
  /** Property names for different languages. */
  displayNames?: DynamicPropertyName[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IDynamicProperty) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.description = _data["description"];
      this.objectType = _data["objectType"];
      this.isArray = _data["isArray"];
      this.isDictionary = _data["isDictionary"];
      this.isMultilingual = _data["isMultilingual"];
      this.isRequired = _data["isRequired"];
      this.displayOrder = _data["displayOrder"];
      this.valueType = _data["valueType"];
      if (Array.isArray(_data["displayNames"])) {
        this.displayNames = [] as any;
        for (let item of _data["displayNames"])
          this.displayNames!.push(DynamicPropertyName.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): DynamicProperty {
    data = typeof data === "object" ? data : {};
    let result = new DynamicProperty();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["description"] = this.description;
    data["objectType"] = this.objectType;
    data["isArray"] = this.isArray;
    data["isDictionary"] = this.isDictionary;
    data["isMultilingual"] = this.isMultilingual;
    data["isRequired"] = this.isRequired;
    data["displayOrder"] = this.displayOrder;
    data["valueType"] = this.valueType;
    if (Array.isArray(this.displayNames)) {
      data["displayNames"] = [];
      for (let item of this.displayNames)
        data["displayNames"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IDynamicProperty {
  name?: string | undefined;
  /** dynamic property description */
  description?: string | undefined;
  objectType?: string | undefined;
  /** Defines whether a property supports multiple values. */
  isArray?: boolean;
  /** Dictionary has a predefined set of values. User can select one or more of them and cannot enter arbitrary values. */
  isDictionary?: boolean;
  /** For multilingual properties user can enter different values for each of registered languages. */
  isMultilingual?: boolean;
  isRequired?: boolean;
  displayOrder?: number | undefined;
  valueType?: DynamicPropertyValueType;
  /** Property names for different languages. */
  displayNames?: DynamicPropertyName[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class DynamicPropertySearchResult
  implements IDynamicPropertySearchResult
{
  totalCount?: number;
  results?: DynamicProperty[] | undefined;

  constructor(data?: IDynamicPropertySearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(DynamicProperty.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DynamicPropertySearchResult {
    data = typeof data === "object" ? data : {};
    let result = new DynamicPropertySearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IDynamicPropertySearchResult {
  totalCount?: number;
  results?: DynamicProperty[] | undefined;
}

export class DynamicPropertyObjectValue implements IDynamicPropertyObjectValue {
  objectType?: string | undefined;
  objectId?: string | undefined;
  locale?: string | undefined;
  value?: any | undefined;
  valueId?: string | undefined;
  valueType?: DynamicPropertyValueType;
  propertyId?: string | undefined;
  propertyName?: string | undefined;

  constructor(data?: IDynamicPropertyObjectValue) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.objectType = _data["objectType"];
      this.objectId = _data["objectId"];
      this.locale = _data["locale"];
      this.value = _data["value"];
      this.valueId = _data["valueId"];
      this.valueType = _data["valueType"];
      this.propertyId = _data["propertyId"];
      this.propertyName = _data["propertyName"];
    }
  }

  static fromJS(data: any): DynamicPropertyObjectValue {
    data = typeof data === "object" ? data : {};
    let result = new DynamicPropertyObjectValue();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["objectType"] = this.objectType;
    data["objectId"] = this.objectId;
    data["locale"] = this.locale;
    data["value"] = this.value;
    data["valueId"] = this.valueId;
    data["valueType"] = this.valueType;
    data["propertyId"] = this.propertyId;
    data["propertyName"] = this.propertyName;
    return data;
  }
}

export interface IDynamicPropertyObjectValue {
  objectType?: string | undefined;
  objectId?: string | undefined;
  locale?: string | undefined;
  value?: any | undefined;
  valueId?: string | undefined;
  valueType?: DynamicPropertyValueType;
  propertyId?: string | undefined;
  propertyName?: string | undefined;
}

export class DynamicObjectProperty implements IDynamicObjectProperty {
  objectId?: string | undefined;
  values?: DynamicPropertyObjectValue[] | undefined;
  name?: string | undefined;
  /** dynamic property description */
  description?: string | undefined;
  objectType?: string | undefined;
  /** Defines whether a property supports multiple values. */
  isArray?: boolean;
  /** Dictionary has a predefined set of values. User can select one or more of them and cannot enter arbitrary values. */
  isDictionary?: boolean;
  /** For multilingual properties user can enter different values for each of registered languages. */
  isMultilingual?: boolean;
  isRequired?: boolean;
  displayOrder?: number | undefined;
  valueType?: DynamicPropertyValueType;
  /** Property names for different languages. */
  displayNames?: DynamicPropertyName[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IDynamicObjectProperty) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.objectId = _data["objectId"];
      if (Array.isArray(_data["values"])) {
        this.values = [] as any;
        for (let item of _data["values"])
          this.values!.push(DynamicPropertyObjectValue.fromJS(item));
      }
      this.name = _data["name"];
      this.description = _data["description"];
      this.objectType = _data["objectType"];
      this.isArray = _data["isArray"];
      this.isDictionary = _data["isDictionary"];
      this.isMultilingual = _data["isMultilingual"];
      this.isRequired = _data["isRequired"];
      this.displayOrder = _data["displayOrder"];
      this.valueType = _data["valueType"];
      if (Array.isArray(_data["displayNames"])) {
        this.displayNames = [] as any;
        for (let item of _data["displayNames"])
          this.displayNames!.push(DynamicPropertyName.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): DynamicObjectProperty {
    data = typeof data === "object" ? data : {};
    let result = new DynamicObjectProperty();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["objectId"] = this.objectId;
    if (Array.isArray(this.values)) {
      data["values"] = [];
      for (let item of this.values) data["values"].push(item.toJSON());
    }
    data["name"] = this.name;
    data["description"] = this.description;
    data["objectType"] = this.objectType;
    data["isArray"] = this.isArray;
    data["isDictionary"] = this.isDictionary;
    data["isMultilingual"] = this.isMultilingual;
    data["isRequired"] = this.isRequired;
    data["displayOrder"] = this.displayOrder;
    data["valueType"] = this.valueType;
    if (Array.isArray(this.displayNames)) {
      data["displayNames"] = [];
      for (let item of this.displayNames)
        data["displayNames"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IDynamicObjectProperty {
  objectId?: string | undefined;
  values?: DynamicPropertyObjectValue[] | undefined;
  name?: string | undefined;
  /** dynamic property description */
  description?: string | undefined;
  objectType?: string | undefined;
  /** Defines whether a property supports multiple values. */
  isArray?: boolean;
  /** Dictionary has a predefined set of values. User can select one or more of them and cannot enter arbitrary values. */
  isDictionary?: boolean;
  /** For multilingual properties user can enter different values for each of registered languages. */
  isMultilingual?: boolean;
  isRequired?: boolean;
  displayOrder?: number | undefined;
  valueType?: DynamicPropertyValueType;
  /** Property names for different languages. */
  displayNames?: DynamicPropertyName[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class DynamicPropertyDictionaryItemSearchCriteria
  implements IDynamicPropertyDictionaryItemSearchCriteria
{
  propertyId?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IDynamicPropertyDictionaryItemSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.propertyId = _data["propertyId"];
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): DynamicPropertyDictionaryItemSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new DynamicPropertyDictionaryItemSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["propertyId"] = this.propertyId;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IDynamicPropertyDictionaryItemSearchCriteria {
  propertyId?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class DynamicPropertyDictionaryItemName
  implements IDynamicPropertyDictionaryItemName
{
  /** Language ID, e.g. en-US. */
  locale?: string | undefined;
  name?: string | undefined;

  constructor(data?: IDynamicPropertyDictionaryItemName) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.locale = _data["locale"];
      this.name = _data["name"];
    }
  }

  static fromJS(data: any): DynamicPropertyDictionaryItemName {
    data = typeof data === "object" ? data : {};
    let result = new DynamicPropertyDictionaryItemName();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["locale"] = this.locale;
    data["name"] = this.name;
    return data;
  }
}

export interface IDynamicPropertyDictionaryItemName {
  /** Language ID, e.g. en-US. */
  locale?: string | undefined;
  name?: string | undefined;
}

export class DynamicPropertyDictionaryItem
  implements IDynamicPropertyDictionaryItem
{
  propertyId?: string | undefined;
  name?: string | undefined;
  /** Item names for different languages. */
  displayNames?: DynamicPropertyDictionaryItemName[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IDynamicPropertyDictionaryItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.propertyId = _data["propertyId"];
      this.name = _data["name"];
      if (Array.isArray(_data["displayNames"])) {
        this.displayNames = [] as any;
        for (let item of _data["displayNames"])
          this.displayNames!.push(
            DynamicPropertyDictionaryItemName.fromJS(item)
          );
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): DynamicPropertyDictionaryItem {
    data = typeof data === "object" ? data : {};
    let result = new DynamicPropertyDictionaryItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["propertyId"] = this.propertyId;
    data["name"] = this.name;
    if (Array.isArray(this.displayNames)) {
      data["displayNames"] = [];
      for (let item of this.displayNames)
        data["displayNames"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IDynamicPropertyDictionaryItem {
  propertyId?: string | undefined;
  name?: string | undefined;
  /** Item names for different languages. */
  displayNames?: DynamicPropertyDictionaryItemName[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class DynamicPropertyDictionaryItemSearchResult
  implements IDynamicPropertyDictionaryItemSearchResult
{
  totalCount?: number;
  results?: DynamicPropertyDictionaryItem[] | undefined;

  constructor(data?: IDynamicPropertyDictionaryItemSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(DynamicPropertyDictionaryItem.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DynamicPropertyDictionaryItemSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new DynamicPropertyDictionaryItemSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IDynamicPropertyDictionaryItemSearchResult {
  totalCount?: number;
  results?: DynamicPropertyDictionaryItem[] | undefined;
}

export class Job implements IJob {
  state?: string | undefined;
  completed?: boolean;
  id?: string | undefined;

  constructor(data?: IJob) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.state = _data["state"];
      this.completed = _data["completed"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Job {
    data = typeof data === "object" ? data : {};
    let result = new Job();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["state"] = this.state;
    data["completed"] = this.completed;
    data["id"] = this.id;
    return data;
  }
}

export interface IJob {
  state?: string | undefined;
  completed?: boolean;
  id?: string | undefined;
}

export enum ProgressMessageLevel {
  Info = "Info",
  Warning = "Warning",
  Debug = "Debug",
  Error = "Error",
}

export class ProgressMessage implements IProgressMessage {
  message?: string | undefined;
  level?: ProgressMessageLevel;

  constructor(data?: IProgressMessage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.message = _data["message"];
      this.level = _data["level"];
    }
  }

  static fromJS(data: any): ProgressMessage {
    data = typeof data === "object" ? data : {};
    let result = new ProgressMessage();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["message"] = this.message;
    data["level"] = this.level;
    return data;
  }
}

export interface IProgressMessage {
  message?: string | undefined;
  level?: ProgressMessageLevel;
}

export class ModulePushNotification implements IModulePushNotification {
  started?: Date | undefined;
  finished?: Date | undefined;
  progressLog?: ProgressMessage[] | undefined;
  /** Gets the count of errors during processing. */
  readonly errorCount?: number;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;

  constructor(data?: IModulePushNotification) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.started = _data["started"]
        ? new Date(_data["started"].toString())
        : <any>undefined;
      this.finished = _data["finished"]
        ? new Date(_data["finished"].toString())
        : <any>undefined;
      if (Array.isArray(_data["progressLog"])) {
        this.progressLog = [] as any;
        for (let item of _data["progressLog"])
          this.progressLog!.push(ProgressMessage.fromJS(item));
      }
      (<any>this).errorCount = _data["errorCount"];
      this.serverId = _data["serverId"];
      this.creator = _data["creator"];
      this.created = _data["created"]
        ? new Date(_data["created"].toString())
        : <any>undefined;
      this.isNew = _data["isNew"];
      this.notifyType = _data["notifyType"];
      this.description = _data["description"];
      this.title = _data["title"];
      this.repeatCount = _data["repeatCount"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): ModulePushNotification {
    data = typeof data === "object" ? data : {};
    let result = new ModulePushNotification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["started"] = this.started
      ? this.started.toISOString()
      : <any>undefined;
    data["finished"] = this.finished
      ? this.finished.toISOString()
      : <any>undefined;
    if (Array.isArray(this.progressLog)) {
      data["progressLog"] = [];
      for (let item of this.progressLog)
        data["progressLog"].push(item.toJSON());
    }
    data["errorCount"] = this.errorCount;
    data["serverId"] = this.serverId;
    data["creator"] = this.creator;
    data["created"] = this.created
      ? this.created.toISOString()
      : <any>undefined;
    data["isNew"] = this.isNew;
    data["notifyType"] = this.notifyType;
    data["description"] = this.description;
    data["title"] = this.title;
    data["repeatCount"] = this.repeatCount;
    data["id"] = this.id;
    return data;
  }
}

export interface IModulePushNotification {
  started?: Date | undefined;
  finished?: Date | undefined;
  progressLog?: ProgressMessage[] | undefined;
  /** Gets the count of errors during processing. */
  errorCount?: number;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;
}

export class ModuleAutoInstallPushNotification
  implements IModuleAutoInstallPushNotification
{
  started?: Date | undefined;
  finished?: Date | undefined;
  progressLog?: ProgressMessage[] | undefined;
  /** Gets the count of errors during processing. */
  readonly errorCount?: number;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;

  constructor(data?: IModuleAutoInstallPushNotification) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.started = _data["started"]
        ? new Date(_data["started"].toString())
        : <any>undefined;
      this.finished = _data["finished"]
        ? new Date(_data["finished"].toString())
        : <any>undefined;
      if (Array.isArray(_data["progressLog"])) {
        this.progressLog = [] as any;
        for (let item of _data["progressLog"])
          this.progressLog!.push(ProgressMessage.fromJS(item));
      }
      (<any>this).errorCount = _data["errorCount"];
      this.serverId = _data["serverId"];
      this.creator = _data["creator"];
      this.created = _data["created"]
        ? new Date(_data["created"].toString())
        : <any>undefined;
      this.isNew = _data["isNew"];
      this.notifyType = _data["notifyType"];
      this.description = _data["description"];
      this.title = _data["title"];
      this.repeatCount = _data["repeatCount"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): ModuleAutoInstallPushNotification {
    data = typeof data === "object" ? data : {};
    let result = new ModuleAutoInstallPushNotification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["started"] = this.started
      ? this.started.toISOString()
      : <any>undefined;
    data["finished"] = this.finished
      ? this.finished.toISOString()
      : <any>undefined;
    if (Array.isArray(this.progressLog)) {
      data["progressLog"] = [];
      for (let item of this.progressLog)
        data["progressLog"].push(item.toJSON());
    }
    data["errorCount"] = this.errorCount;
    data["serverId"] = this.serverId;
    data["creator"] = this.creator;
    data["created"] = this.created
      ? this.created.toISOString()
      : <any>undefined;
    data["isNew"] = this.isNew;
    data["notifyType"] = this.notifyType;
    data["description"] = this.description;
    data["title"] = this.title;
    data["repeatCount"] = this.repeatCount;
    data["id"] = this.id;
    return data;
  }
}

export interface IModuleAutoInstallPushNotification {
  started?: Date | undefined;
  finished?: Date | undefined;
  progressLog?: ProgressMessage[] | undefined;
  /** Gets the count of errors during processing. */
  errorCount?: number;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;
}

export enum JsonValueKind {
  Undefined = "Undefined",
  Object = "Object",
  Array = "Array",
  String = "String",
  Number = "Number",
  True = "True",
  False = "False",
  Null = "Null",
}

export class JsonElement implements IJsonElement {
  valueKind?: JsonValueKind;

  constructor(data?: IJsonElement) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.valueKind = _data["valueKind"];
    }
  }

  static fromJS(data: any): JsonElement {
    data = typeof data === "object" ? data : {};
    let result = new JsonElement();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["valueKind"] = this.valueKind;
    return data;
  }
}

export interface IJsonElement {
  valueKind?: JsonValueKind;
}

export class OpenIddictApplicationDescriptor
  implements IOpenIddictApplicationDescriptor
{
  clientId?: string | undefined;
  clientSecret?: string | undefined;
  consentType?: string | undefined;
  displayName?: string | undefined;
  readonly displayNames?: { [key: string]: string } | undefined;
  readonly permissions?: string[] | undefined;
  readonly postLogoutRedirectUris?: string[] | undefined;
  readonly properties?: { [key: string]: JsonElement } | undefined;
  readonly redirectUris?: string[] | undefined;
  readonly requirements?: string[] | undefined;
  type?: string | undefined;

  constructor(data?: IOpenIddictApplicationDescriptor) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.clientId = _data["clientId"];
      this.clientSecret = _data["clientSecret"];
      this.consentType = _data["consentType"];
      this.displayName = _data["displayName"];
      if (_data["displayNames"]) {
        (<any>this).displayNames = {} as any;
        for (let key in _data["displayNames"]) {
          if (_data["displayNames"].hasOwnProperty(key))
            (<any>(<any>this).displayNames)![key] = _data["displayNames"][key];
        }
      }
      if (Array.isArray(_data["permissions"])) {
        (<any>this).permissions = [] as any;
        for (let item of _data["permissions"])
          (<any>this).permissions!.push(item);
      }
      if (Array.isArray(_data["postLogoutRedirectUris"])) {
        (<any>this).postLogoutRedirectUris = [] as any;
        for (let item of _data["postLogoutRedirectUris"])
          (<any>this).postLogoutRedirectUris!.push(item);
      }
      if (_data["properties"]) {
        (<any>this).properties = {} as any;
        for (let key in _data["properties"]) {
          if (_data["properties"].hasOwnProperty(key))
            (<any>(<any>this).properties)![key] = _data["properties"][key]
              ? JsonElement.fromJS(_data["properties"][key])
              : new JsonElement();
        }
      }
      if (Array.isArray(_data["redirectUris"])) {
        (<any>this).redirectUris = [] as any;
        for (let item of _data["redirectUris"])
          (<any>this).redirectUris!.push(item);
      }
      if (Array.isArray(_data["requirements"])) {
        (<any>this).requirements = [] as any;
        for (let item of _data["requirements"])
          (<any>this).requirements!.push(item);
      }
      this.type = _data["type"];
    }
  }

  static fromJS(data: any): OpenIddictApplicationDescriptor {
    data = typeof data === "object" ? data : {};
    let result = new OpenIddictApplicationDescriptor();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["clientId"] = this.clientId;
    data["clientSecret"] = this.clientSecret;
    data["consentType"] = this.consentType;
    data["displayName"] = this.displayName;
    if (this.displayNames) {
      data["displayNames"] = {};
      for (let key in this.displayNames) {
        if (this.displayNames.hasOwnProperty(key))
          (<any>data["displayNames"])[key] = this.displayNames[key];
      }
    }
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions) data["permissions"].push(item);
    }
    if (Array.isArray(this.postLogoutRedirectUris)) {
      data["postLogoutRedirectUris"] = [];
      for (let item of this.postLogoutRedirectUris)
        data["postLogoutRedirectUris"].push(item);
    }
    if (this.properties) {
      data["properties"] = {};
      for (let key in this.properties) {
        if (this.properties.hasOwnProperty(key))
          (<any>data["properties"])[key] = this.properties[key]
            ? this.properties[key].toJSON()
            : <any>undefined;
      }
    }
    if (Array.isArray(this.redirectUris)) {
      data["redirectUris"] = [];
      for (let item of this.redirectUris) data["redirectUris"].push(item);
    }
    if (Array.isArray(this.requirements)) {
      data["requirements"] = [];
      for (let item of this.requirements) data["requirements"].push(item);
    }
    data["type"] = this.type;
    return data;
  }
}

export interface IOpenIddictApplicationDescriptor {
  clientId?: string | undefined;
  clientSecret?: string | undefined;
  consentType?: string | undefined;
  displayName?: string | undefined;
  displayNames?: { [key: string]: string } | undefined;
  permissions?: string[] | undefined;
  postLogoutRedirectUris?: string[] | undefined;
  properties?: { [key: string]: JsonElement } | undefined;
  redirectUris?: string[] | undefined;
  requirements?: string[] | undefined;
  type?: string | undefined;
}

export class OAuthAppSearchCriteria implements IOAuthAppSearchCriteria {
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IOAuthAppSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): OAuthAppSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new OAuthAppSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IOAuthAppSearchCriteria {
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class OAuthAppSearchResult implements IOAuthAppSearchResult {
  totalCount?: number;
  results?: OpenIddictApplicationDescriptor[] | undefined;

  constructor(data?: IOAuthAppSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(OpenIddictApplicationDescriptor.fromJS(item));
      }
    }
  }

  static fromJS(data: any): OAuthAppSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new OAuthAppSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IOAuthAppSearchResult {
  totalCount?: number;
  results?: OpenIddictApplicationDescriptor[] | undefined;
}


export class PushNotificationSearchCriteria implements IPushNotificationSearchCriteria {
  ids?: string[] | undefined;
  onlyNew?: boolean;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IPushNotificationSearchCriteria) {
      if (data) {
          for (var property in data) {
              if (data.hasOwnProperty(property))
                  (<any>this)[property] = (<any>data)[property];
          }
      }
  }

  init(_data?: any) {
      if (_data) {
          if (Array.isArray(_data["ids"])) {
              this.ids = [] as any;
              for (let item of _data["ids"])
                  this.ids!.push(item);
          }
          this.onlyNew = _data["onlyNew"];
          this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
          this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
          this.responseGroup = _data["responseGroup"];
          this.objectType = _data["objectType"];
          if (Array.isArray(_data["objectTypes"])) {
              this.objectTypes = [] as any;
              for (let item of _data["objectTypes"])
                  this.objectTypes!.push(item);
          }
          if (Array.isArray(_data["objectIds"])) {
              this.objectIds = [] as any;
              for (let item of _data["objectIds"])
                  this.objectIds!.push(item);
          }
          this.keyword = _data["keyword"];
          this.searchPhrase = _data["searchPhrase"];
          this.languageCode = _data["languageCode"];
          this.sort = _data["sort"];
          if (Array.isArray(_data["sortInfos"])) {
              (<any>this).sortInfos = [] as any;
              for (let item of _data["sortInfos"])
                  (<any>this).sortInfos!.push(SortInfo.fromJS(item));
          }
          this.skip = _data["skip"];
          this.take = _data["take"];
      }
  }

  static fromJS(data: any): PushNotificationSearchCriteria {
      data = typeof data === 'object' ? data : {};
      let result = new PushNotificationSearchCriteria();
      result.init(data);
      return result;
  }

  toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.ids)) {
          data["ids"] = [];
          for (let item of this.ids)
              data["ids"].push(item);
      }
      data["onlyNew"] = this.onlyNew;
      data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
      data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
      data["responseGroup"] = this.responseGroup;
      data["objectType"] = this.objectType;
      if (Array.isArray(this.objectTypes)) {
          data["objectTypes"] = [];
          for (let item of this.objectTypes)
              data["objectTypes"].push(item);
      }
      if (Array.isArray(this.objectIds)) {
          data["objectIds"] = [];
          for (let item of this.objectIds)
              data["objectIds"].push(item);
      }
      data["keyword"] = this.keyword;
      data["searchPhrase"] = this.searchPhrase;
      data["languageCode"] = this.languageCode;
      data["sort"] = this.sort;
      if (Array.isArray(this.sortInfos)) {
          data["sortInfos"] = [];
          for (let item of this.sortInfos)
              data["sortInfos"].push(item.toJSON());
      }
      data["skip"] = this.skip;
      data["take"] = this.take;
      return data; 
  }
}

export interface IPushNotificationSearchCriteria {
  ids?: string[] | undefined;
  onlyNew?: boolean;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}


export class PushNotification implements IPushNotification {
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;

  constructor(data?: IPushNotification) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.serverId = _data["serverId"];
      this.creator = _data["creator"];
      this.created = _data["created"]
        ? new Date(_data["created"].toString())
        : <any>undefined;
      this.isNew = _data["isNew"];
      this.notifyType = _data["notifyType"];
      this.description = _data["description"];
      this.title = _data["title"];
      this.repeatCount = _data["repeatCount"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): PushNotification {
    data = typeof data === "object" ? data : {};
    let result = new PushNotification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["serverId"] = this.serverId;
    data["creator"] = this.creator;
    data["created"] = this.created
      ? this.created.toISOString()
      : <any>undefined;
    data["isNew"] = this.isNew;
    data["notifyType"] = this.notifyType;
    data["description"] = this.description;
    data["title"] = this.title;
    data["repeatCount"] = this.repeatCount;
    data["id"] = this.id;
    return data;
  }
}

export interface IPushNotification {
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;
}

export class PushNotificationSearchResult
  implements IPushNotificationSearchResult
{
  totalCount?: number;
  newCount?: number;
  notifyEvents?: PushNotification[] | undefined;

  constructor(data?: IPushNotificationSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      this.newCount = _data["newCount"];
      if (Array.isArray(_data["notifyEvents"])) {
        this.notifyEvents = [] as any;
        for (let item of _data["notifyEvents"])
          this.notifyEvents!.push(PushNotification.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PushNotificationSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new PushNotificationSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    data["newCount"] = this.newCount;
    if (Array.isArray(this.notifyEvents)) {
      data["notifyEvents"] = [];
      for (let item of this.notifyEvents)
        data["notifyEvents"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPushNotificationSearchResult {
  totalCount?: number;
  newCount?: number;
  notifyEvents?: PushNotification[] | undefined;
}

export class LoginRequest implements ILoginRequest {
  userName?: string | undefined;
  password?: string | undefined;
  rememberMe?: boolean;

  constructor(data?: ILoginRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userName = _data["userName"];
      this.password = _data["password"];
      this.rememberMe = _data["rememberMe"];
    }
  }

  static fromJS(data: any): LoginRequest {
    data = typeof data === "object" ? data : {};
    let result = new LoginRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userName"] = this.userName;
    data["password"] = this.password;
    data["rememberMe"] = this.rememberMe;
    return data;
  }
}

export interface ILoginRequest {
  userName?: string | undefined;
  password?: string | undefined;
  rememberMe?: boolean;
}

export class SignInResult implements ISignInResult {
  readonly succeeded?: boolean;
  readonly isLockedOut?: boolean;
  readonly isNotAllowed?: boolean;
  readonly requiresTwoFactor?: boolean;

  constructor(data?: ISignInResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).succeeded = _data["succeeded"];
      (<any>this).isLockedOut = _data["isLockedOut"];
      (<any>this).isNotAllowed = _data["isNotAllowed"];
      (<any>this).requiresTwoFactor = _data["requiresTwoFactor"];
    }
  }

  static fromJS(data: any): SignInResult {
    data = typeof data === "object" ? data : {};
    let result = new SignInResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["succeeded"] = this.succeeded;
    data["isLockedOut"] = this.isLockedOut;
    data["isNotAllowed"] = this.isNotAllowed;
    data["requiresTwoFactor"] = this.requiresTwoFactor;
    return data;
  }
}

export interface ISignInResult {
  succeeded?: boolean;
  isLockedOut?: boolean;
  isNotAllowed?: boolean;
  requiresTwoFactor?: boolean;
}

export class UserDetail implements IUserDetail {
  permissions?: string[] | undefined;
  userName?: string | undefined;
  isAdministrator?: boolean;
  passwordExpired?: boolean;
  daysTillPasswordExpiry?: number;
  id?: string | undefined;

  constructor(data?: IUserDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"]) this.permissions!.push(item);
      }
      this.userName = _data["userName"];
      this.isAdministrator = _data["isAdministrator"];
      this.passwordExpired = _data["passwordExpired"];
      this.daysTillPasswordExpiry = _data["daysTillPasswordExpiry"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UserDetail {
    data = typeof data === "object" ? data : {};
    let result = new UserDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions) data["permissions"].push(item);
    }
    data["userName"] = this.userName;
    data["isAdministrator"] = this.isAdministrator;
    data["passwordExpired"] = this.passwordExpired;
    data["daysTillPasswordExpiry"] = this.daysTillPasswordExpiry;
    data["id"] = this.id;
    return data;
  }
}

export interface IUserDetail {
  permissions?: string[] | undefined;
  userName?: string | undefined;
  isAdministrator?: boolean;
  passwordExpired?: boolean;
  daysTillPasswordExpiry?: number;
  id?: string | undefined;
}

export class ClaimsIdentity implements IClaimsIdentity {
  authenticationType?: string | undefined;
  readonly isAuthenticated?: boolean;
  actor?: ClaimsIdentity;
  bootstrapContext?: any | undefined;
  claims?: Claim[] | undefined;
  label?: string | undefined;
  readonly name?: string | undefined;
  readonly nameClaimType?: string | undefined;
  readonly roleClaimType?: string | undefined;

  constructor(data?: IClaimsIdentity) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.authenticationType = _data["authenticationType"];
      (<any>this).isAuthenticated = _data["isAuthenticated"];
      this.actor = _data["actor"]
        ? ClaimsIdentity.fromJS(_data["actor"])
        : <any>undefined;
      this.bootstrapContext = _data["bootstrapContext"];
      if (Array.isArray(_data["claims"])) {
        this.claims = [] as any;
        for (let item of _data["claims"]) this.claims!.push(Claim.fromJS(item));
      }
      this.label = _data["label"];
      (<any>this).name = _data["name"];
      (<any>this).nameClaimType = _data["nameClaimType"];
      (<any>this).roleClaimType = _data["roleClaimType"];
    }
  }

  static fromJS(data: any): ClaimsIdentity {
    data = typeof data === "object" ? data : {};
    let result = new ClaimsIdentity();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["authenticationType"] = this.authenticationType;
    data["isAuthenticated"] = this.isAuthenticated;
    data["actor"] = this.actor ? this.actor.toJSON() : <any>undefined;
    data["bootstrapContext"] = this.bootstrapContext;
    if (Array.isArray(this.claims)) {
      data["claims"] = [];
      for (let item of this.claims) data["claims"].push(item.toJSON());
    }
    data["label"] = this.label;
    data["name"] = this.name;
    data["nameClaimType"] = this.nameClaimType;
    data["roleClaimType"] = this.roleClaimType;
    return data;
  }
}

export interface IClaimsIdentity {
  authenticationType?: string | undefined;
  isAuthenticated?: boolean;
  actor?: ClaimsIdentity;
  bootstrapContext?: any | undefined;
  claims?: Claim[] | undefined;
  label?: string | undefined;
  name?: string | undefined;
  nameClaimType?: string | undefined;
  roleClaimType?: string | undefined;
}

export class Claim implements IClaim {
  issuer?: string | undefined;
  originalIssuer?: string | undefined;
  readonly properties?: { [key: string]: string } | undefined;
  subject?: ClaimsIdentity;
  type?: string | undefined;
  value?: string | undefined;
  valueType?: string | undefined;

  constructor(data?: IClaim) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.issuer = _data["issuer"];
      this.originalIssuer = _data["originalIssuer"];
      if (_data["properties"]) {
        (<any>this).properties = {} as any;
        for (let key in _data["properties"]) {
          if (_data["properties"].hasOwnProperty(key))
            (<any>(<any>this).properties)![key] = _data["properties"][key];
        }
      }
      this.subject = _data["subject"]
        ? ClaimsIdentity.fromJS(_data["subject"])
        : <any>undefined;
      this.type = _data["type"];
      this.value = _data["value"];
      this.valueType = _data["valueType"];
    }
  }

  static fromJS(data: any): Claim {
    data = typeof data === "object" ? data : {};
    let result = new Claim();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["issuer"] = this.issuer;
    data["originalIssuer"] = this.originalIssuer;
    if (this.properties) {
      data["properties"] = {};
      for (let key in this.properties) {
        if (this.properties.hasOwnProperty(key))
          (<any>data["properties"])[key] = this.properties[key];
      }
    }
    data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
    data["type"] = this.type;
    data["value"] = this.value;
    data["valueType"] = this.valueType;
    return data;
  }
}

export interface IClaim {
  issuer?: string | undefined;
  originalIssuer?: string | undefined;
  properties?: { [key: string]: string } | undefined;
  subject?: ClaimsIdentity;
  type?: string | undefined;
  value?: string | undefined;
  valueType?: string | undefined;
}

export class PermissionScope implements IPermissionScope {
  /** Scope type name */
  type?: string | undefined;
  /** Display label for particular scope value used only for  representation */
  label?: string | undefined;
  /** Represent string scope value */
  scope?: string | undefined;

  constructor(data?: IPermissionScope) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data["type"];
      this.label = _data["label"];
      this.scope = _data["scope"];
    }
  }

  static fromJS(data: any): PermissionScope {
    data = typeof data === "object" ? data : {};
    let result = new PermissionScope();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["type"] = this.type;
    data["label"] = this.label;
    data["scope"] = this.scope;
    return data;
  }
}

export interface IPermissionScope {
  /** Scope type name */
  type?: string | undefined;
  /** Display label for particular scope value used only for  representation */
  label?: string | undefined;
  /** Represent string scope value */
  scope?: string | undefined;
}

export class Permission implements IPermission {
  id?: string | undefined;
  name?: string | undefined;
  /** Id of the module which has registered this permission. */
  moduleId?: string | undefined;
  /** Display name of the group to which this permission belongs. The '|' character is used to separate Child and parent groups. */
  groupName?: string | undefined;
  assignedScopes?: PermissionScope[] | undefined;
  readonly availableScopes?: PermissionScope[] | undefined;

  constructor(data?: IPermission) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.moduleId = _data["moduleId"];
      this.groupName = _data["groupName"];
      if (Array.isArray(_data["assignedScopes"])) {
        this.assignedScopes = [] as any;
        for (let item of _data["assignedScopes"])
          this.assignedScopes!.push(PermissionScope.fromJS(item));
      }
      if (Array.isArray(_data["availableScopes"])) {
        (<any>this).availableScopes = [] as any;
        for (let item of _data["availableScopes"])
          (<any>this).availableScopes!.push(PermissionScope.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Permission {
    data = typeof data === "object" ? data : {};
    let result = new Permission();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["moduleId"] = this.moduleId;
    data["groupName"] = this.groupName;
    if (Array.isArray(this.assignedScopes)) {
      data["assignedScopes"] = [];
      for (let item of this.assignedScopes)
        data["assignedScopes"].push(item.toJSON());
    }
    if (Array.isArray(this.availableScopes)) {
      data["availableScopes"] = [];
      for (let item of this.availableScopes)
        data["availableScopes"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPermission {
  id?: string | undefined;
  name?: string | undefined;
  /** Id of the module which has registered this permission. */
  moduleId?: string | undefined;
  /** Display name of the group to which this permission belongs. The '|' character is used to separate Child and parent groups. */
  groupName?: string | undefined;
  assignedScopes?: PermissionScope[] | undefined;
  availableScopes?: PermissionScope[] | undefined;
}

export class RoleSearchCriteria implements IRoleSearchCriteria {
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IRoleSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): RoleSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new RoleSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IRoleSearchCriteria {
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class Role implements IRole {
  description?: string | undefined;
  permissions?: Permission[] | undefined;
  id?: string | undefined;
  name?: string | undefined;
  normalizedName?: string | undefined;
  concurrencyStamp?: string | undefined;

  constructor(data?: IRole) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data["description"];
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"])
          this.permissions!.push(Permission.fromJS(item));
      }
      this.id = _data["id"];
      this.name = _data["name"];
      this.normalizedName = _data["normalizedName"];
      this.concurrencyStamp = _data["concurrencyStamp"];
    }
  }

  static fromJS(data: any): Role {
    data = typeof data === "object" ? data : {};
    let result = new Role();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["description"] = this.description;
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions)
        data["permissions"].push(item.toJSON());
    }
    data["id"] = this.id;
    data["name"] = this.name;
    data["normalizedName"] = this.normalizedName;
    data["concurrencyStamp"] = this.concurrencyStamp;
    return data;
  }
}

export interface IRole {
  description?: string | undefined;
  permissions?: Permission[] | undefined;
  id?: string | undefined;
  name?: string | undefined;
  normalizedName?: string | undefined;
  concurrencyStamp?: string | undefined;
}

export class RoleSearchResult implements IRoleSearchResult {
  readonly roles?: Role[] | undefined;
  totalCount?: number;
  results?: Role[] | undefined;

  constructor(data?: IRoleSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["roles"])) {
        (<any>this).roles = [] as any;
        for (let item of _data["roles"])
          (<any>this).roles!.push(Role.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(Role.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RoleSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new RoleSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.roles)) {
      data["roles"] = [];
      for (let item of this.roles) data["roles"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IRoleSearchResult {
  roles?: Role[] | undefined;
  totalCount?: number;
  results?: Role[] | undefined;
}

export class SecurityResult implements ISecurityResult {
  succeeded?: boolean;
  errors?: string[] | undefined;

  constructor(data?: ISecurityResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.succeeded = _data["succeeded"];
      if (Array.isArray(_data["errors"])) {
        this.errors = [] as any;
        for (let item of _data["errors"]) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): SecurityResult {
    data = typeof data === "object" ? data : {};
    let result = new SecurityResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["succeeded"] = this.succeeded;
    if (Array.isArray(this.errors)) {
      data["errors"] = [];
      for (let item of this.errors) data["errors"].push(item);
    }
    return data;
  }
}

export interface ISecurityResult {
  succeeded?: boolean;
  errors?: string[] | undefined;
}

export class UserSearchCriteria implements IUserSearchCriteria {
  memberId?: string | undefined;
  memberIds?: string[] | undefined;
  modifiedSinceDate?: Date | undefined;
  roles?: string[] | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IUserSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.memberId = _data["memberId"];
      if (Array.isArray(_data["memberIds"])) {
        this.memberIds = [] as any;
        for (let item of _data["memberIds"]) this.memberIds!.push(item);
      }
      this.modifiedSinceDate = _data["modifiedSinceDate"]
        ? new Date(_data["modifiedSinceDate"].toString())
        : <any>undefined;
      if (Array.isArray(_data["roles"])) {
        this.roles = [] as any;
        for (let item of _data["roles"]) this.roles!.push(item);
      }
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): UserSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new UserSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["memberId"] = this.memberId;
    if (Array.isArray(this.memberIds)) {
      data["memberIds"] = [];
      for (let item of this.memberIds) data["memberIds"].push(item);
    }
    data["modifiedSinceDate"] = this.modifiedSinceDate
      ? this.modifiedSinceDate.toISOString()
      : <any>undefined;
    if (Array.isArray(this.roles)) {
      data["roles"] = [];
      for (let item of this.roles) data["roles"].push(item);
    }
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IUserSearchCriteria {
  memberId?: string | undefined;
  memberIds?: string[] | undefined;
  modifiedSinceDate?: Date | undefined;
  roles?: string[] | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

/** Obsolete. Left due to compatibility issues. Will be removed. Instead of, use: ApplicationUser.EmailConfirmed, ApplicationUser.LockoutEnd. */
export enum AccountState {
  PendingApproval = "PendingApproval",
  Approved = "Approved",
  Rejected = "Rejected",
}

export class ApplicationUserLogin implements IApplicationUserLogin {
  loginProvider?: string | undefined;
  providerKey?: string | undefined;

  constructor(data?: IApplicationUserLogin) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loginProvider = _data["loginProvider"];
      this.providerKey = _data["providerKey"];
    }
  }

  static fromJS(data: any): ApplicationUserLogin {
    data = typeof data === "object" ? data : {};
    let result = new ApplicationUserLogin();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loginProvider"] = this.loginProvider;
    data["providerKey"] = this.providerKey;
    return data;
  }
}

export interface IApplicationUserLogin {
  loginProvider?: string | undefined;
  providerKey?: string | undefined;
}

export class ApplicationUser implements IApplicationUser {
  /** Tenant id */
  storeId?: string | undefined;
  memberId?: string | undefined;
  isAdministrator?: boolean;
  photoUrl?: string | undefined;
  userType?: string | undefined;
  status?: string | undefined;
  password?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  roles?: Role[] | undefined;
  /** Obsolete. Use LockoutEnd. DateTime in UTC when lockout ends, any time in the past is considered not locked out. */
  lockoutEndDateUtc?: Date | undefined;
  userState?: AccountState;
  /** Obsolete. All permissions from assigned roles. */
  permissions?: string[] | undefined;
  /** External provider logins. */
  logins?: ApplicationUserLogin[] | undefined;
  /** Indicates that the password for this user is expired and must be changed. */
  passwordExpired?: boolean;
  /** The last date when the password was changed */
  lastPasswordChangedDate?: Date | undefined;
  id?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;

  constructor(data?: IApplicationUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.storeId = _data["storeId"];
      this.memberId = _data["memberId"];
      this.isAdministrator = _data["isAdministrator"];
      this.photoUrl = _data["photoUrl"];
      this.userType = _data["userType"];
      this.status = _data["status"];
      this.password = _data["password"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      if (Array.isArray(_data["roles"])) {
        this.roles = [] as any;
        for (let item of _data["roles"]) this.roles!.push(Role.fromJS(item));
      }
      this.lockoutEndDateUtc = _data["lockoutEndDateUtc"]
        ? new Date(_data["lockoutEndDateUtc"].toString())
        : <any>undefined;
      this.userState = _data["userState"];
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"]) this.permissions!.push(item);
      }
      if (Array.isArray(_data["logins"])) {
        this.logins = [] as any;
        for (let item of _data["logins"])
          this.logins!.push(ApplicationUserLogin.fromJS(item));
      }
      this.passwordExpired = _data["passwordExpired"];
      this.lastPasswordChangedDate = _data["lastPasswordChangedDate"]
        ? new Date(_data["lastPasswordChangedDate"].toString())
        : <any>undefined;
      this.id = _data["id"];
      this.userName = _data["userName"];
      this.normalizedUserName = _data["normalizedUserName"];
      this.email = _data["email"];
      this.normalizedEmail = _data["normalizedEmail"];
      this.emailConfirmed = _data["emailConfirmed"];
      this.passwordHash = _data["passwordHash"];
      this.securityStamp = _data["securityStamp"];
      this.concurrencyStamp = _data["concurrencyStamp"];
      this.phoneNumber = _data["phoneNumber"];
      this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
      this.twoFactorEnabled = _data["twoFactorEnabled"];
      this.lockoutEnd = _data["lockoutEnd"]
        ? new Date(_data["lockoutEnd"].toString())
        : <any>undefined;
      this.lockoutEnabled = _data["lockoutEnabled"];
      this.accessFailedCount = _data["accessFailedCount"];
    }
  }

  static fromJS(data: any): ApplicationUser {
    data = typeof data === "object" ? data : {};
    let result = new ApplicationUser();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["storeId"] = this.storeId;
    data["memberId"] = this.memberId;
    data["isAdministrator"] = this.isAdministrator;
    data["photoUrl"] = this.photoUrl;
    data["userType"] = this.userType;
    data["status"] = this.status;
    data["password"] = this.password;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    if (Array.isArray(this.roles)) {
      data["roles"] = [];
      for (let item of this.roles) data["roles"].push(item.toJSON());
    }
    data["lockoutEndDateUtc"] = this.lockoutEndDateUtc
      ? this.lockoutEndDateUtc.toISOString()
      : <any>undefined;
    data["userState"] = this.userState;
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions) data["permissions"].push(item);
    }
    if (Array.isArray(this.logins)) {
      data["logins"] = [];
      for (let item of this.logins) data["logins"].push(item.toJSON());
    }
    data["passwordExpired"] = this.passwordExpired;
    data["lastPasswordChangedDate"] = this.lastPasswordChangedDate
      ? this.lastPasswordChangedDate.toISOString()
      : <any>undefined;
    data["id"] = this.id;
    data["userName"] = this.userName;
    data["normalizedUserName"] = this.normalizedUserName;
    data["email"] = this.email;
    data["normalizedEmail"] = this.normalizedEmail;
    data["emailConfirmed"] = this.emailConfirmed;
    data["passwordHash"] = this.passwordHash;
    data["securityStamp"] = this.securityStamp;
    data["concurrencyStamp"] = this.concurrencyStamp;
    data["phoneNumber"] = this.phoneNumber;
    data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
    data["twoFactorEnabled"] = this.twoFactorEnabled;
    data["lockoutEnd"] = this.lockoutEnd
      ? this.lockoutEnd.toISOString()
      : <any>undefined;
    data["lockoutEnabled"] = this.lockoutEnabled;
    data["accessFailedCount"] = this.accessFailedCount;
    return data;
  }
}

export interface IApplicationUser {
  /** Tenant id */
  storeId?: string | undefined;
  memberId?: string | undefined;
  isAdministrator?: boolean;
  photoUrl?: string | undefined;
  userType?: string | undefined;
  status?: string | undefined;
  password?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  roles?: Role[] | undefined;
  /** Obsolete. Use LockoutEnd. DateTime in UTC when lockout ends, any time in the past is considered not locked out. */
  lockoutEndDateUtc?: Date | undefined;
  userState?: AccountState;
  /** Obsolete. All permissions from assigned roles. */
  permissions?: string[] | undefined;
  /** External provider logins. */
  logins?: ApplicationUserLogin[] | undefined;
  /** Indicates that the password for this user is expired and must be changed. */
  passwordExpired?: boolean;
  /** The last date when the password was changed */
  lastPasswordChangedDate?: Date | undefined;
  id?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;
}

export class UserSearchResult implements IUserSearchResult {
  readonly users?: ApplicationUser[] | undefined;
  totalCount?: number;
  results?: ApplicationUser[] | undefined;

  constructor(data?: IUserSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["users"])) {
        (<any>this).users = [] as any;
        for (let item of _data["users"])
          (<any>this).users!.push(ApplicationUser.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(ApplicationUser.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UserSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new UserSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.users)) {
      data["users"] = [];
      for (let item of this.users) data["users"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IUserSearchResult {
  users?: ApplicationUser[] | undefined;
  totalCount?: number;
  results?: ApplicationUser[] | undefined;
}

export class ChangePasswordRequest implements IChangePasswordRequest {
  userName?: string | undefined;
  oldPassword?: string | undefined;
  newPassword?: string | undefined;

  constructor(data?: IChangePasswordRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userName = _data["userName"];
      this.oldPassword = _data["oldPassword"];
      this.newPassword = _data["newPassword"];
    }
  }

  static fromJS(data: any): ChangePasswordRequest {
    data = typeof data === "object" ? data : {};
    let result = new ChangePasswordRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userName"] = this.userName;
    data["oldPassword"] = this.oldPassword;
    data["newPassword"] = this.newPassword;
    return data;
  }
}

export interface IChangePasswordRequest {
  userName?: string | undefined;
  oldPassword?: string | undefined;
  newPassword?: string | undefined;
}

export class ResetPasswordConfirmRequest
  implements IResetPasswordConfirmRequest
{
  token?: string | undefined;
  newPassword?: string | undefined;
  forcePasswordChangeOnNextSignIn?: boolean;

  constructor(data?: IResetPasswordConfirmRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.token = _data["token"];
      this.newPassword = _data["newPassword"];
      this.forcePasswordChangeOnNextSignIn =
        _data["forcePasswordChangeOnNextSignIn"];
    }
  }

  static fromJS(data: any): ResetPasswordConfirmRequest {
    data = typeof data === "object" ? data : {};
    let result = new ResetPasswordConfirmRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["token"] = this.token;
    data["newPassword"] = this.newPassword;
    data["forcePasswordChangeOnNextSignIn"] =
      this.forcePasswordChangeOnNextSignIn;
    return data;
  }
}

export interface IResetPasswordConfirmRequest {
  token?: string | undefined;
  newPassword?: string | undefined;
  forcePasswordChangeOnNextSignIn?: boolean;
}

export class ValidatePasswordResetTokenRequest
  implements IValidatePasswordResetTokenRequest
{
  token?: string | undefined;

  constructor(data?: IValidatePasswordResetTokenRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.token = _data["token"];
    }
  }

  static fromJS(data: any): ValidatePasswordResetTokenRequest {
    data = typeof data === "object" ? data : {};
    let result = new ValidatePasswordResetTokenRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["token"] = this.token;
    return data;
  }
}

export interface IValidatePasswordResetTokenRequest {
  token?: string | undefined;
}

export class IdentityError implements IIdentityError {
  code?: string | undefined;
  description?: string | undefined;

  constructor(data?: IIdentityError) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.code = _data["code"];
      this.description = _data["description"];
    }
  }

  static fromJS(data: any): IdentityError {
    data = typeof data === "object" ? data : {};
    let result = new IdentityError();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["code"] = this.code;
    data["description"] = this.description;
    return data;
  }
}

export interface IIdentityError {
  code?: string | undefined;
  description?: string | undefined;
}

export class IdentityResult implements IIdentityResult {
  readonly succeeded?: boolean;
  readonly errors?: IdentityError[] | undefined;

  constructor(data?: IIdentityResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).succeeded = _data["succeeded"];
      if (Array.isArray(_data["errors"])) {
        (<any>this).errors = [] as any;
        for (let item of _data["errors"])
          (<any>this).errors!.push(IdentityError.fromJS(item));
      }
    }
  }

  static fromJS(data: any): IdentityResult {
    data = typeof data === "object" ? data : {};
    let result = new IdentityResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["succeeded"] = this.succeeded;
    if (Array.isArray(this.errors)) {
      data["errors"] = [];
      for (let item of this.errors) data["errors"].push(item.toJSON());
    }
    return data;
  }
}

export interface IIdentityResult {
  succeeded?: boolean;
  errors?: IdentityError[] | undefined;
}

export class UserLockedResult implements IUserLockedResult {
  locked?: boolean;

  constructor(data?: IUserLockedResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.locked = _data["locked"];
    }
  }

  static fromJS(data: any): UserLockedResult {
    data = typeof data === "object" ? data : {};
    let result = new UserLockedResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["locked"] = this.locked;
    return data;
  }
}

export interface IUserLockedResult {
  locked?: boolean;
}

export class UserApiKey implements IUserApiKey {
  apiKey?: string | undefined;
  userName?: string | undefined;
  userId?: string | undefined;
  isActive?: boolean;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IUserApiKey) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.apiKey = _data["apiKey"];
      this.userName = _data["userName"];
      this.userId = _data["userId"];
      this.isActive = _data["isActive"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UserApiKey {
    data = typeof data === "object" ? data : {};
    let result = new UserApiKey();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["apiKey"] = this.apiKey;
    data["userName"] = this.userName;
    data["userId"] = this.userId;
    data["isActive"] = this.isActive;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IUserApiKey {
  apiKey?: string | undefined;
  userName?: string | undefined;
  userId?: string | undefined;
  isActive?: boolean;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export enum SettingValueType {
  ShortText = "ShortText",
  LongText = "LongText",
  Integer = "Integer",
  Decimal = "Decimal",
  DateTime = "DateTime",
  Boolean = "Boolean",
  SecureString = "SecureString",
  Json = "Json",
  PositiveInteger = "PositiveInteger",
}

export class ObjectSettingEntry implements IObjectSettingEntry {
  readonly itHasValues?: boolean;
  /** Setting may belong to any object in system */
  objectId?: string | undefined;
  objectType?: string | undefined;
  /** Flag indicates the this setting is read only and can't be changed */
  isReadOnly?: string | undefined;
  value?: any | undefined;
  /** The flag indicates that you need to restart the application to apply this setting changes. */
  restartRequired?: boolean;
  /** The module id which setting belong to */
  moduleId?: string | undefined;
  /** Setting group name */
  groupName?: string | undefined;
  /** Setting name */
  name?: string | undefined;
  /** Flag indicates that this setting doesn't need to be displayed on the UI */
  isHidden?: boolean;
  valueType?: SettingValueType;
  allowedValues?: any[] | undefined;
  defaultValue?: any | undefined;
  /** The flag indicates what current setting is just editable dictionary and hasn't any concrete value */
  isDictionary?: boolean;

  constructor(data?: IObjectSettingEntry) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).itHasValues = _data["itHasValues"];
      this.objectId = _data["objectId"];
      this.objectType = _data["objectType"];
      this.isReadOnly = _data["isReadOnly"];
      this.value = _data["value"];
      this.restartRequired = _data["restartRequired"];
      this.moduleId = _data["moduleId"];
      this.groupName = _data["groupName"];
      this.name = _data["name"];
      this.isHidden = _data["isHidden"];
      this.valueType = _data["valueType"];
      if (Array.isArray(_data["allowedValues"])) {
        this.allowedValues = [] as any;
        for (let item of _data["allowedValues"]) this.allowedValues!.push(item);
      }
      this.defaultValue = _data["defaultValue"];
      this.isDictionary = _data["isDictionary"];
    }
  }

  static fromJS(data: any): ObjectSettingEntry {
    data = typeof data === "object" ? data : {};
    let result = new ObjectSettingEntry();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["itHasValues"] = this.itHasValues;
    data["objectId"] = this.objectId;
    data["objectType"] = this.objectType;
    data["isReadOnly"] = this.isReadOnly;
    data["value"] = this.value;
    data["restartRequired"] = this.restartRequired;
    data["moduleId"] = this.moduleId;
    data["groupName"] = this.groupName;
    data["name"] = this.name;
    data["isHidden"] = this.isHidden;
    data["valueType"] = this.valueType;
    if (Array.isArray(this.allowedValues)) {
      data["allowedValues"] = [];
      for (let item of this.allowedValues) data["allowedValues"].push(item);
    }
    data["defaultValue"] = this.defaultValue;
    data["isDictionary"] = this.isDictionary;
    return data;
  }
}

export interface IObjectSettingEntry {
  itHasValues?: boolean;
  /** Setting may belong to any object in system */
  objectId?: string | undefined;
  objectType?: string | undefined;
  /** Flag indicates the this setting is read only and can't be changed */
  isReadOnly?: string | undefined;
  value?: any | undefined;
  /** The flag indicates that you need to restart the application to apply this setting changes. */
  restartRequired?: boolean;
  /** The module id which setting belong to */
  moduleId?: string | undefined;
  /** Setting group name */
  groupName?: string | undefined;
  /** Setting name */
  name?: string | undefined;
  /** Flag indicates that this setting doesn't need to be displayed on the UI */
  isHidden?: boolean;
  valueType?: SettingValueType;
  allowedValues?: any[] | undefined;
  defaultValue?: any | undefined;
  /** The flag indicates what current setting is just editable dictionary and hasn't any concrete value */
  isDictionary?: boolean;
}

export class IBulkActionFactory implements IIBulkActionFactory {
  constructor(data?: IIBulkActionFactory) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): IBulkActionFactory {
    data = typeof data === "object" ? data : {};
    let result = new IBulkActionFactory();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export interface IIBulkActionFactory {}

export class IDataSourceFactory implements IIDataSourceFactory {
  constructor(data?: IIDataSourceFactory) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): IDataSourceFactory {
    data = typeof data === "object" ? data : {};
    let result = new IDataSourceFactory();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export interface IIDataSourceFactory {}

export class IBulkActionProvider implements IIBulkActionProvider {
  applicableTypes?: string[] | undefined;
  bulkActionFactory?: IBulkActionFactory;
  contextTypeName?: string | undefined;
  dataSourceFactory?: IDataSourceFactory;
  name?: string | undefined;
  permissions?: string[] | undefined;

  constructor(data?: IIBulkActionProvider) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["applicableTypes"])) {
        this.applicableTypes = [] as any;
        for (let item of _data["applicableTypes"])
          this.applicableTypes!.push(item);
      }
      this.bulkActionFactory = _data["bulkActionFactory"]
        ? IBulkActionFactory.fromJS(_data["bulkActionFactory"])
        : <any>undefined;
      this.contextTypeName = _data["contextTypeName"];
      this.dataSourceFactory = _data["dataSourceFactory"]
        ? IDataSourceFactory.fromJS(_data["dataSourceFactory"])
        : <any>undefined;
      this.name = _data["name"];
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"]) this.permissions!.push(item);
      }
    }
  }

  static fromJS(data: any): IBulkActionProvider {
    data = typeof data === "object" ? data : {};
    let result = new IBulkActionProvider();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.applicableTypes)) {
      data["applicableTypes"] = [];
      for (let item of this.applicableTypes) data["applicableTypes"].push(item);
    }
    data["bulkActionFactory"] = this.bulkActionFactory
      ? this.bulkActionFactory.toJSON()
      : <any>undefined;
    data["contextTypeName"] = this.contextTypeName;
    data["dataSourceFactory"] = this.dataSourceFactory
      ? this.dataSourceFactory.toJSON()
      : <any>undefined;
    data["name"] = this.name;
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions) data["permissions"].push(item);
    }
    return data;
  }
}

export interface IIBulkActionProvider {
  applicableTypes?: string[] | undefined;
  bulkActionFactory?: IBulkActionFactory;
  contextTypeName?: string | undefined;
  dataSourceFactory?: IDataSourceFactory;
  name?: string | undefined;
  permissions?: string[] | undefined;
}

export class BulkActionContext implements IBulkActionContext {
  /** Gets or sets the action name. */
  actionName?: string | undefined;
  /** Gets the context type name. */
  readonly contextTypeName?: string | undefined;

  constructor(data?: IBulkActionContext) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.actionName = _data["actionName"];
      (<any>this).contextTypeName = _data["contextTypeName"];
    }
  }

  static fromJS(data: any): BulkActionContext {
    data = typeof data === "object" ? data : {};
    let result = new BulkActionContext();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["actionName"] = this.actionName;
    data["contextTypeName"] = this.contextTypeName;
    return data;
  }
}

export interface IBulkActionContext {
  /** Gets or sets the action name. */
  actionName?: string | undefined;
  /** Gets the context type name. */
  contextTypeName?: string | undefined;
}

export class BulkActionPushNotification implements IBulkActionPushNotification {
  /** Gets error count. */
  readonly errorCount?: number;
  /** Gets or sets the errors. */
  errors?: string[] | undefined;
  /** Gets or sets the finished. */
  finished?: Date | undefined;
  /** Gets or sets the job id. */
  jobId?: string | undefined;
  /** Gets or sets the processed count. */
  processedCount?: number | undefined;
  /** Gets or sets the total count. */
  totalCount?: number | undefined;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;

  constructor(data?: IBulkActionPushNotification) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).errorCount = _data["errorCount"];
      if (Array.isArray(_data["errors"])) {
        this.errors = [] as any;
        for (let item of _data["errors"]) this.errors!.push(item);
      }
      this.finished = _data["finished"]
        ? new Date(_data["finished"].toString())
        : <any>undefined;
      this.jobId = _data["jobId"];
      this.processedCount = _data["processedCount"];
      this.totalCount = _data["totalCount"];
      this.serverId = _data["serverId"];
      this.creator = _data["creator"];
      this.created = _data["created"]
        ? new Date(_data["created"].toString())
        : <any>undefined;
      this.isNew = _data["isNew"];
      this.notifyType = _data["notifyType"];
      this.description = _data["description"];
      this.title = _data["title"];
      this.repeatCount = _data["repeatCount"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): BulkActionPushNotification {
    data = typeof data === "object" ? data : {};
    let result = new BulkActionPushNotification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["errorCount"] = this.errorCount;
    if (Array.isArray(this.errors)) {
      data["errors"] = [];
      for (let item of this.errors) data["errors"].push(item);
    }
    data["finished"] = this.finished
      ? this.finished.toISOString()
      : <any>undefined;
    data["jobId"] = this.jobId;
    data["processedCount"] = this.processedCount;
    data["totalCount"] = this.totalCount;
    data["serverId"] = this.serverId;
    data["creator"] = this.creator;
    data["created"] = this.created
      ? this.created.toISOString()
      : <any>undefined;
    data["isNew"] = this.isNew;
    data["notifyType"] = this.notifyType;
    data["description"] = this.description;
    data["title"] = this.title;
    data["repeatCount"] = this.repeatCount;
    data["id"] = this.id;
    return data;
  }
}

export interface IBulkActionPushNotification {
  /** Gets error count. */
  errorCount?: number;
  /** Gets or sets the errors. */
  errors?: string[] | undefined;
  /** Gets or sets the finished. */
  finished?: Date | undefined;
  /** Gets or sets the job id. */
  jobId?: string | undefined;
  /** Gets or sets the processed count. */
  processedCount?: number | undefined;
  /** Gets or sets the total count. */
  totalCount?: number | undefined;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;
}

export enum AddressType {
  Billing = "Billing",
  Shipping = "Shipping",
  BillingAndShipping = "BillingAndShipping",
  Pickup = "Pickup",
}

export class CartAddress implements ICartAddress {
  addressType?: AddressType;
  key?: string | undefined;
  name?: string | undefined;
  organization?: string | undefined;
  countryCode?: string | undefined;
  countryName?: string | undefined;
  city?: string | undefined;
  postalCode?: string | undefined;
  zip?: string | undefined;
  line1?: string | undefined;
  line2?: string | undefined;
  regionId?: string | undefined;
  regionName?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  email?: string | undefined;

  constructor(data?: ICartAddress) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.addressType = _data["addressType"];
      this.key = _data["key"];
      this.name = _data["name"];
      this.organization = _data["organization"];
      this.countryCode = _data["countryCode"];
      this.countryName = _data["countryName"];
      this.city = _data["city"];
      this.postalCode = _data["postalCode"];
      this.zip = _data["zip"];
      this.line1 = _data["line1"];
      this.line2 = _data["line2"];
      this.regionId = _data["regionId"];
      this.regionName = _data["regionName"];
      this.firstName = _data["firstName"];
      this.middleName = _data["middleName"];
      this.lastName = _data["lastName"];
      this.phone = _data["phone"];
      this.email = _data["email"];
    }
  }

  static fromJS(data: any): CartAddress {
    data = typeof data === "object" ? data : {};
    let result = new CartAddress();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["addressType"] = this.addressType;
    data["key"] = this.key;
    data["name"] = this.name;
    data["organization"] = this.organization;
    data["countryCode"] = this.countryCode;
    data["countryName"] = this.countryName;
    data["city"] = this.city;
    data["postalCode"] = this.postalCode;
    data["zip"] = this.zip;
    data["line1"] = this.line1;
    data["line2"] = this.line2;
    data["regionId"] = this.regionId;
    data["regionName"] = this.regionName;
    data["firstName"] = this.firstName;
    data["middleName"] = this.middleName;
    data["lastName"] = this.lastName;
    data["phone"] = this.phone;
    data["email"] = this.email;
    return data;
  }
}

export interface ICartAddress {
  addressType?: AddressType;
  key?: string | undefined;
  name?: string | undefined;
  organization?: string | undefined;
  countryCode?: string | undefined;
  countryName?: string | undefined;
  city?: string | undefined;
  postalCode?: string | undefined;
  zip?: string | undefined;
  line1?: string | undefined;
  line2?: string | undefined;
  regionId?: string | undefined;
  regionName?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  email?: string | undefined;
}

export class IConditionTree implements IIConditionTree {
  readonly id?: string | undefined;
  /** List of all available children for current tree node (is used in expression designer) */
  readonly availableChildren?: IConditionTree[] | undefined;
  readonly children?: IConditionTree[] | undefined;

  constructor(data?: IIConditionTree) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).id = _data["id"];
      if (Array.isArray(_data["availableChildren"])) {
        (<any>this).availableChildren = [] as any;
        for (let item of _data["availableChildren"])
          (<any>this).availableChildren!.push(IConditionTree.fromJS(item));
      }
      if (Array.isArray(_data["children"])) {
        (<any>this).children = [] as any;
        for (let item of _data["children"])
          (<any>this).children!.push(IConditionTree.fromJS(item));
      }
    }
  }

  static fromJS(data: any): IConditionTree {
    data = typeof data === "object" ? data : {};
    let result = new IConditionTree();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    if (Array.isArray(this.availableChildren)) {
      data["availableChildren"] = [];
      for (let item of this.availableChildren)
        data["availableChildren"].push(item.toJSON());
    }
    if (Array.isArray(this.children)) {
      data["children"] = [];
      for (let item of this.children) data["children"].push(item.toJSON());
    }
    return data;
  }
}

export interface IIConditionTree {
  id?: string | undefined;
  /** List of all available children for current tree node (is used in expression designer) */
  availableChildren?: IConditionTree[] | undefined;
  children?: IConditionTree[] | undefined;
}

export class PriceConditionTree implements IPriceConditionTree {
  all?: boolean;
  not?: boolean;
  readonly id?: string | undefined;
  availableChildren?: IConditionTree[] | undefined;
  children?: IConditionTree[] | undefined;

  constructor(data?: IPriceConditionTree) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.all = _data["all"];
      this.not = _data["not"];
      (<any>this).id = _data["id"];
      if (Array.isArray(_data["availableChildren"])) {
        this.availableChildren = [] as any;
        for (let item of _data["availableChildren"])
          this.availableChildren!.push(IConditionTree.fromJS(item));
      }
      if (Array.isArray(_data["children"])) {
        this.children = [] as any;
        for (let item of _data["children"])
          this.children!.push(IConditionTree.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PriceConditionTree {
    data = typeof data === "object" ? data : {};
    let result = new PriceConditionTree();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["all"] = this.all;
    data["not"] = this.not;
    data["id"] = this.id;
    if (Array.isArray(this.availableChildren)) {
      data["availableChildren"] = [];
      for (let item of this.availableChildren)
        data["availableChildren"].push(item.toJSON());
    }
    if (Array.isArray(this.children)) {
      data["children"] = [];
      for (let item of this.children) data["children"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPriceConditionTree {
  all?: boolean;
  not?: boolean;
  id?: string | undefined;
  availableChildren?: IConditionTree[] | undefined;
  children?: IConditionTree[] | undefined;
}

/** Used to assign pricelist to specific catalog by using conditional expression */
export class PricelistAssignment implements IPricelistAssignment {
  catalogId?: string | undefined;
  pricelistId?: string | undefined;
  pricelist?: Pricelist;
  name?: string | undefined;
  description?: string | undefined;
  /** If two PricelistAssignments satisfies the conditions and rules, will use one with the greater priority */
  priority?: number;
  /** Start of period when Prices Assignment is valid. Null value means no limit */
  startDate?: Date | undefined;
  /** End of period when Prices Assignment is valid. Null value means no limit */
  endDate?: Date | undefined;
  dynamicExpression?: PriceConditionTree;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IPricelistAssignment) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.catalogId = _data["catalogId"];
      this.pricelistId = _data["pricelistId"];
      this.pricelist = _data["pricelist"]
        ? Pricelist.fromJS(_data["pricelist"])
        : <any>undefined;
      this.name = _data["name"];
      this.description = _data["description"];
      this.priority = _data["priority"];
      this.startDate = _data["startDate"]
        ? new Date(_data["startDate"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? new Date(_data["endDate"].toString())
        : <any>undefined;
      this.dynamicExpression = _data["dynamicExpression"]
        ? PriceConditionTree.fromJS(_data["dynamicExpression"])
        : <any>undefined;
      this.outerId = _data["outerId"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): PricelistAssignment {
    data = typeof data === "object" ? data : {};
    let result = new PricelistAssignment();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["catalogId"] = this.catalogId;
    data["pricelistId"] = this.pricelistId;
    data["pricelist"] = this.pricelist
      ? this.pricelist.toJSON()
      : <any>undefined;
    data["name"] = this.name;
    data["description"] = this.description;
    data["priority"] = this.priority;
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    data["dynamicExpression"] = this.dynamicExpression
      ? this.dynamicExpression.toJSON()
      : <any>undefined;
    data["outerId"] = this.outerId;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

/** Used to assign pricelist to specific catalog by using conditional expression */
export interface IPricelistAssignment {
  catalogId?: string | undefined;
  pricelistId?: string | undefined;
  pricelist?: Pricelist;
  name?: string | undefined;
  description?: string | undefined;
  /** If two PricelistAssignments satisfies the conditions and rules, will use one with the greater priority */
  priority?: number;
  /** Start of period when Prices Assignment is valid. Null value means no limit */
  startDate?: Date | undefined;
  /** End of period when Prices Assignment is valid. Null value means no limit */
  endDate?: Date | undefined;
  dynamicExpression?: PriceConditionTree;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class Pricelist implements IPricelist {
  name?: string | undefined;
  description?: string | undefined;
  currency?: string | undefined;
  outerId?: string | undefined;
  prices?: Price[] | undefined;
  assignments?: PricelistAssignment[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IPricelist) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.description = _data["description"];
      this.currency = _data["currency"];
      this.outerId = _data["outerId"];
      if (Array.isArray(_data["prices"])) {
        this.prices = [] as any;
        for (let item of _data["prices"]) this.prices!.push(Price.fromJS(item));
      }
      if (Array.isArray(_data["assignments"])) {
        this.assignments = [] as any;
        for (let item of _data["assignments"])
          this.assignments!.push(PricelistAssignment.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Pricelist {
    data = typeof data === "object" ? data : {};
    let result = new Pricelist();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["description"] = this.description;
    data["currency"] = this.currency;
    data["outerId"] = this.outerId;
    if (Array.isArray(this.prices)) {
      data["prices"] = [];
      for (let item of this.prices) data["prices"].push(item.toJSON());
    }
    if (Array.isArray(this.assignments)) {
      data["assignments"] = [];
      for (let item of this.assignments)
        data["assignments"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IPricelist {
  name?: string | undefined;
  description?: string | undefined;
  currency?: string | undefined;
  outerId?: string | undefined;
  prices?: Price[] | undefined;
  assignments?: PricelistAssignment[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class Price implements IPrice {
  pricelistId?: string | undefined;
  pricelist?: Pricelist;
  currency?: string | undefined;
  productId?: string | undefined;
  sale?: number | undefined;
  list?: number;
  minQuantity?: number;
  /** Optional start date for this price, so that we can prepare prices ahead of time.
  If start date equals now, this price will be active. */
  startDate?: Date | undefined;
  /** Optional end date for this price, so that we can prepare prices ahead of time.
  If end date equals now, this price will not be active. */
  endDate?: Date | undefined;
  readonly effectiveValue?: number;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IPrice) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pricelistId = _data["pricelistId"];
      this.pricelist = _data["pricelist"]
        ? Pricelist.fromJS(_data["pricelist"])
        : <any>undefined;
      this.currency = _data["currency"];
      this.productId = _data["productId"];
      this.sale = _data["sale"];
      this.list = _data["list"];
      this.minQuantity = _data["minQuantity"];
      this.startDate = _data["startDate"]
        ? new Date(_data["startDate"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? new Date(_data["endDate"].toString())
        : <any>undefined;
      (<any>this).effectiveValue = _data["effectiveValue"];
      this.outerId = _data["outerId"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Price {
    data = typeof data === "object" ? data : {};
    let result = new Price();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["pricelistId"] = this.pricelistId;
    data["pricelist"] = this.pricelist
      ? this.pricelist.toJSON()
      : <any>undefined;
    data["currency"] = this.currency;
    data["productId"] = this.productId;
    data["sale"] = this.sale;
    data["list"] = this.list;
    data["minQuantity"] = this.minQuantity;
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    data["effectiveValue"] = this.effectiveValue;
    data["outerId"] = this.outerId;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IPrice {
  pricelistId?: string | undefined;
  pricelist?: Pricelist;
  currency?: string | undefined;
  productId?: string | undefined;
  sale?: number | undefined;
  list?: number;
  minQuantity?: number;
  /** Optional start date for this price, so that we can prepare prices ahead of time.
  If start date equals now, this price will be active. */
  startDate?: Date | undefined;
  /** Optional end date for this price, so that we can prepare prices ahead of time.
  If end date equals now, this price will not be active. */
  endDate?: Date | undefined;
  effectiveValue?: number;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class Discount implements IDiscount {
  promotionId?: string | undefined;
  currency?: string | undefined;
  discountAmount?: number;
  discountAmountWithTax?: number;
  coupon?: string | undefined;
  description?: string | undefined;
  id?: string | undefined;

  constructor(data?: IDiscount) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.promotionId = _data["promotionId"];
      this.currency = _data["currency"];
      this.discountAmount = _data["discountAmount"];
      this.discountAmountWithTax = _data["discountAmountWithTax"];
      this.coupon = _data["coupon"];
      this.description = _data["description"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Discount {
    data = typeof data === "object" ? data : {};
    let result = new Discount();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["promotionId"] = this.promotionId;
    data["currency"] = this.currency;
    data["discountAmount"] = this.discountAmount;
    data["discountAmountWithTax"] = this.discountAmountWithTax;
    data["coupon"] = this.coupon;
    data["description"] = this.description;
    data["id"] = this.id;
    return data;
  }
}

export interface IDiscount {
  promotionId?: string | undefined;
  currency?: string | undefined;
  discountAmount?: number;
  discountAmountWithTax?: number;
  coupon?: string | undefined;
  description?: string | undefined;
  id?: string | undefined;
}

export class TaxDetail implements ITaxDetail {
  rate?: number;
  amount?: number;
  name?: string | undefined;

  constructor(data?: ITaxDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.rate = _data["rate"];
      this.amount = _data["amount"];
      this.name = _data["name"];
    }
  }

  static fromJS(data: any): TaxDetail {
    data = typeof data === "object" ? data : {};
    let result = new TaxDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["rate"] = this.rate;
    data["amount"] = this.amount;
    data["name"] = this.name;
    return data;
  }
}

export interface ITaxDetail {
  rate?: number;
  amount?: number;
  name?: string | undefined;
}

export class CartLineItem implements ICartLineItem {
  productId?: string | undefined;
  catalogId?: string | undefined;
  categoryId?: string | undefined;
  sku?: string | undefined;
  productType?: string | undefined;
  name?: string | undefined;
  quantity?: number;
  fulfillmentCenterId?: string | undefined;
  fulfillmentCenterName?: string | undefined;
  fulfillmentLocationCode?: string | undefined;
  shipmentMethodCode?: string | undefined;
  requiredShipping?: boolean;
  thumbnailImageUrl?: string | undefined;
  imageUrl?: string | undefined;
  isGift?: boolean;
  currency?: string | undefined;
  languageCode?: string | undefined;
  note?: string | undefined;
  isReccuring?: boolean;
  taxIncluded?: boolean;
  volumetricWeight?: number | undefined;
  weightUnit?: string | undefined;
  weight?: number | undefined;
  measureUnit?: string | undefined;
  height?: number | undefined;
  length?: number | undefined;
  width?: number | undefined;
  validationType?: string | undefined;
  isReadOnly?: boolean;
  priceId?: string | undefined;
  price?: Price;
  listPrice?: number;
  listPriceWithTax?: number;
  salePrice?: number;
  salePriceWithTax?: number;
  placedPrice?: number;
  placedPriceWithTax?: number;
  extendedPrice?: number;
  extendedPriceWithTax?: number;
  discountAmount?: number;
  discountAmountWithTax?: number;
  discountTotal?: number;
  discountTotalWithTax?: number;
  fee?: number;
  feeWithTax?: number;
  discounts?: Discount[] | undefined;
  taxType?: string | undefined;
  taxTotal?: number;
  taxPercentRate?: number;
  taxDetails?: TaxDetail[] | undefined;
  readonly objectType?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: ICartLineItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data["productId"];
      this.catalogId = _data["catalogId"];
      this.categoryId = _data["categoryId"];
      this.sku = _data["sku"];
      this.productType = _data["productType"];
      this.name = _data["name"];
      this.quantity = _data["quantity"];
      this.fulfillmentCenterId = _data["fulfillmentCenterId"];
      this.fulfillmentCenterName = _data["fulfillmentCenterName"];
      this.fulfillmentLocationCode = _data["fulfillmentLocationCode"];
      this.shipmentMethodCode = _data["shipmentMethodCode"];
      this.requiredShipping = _data["requiredShipping"];
      this.thumbnailImageUrl = _data["thumbnailImageUrl"];
      this.imageUrl = _data["imageUrl"];
      this.isGift = _data["isGift"];
      this.currency = _data["currency"];
      this.languageCode = _data["languageCode"];
      this.note = _data["note"];
      this.isReccuring = _data["isReccuring"];
      this.taxIncluded = _data["taxIncluded"];
      this.volumetricWeight = _data["volumetricWeight"];
      this.weightUnit = _data["weightUnit"];
      this.weight = _data["weight"];
      this.measureUnit = _data["measureUnit"];
      this.height = _data["height"];
      this.length = _data["length"];
      this.width = _data["width"];
      this.validationType = _data["validationType"];
      this.isReadOnly = _data["isReadOnly"];
      this.priceId = _data["priceId"];
      this.price = _data["price"]
        ? Price.fromJS(_data["price"])
        : <any>undefined;
      this.listPrice = _data["listPrice"];
      this.listPriceWithTax = _data["listPriceWithTax"];
      this.salePrice = _data["salePrice"];
      this.salePriceWithTax = _data["salePriceWithTax"];
      this.placedPrice = _data["placedPrice"];
      this.placedPriceWithTax = _data["placedPriceWithTax"];
      this.extendedPrice = _data["extendedPrice"];
      this.extendedPriceWithTax = _data["extendedPriceWithTax"];
      this.discountAmount = _data["discountAmount"];
      this.discountAmountWithTax = _data["discountAmountWithTax"];
      this.discountTotal = _data["discountTotal"];
      this.discountTotalWithTax = _data["discountTotalWithTax"];
      this.fee = _data["fee"];
      this.feeWithTax = _data["feeWithTax"];
      if (Array.isArray(_data["discounts"])) {
        this.discounts = [] as any;
        for (let item of _data["discounts"])
          this.discounts!.push(Discount.fromJS(item));
      }
      this.taxType = _data["taxType"];
      this.taxTotal = _data["taxTotal"];
      this.taxPercentRate = _data["taxPercentRate"];
      if (Array.isArray(_data["taxDetails"])) {
        this.taxDetails = [] as any;
        for (let item of _data["taxDetails"])
          this.taxDetails!.push(TaxDetail.fromJS(item));
      }
      (<any>this).objectType = _data["objectType"];
      if (Array.isArray(_data["dynamicProperties"])) {
        this.dynamicProperties = [] as any;
        for (let item of _data["dynamicProperties"])
          this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): CartLineItem {
    data = typeof data === "object" ? data : {};
    let result = new CartLineItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["productId"] = this.productId;
    data["catalogId"] = this.catalogId;
    data["categoryId"] = this.categoryId;
    data["sku"] = this.sku;
    data["productType"] = this.productType;
    data["name"] = this.name;
    data["quantity"] = this.quantity;
    data["fulfillmentCenterId"] = this.fulfillmentCenterId;
    data["fulfillmentCenterName"] = this.fulfillmentCenterName;
    data["fulfillmentLocationCode"] = this.fulfillmentLocationCode;
    data["shipmentMethodCode"] = this.shipmentMethodCode;
    data["requiredShipping"] = this.requiredShipping;
    data["thumbnailImageUrl"] = this.thumbnailImageUrl;
    data["imageUrl"] = this.imageUrl;
    data["isGift"] = this.isGift;
    data["currency"] = this.currency;
    data["languageCode"] = this.languageCode;
    data["note"] = this.note;
    data["isReccuring"] = this.isReccuring;
    data["taxIncluded"] = this.taxIncluded;
    data["volumetricWeight"] = this.volumetricWeight;
    data["weightUnit"] = this.weightUnit;
    data["weight"] = this.weight;
    data["measureUnit"] = this.measureUnit;
    data["height"] = this.height;
    data["length"] = this.length;
    data["width"] = this.width;
    data["validationType"] = this.validationType;
    data["isReadOnly"] = this.isReadOnly;
    data["priceId"] = this.priceId;
    data["price"] = this.price ? this.price.toJSON() : <any>undefined;
    data["listPrice"] = this.listPrice;
    data["listPriceWithTax"] = this.listPriceWithTax;
    data["salePrice"] = this.salePrice;
    data["salePriceWithTax"] = this.salePriceWithTax;
    data["placedPrice"] = this.placedPrice;
    data["placedPriceWithTax"] = this.placedPriceWithTax;
    data["extendedPrice"] = this.extendedPrice;
    data["extendedPriceWithTax"] = this.extendedPriceWithTax;
    data["discountAmount"] = this.discountAmount;
    data["discountAmountWithTax"] = this.discountAmountWithTax;
    data["discountTotal"] = this.discountTotal;
    data["discountTotalWithTax"] = this.discountTotalWithTax;
    data["fee"] = this.fee;
    data["feeWithTax"] = this.feeWithTax;
    if (Array.isArray(this.discounts)) {
      data["discounts"] = [];
      for (let item of this.discounts) data["discounts"].push(item.toJSON());
    }
    data["taxType"] = this.taxType;
    data["taxTotal"] = this.taxTotal;
    data["taxPercentRate"] = this.taxPercentRate;
    if (Array.isArray(this.taxDetails)) {
      data["taxDetails"] = [];
      for (let item of this.taxDetails) data["taxDetails"].push(item.toJSON());
    }
    data["objectType"] = this.objectType;
    if (Array.isArray(this.dynamicProperties)) {
      data["dynamicProperties"] = [];
      for (let item of this.dynamicProperties)
        data["dynamicProperties"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface ICartLineItem {
  productId?: string | undefined;
  catalogId?: string | undefined;
  categoryId?: string | undefined;
  sku?: string | undefined;
  productType?: string | undefined;
  name?: string | undefined;
  quantity?: number;
  fulfillmentCenterId?: string | undefined;
  fulfillmentCenterName?: string | undefined;
  fulfillmentLocationCode?: string | undefined;
  shipmentMethodCode?: string | undefined;
  requiredShipping?: boolean;
  thumbnailImageUrl?: string | undefined;
  imageUrl?: string | undefined;
  isGift?: boolean;
  currency?: string | undefined;
  languageCode?: string | undefined;
  note?: string | undefined;
  isReccuring?: boolean;
  taxIncluded?: boolean;
  volumetricWeight?: number | undefined;
  weightUnit?: string | undefined;
  weight?: number | undefined;
  measureUnit?: string | undefined;
  height?: number | undefined;
  length?: number | undefined;
  width?: number | undefined;
  validationType?: string | undefined;
  isReadOnly?: boolean;
  priceId?: string | undefined;
  price?: Price;
  listPrice?: number;
  listPriceWithTax?: number;
  salePrice?: number;
  salePriceWithTax?: number;
  placedPrice?: number;
  placedPriceWithTax?: number;
  extendedPrice?: number;
  extendedPriceWithTax?: number;
  discountAmount?: number;
  discountAmountWithTax?: number;
  discountTotal?: number;
  discountTotalWithTax?: number;
  fee?: number;
  feeWithTax?: number;
  discounts?: Discount[] | undefined;
  taxType?: string | undefined;
  taxTotal?: number;
  taxPercentRate?: number;
  taxDetails?: TaxDetail[] | undefined;
  objectType?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class Payment implements IPayment {
  currency?: string | undefined;
  paymentGatewayCode?: string | undefined;
  amount?: number;
  billingAddress?: CartAddress;
  price?: number;
  priceWithTax?: number;
  total?: number;
  totalWithTax?: number;
  discountAmount?: number;
  discountAmountWithTax?: number;
  taxType?: string | undefined;
  taxTotal?: number;
  taxPercentRate?: number;
  discounts?: Discount[] | undefined;
  taxDetails?: TaxDetail[] | undefined;
  readonly objectType?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IPayment) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currency = _data["currency"];
      this.paymentGatewayCode = _data["paymentGatewayCode"];
      this.amount = _data["amount"];
      this.billingAddress = _data["billingAddress"]
        ? CartAddress.fromJS(_data["billingAddress"])
        : <any>undefined;
      this.price = _data["price"];
      this.priceWithTax = _data["priceWithTax"];
      this.total = _data["total"];
      this.totalWithTax = _data["totalWithTax"];
      this.discountAmount = _data["discountAmount"];
      this.discountAmountWithTax = _data["discountAmountWithTax"];
      this.taxType = _data["taxType"];
      this.taxTotal = _data["taxTotal"];
      this.taxPercentRate = _data["taxPercentRate"];
      if (Array.isArray(_data["discounts"])) {
        this.discounts = [] as any;
        for (let item of _data["discounts"])
          this.discounts!.push(Discount.fromJS(item));
      }
      if (Array.isArray(_data["taxDetails"])) {
        this.taxDetails = [] as any;
        for (let item of _data["taxDetails"])
          this.taxDetails!.push(TaxDetail.fromJS(item));
      }
      (<any>this).objectType = _data["objectType"];
      if (Array.isArray(_data["dynamicProperties"])) {
        this.dynamicProperties = [] as any;
        for (let item of _data["dynamicProperties"])
          this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
      }
      this.outerId = _data["outerId"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Payment {
    data = typeof data === "object" ? data : {};
    let result = new Payment();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["currency"] = this.currency;
    data["paymentGatewayCode"] = this.paymentGatewayCode;
    data["amount"] = this.amount;
    data["billingAddress"] = this.billingAddress
      ? this.billingAddress.toJSON()
      : <any>undefined;
    data["price"] = this.price;
    data["priceWithTax"] = this.priceWithTax;
    data["total"] = this.total;
    data["totalWithTax"] = this.totalWithTax;
    data["discountAmount"] = this.discountAmount;
    data["discountAmountWithTax"] = this.discountAmountWithTax;
    data["taxType"] = this.taxType;
    data["taxTotal"] = this.taxTotal;
    data["taxPercentRate"] = this.taxPercentRate;
    if (Array.isArray(this.discounts)) {
      data["discounts"] = [];
      for (let item of this.discounts) data["discounts"].push(item.toJSON());
    }
    if (Array.isArray(this.taxDetails)) {
      data["taxDetails"] = [];
      for (let item of this.taxDetails) data["taxDetails"].push(item.toJSON());
    }
    data["objectType"] = this.objectType;
    if (Array.isArray(this.dynamicProperties)) {
      data["dynamicProperties"] = [];
      for (let item of this.dynamicProperties)
        data["dynamicProperties"].push(item.toJSON());
    }
    data["outerId"] = this.outerId;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IPayment {
  currency?: string | undefined;
  paymentGatewayCode?: string | undefined;
  amount?: number;
  billingAddress?: CartAddress;
  price?: number;
  priceWithTax?: number;
  total?: number;
  totalWithTax?: number;
  discountAmount?: number;
  discountAmountWithTax?: number;
  taxType?: string | undefined;
  taxTotal?: number;
  taxPercentRate?: number;
  discounts?: Discount[] | undefined;
  taxDetails?: TaxDetail[] | undefined;
  objectType?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class CartShipmentItem implements ICartShipmentItem {
  lineItemId?: string | undefined;
  lineItem?: CartLineItem;
  barCode?: string | undefined;
  quantity?: number;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: ICartShipmentItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.lineItemId = _data["lineItemId"];
      this.lineItem = _data["lineItem"]
        ? CartLineItem.fromJS(_data["lineItem"])
        : <any>undefined;
      this.barCode = _data["barCode"];
      this.quantity = _data["quantity"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): CartShipmentItem {
    data = typeof data === "object" ? data : {};
    let result = new CartShipmentItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["lineItemId"] = this.lineItemId;
    data["lineItem"] = this.lineItem ? this.lineItem.toJSON() : <any>undefined;
    data["barCode"] = this.barCode;
    data["quantity"] = this.quantity;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface ICartShipmentItem {
  lineItemId?: string | undefined;
  lineItem?: CartLineItem;
  barCode?: string | undefined;
  quantity?: number;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class CartShipment implements ICartShipment {
  shipmentMethodCode?: string | undefined;
  shipmentMethodOption?: string | undefined;
  fulfillmentCenterId?: string | undefined;
  fulfillmentCenterName?: string | undefined;
  warehouseLocation?: string | undefined;
  currency?: string | undefined;
  volumetricWeight?: number | undefined;
  weightUnit?: string | undefined;
  weight?: number | undefined;
  measureUnit?: string | undefined;
  height?: number | undefined;
  length?: number | undefined;
  width?: number | undefined;
  price?: number;
  priceWithTax?: number;
  total?: number;
  totalWithTax?: number;
  discountAmount?: number;
  discountAmountWithTax?: number;
  fee?: number;
  feeWithTax?: number;
  taxType?: string | undefined;
  taxTotal?: number;
  taxPercentRate?: number;
  deliveryAddress?: CartAddress;
  items?: CartShipmentItem[] | undefined;
  discounts?: Discount[] | undefined;
  taxDetails?: TaxDetail[] | undefined;
  readonly objectType?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: ICartShipment) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.shipmentMethodCode = _data["shipmentMethodCode"];
      this.shipmentMethodOption = _data["shipmentMethodOption"];
      this.fulfillmentCenterId = _data["fulfillmentCenterId"];
      this.fulfillmentCenterName = _data["fulfillmentCenterName"];
      this.warehouseLocation = _data["warehouseLocation"];
      this.currency = _data["currency"];
      this.volumetricWeight = _data["volumetricWeight"];
      this.weightUnit = _data["weightUnit"];
      this.weight = _data["weight"];
      this.measureUnit = _data["measureUnit"];
      this.height = _data["height"];
      this.length = _data["length"];
      this.width = _data["width"];
      this.price = _data["price"];
      this.priceWithTax = _data["priceWithTax"];
      this.total = _data["total"];
      this.totalWithTax = _data["totalWithTax"];
      this.discountAmount = _data["discountAmount"];
      this.discountAmountWithTax = _data["discountAmountWithTax"];
      this.fee = _data["fee"];
      this.feeWithTax = _data["feeWithTax"];
      this.taxType = _data["taxType"];
      this.taxTotal = _data["taxTotal"];
      this.taxPercentRate = _data["taxPercentRate"];
      this.deliveryAddress = _data["deliveryAddress"]
        ? CartAddress.fromJS(_data["deliveryAddress"])
        : <any>undefined;
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(CartShipmentItem.fromJS(item));
      }
      if (Array.isArray(_data["discounts"])) {
        this.discounts = [] as any;
        for (let item of _data["discounts"])
          this.discounts!.push(Discount.fromJS(item));
      }
      if (Array.isArray(_data["taxDetails"])) {
        this.taxDetails = [] as any;
        for (let item of _data["taxDetails"])
          this.taxDetails!.push(TaxDetail.fromJS(item));
      }
      (<any>this).objectType = _data["objectType"];
      if (Array.isArray(_data["dynamicProperties"])) {
        this.dynamicProperties = [] as any;
        for (let item of _data["dynamicProperties"])
          this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): CartShipment {
    data = typeof data === "object" ? data : {};
    let result = new CartShipment();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["shipmentMethodCode"] = this.shipmentMethodCode;
    data["shipmentMethodOption"] = this.shipmentMethodOption;
    data["fulfillmentCenterId"] = this.fulfillmentCenterId;
    data["fulfillmentCenterName"] = this.fulfillmentCenterName;
    data["warehouseLocation"] = this.warehouseLocation;
    data["currency"] = this.currency;
    data["volumetricWeight"] = this.volumetricWeight;
    data["weightUnit"] = this.weightUnit;
    data["weight"] = this.weight;
    data["measureUnit"] = this.measureUnit;
    data["height"] = this.height;
    data["length"] = this.length;
    data["width"] = this.width;
    data["price"] = this.price;
    data["priceWithTax"] = this.priceWithTax;
    data["total"] = this.total;
    data["totalWithTax"] = this.totalWithTax;
    data["discountAmount"] = this.discountAmount;
    data["discountAmountWithTax"] = this.discountAmountWithTax;
    data["fee"] = this.fee;
    data["feeWithTax"] = this.feeWithTax;
    data["taxType"] = this.taxType;
    data["taxTotal"] = this.taxTotal;
    data["taxPercentRate"] = this.taxPercentRate;
    data["deliveryAddress"] = this.deliveryAddress
      ? this.deliveryAddress.toJSON()
      : <any>undefined;
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    if (Array.isArray(this.discounts)) {
      data["discounts"] = [];
      for (let item of this.discounts) data["discounts"].push(item.toJSON());
    }
    if (Array.isArray(this.taxDetails)) {
      data["taxDetails"] = [];
      for (let item of this.taxDetails) data["taxDetails"].push(item.toJSON());
    }
    data["objectType"] = this.objectType;
    if (Array.isArray(this.dynamicProperties)) {
      data["dynamicProperties"] = [];
      for (let item of this.dynamicProperties)
        data["dynamicProperties"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface ICartShipment {
  shipmentMethodCode?: string | undefined;
  shipmentMethodOption?: string | undefined;
  fulfillmentCenterId?: string | undefined;
  fulfillmentCenterName?: string | undefined;
  warehouseLocation?: string | undefined;
  currency?: string | undefined;
  volumetricWeight?: number | undefined;
  weightUnit?: string | undefined;
  weight?: number | undefined;
  measureUnit?: string | undefined;
  height?: number | undefined;
  length?: number | undefined;
  width?: number | undefined;
  price?: number;
  priceWithTax?: number;
  total?: number;
  totalWithTax?: number;
  discountAmount?: number;
  discountAmountWithTax?: number;
  fee?: number;
  feeWithTax?: number;
  taxType?: string | undefined;
  taxTotal?: number;
  taxPercentRate?: number;
  deliveryAddress?: CartAddress;
  items?: CartShipmentItem[] | undefined;
  discounts?: Discount[] | undefined;
  taxDetails?: TaxDetail[] | undefined;
  objectType?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class ShoppingCart implements IShoppingCart {
  name?: string | undefined;
  storeId?: string | undefined;
  channelId?: string | undefined;
  isAnonymous?: boolean;
  customerId?: string | undefined;
  customerName?: string | undefined;
  organizationId?: string | undefined;
  currency?: string | undefined;
  languageCode?: string | undefined;
  taxIncluded?: boolean | undefined;
  isRecuring?: boolean | undefined;
  comment?: string | undefined;
  status?: string | undefined;
  purchaseOrderNumber?: string | undefined;
  weightUnit?: string | undefined;
  weight?: number | undefined;
  validationType?: string | undefined;
  type?: string | undefined;
  volumetricWeight?: number | undefined;
  total?: number;
  subTotal?: number;
  subTotalWithTax?: number;
  subTotalDiscount?: number;
  subTotalDiscountWithTax?: number;
  shippingTotal?: number;
  shippingTotalWithTax?: number;
  shippingSubTotal?: number;
  shippingSubTotalWithTax?: number;
  shippingDiscountTotal?: number;
  shippingDiscountTotalWithTax?: number;
  paymentTotal?: number;
  paymentTotalWithTax?: number;
  paymentSubTotal?: number;
  paymentSubTotalWithTax?: number;
  paymentDiscountTotal?: number;
  paymentDiscountTotalWithTax?: number;
  handlingTotal?: number;
  handlingTotalWithTax?: number;
  discountAmount?: number;
  discountAmountWithTax?: number;
  discountTotal?: number;
  discountTotalWithTax?: number;
  fee?: number;
  feeWithTax?: number;
  feeTotal?: number;
  feeTotalWithTax?: number;
  addresses?: CartAddress[] | undefined;
  items?: CartLineItem[] | undefined;
  payments?: Payment[] | undefined;
  shipments?: CartShipment[] | undefined;
  coupons?: string[] | undefined;
  coupon?: string | undefined;
  discounts?: Discount[] | undefined;
  taxType?: string | undefined;
  taxTotal?: number;
  taxPercentRate?: number;
  taxDetails?: TaxDetail[] | undefined;
  readonly objectType?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IShoppingCart) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.storeId = _data["storeId"];
      this.channelId = _data["channelId"];
      this.isAnonymous = _data["isAnonymous"];
      this.customerId = _data["customerId"];
      this.customerName = _data["customerName"];
      this.organizationId = _data["organizationId"];
      this.currency = _data["currency"];
      this.languageCode = _data["languageCode"];
      this.taxIncluded = _data["taxIncluded"];
      this.isRecuring = _data["isRecuring"];
      this.comment = _data["comment"];
      this.status = _data["status"];
      this.purchaseOrderNumber = _data["purchaseOrderNumber"];
      this.weightUnit = _data["weightUnit"];
      this.weight = _data["weight"];
      this.validationType = _data["validationType"];
      this.type = _data["type"];
      this.volumetricWeight = _data["volumetricWeight"];
      this.total = _data["total"];
      this.subTotal = _data["subTotal"];
      this.subTotalWithTax = _data["subTotalWithTax"];
      this.subTotalDiscount = _data["subTotalDiscount"];
      this.subTotalDiscountWithTax = _data["subTotalDiscountWithTax"];
      this.shippingTotal = _data["shippingTotal"];
      this.shippingTotalWithTax = _data["shippingTotalWithTax"];
      this.shippingSubTotal = _data["shippingSubTotal"];
      this.shippingSubTotalWithTax = _data["shippingSubTotalWithTax"];
      this.shippingDiscountTotal = _data["shippingDiscountTotal"];
      this.shippingDiscountTotalWithTax = _data["shippingDiscountTotalWithTax"];
      this.paymentTotal = _data["paymentTotal"];
      this.paymentTotalWithTax = _data["paymentTotalWithTax"];
      this.paymentSubTotal = _data["paymentSubTotal"];
      this.paymentSubTotalWithTax = _data["paymentSubTotalWithTax"];
      this.paymentDiscountTotal = _data["paymentDiscountTotal"];
      this.paymentDiscountTotalWithTax = _data["paymentDiscountTotalWithTax"];
      this.handlingTotal = _data["handlingTotal"];
      this.handlingTotalWithTax = _data["handlingTotalWithTax"];
      this.discountAmount = _data["discountAmount"];
      this.discountAmountWithTax = _data["discountAmountWithTax"];
      this.discountTotal = _data["discountTotal"];
      this.discountTotalWithTax = _data["discountTotalWithTax"];
      this.fee = _data["fee"];
      this.feeWithTax = _data["feeWithTax"];
      this.feeTotal = _data["feeTotal"];
      this.feeTotalWithTax = _data["feeTotalWithTax"];
      if (Array.isArray(_data["addresses"])) {
        this.addresses = [] as any;
        for (let item of _data["addresses"])
          this.addresses!.push(CartAddress.fromJS(item));
      }
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(CartLineItem.fromJS(item));
      }
      if (Array.isArray(_data["payments"])) {
        this.payments = [] as any;
        for (let item of _data["payments"])
          this.payments!.push(Payment.fromJS(item));
      }
      if (Array.isArray(_data["shipments"])) {
        this.shipments = [] as any;
        for (let item of _data["shipments"])
          this.shipments!.push(CartShipment.fromJS(item));
      }
      if (Array.isArray(_data["coupons"])) {
        this.coupons = [] as any;
        for (let item of _data["coupons"]) this.coupons!.push(item);
      }
      this.coupon = _data["coupon"];
      if (Array.isArray(_data["discounts"])) {
        this.discounts = [] as any;
        for (let item of _data["discounts"])
          this.discounts!.push(Discount.fromJS(item));
      }
      this.taxType = _data["taxType"];
      this.taxTotal = _data["taxTotal"];
      this.taxPercentRate = _data["taxPercentRate"];
      if (Array.isArray(_data["taxDetails"])) {
        this.taxDetails = [] as any;
        for (let item of _data["taxDetails"])
          this.taxDetails!.push(TaxDetail.fromJS(item));
      }
      (<any>this).objectType = _data["objectType"];
      if (Array.isArray(_data["dynamicProperties"])) {
        this.dynamicProperties = [] as any;
        for (let item of _data["dynamicProperties"])
          this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): ShoppingCart {
    data = typeof data === "object" ? data : {};
    let result = new ShoppingCart();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["storeId"] = this.storeId;
    data["channelId"] = this.channelId;
    data["isAnonymous"] = this.isAnonymous;
    data["customerId"] = this.customerId;
    data["customerName"] = this.customerName;
    data["organizationId"] = this.organizationId;
    data["currency"] = this.currency;
    data["languageCode"] = this.languageCode;
    data["taxIncluded"] = this.taxIncluded;
    data["isRecuring"] = this.isRecuring;
    data["comment"] = this.comment;
    data["status"] = this.status;
    data["purchaseOrderNumber"] = this.purchaseOrderNumber;
    data["weightUnit"] = this.weightUnit;
    data["weight"] = this.weight;
    data["validationType"] = this.validationType;
    data["type"] = this.type;
    data["volumetricWeight"] = this.volumetricWeight;
    data["total"] = this.total;
    data["subTotal"] = this.subTotal;
    data["subTotalWithTax"] = this.subTotalWithTax;
    data["subTotalDiscount"] = this.subTotalDiscount;
    data["subTotalDiscountWithTax"] = this.subTotalDiscountWithTax;
    data["shippingTotal"] = this.shippingTotal;
    data["shippingTotalWithTax"] = this.shippingTotalWithTax;
    data["shippingSubTotal"] = this.shippingSubTotal;
    data["shippingSubTotalWithTax"] = this.shippingSubTotalWithTax;
    data["shippingDiscountTotal"] = this.shippingDiscountTotal;
    data["shippingDiscountTotalWithTax"] = this.shippingDiscountTotalWithTax;
    data["paymentTotal"] = this.paymentTotal;
    data["paymentTotalWithTax"] = this.paymentTotalWithTax;
    data["paymentSubTotal"] = this.paymentSubTotal;
    data["paymentSubTotalWithTax"] = this.paymentSubTotalWithTax;
    data["paymentDiscountTotal"] = this.paymentDiscountTotal;
    data["paymentDiscountTotalWithTax"] = this.paymentDiscountTotalWithTax;
    data["handlingTotal"] = this.handlingTotal;
    data["handlingTotalWithTax"] = this.handlingTotalWithTax;
    data["discountAmount"] = this.discountAmount;
    data["discountAmountWithTax"] = this.discountAmountWithTax;
    data["discountTotal"] = this.discountTotal;
    data["discountTotalWithTax"] = this.discountTotalWithTax;
    data["fee"] = this.fee;
    data["feeWithTax"] = this.feeWithTax;
    data["feeTotal"] = this.feeTotal;
    data["feeTotalWithTax"] = this.feeTotalWithTax;
    if (Array.isArray(this.addresses)) {
      data["addresses"] = [];
      for (let item of this.addresses) data["addresses"].push(item.toJSON());
    }
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    if (Array.isArray(this.payments)) {
      data["payments"] = [];
      for (let item of this.payments) data["payments"].push(item.toJSON());
    }
    if (Array.isArray(this.shipments)) {
      data["shipments"] = [];
      for (let item of this.shipments) data["shipments"].push(item.toJSON());
    }
    if (Array.isArray(this.coupons)) {
      data["coupons"] = [];
      for (let item of this.coupons) data["coupons"].push(item);
    }
    data["coupon"] = this.coupon;
    if (Array.isArray(this.discounts)) {
      data["discounts"] = [];
      for (let item of this.discounts) data["discounts"].push(item.toJSON());
    }
    data["taxType"] = this.taxType;
    data["taxTotal"] = this.taxTotal;
    data["taxPercentRate"] = this.taxPercentRate;
    if (Array.isArray(this.taxDetails)) {
      data["taxDetails"] = [];
      for (let item of this.taxDetails) data["taxDetails"].push(item.toJSON());
    }
    data["objectType"] = this.objectType;
    if (Array.isArray(this.dynamicProperties)) {
      data["dynamicProperties"] = [];
      for (let item of this.dynamicProperties)
        data["dynamicProperties"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IShoppingCart {
  name?: string | undefined;
  storeId?: string | undefined;
  channelId?: string | undefined;
  isAnonymous?: boolean;
  customerId?: string | undefined;
  customerName?: string | undefined;
  organizationId?: string | undefined;
  currency?: string | undefined;
  languageCode?: string | undefined;
  taxIncluded?: boolean | undefined;
  isRecuring?: boolean | undefined;
  comment?: string | undefined;
  status?: string | undefined;
  purchaseOrderNumber?: string | undefined;
  weightUnit?: string | undefined;
  weight?: number | undefined;
  validationType?: string | undefined;
  type?: string | undefined;
  volumetricWeight?: number | undefined;
  total?: number;
  subTotal?: number;
  subTotalWithTax?: number;
  subTotalDiscount?: number;
  subTotalDiscountWithTax?: number;
  shippingTotal?: number;
  shippingTotalWithTax?: number;
  shippingSubTotal?: number;
  shippingSubTotalWithTax?: number;
  shippingDiscountTotal?: number;
  shippingDiscountTotalWithTax?: number;
  paymentTotal?: number;
  paymentTotalWithTax?: number;
  paymentSubTotal?: number;
  paymentSubTotalWithTax?: number;
  paymentDiscountTotal?: number;
  paymentDiscountTotalWithTax?: number;
  handlingTotal?: number;
  handlingTotalWithTax?: number;
  discountAmount?: number;
  discountAmountWithTax?: number;
  discountTotal?: number;
  discountTotalWithTax?: number;
  fee?: number;
  feeWithTax?: number;
  feeTotal?: number;
  feeTotalWithTax?: number;
  addresses?: CartAddress[] | undefined;
  items?: CartLineItem[] | undefined;
  payments?: Payment[] | undefined;
  shipments?: CartShipment[] | undefined;
  coupons?: string[] | undefined;
  coupon?: string | undefined;
  discounts?: Discount[] | undefined;
  taxType?: string | undefined;
  taxTotal?: number;
  taxPercentRate?: number;
  taxDetails?: TaxDetail[] | undefined;
  objectType?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class ShippingMethod implements IShippingMethod {
  code?: string | undefined;
  readonly name?: string | undefined;
  logoUrl?: string | undefined;
  isActive?: boolean;
  priority?: number;
  taxType?: string | undefined;
  storeId?: string | undefined;
  settings?: ObjectSettingEntry[] | undefined;
  readonly typeName?: string | undefined;
  id?: string | undefined;

  constructor(data?: IShippingMethod) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.code = _data["code"];
      (<any>this).name = _data["name"];
      this.logoUrl = _data["logoUrl"];
      this.isActive = _data["isActive"];
      this.priority = _data["priority"];
      this.taxType = _data["taxType"];
      this.storeId = _data["storeId"];
      if (Array.isArray(_data["settings"])) {
        this.settings = [] as any;
        for (let item of _data["settings"])
          this.settings!.push(ObjectSettingEntry.fromJS(item));
      }
      (<any>this).typeName = _data["typeName"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): ShippingMethod {
    data = typeof data === "object" ? data : {};
    let result = new ShippingMethod();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["code"] = this.code;
    data["name"] = this.name;
    data["logoUrl"] = this.logoUrl;
    data["isActive"] = this.isActive;
    data["priority"] = this.priority;
    data["taxType"] = this.taxType;
    data["storeId"] = this.storeId;
    if (Array.isArray(this.settings)) {
      data["settings"] = [];
      for (let item of this.settings) data["settings"].push(item.toJSON());
    }
    data["typeName"] = this.typeName;
    data["id"] = this.id;
    return data;
  }
}

export interface IShippingMethod {
  code?: string | undefined;
  name?: string | undefined;
  logoUrl?: string | undefined;
  isActive?: boolean;
  priority?: number;
  taxType?: string | undefined;
  storeId?: string | undefined;
  settings?: ObjectSettingEntry[] | undefined;
  typeName?: string | undefined;
  id?: string | undefined;
}

export class ShippingRate implements IShippingRate {
  optionName?: string | undefined;
  optionDescription?: string | undefined;
  rate?: number;
  rateWithTax?: number;
  currency?: string | undefined;
  discountAmount?: number;
  discountAmountWithTax?: number;
  shippingMethod?: ShippingMethod;

  constructor(data?: IShippingRate) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.optionName = _data["optionName"];
      this.optionDescription = _data["optionDescription"];
      this.rate = _data["rate"];
      this.rateWithTax = _data["rateWithTax"];
      this.currency = _data["currency"];
      this.discountAmount = _data["discountAmount"];
      this.discountAmountWithTax = _data["discountAmountWithTax"];
      this.shippingMethod = _data["shippingMethod"]
        ? ShippingMethod.fromJS(_data["shippingMethod"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ShippingRate {
    data = typeof data === "object" ? data : {};
    let result = new ShippingRate();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["optionName"] = this.optionName;
    data["optionDescription"] = this.optionDescription;
    data["rate"] = this.rate;
    data["rateWithTax"] = this.rateWithTax;
    data["currency"] = this.currency;
    data["discountAmount"] = this.discountAmount;
    data["discountAmountWithTax"] = this.discountAmountWithTax;
    data["shippingMethod"] = this.shippingMethod
      ? this.shippingMethod.toJSON()
      : <any>undefined;
    return data;
  }
}

export interface IShippingRate {
  optionName?: string | undefined;
  optionDescription?: string | undefined;
  rate?: number;
  rateWithTax?: number;
  currency?: string | undefined;
  discountAmount?: number;
  discountAmountWithTax?: number;
  shippingMethod?: ShippingMethod;
}

export class ShippingEvaluationContext implements IShippingEvaluationContext {
  shoppingCart?: ShoppingCart;
  currency?: string | undefined;

  constructor(data?: IShippingEvaluationContext) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.shoppingCart = _data["shoppingCart"]
        ? ShoppingCart.fromJS(_data["shoppingCart"])
        : <any>undefined;
      this.currency = _data["currency"];
    }
  }

  static fromJS(data: any): ShippingEvaluationContext {
    data = typeof data === "object" ? data : {};
    let result = new ShippingEvaluationContext();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["shoppingCart"] = this.shoppingCart
      ? this.shoppingCart.toJSON()
      : <any>undefined;
    data["currency"] = this.currency;
    return data;
  }
}

export interface IShippingEvaluationContext {
  shoppingCart?: ShoppingCart;
  currency?: string | undefined;
}

export enum PaymentMethodType {
  Unknown = "Unknown",
  Standard = "Standard",
  Redirection = "Redirection",
  PreparedForm = "PreparedForm",
}

export enum PaymentMethodGroupType {
  Paypal = "Paypal",
  BankCard = "BankCard",
  Alternative = "Alternative",
  Manual = "Manual",
}

export class PaymentMethod implements IPaymentMethod {
  code?: string | undefined;
  readonly name?: string | undefined;
  logoUrl?: string | undefined;
  isActive?: boolean;
  priority?: number;
  isAvailableForPartial?: boolean;
  currency?: string | undefined;
  price?: number;
  readonly priceWithTax?: number;
  readonly total?: number;
  readonly totalWithTax?: number;
  discountAmount?: number;
  readonly discountAmountWithTax?: number;
  storeId?: string | undefined;
  readonly typeName?: string | undefined;
  settings?: ObjectSettingEntry[] | undefined;
  taxType?: string | undefined;
  readonly taxTotal?: number;
  taxPercentRate?: number;
  taxDetails?: TaxDetail[] | undefined;
  paymentMethodType?: PaymentMethodType;
  paymentMethodGroupType?: PaymentMethodGroupType;
  id?: string | undefined;

  constructor(data?: IPaymentMethod) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.code = _data["code"];
      (<any>this).name = _data["name"];
      this.logoUrl = _data["logoUrl"];
      this.isActive = _data["isActive"];
      this.priority = _data["priority"];
      this.isAvailableForPartial = _data["isAvailableForPartial"];
      this.currency = _data["currency"];
      this.price = _data["price"];
      (<any>this).priceWithTax = _data["priceWithTax"];
      (<any>this).total = _data["total"];
      (<any>this).totalWithTax = _data["totalWithTax"];
      this.discountAmount = _data["discountAmount"];
      (<any>this).discountAmountWithTax = _data["discountAmountWithTax"];
      this.storeId = _data["storeId"];
      (<any>this).typeName = _data["typeName"];
      if (Array.isArray(_data["settings"])) {
        this.settings = [] as any;
        for (let item of _data["settings"])
          this.settings!.push(ObjectSettingEntry.fromJS(item));
      }
      this.taxType = _data["taxType"];
      (<any>this).taxTotal = _data["taxTotal"];
      this.taxPercentRate = _data["taxPercentRate"];
      if (Array.isArray(_data["taxDetails"])) {
        this.taxDetails = [] as any;
        for (let item of _data["taxDetails"])
          this.taxDetails!.push(TaxDetail.fromJS(item));
      }
      this.paymentMethodType = _data["paymentMethodType"];
      this.paymentMethodGroupType = _data["paymentMethodGroupType"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): PaymentMethod {
    data = typeof data === "object" ? data : {};
    let result = new PaymentMethod();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["code"] = this.code;
    data["name"] = this.name;
    data["logoUrl"] = this.logoUrl;
    data["isActive"] = this.isActive;
    data["priority"] = this.priority;
    data["isAvailableForPartial"] = this.isAvailableForPartial;
    data["currency"] = this.currency;
    data["price"] = this.price;
    data["priceWithTax"] = this.priceWithTax;
    data["total"] = this.total;
    data["totalWithTax"] = this.totalWithTax;
    data["discountAmount"] = this.discountAmount;
    data["discountAmountWithTax"] = this.discountAmountWithTax;
    data["storeId"] = this.storeId;
    data["typeName"] = this.typeName;
    if (Array.isArray(this.settings)) {
      data["settings"] = [];
      for (let item of this.settings) data["settings"].push(item.toJSON());
    }
    data["taxType"] = this.taxType;
    data["taxTotal"] = this.taxTotal;
    data["taxPercentRate"] = this.taxPercentRate;
    if (Array.isArray(this.taxDetails)) {
      data["taxDetails"] = [];
      for (let item of this.taxDetails) data["taxDetails"].push(item.toJSON());
    }
    data["paymentMethodType"] = this.paymentMethodType;
    data["paymentMethodGroupType"] = this.paymentMethodGroupType;
    data["id"] = this.id;
    return data;
  }
}

export interface IPaymentMethod {
  code?: string | undefined;
  name?: string | undefined;
  logoUrl?: string | undefined;
  isActive?: boolean;
  priority?: number;
  isAvailableForPartial?: boolean;
  currency?: string | undefined;
  price?: number;
  priceWithTax?: number;
  total?: number;
  totalWithTax?: number;
  discountAmount?: number;
  discountAmountWithTax?: number;
  storeId?: string | undefined;
  typeName?: string | undefined;
  settings?: ObjectSettingEntry[] | undefined;
  taxType?: string | undefined;
  taxTotal?: number;
  taxPercentRate?: number;
  taxDetails?: TaxDetail[] | undefined;
  paymentMethodType?: PaymentMethodType;
  paymentMethodGroupType?: PaymentMethodGroupType;
  id?: string | undefined;
}

export class ShoppingCartSearchCriteria implements IShoppingCartSearchCriteria {
  name?: string | undefined;
  customerId?: string | undefined;
  storeId?: string | undefined;
  currency?: string | undefined;
  status?: string | undefined;
  type?: string | undefined;
  customerIds?: string[] | undefined;
  organizationId?: string | undefined;
  createdStartDate?: Date | undefined;
  createdEndDate?: Date | undefined;
  modifiedStartDate?: Date | undefined;
  modifiedEndDate?: Date | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IShoppingCartSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.customerId = _data["customerId"];
      this.storeId = _data["storeId"];
      this.currency = _data["currency"];
      this.status = _data["status"];
      this.type = _data["type"];
      if (Array.isArray(_data["customerIds"])) {
        this.customerIds = [] as any;
        for (let item of _data["customerIds"]) this.customerIds!.push(item);
      }
      this.organizationId = _data["organizationId"];
      this.createdStartDate = _data["createdStartDate"]
        ? new Date(_data["createdStartDate"].toString())
        : <any>undefined;
      this.createdEndDate = _data["createdEndDate"]
        ? new Date(_data["createdEndDate"].toString())
        : <any>undefined;
      this.modifiedStartDate = _data["modifiedStartDate"]
        ? new Date(_data["modifiedStartDate"].toString())
        : <any>undefined;
      this.modifiedEndDate = _data["modifiedEndDate"]
        ? new Date(_data["modifiedEndDate"].toString())
        : <any>undefined;
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): ShoppingCartSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new ShoppingCartSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["customerId"] = this.customerId;
    data["storeId"] = this.storeId;
    data["currency"] = this.currency;
    data["status"] = this.status;
    data["type"] = this.type;
    if (Array.isArray(this.customerIds)) {
      data["customerIds"] = [];
      for (let item of this.customerIds) data["customerIds"].push(item);
    }
    data["organizationId"] = this.organizationId;
    data["createdStartDate"] = this.createdStartDate
      ? this.createdStartDate.toISOString()
      : <any>undefined;
    data["createdEndDate"] = this.createdEndDate
      ? this.createdEndDate.toISOString()
      : <any>undefined;
    data["modifiedStartDate"] = this.modifiedStartDate
      ? this.modifiedStartDate.toISOString()
      : <any>undefined;
    data["modifiedEndDate"] = this.modifiedEndDate
      ? this.modifiedEndDate.toISOString()
      : <any>undefined;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IShoppingCartSearchCriteria {
  name?: string | undefined;
  customerId?: string | undefined;
  storeId?: string | undefined;
  currency?: string | undefined;
  status?: string | undefined;
  type?: string | undefined;
  customerIds?: string[] | undefined;
  organizationId?: string | undefined;
  createdStartDate?: Date | undefined;
  createdEndDate?: Date | undefined;
  modifiedStartDate?: Date | undefined;
  modifiedEndDate?: Date | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class ShoppingCartSearchResult implements IShoppingCartSearchResult {
  totalCount?: number;
  results?: ShoppingCart[] | undefined;

  constructor(data?: IShoppingCartSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(ShoppingCart.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ShoppingCartSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new ShoppingCartSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IShoppingCartSearchResult {
  totalCount?: number;
  results?: ShoppingCart[] | undefined;
}

export class SeoInfo implements ISeoInfo {
  name?: string | undefined;
  /** Slug */
  semanticUrl?: string | undefined;
  /** head title tag content */
  pageTitle?: string | undefined;
  /** <meta name="description" /> */
  metaDescription?: string | undefined;
  imageAltDescription?: string | undefined;
  /** <meta name="keywords" /> */
  metaKeywords?: string | undefined;
  /** Tenant StoreId which SEO defined */
  storeId?: string | undefined;
  /** SEO related object id */
  objectId?: string | undefined;
  /** SEO related object type name */
  objectType?: string | undefined;
  /** Active/Inactive */
  isActive?: boolean;
  languageCode?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: ISeoInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.semanticUrl = _data["semanticUrl"];
      this.pageTitle = _data["pageTitle"];
      this.metaDescription = _data["metaDescription"];
      this.imageAltDescription = _data["imageAltDescription"];
      this.metaKeywords = _data["metaKeywords"];
      this.storeId = _data["storeId"];
      this.objectId = _data["objectId"];
      this.objectType = _data["objectType"];
      this.isActive = _data["isActive"];
      this.languageCode = _data["languageCode"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): SeoInfo {
    data = typeof data === "object" ? data : {};
    let result = new SeoInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["semanticUrl"] = this.semanticUrl;
    data["pageTitle"] = this.pageTitle;
    data["metaDescription"] = this.metaDescription;
    data["imageAltDescription"] = this.imageAltDescription;
    data["metaKeywords"] = this.metaKeywords;
    data["storeId"] = this.storeId;
    data["objectId"] = this.objectId;
    data["objectType"] = this.objectType;
    data["isActive"] = this.isActive;
    data["languageCode"] = this.languageCode;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface ISeoInfo {
  name?: string | undefined;
  /** Slug */
  semanticUrl?: string | undefined;
  /** head title tag content */
  pageTitle?: string | undefined;
  /** <meta name="description" /> */
  metaDescription?: string | undefined;
  imageAltDescription?: string | undefined;
  /** <meta name="keywords" /> */
  metaKeywords?: string | undefined;
  /** Tenant StoreId which SEO defined */
  storeId?: string | undefined;
  /** SEO related object id */
  objectId?: string | undefined;
  /** SEO related object type name */
  objectType?: string | undefined;
  /** Active/Inactive */
  isActive?: boolean;
  languageCode?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class Image implements IImage {
  binaryData?: string | undefined;
  altText?: string | undefined;
  relativeUrl?: string | undefined;
  url?: string | undefined;
  description?: string | undefined;
  sortOrder?: number;
  /** Gets or sets the asset type identifier. */
  typeId?: string | undefined;
  /** Gets or sets the asset group name. */
  group?: string | undefined;
  /** Gets or sets the asset name. */
  name?: string | undefined;
  outerId?: string | undefined;
  /** Gets or sets the asset language. */
  languageCode?: string | undefined;
  /** System flag used to mark that object was inherited from other */
  readonly isInherited?: boolean;
  readonly seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IImage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.binaryData = _data["binaryData"];
      this.altText = _data["altText"];
      this.relativeUrl = _data["relativeUrl"];
      this.url = _data["url"];
      this.description = _data["description"];
      this.sortOrder = _data["sortOrder"];
      this.typeId = _data["typeId"];
      this.group = _data["group"];
      this.name = _data["name"];
      this.outerId = _data["outerId"];
      this.languageCode = _data["languageCode"];
      (<any>this).isInherited = _data["isInherited"];
      (<any>this).seoObjectType = _data["seoObjectType"];
      if (Array.isArray(_data["seoInfos"])) {
        this.seoInfos = [] as any;
        for (let item of _data["seoInfos"])
          this.seoInfos!.push(SeoInfo.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Image {
    data = typeof data === "object" ? data : {};
    let result = new Image();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["binaryData"] = this.binaryData;
    data["altText"] = this.altText;
    data["relativeUrl"] = this.relativeUrl;
    data["url"] = this.url;
    data["description"] = this.description;
    data["sortOrder"] = this.sortOrder;
    data["typeId"] = this.typeId;
    data["group"] = this.group;
    data["name"] = this.name;
    data["outerId"] = this.outerId;
    data["languageCode"] = this.languageCode;
    data["isInherited"] = this.isInherited;
    data["seoObjectType"] = this.seoObjectType;
    if (Array.isArray(this.seoInfos)) {
      data["seoInfos"] = [];
      for (let item of this.seoInfos) data["seoInfos"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IImage {
  binaryData?: string | undefined;
  altText?: string | undefined;
  relativeUrl?: string | undefined;
  url?: string | undefined;
  description?: string | undefined;
  sortOrder?: number;
  /** Gets or sets the asset type identifier. */
  typeId?: string | undefined;
  /** Gets or sets the asset group name. */
  group?: string | undefined;
  /** Gets or sets the asset name. */
  name?: string | undefined;
  outerId?: string | undefined;
  /** Gets or sets the asset language. */
  languageCode?: string | undefined;
  /** System flag used to mark that object was inherited from other */
  isInherited?: boolean;
  seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class ProductAssociation implements IProductAssociation {
  /** Association type (Accessories, Up-Sales, Cross-Sales, Related etc) */
  type?: string | undefined;
  priority?: number;
  quantity?: number | undefined;
  /** Is a primary key of associating object */
  itemId?: string | undefined;
  /** Each link element can have an associated object like Product, Category, etc.
  Is a primary key of associated object */
  associatedObjectId?: string | undefined;
  /** Associated object type : 'product', 'category' etc */
  associatedObjectType?: string | undefined;
  outerId?: string | undefined;
  /** Display name for associated object */
  readonly associatedObjectName?: string | undefined;
  /** Associated object image URL */
  readonly associatedObjectImg?: string | undefined;
  tags?: string[] | undefined;
  readonly imgSrc?: string | undefined;
  images?: Image[] | undefined;
  id?: string | undefined;

  constructor(data?: IProductAssociation) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data["type"];
      this.priority = _data["priority"];
      this.quantity = _data["quantity"];
      this.itemId = _data["itemId"];
      this.associatedObjectId = _data["associatedObjectId"];
      this.associatedObjectType = _data["associatedObjectType"];
      this.outerId = _data["outerId"];
      (<any>this).associatedObjectName = _data["associatedObjectName"];
      (<any>this).associatedObjectImg = _data["associatedObjectImg"];
      if (Array.isArray(_data["tags"])) {
        this.tags = [] as any;
        for (let item of _data["tags"]) this.tags!.push(item);
      }
      (<any>this).imgSrc = _data["imgSrc"];
      if (Array.isArray(_data["images"])) {
        this.images = [] as any;
        for (let item of _data["images"]) this.images!.push(Image.fromJS(item));
      }
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): ProductAssociation {
    data = typeof data === "object" ? data : {};
    let result = new ProductAssociation();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["type"] = this.type;
    data["priority"] = this.priority;
    data["quantity"] = this.quantity;
    data["itemId"] = this.itemId;
    data["associatedObjectId"] = this.associatedObjectId;
    data["associatedObjectType"] = this.associatedObjectType;
    data["outerId"] = this.outerId;
    data["associatedObjectName"] = this.associatedObjectName;
    data["associatedObjectImg"] = this.associatedObjectImg;
    if (Array.isArray(this.tags)) {
      data["tags"] = [];
      for (let item of this.tags) data["tags"].push(item);
    }
    data["imgSrc"] = this.imgSrc;
    if (Array.isArray(this.images)) {
      data["images"] = [];
      for (let item of this.images) data["images"].push(item.toJSON());
    }
    data["id"] = this.id;
    return data;
  }
}

export interface IProductAssociation {
  /** Association type (Accessories, Up-Sales, Cross-Sales, Related etc) */
  type?: string | undefined;
  priority?: number;
  quantity?: number | undefined;
  /** Is a primary key of associating object */
  itemId?: string | undefined;
  /** Each link element can have an associated object like Product, Category, etc.
  Is a primary key of associated object */
  associatedObjectId?: string | undefined;
  /** Associated object type : 'product', 'category' etc */
  associatedObjectType?: string | undefined;
  outerId?: string | undefined;
  /** Display name for associated object */
  associatedObjectName?: string | undefined;
  /** Associated object image URL */
  associatedObjectImg?: string | undefined;
  tags?: string[] | undefined;
  imgSrc?: string | undefined;
  images?: Image[] | undefined;
  id?: string | undefined;
}

export class ProductAssociationSearchCriteria
  implements IProductAssociationSearchCriteria
{
  group?: string | undefined;
  tags?: string[] | undefined;
  associatedObjectIds?: string[] | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IProductAssociationSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.group = _data["group"];
      if (Array.isArray(_data["tags"])) {
        this.tags = [] as any;
        for (let item of _data["tags"]) this.tags!.push(item);
      }
      if (Array.isArray(_data["associatedObjectIds"])) {
        this.associatedObjectIds = [] as any;
        for (let item of _data["associatedObjectIds"])
          this.associatedObjectIds!.push(item);
      }
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): ProductAssociationSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new ProductAssociationSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["group"] = this.group;
    if (Array.isArray(this.tags)) {
      data["tags"] = [];
      for (let item of this.tags) data["tags"].push(item);
    }
    if (Array.isArray(this.associatedObjectIds)) {
      data["associatedObjectIds"] = [];
      for (let item of this.associatedObjectIds)
        data["associatedObjectIds"].push(item);
    }
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IProductAssociationSearchCriteria {
  group?: string | undefined;
  tags?: string[] | undefined;
  associatedObjectIds?: string[] | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class ProductAssociationSearchResult
  implements IProductAssociationSearchResult
{
  totalCount?: number;
  results?: ProductAssociation[] | undefined;

  constructor(data?: IProductAssociationSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(ProductAssociation.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ProductAssociationSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new ProductAssociationSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IProductAssociationSearchResult {
  totalCount?: number;
  results?: ProductAssociation[] | undefined;
}

export class CatalogSearchCriteria implements ICatalogSearchCriteria {
  catalogIds?: string[] | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: ICatalogSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["catalogIds"])) {
        this.catalogIds = [] as any;
        for (let item of _data["catalogIds"]) this.catalogIds!.push(item);
      }
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): CatalogSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new CatalogSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.catalogIds)) {
      data["catalogIds"] = [];
      for (let item of this.catalogIds) data["catalogIds"].push(item);
    }
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface ICatalogSearchCriteria {
  catalogIds?: string[] | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class CatalogLanguage implements ICatalogLanguage {
  catalogId?: string | undefined;
  isDefault?: boolean;
  languageCode?: string | undefined;
  id?: string | undefined;

  constructor(data?: ICatalogLanguage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.catalogId = _data["catalogId"];
      this.isDefault = _data["isDefault"];
      this.languageCode = _data["languageCode"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): CatalogLanguage {
    data = typeof data === "object" ? data : {};
    let result = new CatalogLanguage();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["catalogId"] = this.catalogId;
    data["isDefault"] = this.isDefault;
    data["languageCode"] = this.languageCode;
    data["id"] = this.id;
    return data;
  }
}

export interface ICatalogLanguage {
  catalogId?: string | undefined;
  isDefault?: boolean;
  languageCode?: string | undefined;
  id?: string | undefined;
}

export enum PropertyValueType {
  ShortText = "ShortText",
  LongText = "LongText",
  Number = "Number",
  DateTime = "DateTime",
  Boolean = "Boolean",
  Integer = "Integer",
  GeoPoint = "GeoPoint",
}

export enum PropertyType {
  Product = "Product",
  Variation = "Variation",
  Category = "Category",
  Catalog = "Catalog",
}

export class PropertyValue implements IPropertyValue {
  propertyName?: string | undefined;
  propertyId?: string | undefined;
  languageCode?: string | undefined;
  alias?: string | undefined;
  valueType?: PropertyValueType;
  valueId?: string | undefined;
  value?: any | undefined;
  readonly propertyMultivalue?: boolean;
  outerId?: string | undefined;
  isInherited?: boolean;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IPropertyValue) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.propertyName = _data["propertyName"];
      this.propertyId = _data["propertyId"];
      this.languageCode = _data["languageCode"];
      this.alias = _data["alias"];
      this.valueType = _data["valueType"];
      this.valueId = _data["valueId"];
      this.value = _data["value"];
      (<any>this).propertyMultivalue = _data["propertyMultivalue"];
      this.outerId = _data["outerId"];
      this.isInherited = _data["isInherited"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): PropertyValue {
    data = typeof data === "object" ? data : {};
    let result = new PropertyValue();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["propertyName"] = this.propertyName;
    data["propertyId"] = this.propertyId;
    data["languageCode"] = this.languageCode;
    data["alias"] = this.alias;
    data["valueType"] = this.valueType;
    data["valueId"] = this.valueId;
    data["value"] = this.value;
    data["propertyMultivalue"] = this.propertyMultivalue;
    data["outerId"] = this.outerId;
    data["isInherited"] = this.isInherited;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IPropertyValue {
  propertyName?: string | undefined;
  propertyId?: string | undefined;
  languageCode?: string | undefined;
  alias?: string | undefined;
  valueType?: PropertyValueType;
  valueId?: string | undefined;
  value?: any | undefined;
  propertyMultivalue?: boolean;
  outerId?: string | undefined;
  isInherited?: boolean;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class PropertyAttribute implements IPropertyAttribute {
  propertyId?: string | undefined;
  value?: string | undefined;
  name?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IPropertyAttribute) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.propertyId = _data["propertyId"];
      this.value = _data["value"];
      this.name = _data["name"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): PropertyAttribute {
    data = typeof data === "object" ? data : {};
    let result = new PropertyAttribute();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["propertyId"] = this.propertyId;
    data["value"] = this.value;
    data["name"] = this.name;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IPropertyAttribute {
  propertyId?: string | undefined;
  value?: string | undefined;
  name?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class PropertyDisplayName implements IPropertyDisplayName {
  name?: string | undefined;
  languageCode?: string | undefined;

  constructor(data?: IPropertyDisplayName) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.languageCode = _data["languageCode"];
    }
  }

  static fromJS(data: any): PropertyDisplayName {
    data = typeof data === "object" ? data : {};
    let result = new PropertyDisplayName();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["languageCode"] = this.languageCode;
    return data;
  }
}

export interface IPropertyDisplayName {
  name?: string | undefined;
  languageCode?: string | undefined;
}

/** Represents property validation rules definition */
export class PropertyValidationRule implements IPropertyValidationRule {
  /** Uniquie value flag constrain */
  isUnique?: boolean;
  /** Down chars count border or null if no defined */
  charCountMin?: number | undefined;
  /** Upper chars count border or null if no defined */
  charCountMax?: number | undefined;
  /** Custom regular expression */
  regExp?: string | undefined;
  propertyId?: string | undefined;
  id?: string | undefined;

  constructor(data?: IPropertyValidationRule) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isUnique = _data["isUnique"];
      this.charCountMin = _data["charCountMin"];
      this.charCountMax = _data["charCountMax"];
      this.regExp = _data["regExp"];
      this.propertyId = _data["propertyId"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): PropertyValidationRule {
    data = typeof data === "object" ? data : {};
    let result = new PropertyValidationRule();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["isUnique"] = this.isUnique;
    data["charCountMin"] = this.charCountMin;
    data["charCountMax"] = this.charCountMax;
    data["regExp"] = this.regExp;
    data["propertyId"] = this.propertyId;
    data["id"] = this.id;
    return data;
  }
}

/** Represents property validation rules definition */
export interface IPropertyValidationRule {
  /** Uniquie value flag constrain */
  isUnique?: boolean;
  /** Down chars count border or null if no defined */
  charCountMin?: number | undefined;
  /** Upper chars count border or null if no defined */
  charCountMax?: number | undefined;
  /** Custom regular expression */
  regExp?: string | undefined;
  propertyId?: string | undefined;
  id?: string | undefined;
}

export class Property implements IProperty {
  /** Gets or sets a value indicating whether user can change property value. */
  isReadOnly?: boolean;
  /** Gets or sets a value indicating whether user can change property metadata or remove this property. */
  readonly isManageable?: boolean;
  /** Gets or sets a value indicating whether this instance is new. A new property should be created on server site instead of trying to update it. */
  isNew?: boolean;
  /** Gets or sets the catalog id that this product belongs to. */
  catalogId?: string | undefined;
  /** Gets or sets the category id that this product belongs to. */
  categoryId?: string | undefined;
  name?: string | undefined;
  required?: boolean;
  dictionary?: boolean;
  multivalue?: boolean;
  multilanguage?: boolean;
  /** Gets or sets a value indicating whether this VirtoCommerce.CatalogModule.Core.Model.Property is hidden. */
  hidden?: boolean;
  valueType?: PropertyValueType;
  type?: PropertyType;
  outerId?: string | undefined;
  ownerName?: string | undefined;
  values?: PropertyValue[] | undefined;
  attributes?: PropertyAttribute[] | undefined;
  displayNames?: PropertyDisplayName[] | undefined;
  validationRules?: PropertyValidationRule[] | undefined;
  validationRule?: PropertyValidationRule;
  isInherited?: boolean;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IProperty) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isReadOnly = _data["isReadOnly"];
      (<any>this).isManageable = _data["isManageable"];
      this.isNew = _data["isNew"];
      this.catalogId = _data["catalogId"];
      this.categoryId = _data["categoryId"];
      this.name = _data["name"];
      this.required = _data["required"];
      this.dictionary = _data["dictionary"];
      this.multivalue = _data["multivalue"];
      this.multilanguage = _data["multilanguage"];
      this.hidden = _data["hidden"];
      this.valueType = _data["valueType"];
      this.type = _data["type"];
      this.outerId = _data["outerId"];
      this.ownerName = _data["ownerName"];
      if (Array.isArray(_data["values"])) {
        this.values = [] as any;
        for (let item of _data["values"])
          this.values!.push(PropertyValue.fromJS(item));
      }
      if (Array.isArray(_data["attributes"])) {
        this.attributes = [] as any;
        for (let item of _data["attributes"])
          this.attributes!.push(PropertyAttribute.fromJS(item));
      }
      if (Array.isArray(_data["displayNames"])) {
        this.displayNames = [] as any;
        for (let item of _data["displayNames"])
          this.displayNames!.push(PropertyDisplayName.fromJS(item));
      }
      if (Array.isArray(_data["validationRules"])) {
        this.validationRules = [] as any;
        for (let item of _data["validationRules"])
          this.validationRules!.push(PropertyValidationRule.fromJS(item));
      }
      this.validationRule = _data["validationRule"]
        ? PropertyValidationRule.fromJS(_data["validationRule"])
        : <any>undefined;
      this.isInherited = _data["isInherited"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Property {
    data = typeof data === "object" ? data : {};
    let result = new Property();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["isReadOnly"] = this.isReadOnly;
    data["isManageable"] = this.isManageable;
    data["isNew"] = this.isNew;
    data["catalogId"] = this.catalogId;
    data["categoryId"] = this.categoryId;
    data["name"] = this.name;
    data["required"] = this.required;
    data["dictionary"] = this.dictionary;
    data["multivalue"] = this.multivalue;
    data["multilanguage"] = this.multilanguage;
    data["hidden"] = this.hidden;
    data["valueType"] = this.valueType;
    data["type"] = this.type;
    data["outerId"] = this.outerId;
    data["ownerName"] = this.ownerName;
    if (Array.isArray(this.values)) {
      data["values"] = [];
      for (let item of this.values) data["values"].push(item.toJSON());
    }
    if (Array.isArray(this.attributes)) {
      data["attributes"] = [];
      for (let item of this.attributes) data["attributes"].push(item.toJSON());
    }
    if (Array.isArray(this.displayNames)) {
      data["displayNames"] = [];
      for (let item of this.displayNames)
        data["displayNames"].push(item.toJSON());
    }
    if (Array.isArray(this.validationRules)) {
      data["validationRules"] = [];
      for (let item of this.validationRules)
        data["validationRules"].push(item.toJSON());
    }
    data["validationRule"] = this.validationRule
      ? this.validationRule.toJSON()
      : <any>undefined;
    data["isInherited"] = this.isInherited;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IProperty {
  /** Gets or sets a value indicating whether user can change property value. */
  isReadOnly?: boolean;
  /** Gets or sets a value indicating whether user can change property metadata or remove this property. */
  isManageable?: boolean;
  /** Gets or sets a value indicating whether this instance is new. A new property should be created on server site instead of trying to update it. */
  isNew?: boolean;
  /** Gets or sets the catalog id that this product belongs to. */
  catalogId?: string | undefined;
  /** Gets or sets the category id that this product belongs to. */
  categoryId?: string | undefined;
  name?: string | undefined;
  required?: boolean;
  dictionary?: boolean;
  multivalue?: boolean;
  multilanguage?: boolean;
  /** Gets or sets a value indicating whether this VirtoCommerce.CatalogModule.Core.Model.Property is hidden. */
  hidden?: boolean;
  valueType?: PropertyValueType;
  type?: PropertyType;
  outerId?: string | undefined;
  ownerName?: string | undefined;
  values?: PropertyValue[] | undefined;
  attributes?: PropertyAttribute[] | undefined;
  displayNames?: PropertyDisplayName[] | undefined;
  validationRules?: PropertyValidationRule[] | undefined;
  validationRule?: PropertyValidationRule;
  isInherited?: boolean;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class Catalog implements ICatalog {
  name?: string | undefined;
  isVirtual?: boolean;
  outerId?: string | undefined;
  defaultLanguage?: CatalogLanguage;
  languages?: CatalogLanguage[] | undefined;
  properties?: Property[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: ICatalog) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.isVirtual = _data["isVirtual"];
      this.outerId = _data["outerId"];
      this.defaultLanguage = _data["defaultLanguage"]
        ? CatalogLanguage.fromJS(_data["defaultLanguage"])
        : <any>undefined;
      if (Array.isArray(_data["languages"])) {
        this.languages = [] as any;
        for (let item of _data["languages"])
          this.languages!.push(CatalogLanguage.fromJS(item));
      }
      if (Array.isArray(_data["properties"])) {
        this.properties = [] as any;
        for (let item of _data["properties"])
          this.properties!.push(Property.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Catalog {
    data = typeof data === "object" ? data : {};
    let result = new Catalog();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["isVirtual"] = this.isVirtual;
    data["outerId"] = this.outerId;
    data["defaultLanguage"] = this.defaultLanguage
      ? this.defaultLanguage.toJSON()
      : <any>undefined;
    if (Array.isArray(this.languages)) {
      data["languages"] = [];
      for (let item of this.languages) data["languages"].push(item.toJSON());
    }
    if (Array.isArray(this.properties)) {
      data["properties"] = [];
      for (let item of this.properties) data["properties"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface ICatalog {
  name?: string | undefined;
  isVirtual?: boolean;
  outerId?: string | undefined;
  defaultLanguage?: CatalogLanguage;
  languages?: CatalogLanguage[] | undefined;
  properties?: Property[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class CatalogSearchResult implements ICatalogSearchResult {
  totalCount?: number;
  results?: Catalog[] | undefined;

  constructor(data?: ICatalogSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(Catalog.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CatalogSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new CatalogSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface ICatalogSearchResult {
  totalCount?: number;
  results?: Catalog[] | undefined;
}

export class ExcludedProperty implements IExcludedProperty {
  name?: string | undefined;
  isInherited?: boolean;

  constructor(data?: IExcludedProperty) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.isInherited = _data["isInherited"];
    }
  }

  static fromJS(data: any): ExcludedProperty {
    data = typeof data === "object" ? data : {};
    let result = new ExcludedProperty();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["isInherited"] = this.isInherited;
    return data;
  }
}

export interface IExcludedProperty {
  name?: string | undefined;
  isInherited?: boolean;
}

export class CategoryLink implements ICategoryLink {
  /** Entry identifier which this link belongs to */
  readonly entryId?: string | undefined;
  listEntryId?: string | undefined;
  /** Gets or sets the type of the list entry. E.g. "product", "category" */
  listEntryType?: string | undefined;
  /** Product order position in virtual catalog */
  priority?: number;
  catalogId?: string | undefined;
  categoryId?: string | undefined;
  category?: Category;

  constructor(data?: ICategoryLink) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).entryId = _data["entryId"];
      this.listEntryId = _data["listEntryId"];
      this.listEntryType = _data["listEntryType"];
      this.priority = _data["priority"];
      this.catalogId = _data["catalogId"];
      this.categoryId = _data["categoryId"];
      this.category = _data["category"]
        ? Category.fromJS(_data["category"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): CategoryLink {
    data = typeof data === "object" ? data : {};
    let result = new CategoryLink();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["entryId"] = this.entryId;
    data["listEntryId"] = this.listEntryId;
    data["listEntryType"] = this.listEntryType;
    data["priority"] = this.priority;
    data["catalogId"] = this.catalogId;
    data["categoryId"] = this.categoryId;
    data["category"] = this.category ? this.category.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICategoryLink {
  /** Entry identifier which this link belongs to */
  entryId?: string | undefined;
  listEntryId?: string | undefined;
  /** Gets or sets the type of the list entry. E.g. "product", "category" */
  listEntryType?: string | undefined;
  /** Product order position in virtual catalog */
  priority?: number;
  catalogId?: string | undefined;
  categoryId?: string | undefined;
  category?: Category;
}

/** Represents one outline element: catalog, category or product. */
export class OutlineItem implements IOutlineItem {
  /** Object id */
  id?: string | undefined;
  /** Object type */
  seoObjectType?: string | undefined;
  /** All SEO records for the object */
  seoInfos?: SeoInfo[] | undefined;
  /** The name of current item */
  name?: string | undefined;
  /** True when this object is linked to the virtual parent. */
  hasVirtualParent?: boolean;

  constructor(data?: IOutlineItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.seoObjectType = _data["seoObjectType"];
      if (Array.isArray(_data["seoInfos"])) {
        this.seoInfos = [] as any;
        for (let item of _data["seoInfos"])
          this.seoInfos!.push(SeoInfo.fromJS(item));
      }
      this.name = _data["name"];
      this.hasVirtualParent = _data["hasVirtualParent"];
    }
  }

  static fromJS(data: any): OutlineItem {
    data = typeof data === "object" ? data : {};
    let result = new OutlineItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["seoObjectType"] = this.seoObjectType;
    if (Array.isArray(this.seoInfos)) {
      data["seoInfos"] = [];
      for (let item of this.seoInfos) data["seoInfos"].push(item.toJSON());
    }
    data["name"] = this.name;
    data["hasVirtualParent"] = this.hasVirtualParent;
    return data;
  }
}

/** Represents one outline element: catalog, category or product. */
export interface IOutlineItem {
  /** Object id */
  id?: string | undefined;
  /** Object type */
  seoObjectType?: string | undefined;
  /** All SEO records for the object */
  seoInfos?: SeoInfo[] | undefined;
  /** The name of current item */
  name?: string | undefined;
  /** True when this object is linked to the virtual parent. */
  hasVirtualParent?: boolean;
}

/** Represents the path from the catalog to one of the child objects (product or category): catalog/parent-category1/.../parent-categoryN/object */
export class Outline implements IOutline {
  /** Outline parts */
  items?: OutlineItem[] | undefined;

  constructor(data?: IOutline) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(OutlineItem.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Outline {
    data = typeof data === "object" ? data : {};
    let result = new Outline();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }
}

/** Represents the path from the catalog to one of the child objects (product or category): catalog/parent-category1/.../parent-categoryN/object */
export interface IOutline {
  /** Outline parts */
  items?: OutlineItem[] | undefined;
}

export class Category implements ICategory {
  catalogId?: string | undefined;
  parentId?: string | undefined;
  code?: string | undefined;
  name?: string | undefined;
  /** Category outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
  readonly outline?: string | undefined;
  /** Category path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
  path?: string | undefined;
  isVirtual?: boolean;
  level?: number;
  packageType?: string | undefined;
  priority?: number;
  isActive?: boolean | undefined;
  outerId?: string | undefined;
  properties?: Property[] | undefined;
  excludedProperties?: ExcludedProperty[] | undefined;
  links?: CategoryLink[] | undefined;
  taxType?: string | undefined;
  readonly seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  /** Gets the default image */
  readonly imgSrc?: string | undefined;
  images?: Image[] | undefined;
  outlines?: Outline[] | undefined;
  /** System flag used to mark that object was inherited from other */
  readonly isInherited?: boolean;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: ICategory) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.catalogId = _data["catalogId"];
      this.parentId = _data["parentId"];
      this.code = _data["code"];
      this.name = _data["name"];
      (<any>this).outline = _data["outline"];
      this.path = _data["path"];
      this.isVirtual = _data["isVirtual"];
      this.level = _data["level"];
      this.packageType = _data["packageType"];
      this.priority = _data["priority"];
      this.isActive = _data["isActive"];
      this.outerId = _data["outerId"];
      if (Array.isArray(_data["properties"])) {
        this.properties = [] as any;
        for (let item of _data["properties"])
          this.properties!.push(Property.fromJS(item));
      }
      if (Array.isArray(_data["excludedProperties"])) {
        this.excludedProperties = [] as any;
        for (let item of _data["excludedProperties"])
          this.excludedProperties!.push(ExcludedProperty.fromJS(item));
      }
      if (Array.isArray(_data["links"])) {
        this.links = [] as any;
        for (let item of _data["links"])
          this.links!.push(CategoryLink.fromJS(item));
      }
      this.taxType = _data["taxType"];
      (<any>this).seoObjectType = _data["seoObjectType"];
      if (Array.isArray(_data["seoInfos"])) {
        this.seoInfos = [] as any;
        for (let item of _data["seoInfos"])
          this.seoInfos!.push(SeoInfo.fromJS(item));
      }
      (<any>this).imgSrc = _data["imgSrc"];
      if (Array.isArray(_data["images"])) {
        this.images = [] as any;
        for (let item of _data["images"]) this.images!.push(Image.fromJS(item));
      }
      if (Array.isArray(_data["outlines"])) {
        this.outlines = [] as any;
        for (let item of _data["outlines"])
          this.outlines!.push(Outline.fromJS(item));
      }
      (<any>this).isInherited = _data["isInherited"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Category {
    data = typeof data === "object" ? data : {};
    let result = new Category();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["catalogId"] = this.catalogId;
    data["parentId"] = this.parentId;
    data["code"] = this.code;
    data["name"] = this.name;
    data["outline"] = this.outline;
    data["path"] = this.path;
    data["isVirtual"] = this.isVirtual;
    data["level"] = this.level;
    data["packageType"] = this.packageType;
    data["priority"] = this.priority;
    data["isActive"] = this.isActive;
    data["outerId"] = this.outerId;
    if (Array.isArray(this.properties)) {
      data["properties"] = [];
      for (let item of this.properties) data["properties"].push(item.toJSON());
    }
    if (Array.isArray(this.excludedProperties)) {
      data["excludedProperties"] = [];
      for (let item of this.excludedProperties)
        data["excludedProperties"].push(item.toJSON());
    }
    if (Array.isArray(this.links)) {
      data["links"] = [];
      for (let item of this.links) data["links"].push(item.toJSON());
    }
    data["taxType"] = this.taxType;
    data["seoObjectType"] = this.seoObjectType;
    if (Array.isArray(this.seoInfos)) {
      data["seoInfos"] = [];
      for (let item of this.seoInfos) data["seoInfos"].push(item.toJSON());
    }
    data["imgSrc"] = this.imgSrc;
    if (Array.isArray(this.images)) {
      data["images"] = [];
      for (let item of this.images) data["images"].push(item.toJSON());
    }
    if (Array.isArray(this.outlines)) {
      data["outlines"] = [];
      for (let item of this.outlines) data["outlines"].push(item.toJSON());
    }
    data["isInherited"] = this.isInherited;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface ICategory {
  catalogId?: string | undefined;
  parentId?: string | undefined;
  code?: string | undefined;
  name?: string | undefined;
  /** Category outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
  outline?: string | undefined;
  /** Category path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
  path?: string | undefined;
  isVirtual?: boolean;
  level?: number;
  packageType?: string | undefined;
  priority?: number;
  isActive?: boolean | undefined;
  outerId?: string | undefined;
  properties?: Property[] | undefined;
  excludedProperties?: ExcludedProperty[] | undefined;
  links?: CategoryLink[] | undefined;
  taxType?: string | undefined;
  seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  /** Gets the default image */
  imgSrc?: string | undefined;
  images?: Image[] | undefined;
  outlines?: Outline[] | undefined;
  /** System flag used to mark that object was inherited from other */
  isInherited?: boolean;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class NumericRange implements INumericRange {
  lower?: number | undefined;
  upper?: number | undefined;
  includeLower?: boolean;
  includeUpper?: boolean;

  constructor(data?: INumericRange) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.lower = _data["lower"];
      this.upper = _data["upper"];
      this.includeLower = _data["includeLower"];
      this.includeUpper = _data["includeUpper"];
    }
  }

  static fromJS(data: any): NumericRange {
    data = typeof data === "object" ? data : {};
    let result = new NumericRange();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["lower"] = this.lower;
    data["upper"] = this.upper;
    data["includeLower"] = this.includeLower;
    data["includeUpper"] = this.includeUpper;
    return data;
  }
}

export interface INumericRange {
  lower?: number | undefined;
  upper?: number | undefined;
  includeLower?: boolean;
  includeUpper?: boolean;
}

export class GeoPoint implements IGeoPoint {
  latitude?: number;
  longitude?: number;

  constructor(data?: IGeoPoint) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.latitude = _data["latitude"];
      this.longitude = _data["longitude"];
    }
  }

  static fromJS(data: any): GeoPoint {
    data = typeof data === "object" ? data : {};
    let result = new GeoPoint();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["latitude"] = this.latitude;
    data["longitude"] = this.longitude;
    return data;
  }
}

export interface IGeoPoint {
  latitude?: number;
  longitude?: number;
}

export class GeoDistanceFilter implements IGeoDistanceFilter {
  fieldName?: string | undefined;
  location?: GeoPoint;
  distance?: number;

  constructor(data?: IGeoDistanceFilter) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fieldName = _data["fieldName"];
      this.location = _data["location"]
        ? GeoPoint.fromJS(_data["location"])
        : <any>undefined;
      this.distance = _data["distance"];
    }
  }

  static fromJS(data: any): GeoDistanceFilter {
    data = typeof data === "object" ? data : {};
    let result = new GeoDistanceFilter();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["fieldName"] = this.fieldName;
    data["location"] = this.location ? this.location.toJSON() : <any>undefined;
    data["distance"] = this.distance;
    return data;
  }
}

export interface IGeoDistanceFilter {
  fieldName?: string | undefined;
  location?: GeoPoint;
  distance?: number;
}

export class ProductIndexedSearchCriteria
  implements IProductIndexedSearchCriteria
{
  objectType?: string | undefined;
  /** Physical, Digital, etc. */
  productType?: string | undefined;
  currency?: string | undefined;
  pricelists?: string[] | undefined;
  priceRange?: NumericRange;
  /** Gets or sets the class types. */
  classTypes?: string[] | undefined;
  /** Specifies if we search for hidden products. */
  withHidden?: boolean;
  /** Include product variations in result */
  searchInVariations?: boolean;
  /** Gets or sets the start date. The date must be in UTC format as that is format indexes are stored in. */
  startDate?: Date;
  /** Gets or sets the start date from filter. Used for filtering new products. The date must be in UTC format as that is format indexes are stored in. */
  startDateFrom?: Date | undefined;
  /** Gets or sets the end date. The date must be in UTC format as that is format indexes are stored in. */
  endDate?: Date | undefined;
  /** Gets or sets a "white" list of aggregation keys that identify preconfigured aggregations, which SHOULD be calculated and returned with the search result. */
  includeAggregations?: string[] | undefined;
  /** Gets or sets a "black" list of aggregation keys that identify preconfigured aggregations, which SHOULD NOT be calculated and returned with the search result. */
  excludeAggregations?: string[] | undefined;
  geoDistanceFilter?: GeoDistanceFilter;
  /** Override base SortInfo property to support GeoSortInfo sorting types */
  readonly sortInfos?: SortInfo[] | undefined;
  storeId?: string | undefined;
  catalogId?: string | undefined;
  /** CategoryId1/CategoryId2, no catalog should be included in the outline */
  outline?: string | undefined;
  /** CategoryId1/CategoryId2, no catalog should be included in the outline */
  outlines?: string[] | undefined;
  /** Term format: name:value1,value2 */
  terms?: string[] | undefined;
  /** Assigned groups for current user. Data format: user_groups:value1,value2 */
  userGroups?: string[] | undefined;
  /** Enable fuzzy search, i.e. allow to search color:white even if color:wihte actually passed to criteria */
  isFuzzySearch?: boolean;
  /** Gets or sets the search provider specific raw search query; all other search criteria will be ignored */
  rawQuery?: string | undefined;
  /** Allows to retrieve only a specific set of fields in the result hits */
  includeFields?: string[] | undefined;
  searchPhrase?: string | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  responseGroup?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IProductIndexedSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.objectType = _data["objectType"];
      this.productType = _data["productType"];
      this.currency = _data["currency"];
      if (Array.isArray(_data["pricelists"])) {
        this.pricelists = [] as any;
        for (let item of _data["pricelists"]) this.pricelists!.push(item);
      }
      this.priceRange = _data["priceRange"]
        ? NumericRange.fromJS(_data["priceRange"])
        : <any>undefined;
      if (Array.isArray(_data["classTypes"])) {
        this.classTypes = [] as any;
        for (let item of _data["classTypes"]) this.classTypes!.push(item);
      }
      this.withHidden = _data["withHidden"];
      this.searchInVariations = _data["searchInVariations"];
      this.startDate = _data["startDate"]
        ? new Date(_data["startDate"].toString())
        : <any>undefined;
      this.startDateFrom = _data["startDateFrom"]
        ? new Date(_data["startDateFrom"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? new Date(_data["endDate"].toString())
        : <any>undefined;
      if (Array.isArray(_data["includeAggregations"])) {
        this.includeAggregations = [] as any;
        for (let item of _data["includeAggregations"])
          this.includeAggregations!.push(item);
      }
      if (Array.isArray(_data["excludeAggregations"])) {
        this.excludeAggregations = [] as any;
        for (let item of _data["excludeAggregations"])
          this.excludeAggregations!.push(item);
      }
      this.geoDistanceFilter = _data["geoDistanceFilter"]
        ? GeoDistanceFilter.fromJS(_data["geoDistanceFilter"])
        : <any>undefined;
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.storeId = _data["storeId"];
      this.catalogId = _data["catalogId"];
      this.outline = _data["outline"];
      if (Array.isArray(_data["outlines"])) {
        this.outlines = [] as any;
        for (let item of _data["outlines"]) this.outlines!.push(item);
      }
      if (Array.isArray(_data["terms"])) {
        this.terms = [] as any;
        for (let item of _data["terms"]) this.terms!.push(item);
      }
      if (Array.isArray(_data["userGroups"])) {
        this.userGroups = [] as any;
        for (let item of _data["userGroups"]) this.userGroups!.push(item);
      }
      this.isFuzzySearch = _data["isFuzzySearch"];
      this.rawQuery = _data["rawQuery"];
      if (Array.isArray(_data["includeFields"])) {
        this.includeFields = [] as any;
        for (let item of _data["includeFields"]) this.includeFields!.push(item);
      }
      this.searchPhrase = _data["searchPhrase"];
      this.keyword = _data["keyword"];
      this.responseGroup = _data["responseGroup"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): ProductIndexedSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new ProductIndexedSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["objectType"] = this.objectType;
    data["productType"] = this.productType;
    data["currency"] = this.currency;
    if (Array.isArray(this.pricelists)) {
      data["pricelists"] = [];
      for (let item of this.pricelists) data["pricelists"].push(item);
    }
    data["priceRange"] = this.priceRange
      ? this.priceRange.toJSON()
      : <any>undefined;
    if (Array.isArray(this.classTypes)) {
      data["classTypes"] = [];
      for (let item of this.classTypes) data["classTypes"].push(item);
    }
    data["withHidden"] = this.withHidden;
    data["searchInVariations"] = this.searchInVariations;
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["startDateFrom"] = this.startDateFrom
      ? this.startDateFrom.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    if (Array.isArray(this.includeAggregations)) {
      data["includeAggregations"] = [];
      for (let item of this.includeAggregations)
        data["includeAggregations"].push(item);
    }
    if (Array.isArray(this.excludeAggregations)) {
      data["excludeAggregations"] = [];
      for (let item of this.excludeAggregations)
        data["excludeAggregations"].push(item);
    }
    data["geoDistanceFilter"] = this.geoDistanceFilter
      ? this.geoDistanceFilter.toJSON()
      : <any>undefined;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["storeId"] = this.storeId;
    data["catalogId"] = this.catalogId;
    data["outline"] = this.outline;
    if (Array.isArray(this.outlines)) {
      data["outlines"] = [];
      for (let item of this.outlines) data["outlines"].push(item);
    }
    if (Array.isArray(this.terms)) {
      data["terms"] = [];
      for (let item of this.terms) data["terms"].push(item);
    }
    if (Array.isArray(this.userGroups)) {
      data["userGroups"] = [];
      for (let item of this.userGroups) data["userGroups"].push(item);
    }
    data["isFuzzySearch"] = this.isFuzzySearch;
    data["rawQuery"] = this.rawQuery;
    if (Array.isArray(this.includeFields)) {
      data["includeFields"] = [];
      for (let item of this.includeFields) data["includeFields"].push(item);
    }
    data["searchPhrase"] = this.searchPhrase;
    data["keyword"] = this.keyword;
    data["responseGroup"] = this.responseGroup;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IProductIndexedSearchCriteria {
  objectType?: string | undefined;
  /** Physical, Digital, etc. */
  productType?: string | undefined;
  currency?: string | undefined;
  pricelists?: string[] | undefined;
  priceRange?: NumericRange;
  /** Gets or sets the class types. */
  classTypes?: string[] | undefined;
  /** Specifies if we search for hidden products. */
  withHidden?: boolean;
  /** Include product variations in result */
  searchInVariations?: boolean;
  /** Gets or sets the start date. The date must be in UTC format as that is format indexes are stored in. */
  startDate?: Date;
  /** Gets or sets the start date from filter. Used for filtering new products. The date must be in UTC format as that is format indexes are stored in. */
  startDateFrom?: Date | undefined;
  /** Gets or sets the end date. The date must be in UTC format as that is format indexes are stored in. */
  endDate?: Date | undefined;
  /** Gets or sets a "white" list of aggregation keys that identify preconfigured aggregations, which SHOULD be calculated and returned with the search result. */
  includeAggregations?: string[] | undefined;
  /** Gets or sets a "black" list of aggregation keys that identify preconfigured aggregations, which SHOULD NOT be calculated and returned with the search result. */
  excludeAggregations?: string[] | undefined;
  geoDistanceFilter?: GeoDistanceFilter;
  /** Override base SortInfo property to support GeoSortInfo sorting types */
  sortInfos?: SortInfo[] | undefined;
  storeId?: string | undefined;
  catalogId?: string | undefined;
  /** CategoryId1/CategoryId2, no catalog should be included in the outline */
  outline?: string | undefined;
  /** CategoryId1/CategoryId2, no catalog should be included in the outline */
  outlines?: string[] | undefined;
  /** Term format: name:value1,value2 */
  terms?: string[] | undefined;
  /** Assigned groups for current user. Data format: user_groups:value1,value2 */
  userGroups?: string[] | undefined;
  /** Enable fuzzy search, i.e. allow to search color:white even if color:wihte actually passed to criteria */
  isFuzzySearch?: boolean;
  /** Gets or sets the search provider specific raw search query; all other search criteria will be ignored */
  rawQuery?: string | undefined;
  /** Allows to retrieve only a specific set of fields in the result hits */
  includeFields?: string[] | undefined;
  searchPhrase?: string | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  responseGroup?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  skip?: number;
  take?: number;
}

export class Asset implements IAsset {
  mimeType?: string | undefined;
  size?: number;
  readonly readableSize?: string | undefined;
  binaryData?: string | undefined;
  relativeUrl?: string | undefined;
  url?: string | undefined;
  description?: string | undefined;
  sortOrder?: number;
  /** Gets or sets the asset type identifier. */
  typeId?: string | undefined;
  /** Gets or sets the asset group name. */
  group?: string | undefined;
  /** Gets or sets the asset name. */
  name?: string | undefined;
  outerId?: string | undefined;
  /** Gets or sets the asset language. */
  languageCode?: string | undefined;
  /** System flag used to mark that object was inherited from other */
  readonly isInherited?: boolean;
  readonly seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IAsset) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.mimeType = _data["mimeType"];
      this.size = _data["size"];
      (<any>this).readableSize = _data["readableSize"];
      this.binaryData = _data["binaryData"];
      this.relativeUrl = _data["relativeUrl"];
      this.url = _data["url"];
      this.description = _data["description"];
      this.sortOrder = _data["sortOrder"];
      this.typeId = _data["typeId"];
      this.group = _data["group"];
      this.name = _data["name"];
      this.outerId = _data["outerId"];
      this.languageCode = _data["languageCode"];
      (<any>this).isInherited = _data["isInherited"];
      (<any>this).seoObjectType = _data["seoObjectType"];
      if (Array.isArray(_data["seoInfos"])) {
        this.seoInfos = [] as any;
        for (let item of _data["seoInfos"])
          this.seoInfos!.push(SeoInfo.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Asset {
    data = typeof data === "object" ? data : {};
    let result = new Asset();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["mimeType"] = this.mimeType;
    data["size"] = this.size;
    data["readableSize"] = this.readableSize;
    data["binaryData"] = this.binaryData;
    data["relativeUrl"] = this.relativeUrl;
    data["url"] = this.url;
    data["description"] = this.description;
    data["sortOrder"] = this.sortOrder;
    data["typeId"] = this.typeId;
    data["group"] = this.group;
    data["name"] = this.name;
    data["outerId"] = this.outerId;
    data["languageCode"] = this.languageCode;
    data["isInherited"] = this.isInherited;
    data["seoObjectType"] = this.seoObjectType;
    if (Array.isArray(this.seoInfos)) {
      data["seoInfos"] = [];
      for (let item of this.seoInfos) data["seoInfos"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IAsset {
  mimeType?: string | undefined;
  size?: number;
  readableSize?: string | undefined;
  binaryData?: string | undefined;
  relativeUrl?: string | undefined;
  url?: string | undefined;
  description?: string | undefined;
  sortOrder?: number;
  /** Gets or sets the asset type identifier. */
  typeId?: string | undefined;
  /** Gets or sets the asset group name. */
  group?: string | undefined;
  /** Gets or sets the asset name. */
  name?: string | undefined;
  outerId?: string | undefined;
  /** Gets or sets the asset language. */
  languageCode?: string | undefined;
  /** System flag used to mark that object was inherited from other */
  isInherited?: boolean;
  seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class EditorialReview implements IEditorialReview {
  content?: string | undefined;
  reviewType?: string | undefined;
  languageCode?: string | undefined;
  isInherited?: boolean;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IEditorialReview) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.content = _data["content"];
      this.reviewType = _data["reviewType"];
      this.languageCode = _data["languageCode"];
      this.isInherited = _data["isInherited"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): EditorialReview {
    data = typeof data === "object" ? data : {};
    let result = new EditorialReview();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["content"] = this.content;
    data["reviewType"] = this.reviewType;
    data["languageCode"] = this.languageCode;
    data["isInherited"] = this.isInherited;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IEditorialReview {
  content?: string | undefined;
  reviewType?: string | undefined;
  languageCode?: string | undefined;
  isInherited?: boolean;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class Variation implements IVariation {
  /** SKU code */
  code?: string | undefined;
  manufacturerPartNumber?: string | undefined;
  /** Global Trade Item Number (GTIN). These identifiers include UPC (in North America), EAN (in Europe), JAN (in Japan), and ISBN (for books). */
  gtin?: string | undefined;
  name?: string | undefined;
  catalogId?: string | undefined;
  categoryId?: string | undefined;
  /** Product outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
  readonly outline?: string | undefined;
  /** Product path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
  readonly path?: string | undefined;
  readonly titularItemId?: string | undefined;
  mainProductId?: string | undefined;
  isBuyable?: boolean | undefined;
  isActive?: boolean | undefined;
  trackInventory?: boolean | undefined;
  indexingDate?: Date | undefined;
  maxQuantity?: number | undefined;
  minQuantity?: number | undefined;
  /** Can be Physical, Digital or Subscription. */
  productType?: string | undefined;
  packageType?: string | undefined;
  weightUnit?: string | undefined;
  weight?: number | undefined;
  measureUnit?: string | undefined;
  height?: number | undefined;
  length?: number | undefined;
  width?: number | undefined;
  enableReview?: boolean | undefined;
  /** re-downloads limit */
  maxNumberOfDownload?: number | undefined;
  downloadExpiration?: Date | undefined;
  /** DownloadType: {Standard Product, Software, Music} */
  downloadType?: string | undefined;
  hasUserAgreement?: boolean | undefined;
  shippingType?: string | undefined;
  taxType?: string | undefined;
  vendor?: string | undefined;
  startDate?: Date;
  endDate?: Date | undefined;
  /** Product order position in catalog */
  priority?: number;
  outerId?: string | undefined;
  properties?: Property[] | undefined;
  excludedProperties?: ExcludedProperty[] | undefined;
  propertyValues?: PropertyValue[] | undefined;
  /** Gets the default image for the product. */
  readonly imgSrc?: string | undefined;
  images?: Image[] | undefined;
  assets?: Asset[] | undefined;
  links?: CategoryLink[] | undefined;
  variations?: Variation[] | undefined;
  /** Each descendant type should override this property to use other object type for seo records */
  readonly seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  reviews?: EditorialReview[] | undefined;
  associations?: ProductAssociation[] | undefined;
  referencedAssociations?: ProductAssociation[] | undefined;
  outlines?: Outline[] | undefined;
  /** System flag used to mark that object was inherited from other */
  readonly isInherited?: boolean;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IVariation) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.code = _data["code"];
      this.manufacturerPartNumber = _data["manufacturerPartNumber"];
      this.gtin = _data["gtin"];
      this.name = _data["name"];
      this.catalogId = _data["catalogId"];
      this.categoryId = _data["categoryId"];
      (<any>this).outline = _data["outline"];
      (<any>this).path = _data["path"];
      (<any>this).titularItemId = _data["titularItemId"];
      this.mainProductId = _data["mainProductId"];
      this.isBuyable = _data["isBuyable"];
      this.isActive = _data["isActive"];
      this.trackInventory = _data["trackInventory"];
      this.indexingDate = _data["indexingDate"]
        ? new Date(_data["indexingDate"].toString())
        : <any>undefined;
      this.maxQuantity = _data["maxQuantity"];
      this.minQuantity = _data["minQuantity"];
      this.productType = _data["productType"];
      this.packageType = _data["packageType"];
      this.weightUnit = _data["weightUnit"];
      this.weight = _data["weight"];
      this.measureUnit = _data["measureUnit"];
      this.height = _data["height"];
      this.length = _data["length"];
      this.width = _data["width"];
      this.enableReview = _data["enableReview"];
      this.maxNumberOfDownload = _data["maxNumberOfDownload"];
      this.downloadExpiration = _data["downloadExpiration"]
        ? new Date(_data["downloadExpiration"].toString())
        : <any>undefined;
      this.downloadType = _data["downloadType"];
      this.hasUserAgreement = _data["hasUserAgreement"];
      this.shippingType = _data["shippingType"];
      this.taxType = _data["taxType"];
      this.vendor = _data["vendor"];
      this.startDate = _data["startDate"]
        ? new Date(_data["startDate"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? new Date(_data["endDate"].toString())
        : <any>undefined;
      this.priority = _data["priority"];
      this.outerId = _data["outerId"];
      if (Array.isArray(_data["properties"])) {
        this.properties = [] as any;
        for (let item of _data["properties"])
          this.properties!.push(Property.fromJS(item));
      }
      if (Array.isArray(_data["excludedProperties"])) {
        this.excludedProperties = [] as any;
        for (let item of _data["excludedProperties"])
          this.excludedProperties!.push(ExcludedProperty.fromJS(item));
      }
      if (Array.isArray(_data["propertyValues"])) {
        this.propertyValues = [] as any;
        for (let item of _data["propertyValues"])
          this.propertyValues!.push(PropertyValue.fromJS(item));
      }
      (<any>this).imgSrc = _data["imgSrc"];
      if (Array.isArray(_data["images"])) {
        this.images = [] as any;
        for (let item of _data["images"]) this.images!.push(Image.fromJS(item));
      }
      if (Array.isArray(_data["assets"])) {
        this.assets = [] as any;
        for (let item of _data["assets"]) this.assets!.push(Asset.fromJS(item));
      }
      if (Array.isArray(_data["links"])) {
        this.links = [] as any;
        for (let item of _data["links"])
          this.links!.push(CategoryLink.fromJS(item));
      }
      if (Array.isArray(_data["variations"])) {
        this.variations = [] as any;
        for (let item of _data["variations"])
          this.variations!.push(Variation.fromJS(item));
      }
      (<any>this).seoObjectType = _data["seoObjectType"];
      if (Array.isArray(_data["seoInfos"])) {
        this.seoInfos = [] as any;
        for (let item of _data["seoInfos"])
          this.seoInfos!.push(SeoInfo.fromJS(item));
      }
      if (Array.isArray(_data["reviews"])) {
        this.reviews = [] as any;
        for (let item of _data["reviews"])
          this.reviews!.push(EditorialReview.fromJS(item));
      }
      if (Array.isArray(_data["associations"])) {
        this.associations = [] as any;
        for (let item of _data["associations"])
          this.associations!.push(ProductAssociation.fromJS(item));
      }
      if (Array.isArray(_data["referencedAssociations"])) {
        this.referencedAssociations = [] as any;
        for (let item of _data["referencedAssociations"])
          this.referencedAssociations!.push(ProductAssociation.fromJS(item));
      }
      if (Array.isArray(_data["outlines"])) {
        this.outlines = [] as any;
        for (let item of _data["outlines"])
          this.outlines!.push(Outline.fromJS(item));
      }
      (<any>this).isInherited = _data["isInherited"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Variation {
    data = typeof data === "object" ? data : {};
    let result = new Variation();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["code"] = this.code;
    data["manufacturerPartNumber"] = this.manufacturerPartNumber;
    data["gtin"] = this.gtin;
    data["name"] = this.name;
    data["catalogId"] = this.catalogId;
    data["categoryId"] = this.categoryId;
    data["outline"] = this.outline;
    data["path"] = this.path;
    data["titularItemId"] = this.titularItemId;
    data["mainProductId"] = this.mainProductId;
    data["isBuyable"] = this.isBuyable;
    data["isActive"] = this.isActive;
    data["trackInventory"] = this.trackInventory;
    data["indexingDate"] = this.indexingDate
      ? this.indexingDate.toISOString()
      : <any>undefined;
    data["maxQuantity"] = this.maxQuantity;
    data["minQuantity"] = this.minQuantity;
    data["productType"] = this.productType;
    data["packageType"] = this.packageType;
    data["weightUnit"] = this.weightUnit;
    data["weight"] = this.weight;
    data["measureUnit"] = this.measureUnit;
    data["height"] = this.height;
    data["length"] = this.length;
    data["width"] = this.width;
    data["enableReview"] = this.enableReview;
    data["maxNumberOfDownload"] = this.maxNumberOfDownload;
    data["downloadExpiration"] = this.downloadExpiration
      ? this.downloadExpiration.toISOString()
      : <any>undefined;
    data["downloadType"] = this.downloadType;
    data["hasUserAgreement"] = this.hasUserAgreement;
    data["shippingType"] = this.shippingType;
    data["taxType"] = this.taxType;
    data["vendor"] = this.vendor;
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    data["priority"] = this.priority;
    data["outerId"] = this.outerId;
    if (Array.isArray(this.properties)) {
      data["properties"] = [];
      for (let item of this.properties) data["properties"].push(item.toJSON());
    }
    if (Array.isArray(this.excludedProperties)) {
      data["excludedProperties"] = [];
      for (let item of this.excludedProperties)
        data["excludedProperties"].push(item.toJSON());
    }
    if (Array.isArray(this.propertyValues)) {
      data["propertyValues"] = [];
      for (let item of this.propertyValues)
        data["propertyValues"].push(item.toJSON());
    }
    data["imgSrc"] = this.imgSrc;
    if (Array.isArray(this.images)) {
      data["images"] = [];
      for (let item of this.images) data["images"].push(item.toJSON());
    }
    if (Array.isArray(this.assets)) {
      data["assets"] = [];
      for (let item of this.assets) data["assets"].push(item.toJSON());
    }
    if (Array.isArray(this.links)) {
      data["links"] = [];
      for (let item of this.links) data["links"].push(item.toJSON());
    }
    if (Array.isArray(this.variations)) {
      data["variations"] = [];
      for (let item of this.variations) data["variations"].push(item.toJSON());
    }
    data["seoObjectType"] = this.seoObjectType;
    if (Array.isArray(this.seoInfos)) {
      data["seoInfos"] = [];
      for (let item of this.seoInfos) data["seoInfos"].push(item.toJSON());
    }
    if (Array.isArray(this.reviews)) {
      data["reviews"] = [];
      for (let item of this.reviews) data["reviews"].push(item.toJSON());
    }
    if (Array.isArray(this.associations)) {
      data["associations"] = [];
      for (let item of this.associations)
        data["associations"].push(item.toJSON());
    }
    if (Array.isArray(this.referencedAssociations)) {
      data["referencedAssociations"] = [];
      for (let item of this.referencedAssociations)
        data["referencedAssociations"].push(item.toJSON());
    }
    if (Array.isArray(this.outlines)) {
      data["outlines"] = [];
      for (let item of this.outlines) data["outlines"].push(item.toJSON());
    }
    data["isInherited"] = this.isInherited;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IVariation {
  /** SKU code */
  code?: string | undefined;
  manufacturerPartNumber?: string | undefined;
  /** Global Trade Item Number (GTIN). These identifiers include UPC (in North America), EAN (in Europe), JAN (in Japan), and ISBN (for books). */
  gtin?: string | undefined;
  name?: string | undefined;
  catalogId?: string | undefined;
  categoryId?: string | undefined;
  /** Product outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
  outline?: string | undefined;
  /** Product path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
  path?: string | undefined;
  titularItemId?: string | undefined;
  mainProductId?: string | undefined;
  isBuyable?: boolean | undefined;
  isActive?: boolean | undefined;
  trackInventory?: boolean | undefined;
  indexingDate?: Date | undefined;
  maxQuantity?: number | undefined;
  minQuantity?: number | undefined;
  /** Can be Physical, Digital or Subscription. */
  productType?: string | undefined;
  packageType?: string | undefined;
  weightUnit?: string | undefined;
  weight?: number | undefined;
  measureUnit?: string | undefined;
  height?: number | undefined;
  length?: number | undefined;
  width?: number | undefined;
  enableReview?: boolean | undefined;
  /** re-downloads limit */
  maxNumberOfDownload?: number | undefined;
  downloadExpiration?: Date | undefined;
  /** DownloadType: {Standard Product, Software, Music} */
  downloadType?: string | undefined;
  hasUserAgreement?: boolean | undefined;
  shippingType?: string | undefined;
  taxType?: string | undefined;
  vendor?: string | undefined;
  startDate?: Date;
  endDate?: Date | undefined;
  /** Product order position in catalog */
  priority?: number;
  outerId?: string | undefined;
  properties?: Property[] | undefined;
  excludedProperties?: ExcludedProperty[] | undefined;
  propertyValues?: PropertyValue[] | undefined;
  /** Gets the default image for the product. */
  imgSrc?: string | undefined;
  images?: Image[] | undefined;
  assets?: Asset[] | undefined;
  links?: CategoryLink[] | undefined;
  variations?: Variation[] | undefined;
  /** Each descendant type should override this property to use other object type for seo records */
  seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  reviews?: EditorialReview[] | undefined;
  associations?: ProductAssociation[] | undefined;
  referencedAssociations?: ProductAssociation[] | undefined;
  outlines?: Outline[] | undefined;
  /** System flag used to mark that object was inherited from other */
  isInherited?: boolean;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class CatalogProduct implements ICatalogProduct {
  /** SKU code */
  code?: string | undefined;
  manufacturerPartNumber?: string | undefined;
  /** Global Trade Item Number (GTIN). These identifiers include UPC (in North America), EAN (in Europe), JAN (in Japan), and ISBN (for books). */
  gtin?: string | undefined;
  name?: string | undefined;
  catalogId?: string | undefined;
  categoryId?: string | undefined;
  /** Product outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
  readonly outline?: string | undefined;
  /** Product path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
  readonly path?: string | undefined;
  readonly titularItemId?: string | undefined;
  mainProductId?: string | undefined;
  isBuyable?: boolean | undefined;
  isActive?: boolean | undefined;
  trackInventory?: boolean | undefined;
  indexingDate?: Date | undefined;
  maxQuantity?: number | undefined;
  minQuantity?: number | undefined;
  /** Can be Physical, Digital or Subscription. */
  productType?: string | undefined;
  packageType?: string | undefined;
  weightUnit?: string | undefined;
  weight?: number | undefined;
  measureUnit?: string | undefined;
  height?: number | undefined;
  length?: number | undefined;
  width?: number | undefined;
  enableReview?: boolean | undefined;
  /** re-downloads limit */
  maxNumberOfDownload?: number | undefined;
  downloadExpiration?: Date | undefined;
  /** DownloadType: {Standard Product, Software, Music} */
  downloadType?: string | undefined;
  hasUserAgreement?: boolean | undefined;
  shippingType?: string | undefined;
  taxType?: string | undefined;
  vendor?: string | undefined;
  startDate?: Date;
  endDate?: Date | undefined;
  /** Product order position in catalog */
  priority?: number;
  outerId?: string | undefined;
  properties?: Property[] | undefined;
  excludedProperties?: ExcludedProperty[] | undefined;
  propertyValues?: PropertyValue[] | undefined;
  /** Gets the default image for the product. */
  readonly imgSrc?: string | undefined;
  images?: Image[] | undefined;
  assets?: Asset[] | undefined;
  links?: CategoryLink[] | undefined;
  variations?: Variation[] | undefined;
  /** Each descendant type should override this property to use other object type for seo records */
  readonly seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  reviews?: EditorialReview[] | undefined;
  associations?: ProductAssociation[] | undefined;
  referencedAssociations?: ProductAssociation[] | undefined;
  outlines?: Outline[] | undefined;
  /** System flag used to mark that object was inherited from other */
  readonly isInherited?: boolean;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: ICatalogProduct) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.code = _data["code"];
      this.manufacturerPartNumber = _data["manufacturerPartNumber"];
      this.gtin = _data["gtin"];
      this.name = _data["name"];
      this.catalogId = _data["catalogId"];
      this.categoryId = _data["categoryId"];
      (<any>this).outline = _data["outline"];
      (<any>this).path = _data["path"];
      (<any>this).titularItemId = _data["titularItemId"];
      this.mainProductId = _data["mainProductId"];
      this.isBuyable = _data["isBuyable"];
      this.isActive = _data["isActive"];
      this.trackInventory = _data["trackInventory"];
      this.indexingDate = _data["indexingDate"]
        ? new Date(_data["indexingDate"].toString())
        : <any>undefined;
      this.maxQuantity = _data["maxQuantity"];
      this.minQuantity = _data["minQuantity"];
      this.productType = _data["productType"];
      this.packageType = _data["packageType"];
      this.weightUnit = _data["weightUnit"];
      this.weight = _data["weight"];
      this.measureUnit = _data["measureUnit"];
      this.height = _data["height"];
      this.length = _data["length"];
      this.width = _data["width"];
      this.enableReview = _data["enableReview"];
      this.maxNumberOfDownload = _data["maxNumberOfDownload"];
      this.downloadExpiration = _data["downloadExpiration"]
        ? new Date(_data["downloadExpiration"].toString())
        : <any>undefined;
      this.downloadType = _data["downloadType"];
      this.hasUserAgreement = _data["hasUserAgreement"];
      this.shippingType = _data["shippingType"];
      this.taxType = _data["taxType"];
      this.vendor = _data["vendor"];
      this.startDate = _data["startDate"]
        ? new Date(_data["startDate"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? new Date(_data["endDate"].toString())
        : <any>undefined;
      this.priority = _data["priority"];
      this.outerId = _data["outerId"];
      if (Array.isArray(_data["properties"])) {
        this.properties = [] as any;
        for (let item of _data["properties"])
          this.properties!.push(Property.fromJS(item));
      }
      if (Array.isArray(_data["excludedProperties"])) {
        this.excludedProperties = [] as any;
        for (let item of _data["excludedProperties"])
          this.excludedProperties!.push(ExcludedProperty.fromJS(item));
      }
      if (Array.isArray(_data["propertyValues"])) {
        this.propertyValues = [] as any;
        for (let item of _data["propertyValues"])
          this.propertyValues!.push(PropertyValue.fromJS(item));
      }
      (<any>this).imgSrc = _data["imgSrc"];
      if (Array.isArray(_data["images"])) {
        this.images = [] as any;
        for (let item of _data["images"]) this.images!.push(Image.fromJS(item));
      }
      if (Array.isArray(_data["assets"])) {
        this.assets = [] as any;
        for (let item of _data["assets"]) this.assets!.push(Asset.fromJS(item));
      }
      if (Array.isArray(_data["links"])) {
        this.links = [] as any;
        for (let item of _data["links"])
          this.links!.push(CategoryLink.fromJS(item));
      }
      if (Array.isArray(_data["variations"])) {
        this.variations = [] as any;
        for (let item of _data["variations"])
          this.variations!.push(Variation.fromJS(item));
      }
      (<any>this).seoObjectType = _data["seoObjectType"];
      if (Array.isArray(_data["seoInfos"])) {
        this.seoInfos = [] as any;
        for (let item of _data["seoInfos"])
          this.seoInfos!.push(SeoInfo.fromJS(item));
      }
      if (Array.isArray(_data["reviews"])) {
        this.reviews = [] as any;
        for (let item of _data["reviews"])
          this.reviews!.push(EditorialReview.fromJS(item));
      }
      if (Array.isArray(_data["associations"])) {
        this.associations = [] as any;
        for (let item of _data["associations"])
          this.associations!.push(ProductAssociation.fromJS(item));
      }
      if (Array.isArray(_data["referencedAssociations"])) {
        this.referencedAssociations = [] as any;
        for (let item of _data["referencedAssociations"])
          this.referencedAssociations!.push(ProductAssociation.fromJS(item));
      }
      if (Array.isArray(_data["outlines"])) {
        this.outlines = [] as any;
        for (let item of _data["outlines"])
          this.outlines!.push(Outline.fromJS(item));
      }
      (<any>this).isInherited = _data["isInherited"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): CatalogProduct {
    data = typeof data === "object" ? data : {};
    let result = new CatalogProduct();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["code"] = this.code;
    data["manufacturerPartNumber"] = this.manufacturerPartNumber;
    data["gtin"] = this.gtin;
    data["name"] = this.name;
    data["catalogId"] = this.catalogId;
    data["categoryId"] = this.categoryId;
    data["outline"] = this.outline;
    data["path"] = this.path;
    data["titularItemId"] = this.titularItemId;
    data["mainProductId"] = this.mainProductId;
    data["isBuyable"] = this.isBuyable;
    data["isActive"] = this.isActive;
    data["trackInventory"] = this.trackInventory;
    data["indexingDate"] = this.indexingDate
      ? this.indexingDate.toISOString()
      : <any>undefined;
    data["maxQuantity"] = this.maxQuantity;
    data["minQuantity"] = this.minQuantity;
    data["productType"] = this.productType;
    data["packageType"] = this.packageType;
    data["weightUnit"] = this.weightUnit;
    data["weight"] = this.weight;
    data["measureUnit"] = this.measureUnit;
    data["height"] = this.height;
    data["length"] = this.length;
    data["width"] = this.width;
    data["enableReview"] = this.enableReview;
    data["maxNumberOfDownload"] = this.maxNumberOfDownload;
    data["downloadExpiration"] = this.downloadExpiration
      ? this.downloadExpiration.toISOString()
      : <any>undefined;
    data["downloadType"] = this.downloadType;
    data["hasUserAgreement"] = this.hasUserAgreement;
    data["shippingType"] = this.shippingType;
    data["taxType"] = this.taxType;
    data["vendor"] = this.vendor;
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    data["priority"] = this.priority;
    data["outerId"] = this.outerId;
    if (Array.isArray(this.properties)) {
      data["properties"] = [];
      for (let item of this.properties) data["properties"].push(item.toJSON());
    }
    if (Array.isArray(this.excludedProperties)) {
      data["excludedProperties"] = [];
      for (let item of this.excludedProperties)
        data["excludedProperties"].push(item.toJSON());
    }
    if (Array.isArray(this.propertyValues)) {
      data["propertyValues"] = [];
      for (let item of this.propertyValues)
        data["propertyValues"].push(item.toJSON());
    }
    data["imgSrc"] = this.imgSrc;
    if (Array.isArray(this.images)) {
      data["images"] = [];
      for (let item of this.images) data["images"].push(item.toJSON());
    }
    if (Array.isArray(this.assets)) {
      data["assets"] = [];
      for (let item of this.assets) data["assets"].push(item.toJSON());
    }
    if (Array.isArray(this.links)) {
      data["links"] = [];
      for (let item of this.links) data["links"].push(item.toJSON());
    }
    if (Array.isArray(this.variations)) {
      data["variations"] = [];
      for (let item of this.variations) data["variations"].push(item.toJSON());
    }
    data["seoObjectType"] = this.seoObjectType;
    if (Array.isArray(this.seoInfos)) {
      data["seoInfos"] = [];
      for (let item of this.seoInfos) data["seoInfos"].push(item.toJSON());
    }
    if (Array.isArray(this.reviews)) {
      data["reviews"] = [];
      for (let item of this.reviews) data["reviews"].push(item.toJSON());
    }
    if (Array.isArray(this.associations)) {
      data["associations"] = [];
      for (let item of this.associations)
        data["associations"].push(item.toJSON());
    }
    if (Array.isArray(this.referencedAssociations)) {
      data["referencedAssociations"] = [];
      for (let item of this.referencedAssociations)
        data["referencedAssociations"].push(item.toJSON());
    }
    if (Array.isArray(this.outlines)) {
      data["outlines"] = [];
      for (let item of this.outlines) data["outlines"].push(item.toJSON());
    }
    data["isInherited"] = this.isInherited;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface ICatalogProduct {
  /** SKU code */
  code?: string | undefined;
  manufacturerPartNumber?: string | undefined;
  /** Global Trade Item Number (GTIN). These identifiers include UPC (in North America), EAN (in Europe), JAN (in Japan), and ISBN (for books). */
  gtin?: string | undefined;
  name?: string | undefined;
  catalogId?: string | undefined;
  categoryId?: string | undefined;
  /** Product outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
  outline?: string | undefined;
  /** Product path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
  path?: string | undefined;
  titularItemId?: string | undefined;
  mainProductId?: string | undefined;
  isBuyable?: boolean | undefined;
  isActive?: boolean | undefined;
  trackInventory?: boolean | undefined;
  indexingDate?: Date | undefined;
  maxQuantity?: number | undefined;
  minQuantity?: number | undefined;
  /** Can be Physical, Digital or Subscription. */
  productType?: string | undefined;
  packageType?: string | undefined;
  weightUnit?: string | undefined;
  weight?: number | undefined;
  measureUnit?: string | undefined;
  height?: number | undefined;
  length?: number | undefined;
  width?: number | undefined;
  enableReview?: boolean | undefined;
  /** re-downloads limit */
  maxNumberOfDownload?: number | undefined;
  downloadExpiration?: Date | undefined;
  /** DownloadType: {Standard Product, Software, Music} */
  downloadType?: string | undefined;
  hasUserAgreement?: boolean | undefined;
  shippingType?: string | undefined;
  taxType?: string | undefined;
  vendor?: string | undefined;
  startDate?: Date;
  endDate?: Date | undefined;
  /** Product order position in catalog */
  priority?: number;
  outerId?: string | undefined;
  properties?: Property[] | undefined;
  excludedProperties?: ExcludedProperty[] | undefined;
  propertyValues?: PropertyValue[] | undefined;
  /** Gets the default image for the product. */
  imgSrc?: string | undefined;
  images?: Image[] | undefined;
  assets?: Asset[] | undefined;
  links?: CategoryLink[] | undefined;
  variations?: Variation[] | undefined;
  /** Each descendant type should override this property to use other object type for seo records */
  seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  reviews?: EditorialReview[] | undefined;
  associations?: ProductAssociation[] | undefined;
  referencedAssociations?: ProductAssociation[] | undefined;
  outlines?: Outline[] | undefined;
  /** System flag used to mark that object was inherited from other */
  isInherited?: boolean;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class AggregationLabel implements IAggregationLabel {
  language?: string | undefined;
  label?: string | undefined;

  constructor(data?: IAggregationLabel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.language = _data["language"];
      this.label = _data["label"];
    }
  }

  static fromJS(data: any): AggregationLabel {
    data = typeof data === "object" ? data : {};
    let result = new AggregationLabel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["language"] = this.language;
    data["label"] = this.label;
    return data;
  }
}

export interface IAggregationLabel {
  language?: string | undefined;
  label?: string | undefined;
}

export class AggregationItem implements IAggregationItem {
  /** Gets or sets the aggregation item value */
  value?: any | undefined;
  /** Gets or sets the aggregation item count */
  count?: number;
  /** Gets or sets the flag for aggregation item is applied */
  isApplied?: boolean;
  /** Gets or sets the collection of the aggregation item labels */
  labels?: AggregationLabel[] | undefined;
  /** Gets or sets the request lower bound for range aggregation value */
  requestedLowerBound?: string | undefined;
  /** Gets or sets the request lower bound for range aggregation value */
  requestedUpperBound?: string | undefined;

  constructor(data?: IAggregationItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data["value"];
      this.count = _data["count"];
      this.isApplied = _data["isApplied"];
      if (Array.isArray(_data["labels"])) {
        this.labels = [] as any;
        for (let item of _data["labels"])
          this.labels!.push(AggregationLabel.fromJS(item));
      }
      this.requestedLowerBound = _data["requestedLowerBound"];
      this.requestedUpperBound = _data["requestedUpperBound"];
    }
  }

  static fromJS(data: any): AggregationItem {
    data = typeof data === "object" ? data : {};
    let result = new AggregationItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["value"] = this.value;
    data["count"] = this.count;
    data["isApplied"] = this.isApplied;
    if (Array.isArray(this.labels)) {
      data["labels"] = [];
      for (let item of this.labels) data["labels"].push(item.toJSON());
    }
    data["requestedLowerBound"] = this.requestedLowerBound;
    data["requestedUpperBound"] = this.requestedUpperBound;
    return data;
  }
}

export interface IAggregationItem {
  /** Gets or sets the aggregation item value */
  value?: any | undefined;
  /** Gets or sets the aggregation item count */
  count?: number;
  /** Gets or sets the flag for aggregation item is applied */
  isApplied?: boolean;
  /** Gets or sets the collection of the aggregation item labels */
  labels?: AggregationLabel[] | undefined;
  /** Gets or sets the request lower bound for range aggregation value */
  requestedLowerBound?: string | undefined;
  /** Gets or sets the request lower bound for range aggregation value */
  requestedUpperBound?: string | undefined;
}

export class Aggregation implements IAggregation {
  /** Gets or sets the value of the aggregation type */
  aggregationType?: string | undefined;
  /** Gets or sets the value of the aggregation field */
  field?: string | undefined;
  /** Gets or sets the collection of the aggregation labels */
  labels?: AggregationLabel[] | undefined;
  /** Gets or sets the collection of the aggregation items */
  items?: AggregationItem[] | undefined;

  constructor(data?: IAggregation) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.aggregationType = _data["aggregationType"];
      this.field = _data["field"];
      if (Array.isArray(_data["labels"])) {
        this.labels = [] as any;
        for (let item of _data["labels"])
          this.labels!.push(AggregationLabel.fromJS(item));
      }
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(AggregationItem.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Aggregation {
    data = typeof data === "object" ? data : {};
    let result = new Aggregation();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["aggregationType"] = this.aggregationType;
    data["field"] = this.field;
    if (Array.isArray(this.labels)) {
      data["labels"] = [];
      for (let item of this.labels) data["labels"].push(item.toJSON());
    }
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }
}

export interface IAggregation {
  /** Gets or sets the value of the aggregation type */
  aggregationType?: string | undefined;
  /** Gets or sets the value of the aggregation field */
  field?: string | undefined;
  /** Gets or sets the collection of the aggregation labels */
  labels?: AggregationLabel[] | undefined;
  /** Gets or sets the collection of the aggregation items */
  items?: AggregationItem[] | undefined;
}

export class ProductIndexedSearchResult implements IProductIndexedSearchResult {
  totalCount?: number;
  items?: CatalogProduct[] | undefined;
  aggregations?: Aggregation[] | undefined;

  constructor(data?: IProductIndexedSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(CatalogProduct.fromJS(item));
      }
      if (Array.isArray(_data["aggregations"])) {
        this.aggregations = [] as any;
        for (let item of _data["aggregations"])
          this.aggregations!.push(Aggregation.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ProductIndexedSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new ProductIndexedSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    if (Array.isArray(this.aggregations)) {
      data["aggregations"] = [];
      for (let item of this.aggregations)
        data["aggregations"].push(item.toJSON());
    }
    return data;
  }
}

export interface IProductIndexedSearchResult {
  totalCount?: number;
  items?: CatalogProduct[] | undefined;
  aggregations?: Aggregation[] | undefined;
}

export class CategoryIndexedSearchCriteria
  implements ICategoryIndexedSearchCriteria
{
  objectType?: string | undefined;
  storeId?: string | undefined;
  catalogId?: string | undefined;
  /** CategoryId1/CategoryId2, no catalog should be included in the outline */
  outline?: string | undefined;
  /** CategoryId1/CategoryId2, no catalog should be included in the outline */
  outlines?: string[] | undefined;
  /** Term format: name:value1,value2 */
  terms?: string[] | undefined;
  /** Assigned groups for current user. Data format: user_groups:value1,value2 */
  userGroups?: string[] | undefined;
  /** Enable fuzzy search, i.e. allow to search color:white even if color:wihte actually passed to criteria */
  isFuzzySearch?: boolean;
  /** Gets or sets the search provider specific raw search query; all other search criteria will be ignored */
  rawQuery?: string | undefined;
  /** Allows to retrieve only a specific set of fields in the result hits */
  includeFields?: string[] | undefined;
  searchPhrase?: string | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  responseGroup?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: ICategoryIndexedSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.objectType = _data["objectType"];
      this.storeId = _data["storeId"];
      this.catalogId = _data["catalogId"];
      this.outline = _data["outline"];
      if (Array.isArray(_data["outlines"])) {
        this.outlines = [] as any;
        for (let item of _data["outlines"]) this.outlines!.push(item);
      }
      if (Array.isArray(_data["terms"])) {
        this.terms = [] as any;
        for (let item of _data["terms"]) this.terms!.push(item);
      }
      if (Array.isArray(_data["userGroups"])) {
        this.userGroups = [] as any;
        for (let item of _data["userGroups"]) this.userGroups!.push(item);
      }
      this.isFuzzySearch = _data["isFuzzySearch"];
      this.rawQuery = _data["rawQuery"];
      if (Array.isArray(_data["includeFields"])) {
        this.includeFields = [] as any;
        for (let item of _data["includeFields"]) this.includeFields!.push(item);
      }
      this.searchPhrase = _data["searchPhrase"];
      this.keyword = _data["keyword"];
      this.responseGroup = _data["responseGroup"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): CategoryIndexedSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new CategoryIndexedSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["objectType"] = this.objectType;
    data["storeId"] = this.storeId;
    data["catalogId"] = this.catalogId;
    data["outline"] = this.outline;
    if (Array.isArray(this.outlines)) {
      data["outlines"] = [];
      for (let item of this.outlines) data["outlines"].push(item);
    }
    if (Array.isArray(this.terms)) {
      data["terms"] = [];
      for (let item of this.terms) data["terms"].push(item);
    }
    if (Array.isArray(this.userGroups)) {
      data["userGroups"] = [];
      for (let item of this.userGroups) data["userGroups"].push(item);
    }
    data["isFuzzySearch"] = this.isFuzzySearch;
    data["rawQuery"] = this.rawQuery;
    if (Array.isArray(this.includeFields)) {
      data["includeFields"] = [];
      for (let item of this.includeFields) data["includeFields"].push(item);
    }
    data["searchPhrase"] = this.searchPhrase;
    data["keyword"] = this.keyword;
    data["responseGroup"] = this.responseGroup;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface ICategoryIndexedSearchCriteria {
  objectType?: string | undefined;
  storeId?: string | undefined;
  catalogId?: string | undefined;
  /** CategoryId1/CategoryId2, no catalog should be included in the outline */
  outline?: string | undefined;
  /** CategoryId1/CategoryId2, no catalog should be included in the outline */
  outlines?: string[] | undefined;
  /** Term format: name:value1,value2 */
  terms?: string[] | undefined;
  /** Assigned groups for current user. Data format: user_groups:value1,value2 */
  userGroups?: string[] | undefined;
  /** Enable fuzzy search, i.e. allow to search color:white even if color:wihte actually passed to criteria */
  isFuzzySearch?: boolean;
  /** Gets or sets the search provider specific raw search query; all other search criteria will be ignored */
  rawQuery?: string | undefined;
  /** Allows to retrieve only a specific set of fields in the result hits */
  includeFields?: string[] | undefined;
  searchPhrase?: string | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  responseGroup?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class CategoryIndexedSearchResult
  implements ICategoryIndexedSearchResult
{
  totalCount?: number;
  items?: Category[] | undefined;
  aggregations?: Aggregation[] | undefined;

  constructor(data?: ICategoryIndexedSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(Category.fromJS(item));
      }
      if (Array.isArray(_data["aggregations"])) {
        this.aggregations = [] as any;
        for (let item of _data["aggregations"])
          this.aggregations!.push(Aggregation.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CategoryIndexedSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new CategoryIndexedSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    if (Array.isArray(this.aggregations)) {
      data["aggregations"] = [];
      for (let item of this.aggregations)
        data["aggregations"].push(item.toJSON());
    }
    return data;
  }
}

export interface ICategoryIndexedSearchResult {
  totalCount?: number;
  items?: Category[] | undefined;
  aggregations?: Aggregation[] | undefined;
}

export class CatalogListEntrySearchCriteria
  implements ICatalogListEntrySearchCriteria
{
  code?: string | undefined;
  /** Search by vendor */
  vendorId?: string | undefined;
  vendorIds?: string[] | undefined;
  /** Search product with specified type */
  productType?: string | undefined;
  productTypes?: string[] | undefined;
  /** Exclude a specified product type from the search */
  excludeProductType?: string | undefined;
  excludeProductTypes?: string[] | undefined;
  withHidden?: boolean;
  hideDirectLinkedCategories?: boolean;
  /** Search within variations of specified main product */
  mainProductId?: string | undefined;
  /** Search  in all children categories for specified catalog or categories */
  searchInChildren?: boolean;
  /** Also search in variations */
  searchInVariations?: boolean;
  onlyBuyable?: boolean | undefined;
  onlyWithTrackingInventory?: boolean | undefined;
  catalogId?: string | undefined;
  catalogIds?: string[] | undefined;
  categoryId?: string | undefined;
  categoryIds?: string[] | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: ICatalogListEntrySearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.code = _data["code"];
      this.vendorId = _data["vendorId"];
      if (Array.isArray(_data["vendorIds"])) {
        this.vendorIds = [] as any;
        for (let item of _data["vendorIds"]) this.vendorIds!.push(item);
      }
      this.productType = _data["productType"];
      if (Array.isArray(_data["productTypes"])) {
        this.productTypes = [] as any;
        for (let item of _data["productTypes"]) this.productTypes!.push(item);
      }
      this.excludeProductType = _data["excludeProductType"];
      if (Array.isArray(_data["excludeProductTypes"])) {
        this.excludeProductTypes = [] as any;
        for (let item of _data["excludeProductTypes"])
          this.excludeProductTypes!.push(item);
      }
      this.withHidden = _data["withHidden"];
      this.hideDirectLinkedCategories = _data["hideDirectLinkedCategories"];
      this.mainProductId = _data["mainProductId"];
      this.searchInChildren = _data["searchInChildren"];
      this.searchInVariations = _data["searchInVariations"];
      this.onlyBuyable = _data["onlyBuyable"];
      this.onlyWithTrackingInventory = _data["onlyWithTrackingInventory"];
      this.catalogId = _data["catalogId"];
      if (Array.isArray(_data["catalogIds"])) {
        this.catalogIds = [] as any;
        for (let item of _data["catalogIds"]) this.catalogIds!.push(item);
      }
      this.categoryId = _data["categoryId"];
      if (Array.isArray(_data["categoryIds"])) {
        this.categoryIds = [] as any;
        for (let item of _data["categoryIds"]) this.categoryIds!.push(item);
      }
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): CatalogListEntrySearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new CatalogListEntrySearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["code"] = this.code;
    data["vendorId"] = this.vendorId;
    if (Array.isArray(this.vendorIds)) {
      data["vendorIds"] = [];
      for (let item of this.vendorIds) data["vendorIds"].push(item);
    }
    data["productType"] = this.productType;
    if (Array.isArray(this.productTypes)) {
      data["productTypes"] = [];
      for (let item of this.productTypes) data["productTypes"].push(item);
    }
    data["excludeProductType"] = this.excludeProductType;
    if (Array.isArray(this.excludeProductTypes)) {
      data["excludeProductTypes"] = [];
      for (let item of this.excludeProductTypes)
        data["excludeProductTypes"].push(item);
    }
    data["withHidden"] = this.withHidden;
    data["hideDirectLinkedCategories"] = this.hideDirectLinkedCategories;
    data["mainProductId"] = this.mainProductId;
    data["searchInChildren"] = this.searchInChildren;
    data["searchInVariations"] = this.searchInVariations;
    data["onlyBuyable"] = this.onlyBuyable;
    data["onlyWithTrackingInventory"] = this.onlyWithTrackingInventory;
    data["catalogId"] = this.catalogId;
    if (Array.isArray(this.catalogIds)) {
      data["catalogIds"] = [];
      for (let item of this.catalogIds) data["catalogIds"].push(item);
    }
    data["categoryId"] = this.categoryId;
    if (Array.isArray(this.categoryIds)) {
      data["categoryIds"] = [];
      for (let item of this.categoryIds) data["categoryIds"].push(item);
    }
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface ICatalogListEntrySearchCriteria {
  code?: string | undefined;
  /** Search by vendor */
  vendorId?: string | undefined;
  vendorIds?: string[] | undefined;
  /** Search product with specified type */
  productType?: string | undefined;
  productTypes?: string[] | undefined;
  /** Exclude a specified product type from the search */
  excludeProductType?: string | undefined;
  excludeProductTypes?: string[] | undefined;
  withHidden?: boolean;
  hideDirectLinkedCategories?: boolean;
  /** Search within variations of specified main product */
  mainProductId?: string | undefined;
  /** Search  in all children categories for specified catalog or categories */
  searchInChildren?: boolean;
  /** Also search in variations */
  searchInVariations?: boolean;
  onlyBuyable?: boolean | undefined;
  onlyWithTrackingInventory?: boolean | undefined;
  catalogId?: string | undefined;
  catalogIds?: string[] | undefined;
  categoryId?: string | undefined;
  categoryIds?: string[] | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

/** Base class for all entries used in catalog categories browsing. */
export class ListEntryBase implements IListEntryBase {
  /** Gets or sets the type. E.g. "product", "category" */
  type?: string | undefined;
  /** Gets or sets a value indicating whether this entry is active. */
  isActive?: boolean | undefined;
  /** Gets or sets the image URL. */
  imageUrl?: string | undefined;
  /** Gets or sets the entry code. */
  code?: string | undefined;
  /** Gets or sets the name. */
  name?: string | undefined;
  /** Gets or sets the links. */
  links?: CategoryLink[] | undefined;
  /** All entry parents ids */
  outline?: string[] | undefined;
  /** All entry parents names */
  path?: string[] | undefined;
  /** Gets or sets the catalog id. */
  catalogId?: string | undefined;
  seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IListEntryBase) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data["type"];
      this.isActive = _data["isActive"];
      this.imageUrl = _data["imageUrl"];
      this.code = _data["code"];
      this.name = _data["name"];
      if (Array.isArray(_data["links"])) {
        this.links = [] as any;
        for (let item of _data["links"])
          this.links!.push(CategoryLink.fromJS(item));
      }
      if (Array.isArray(_data["outline"])) {
        this.outline = [] as any;
        for (let item of _data["outline"]) this.outline!.push(item);
      }
      if (Array.isArray(_data["path"])) {
        this.path = [] as any;
        for (let item of _data["path"]) this.path!.push(item);
      }
      this.catalogId = _data["catalogId"];
      this.seoObjectType = _data["seoObjectType"];
      if (Array.isArray(_data["seoInfos"])) {
        this.seoInfos = [] as any;
        for (let item of _data["seoInfos"])
          this.seoInfos!.push(SeoInfo.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): ListEntryBase {
    data = typeof data === "object" ? data : {};
    let result = new ListEntryBase();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["type"] = this.type;
    data["isActive"] = this.isActive;
    data["imageUrl"] = this.imageUrl;
    data["code"] = this.code;
    data["name"] = this.name;
    if (Array.isArray(this.links)) {
      data["links"] = [];
      for (let item of this.links) data["links"].push(item.toJSON());
    }
    if (Array.isArray(this.outline)) {
      data["outline"] = [];
      for (let item of this.outline) data["outline"].push(item);
    }
    if (Array.isArray(this.path)) {
      data["path"] = [];
      for (let item of this.path) data["path"].push(item);
    }
    data["catalogId"] = this.catalogId;
    data["seoObjectType"] = this.seoObjectType;
    if (Array.isArray(this.seoInfos)) {
      data["seoInfos"] = [];
      for (let item of this.seoInfos) data["seoInfos"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

/** Base class for all entries used in catalog categories browsing. */
export interface IListEntryBase {
  /** Gets or sets the type. E.g. "product", "category" */
  type?: string | undefined;
  /** Gets or sets a value indicating whether this entry is active. */
  isActive?: boolean | undefined;
  /** Gets or sets the image URL. */
  imageUrl?: string | undefined;
  /** Gets or sets the entry code. */
  code?: string | undefined;
  /** Gets or sets the name. */
  name?: string | undefined;
  /** Gets or sets the links. */
  links?: CategoryLink[] | undefined;
  /** All entry parents ids */
  outline?: string[] | undefined;
  /** All entry parents names */
  path?: string[] | undefined;
  /** Gets or sets the catalog id. */
  catalogId?: string | undefined;
  seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class ListEntrySearchResult implements IListEntrySearchResult {
  /** Gets or sets the list entries. */
  readonly listEntries?: ListEntryBase[] | undefined;
  totalCount?: number;
  results?: ListEntryBase[] | undefined;

  constructor(data?: IListEntrySearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["listEntries"])) {
        (<any>this).listEntries = [] as any;
        for (let item of _data["listEntries"])
          (<any>this).listEntries!.push(ListEntryBase.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(ListEntryBase.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListEntrySearchResult {
    data = typeof data === "object" ? data : {};
    let result = new ListEntrySearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.listEntries)) {
      data["listEntries"] = [];
      for (let item of this.listEntries)
        data["listEntries"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IListEntrySearchResult {
  /** Gets or sets the list entries. */
  listEntries?: ListEntryBase[] | undefined;
  totalCount?: number;
  results?: ListEntryBase[] | undefined;
}

/** Information to search and create links to categories and items */
export class BulkLinkCreationRequest implements IBulkLinkCreationRequest {
  searchCriteria?: CatalogListEntrySearchCriteria;
  /** The target category identifier for the link */
  categoryId?: string | undefined;
  /** The target catalog identifier for the link */
  catalogId?: string | undefined;

  constructor(data?: IBulkLinkCreationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.searchCriteria = _data["searchCriteria"]
        ? CatalogListEntrySearchCriteria.fromJS(_data["searchCriteria"])
        : <any>undefined;
      this.categoryId = _data["categoryId"];
      this.catalogId = _data["catalogId"];
    }
  }

  static fromJS(data: any): BulkLinkCreationRequest {
    data = typeof data === "object" ? data : {};
    let result = new BulkLinkCreationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["searchCriteria"] = this.searchCriteria
      ? this.searchCriteria.toJSON()
      : <any>undefined;
    data["categoryId"] = this.categoryId;
    data["catalogId"] = this.catalogId;
    return data;
  }
}

/** Information to search and create links to categories and items */
export interface IBulkLinkCreationRequest {
  searchCriteria?: CatalogListEntrySearchCriteria;
  /** The target category identifier for the link */
  categoryId?: string | undefined;
  /** The target catalog identifier for the link */
  catalogId?: string | undefined;
}

/** Represents  move list entries command */
export class ListEntriesMoveRequest implements IListEntriesMoveRequest {
  catalog?: string | undefined;
  readonly catalogId?: string | undefined;
  category?: string | undefined;
  listEntries?: ListEntryBase[] | undefined;

  constructor(data?: IListEntriesMoveRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.catalog = _data["catalog"];
      (<any>this).catalogId = _data["catalogId"];
      this.category = _data["category"];
      if (Array.isArray(_data["listEntries"])) {
        this.listEntries = [] as any;
        for (let item of _data["listEntries"])
          this.listEntries!.push(ListEntryBase.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListEntriesMoveRequest {
    data = typeof data === "object" ? data : {};
    let result = new ListEntriesMoveRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["catalog"] = this.catalog;
    data["catalogId"] = this.catalogId;
    data["category"] = this.category;
    if (Array.isArray(this.listEntries)) {
      data["listEntries"] = [];
      for (let item of this.listEntries)
        data["listEntries"].push(item.toJSON());
    }
    return data;
  }
}

/** Represents  move list entries command */
export interface IListEntriesMoveRequest {
  catalog?: string | undefined;
  catalogId?: string | undefined;
  category?: string | undefined;
  listEntries?: ListEntryBase[] | undefined;
}

/** Property name validation data */
export class PropertyValidationRequest implements IPropertyValidationRequest {
  originalName?: string | undefined;
  name?: string | undefined;
  productId?: string | undefined;

  constructor(data?: IPropertyValidationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.originalName = _data["originalName"];
      this.name = _data["name"];
      this.productId = _data["productId"];
    }
  }

  static fromJS(data: any): PropertyValidationRequest {
    data = typeof data === "object" ? data : {};
    let result = new PropertyValidationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["originalName"] = this.originalName;
    data["name"] = this.name;
    data["productId"] = this.productId;
    return data;
  }
}

/** Property name validation data */
export interface IPropertyValidationRequest {
  originalName?: string | undefined;
  name?: string | undefined;
  productId?: string | undefined;
}

export enum Severity {
  Error = "Error",
  Warning = "Warning",
  Info = "Info",
}

export class ValidationFailure implements IValidationFailure {
  propertyName?: string | undefined;
  errorMessage?: string | undefined;
  attemptedValue?: any | undefined;
  customState?: any | undefined;
  severity?: Severity;
  errorCode?: string | undefined;
  formattedMessageArguments?: any[] | undefined;
  formattedMessagePlaceholderValues?: { [key: string]: any } | undefined;
  resourceName?: string | undefined;

  constructor(data?: IValidationFailure) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.propertyName = _data["propertyName"];
      this.errorMessage = _data["errorMessage"];
      this.attemptedValue = _data["attemptedValue"];
      this.customState = _data["customState"];
      this.severity = _data["severity"];
      this.errorCode = _data["errorCode"];
      if (Array.isArray(_data["formattedMessageArguments"])) {
        this.formattedMessageArguments = [] as any;
        for (let item of _data["formattedMessageArguments"])
          this.formattedMessageArguments!.push(item);
      }
      if (_data["formattedMessagePlaceholderValues"]) {
        this.formattedMessagePlaceholderValues = {} as any;
        for (let key in _data["formattedMessagePlaceholderValues"]) {
          if (_data["formattedMessagePlaceholderValues"].hasOwnProperty(key))
            (<any>this.formattedMessagePlaceholderValues)![key] =
              _data["formattedMessagePlaceholderValues"][key];
        }
      }
      this.resourceName = _data["resourceName"];
    }
  }

  static fromJS(data: any): ValidationFailure {
    data = typeof data === "object" ? data : {};
    let result = new ValidationFailure();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["propertyName"] = this.propertyName;
    data["errorMessage"] = this.errorMessage;
    data["attemptedValue"] = this.attemptedValue;
    data["customState"] = this.customState;
    data["severity"] = this.severity;
    data["errorCode"] = this.errorCode;
    if (Array.isArray(this.formattedMessageArguments)) {
      data["formattedMessageArguments"] = [];
      for (let item of this.formattedMessageArguments)
        data["formattedMessageArguments"].push(item);
    }
    if (this.formattedMessagePlaceholderValues) {
      data["formattedMessagePlaceholderValues"] = {};
      for (let key in this.formattedMessagePlaceholderValues) {
        if (this.formattedMessagePlaceholderValues.hasOwnProperty(key))
          (<any>data["formattedMessagePlaceholderValues"])[key] =
            this.formattedMessagePlaceholderValues[key];
      }
    }
    data["resourceName"] = this.resourceName;
    return data;
  }
}

export interface IValidationFailure {
  propertyName?: string | undefined;
  errorMessage?: string | undefined;
  attemptedValue?: any | undefined;
  customState?: any | undefined;
  severity?: Severity;
  errorCode?: string | undefined;
  formattedMessageArguments?: any[] | undefined;
  formattedMessagePlaceholderValues?: { [key: string]: any } | undefined;
  resourceName?: string | undefined;
}

export class ValidationResult implements IValidationResult {
  readonly isValid?: boolean;
  readonly errors?: ValidationFailure[] | undefined;
  readonly ruleSetsExecuted?: string[] | undefined;

  constructor(data?: IValidationResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).isValid = _data["isValid"];
      if (Array.isArray(_data["errors"])) {
        (<any>this).errors = [] as any;
        for (let item of _data["errors"])
          (<any>this).errors!.push(ValidationFailure.fromJS(item));
      }
      if (Array.isArray(_data["ruleSetsExecuted"])) {
        (<any>this).ruleSetsExecuted = [] as any;
        for (let item of _data["ruleSetsExecuted"])
          (<any>this).ruleSetsExecuted!.push(item);
      }
    }
  }

  static fromJS(data: any): ValidationResult {
    data = typeof data === "object" ? data : {};
    let result = new ValidationResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["isValid"] = this.isValid;
    if (Array.isArray(this.errors)) {
      data["errors"] = [];
      for (let item of this.errors) data["errors"].push(item.toJSON());
    }
    if (Array.isArray(this.ruleSetsExecuted)) {
      data["ruleSetsExecuted"] = [];
      for (let item of this.ruleSetsExecuted)
        data["ruleSetsExecuted"].push(item);
    }
    return data;
  }
}

export interface IValidationResult {
  isValid?: boolean;
  errors?: ValidationFailure[] | undefined;
  ruleSetsExecuted?: string[] | undefined;
}

export class CategoryPropertyValidationRequest
  implements ICategoryPropertyValidationRequest
{
  propertyName?: string | undefined;
  categoryId?: string | undefined;

  constructor(data?: ICategoryPropertyValidationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.propertyName = _data["propertyName"];
      this.categoryId = _data["categoryId"];
    }
  }

  static fromJS(data: any): CategoryPropertyValidationRequest {
    data = typeof data === "object" ? data : {};
    let result = new CategoryPropertyValidationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["propertyName"] = this.propertyName;
    data["categoryId"] = this.categoryId;
    return data;
  }
}

export interface ICategoryPropertyValidationRequest {
  propertyName?: string | undefined;
  categoryId?: string | undefined;
}

/** Search criteria used for search property dictionary items */
export class PropertyDictionaryItemSearchCriteria
  implements IPropertyDictionaryItemSearchCriteria
{
  propertyIds?: string[] | undefined;
  catalogIds?: string[] | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IPropertyDictionaryItemSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["propertyIds"])) {
        this.propertyIds = [] as any;
        for (let item of _data["propertyIds"]) this.propertyIds!.push(item);
      }
      if (Array.isArray(_data["catalogIds"])) {
        this.catalogIds = [] as any;
        for (let item of _data["catalogIds"]) this.catalogIds!.push(item);
      }
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): PropertyDictionaryItemSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new PropertyDictionaryItemSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.propertyIds)) {
      data["propertyIds"] = [];
      for (let item of this.propertyIds) data["propertyIds"].push(item);
    }
    if (Array.isArray(this.catalogIds)) {
      data["catalogIds"] = [];
      for (let item of this.catalogIds) data["catalogIds"].push(item);
    }
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

/** Search criteria used for search property dictionary items */
export interface IPropertyDictionaryItemSearchCriteria {
  propertyIds?: string[] | undefined;
  catalogIds?: string[] | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class PropertyDictionaryItemLocalizedValue
  implements IPropertyDictionaryItemLocalizedValue
{
  languageCode?: string | undefined;
  value?: string | undefined;

  constructor(data?: IPropertyDictionaryItemLocalizedValue) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.languageCode = _data["languageCode"];
      this.value = _data["value"];
    }
  }

  static fromJS(data: any): PropertyDictionaryItemLocalizedValue {
    data = typeof data === "object" ? data : {};
    let result = new PropertyDictionaryItemLocalizedValue();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["languageCode"] = this.languageCode;
    data["value"] = this.value;
    return data;
  }
}

export interface IPropertyDictionaryItemLocalizedValue {
  languageCode?: string | undefined;
  value?: string | undefined;
}

export class PropertyDictionaryItem implements IPropertyDictionaryItem {
  propertyId?: string | undefined;
  alias?: string | undefined;
  sortOrder?: number;
  localizedValues?: PropertyDictionaryItemLocalizedValue[] | undefined;
  id?: string | undefined;

  constructor(data?: IPropertyDictionaryItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.propertyId = _data["propertyId"];
      this.alias = _data["alias"];
      this.sortOrder = _data["sortOrder"];
      if (Array.isArray(_data["localizedValues"])) {
        this.localizedValues = [] as any;
        for (let item of _data["localizedValues"])
          this.localizedValues!.push(
            PropertyDictionaryItemLocalizedValue.fromJS(item)
          );
      }
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): PropertyDictionaryItem {
    data = typeof data === "object" ? data : {};
    let result = new PropertyDictionaryItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["propertyId"] = this.propertyId;
    data["alias"] = this.alias;
    data["sortOrder"] = this.sortOrder;
    if (Array.isArray(this.localizedValues)) {
      data["localizedValues"] = [];
      for (let item of this.localizedValues)
        data["localizedValues"].push(item.toJSON());
    }
    data["id"] = this.id;
    return data;
  }
}

export interface IPropertyDictionaryItem {
  propertyId?: string | undefined;
  alias?: string | undefined;
  sortOrder?: number;
  localizedValues?: PropertyDictionaryItemLocalizedValue[] | undefined;
  id?: string | undefined;
}

export class PropertyDictionaryItemSearchResult
  implements IPropertyDictionaryItemSearchResult
{
  totalCount?: number;
  results?: PropertyDictionaryItem[] | undefined;

  constructor(data?: IPropertyDictionaryItemSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(PropertyDictionaryItem.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PropertyDictionaryItemSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new PropertyDictionaryItemSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPropertyDictionaryItemSearchResult {
  totalCount?: number;
  results?: PropertyDictionaryItem[] | undefined;
}

export class CsvProductPropertyMap implements ICsvProductPropertyMap {
  entityColumnName?: string | undefined;
  csvColumnName?: string | undefined;
  isSystemProperty?: boolean;
  isRequired?: boolean;
  customValue?: string | undefined;
  stringFormat?: string | undefined;
  locale?: string | undefined;

  constructor(data?: ICsvProductPropertyMap) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.entityColumnName = _data["entityColumnName"];
      this.csvColumnName = _data["csvColumnName"];
      this.isSystemProperty = _data["isSystemProperty"];
      this.isRequired = _data["isRequired"];
      this.customValue = _data["customValue"];
      this.stringFormat = _data["stringFormat"];
      this.locale = _data["locale"];
    }
  }

  static fromJS(data: any): CsvProductPropertyMap {
    data = typeof data === "object" ? data : {};
    let result = new CsvProductPropertyMap();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["entityColumnName"] = this.entityColumnName;
    data["csvColumnName"] = this.csvColumnName;
    data["isSystemProperty"] = this.isSystemProperty;
    data["isRequired"] = this.isRequired;
    data["customValue"] = this.customValue;
    data["stringFormat"] = this.stringFormat;
    data["locale"] = this.locale;
    return data;
  }
}

export interface ICsvProductPropertyMap {
  entityColumnName?: string | undefined;
  csvColumnName?: string | undefined;
  isSystemProperty?: boolean;
  isRequired?: boolean;
  customValue?: string | undefined;
  stringFormat?: string | undefined;
  locale?: string | undefined;
}

export class CsvProductMappingConfiguration
  implements ICsvProductMappingConfiguration
{
  eTag?: string | undefined;
  delimiter?: string | undefined;
  csvColumns?: string[] | undefined;
  propertyMaps?: CsvProductPropertyMap[] | undefined;
  propertyCsvColumns?: string[] | undefined;

  constructor(data?: ICsvProductMappingConfiguration) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.eTag = _data["eTag"];
      this.delimiter = _data["delimiter"];
      if (Array.isArray(_data["csvColumns"])) {
        this.csvColumns = [] as any;
        for (let item of _data["csvColumns"]) this.csvColumns!.push(item);
      }
      if (Array.isArray(_data["propertyMaps"])) {
        this.propertyMaps = [] as any;
        for (let item of _data["propertyMaps"])
          this.propertyMaps!.push(CsvProductPropertyMap.fromJS(item));
      }
      if (Array.isArray(_data["propertyCsvColumns"])) {
        this.propertyCsvColumns = [] as any;
        for (let item of _data["propertyCsvColumns"])
          this.propertyCsvColumns!.push(item);
      }
    }
  }

  static fromJS(data: any): CsvProductMappingConfiguration {
    data = typeof data === "object" ? data : {};
    let result = new CsvProductMappingConfiguration();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["eTag"] = this.eTag;
    data["delimiter"] = this.delimiter;
    if (Array.isArray(this.csvColumns)) {
      data["csvColumns"] = [];
      for (let item of this.csvColumns) data["csvColumns"].push(item);
    }
    if (Array.isArray(this.propertyMaps)) {
      data["propertyMaps"] = [];
      for (let item of this.propertyMaps)
        data["propertyMaps"].push(item.toJSON());
    }
    if (Array.isArray(this.propertyCsvColumns)) {
      data["propertyCsvColumns"] = [];
      for (let item of this.propertyCsvColumns)
        data["propertyCsvColumns"].push(item);
    }
    return data;
  }
}

export interface ICsvProductMappingConfiguration {
  eTag?: string | undefined;
  delimiter?: string | undefined;
  csvColumns?: string[] | undefined;
  propertyMaps?: CsvProductPropertyMap[] | undefined;
  propertyCsvColumns?: string[] | undefined;
}

export class CsvExportInfo implements ICsvExportInfo {
  catalogId?: string | undefined;
  productIds?: string[] | undefined;
  categoryIds?: string[] | undefined;
  priceListId?: string | undefined;
  fulfilmentCenterId?: string | undefined;
  currency?: string | undefined;
  configuration?: CsvProductMappingConfiguration;

  constructor(data?: ICsvExportInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.catalogId = _data["catalogId"];
      if (Array.isArray(_data["productIds"])) {
        this.productIds = [] as any;
        for (let item of _data["productIds"]) this.productIds!.push(item);
      }
      if (Array.isArray(_data["categoryIds"])) {
        this.categoryIds = [] as any;
        for (let item of _data["categoryIds"]) this.categoryIds!.push(item);
      }
      this.priceListId = _data["priceListId"];
      this.fulfilmentCenterId = _data["fulfilmentCenterId"];
      this.currency = _data["currency"];
      this.configuration = _data["configuration"]
        ? CsvProductMappingConfiguration.fromJS(_data["configuration"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): CsvExportInfo {
    data = typeof data === "object" ? data : {};
    let result = new CsvExportInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["catalogId"] = this.catalogId;
    if (Array.isArray(this.productIds)) {
      data["productIds"] = [];
      for (let item of this.productIds) data["productIds"].push(item);
    }
    if (Array.isArray(this.categoryIds)) {
      data["categoryIds"] = [];
      for (let item of this.categoryIds) data["categoryIds"].push(item);
    }
    data["priceListId"] = this.priceListId;
    data["fulfilmentCenterId"] = this.fulfilmentCenterId;
    data["currency"] = this.currency;
    data["configuration"] = this.configuration
      ? this.configuration.toJSON()
      : <any>undefined;
    return data;
  }
}

export interface ICsvExportInfo {
  catalogId?: string | undefined;
  productIds?: string[] | undefined;
  categoryIds?: string[] | undefined;
  priceListId?: string | undefined;
  fulfilmentCenterId?: string | undefined;
  currency?: string | undefined;
  configuration?: CsvProductMappingConfiguration;
}

/** Notification for catalog data export job. */
export class ExportNotification implements IExportNotification {
  /** Gets or sets the URL for downloading exported data. */
  downloadUrl?: string | undefined;
  /** Gets or sets the job finish date and time. */
  finished?: Date | undefined;
  /** Gets or sets the total count of objects to process. */
  totalCount?: number;
  /** Gets or sets the count of processed objects. */
  processedCount?: number;
  /** Gets the count of errors during processing. */
  readonly errorCount?: number;
  /** Gets or sets the errors that has occurred during processing. */
  errors?: string[] | undefined;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;

  constructor(data?: IExportNotification) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.downloadUrl = _data["downloadUrl"];
      this.finished = _data["finished"]
        ? new Date(_data["finished"].toString())
        : <any>undefined;
      this.totalCount = _data["totalCount"];
      this.processedCount = _data["processedCount"];
      (<any>this).errorCount = _data["errorCount"];
      if (Array.isArray(_data["errors"])) {
        this.errors = [] as any;
        for (let item of _data["errors"]) this.errors!.push(item);
      }
      this.serverId = _data["serverId"];
      this.creator = _data["creator"];
      this.created = _data["created"]
        ? new Date(_data["created"].toString())
        : <any>undefined;
      this.isNew = _data["isNew"];
      this.notifyType = _data["notifyType"];
      this.description = _data["description"];
      this.title = _data["title"];
      this.repeatCount = _data["repeatCount"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): ExportNotification {
    data = typeof data === "object" ? data : {};
    let result = new ExportNotification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["downloadUrl"] = this.downloadUrl;
    data["finished"] = this.finished
      ? this.finished.toISOString()
      : <any>undefined;
    data["totalCount"] = this.totalCount;
    data["processedCount"] = this.processedCount;
    data["errorCount"] = this.errorCount;
    if (Array.isArray(this.errors)) {
      data["errors"] = [];
      for (let item of this.errors) data["errors"].push(item);
    }
    data["serverId"] = this.serverId;
    data["creator"] = this.creator;
    data["created"] = this.created
      ? this.created.toISOString()
      : <any>undefined;
    data["isNew"] = this.isNew;
    data["notifyType"] = this.notifyType;
    data["description"] = this.description;
    data["title"] = this.title;
    data["repeatCount"] = this.repeatCount;
    data["id"] = this.id;
    return data;
  }
}

/** Notification for catalog data export job. */
export interface IExportNotification {
  /** Gets or sets the URL for downloading exported data. */
  downloadUrl?: string | undefined;
  /** Gets or sets the job finish date and time. */
  finished?: Date | undefined;
  /** Gets or sets the total count of objects to process. */
  totalCount?: number;
  /** Gets or sets the count of processed objects. */
  processedCount?: number;
  /** Gets the count of errors during processing. */
  errorCount?: number;
  /** Gets or sets the errors that has occurred during processing. */
  errors?: string[] | undefined;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;
}

export class CsvImportInfo implements ICsvImportInfo {
  catalogId?: string | undefined;
  fileUrl?: string | undefined;
  configuration?: CsvProductMappingConfiguration;

  constructor(data?: ICsvImportInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.catalogId = _data["catalogId"];
      this.fileUrl = _data["fileUrl"];
      this.configuration = _data["configuration"]
        ? CsvProductMappingConfiguration.fromJS(_data["configuration"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): CsvImportInfo {
    data = typeof data === "object" ? data : {};
    let result = new CsvImportInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["catalogId"] = this.catalogId;
    data["fileUrl"] = this.fileUrl;
    data["configuration"] = this.configuration
      ? this.configuration.toJSON()
      : <any>undefined;
    return data;
  }
}

export interface ICsvImportInfo {
  catalogId?: string | undefined;
  fileUrl?: string | undefined;
  configuration?: CsvProductMappingConfiguration;
}

/** Notification for catalog data import job. */
export class CatalogCsvImportNotification
  implements ICatalogCsvImportNotification
{
  /** Gets or sets the job finish date and time. */
  finished?: Date | undefined;
  /** Gets or sets the total count of objects to process. */
  totalCount?: number;
  /** Gets or sets the count of processed objects. */
  processedCount?: number;
  /** Gets the count of errors during processing. */
  readonly errorCount?: number;
  /** Gets or sets the errors that has occurred during processing. */
  errors?: string[] | undefined;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;

  constructor(data?: ICatalogCsvImportNotification) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.finished = _data["finished"]
        ? new Date(_data["finished"].toString())
        : <any>undefined;
      this.totalCount = _data["totalCount"];
      this.processedCount = _data["processedCount"];
      (<any>this).errorCount = _data["errorCount"];
      if (Array.isArray(_data["errors"])) {
        this.errors = [] as any;
        for (let item of _data["errors"]) this.errors!.push(item);
      }
      this.serverId = _data["serverId"];
      this.creator = _data["creator"];
      this.created = _data["created"]
        ? new Date(_data["created"].toString())
        : <any>undefined;
      this.isNew = _data["isNew"];
      this.notifyType = _data["notifyType"];
      this.description = _data["description"];
      this.title = _data["title"];
      this.repeatCount = _data["repeatCount"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): CatalogCsvImportNotification {
    data = typeof data === "object" ? data : {};
    let result = new CatalogCsvImportNotification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["finished"] = this.finished
      ? this.finished.toISOString()
      : <any>undefined;
    data["totalCount"] = this.totalCount;
    data["processedCount"] = this.processedCount;
    data["errorCount"] = this.errorCount;
    if (Array.isArray(this.errors)) {
      data["errors"] = [];
      for (let item of this.errors) data["errors"].push(item);
    }
    data["serverId"] = this.serverId;
    data["creator"] = this.creator;
    data["created"] = this.created
      ? this.created.toISOString()
      : <any>undefined;
    data["isNew"] = this.isNew;
    data["notifyType"] = this.notifyType;
    data["description"] = this.description;
    data["title"] = this.title;
    data["repeatCount"] = this.repeatCount;
    data["id"] = this.id;
    return data;
  }
}

/** Notification for catalog data import job. */
export interface ICatalogCsvImportNotification {
  /** Gets or sets the job finish date and time. */
  finished?: Date | undefined;
  /** Gets or sets the total count of objects to process. */
  totalCount?: number;
  /** Gets or sets the count of processed objects. */
  processedCount?: number;
  /** Gets the count of errors during processing. */
  errorCount?: number;
  /** Gets or sets the errors that has occurred during processing. */
  errors?: string[] | undefined;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;
}

export class TaggedItemOutline implements ITaggedItemOutline {
  outline?: string | undefined;
  taggedItem?: TaggedItem;
  taggedItemId?: string | undefined;
  id?: string | undefined;

  constructor(data?: ITaggedItemOutline) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.outline = _data["outline"];
      this.taggedItem = _data["taggedItem"]
        ? TaggedItem.fromJS(_data["taggedItem"])
        : <any>undefined;
      this.taggedItemId = _data["taggedItemId"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): TaggedItemOutline {
    data = typeof data === "object" ? data : {};
    let result = new TaggedItemOutline();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["outline"] = this.outline;
    data["taggedItem"] = this.taggedItem
      ? this.taggedItem.toJSON()
      : <any>undefined;
    data["taggedItemId"] = this.taggedItemId;
    data["id"] = this.id;
    return data;
  }
}

export interface ITaggedItemOutline {
  outline?: string | undefined;
  taggedItem?: TaggedItem;
  taggedItemId?: string | undefined;
  id?: string | undefined;
}

export class TaggedItem implements ITaggedItem {
  label?: string | undefined;
  entityType?: string | undefined;
  entityId?: string | undefined;
  tags?: string[] | undefined;
  inheritedTags?: string[] | undefined;
  outlines?: TaggedItemOutline[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: ITaggedItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.label = _data["label"];
      this.entityType = _data["entityType"];
      this.entityId = _data["entityId"];
      if (Array.isArray(_data["tags"])) {
        this.tags = [] as any;
        for (let item of _data["tags"]) this.tags!.push(item);
      }
      if (Array.isArray(_data["inheritedTags"])) {
        this.inheritedTags = [] as any;
        for (let item of _data["inheritedTags"]) this.inheritedTags!.push(item);
      }
      if (Array.isArray(_data["outlines"])) {
        this.outlines = [] as any;
        for (let item of _data["outlines"])
          this.outlines!.push(TaggedItemOutline.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): TaggedItem {
    data = typeof data === "object" ? data : {};
    let result = new TaggedItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["label"] = this.label;
    data["entityType"] = this.entityType;
    data["entityId"] = this.entityId;
    if (Array.isArray(this.tags)) {
      data["tags"] = [];
      for (let item of this.tags) data["tags"].push(item);
    }
    if (Array.isArray(this.inheritedTags)) {
      data["inheritedTags"] = [];
      for (let item of this.inheritedTags) data["inheritedTags"].push(item);
    }
    if (Array.isArray(this.outlines)) {
      data["outlines"] = [];
      for (let item of this.outlines) data["outlines"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface ITaggedItem {
  label?: string | undefined;
  entityType?: string | undefined;
  entityId?: string | undefined;
  tags?: string[] | undefined;
  inheritedTags?: string[] | undefined;
  outlines?: TaggedItemOutline[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class TaggedItemSearchCriteria implements ITaggedItemSearchCriteria {
  entityId?: string | undefined;
  entityIds?: string[] | undefined;
  changedFrom?: Date | undefined;
  entityType?: string | undefined;
  ids?: string[] | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: ITaggedItemSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.entityId = _data["entityId"];
      if (Array.isArray(_data["entityIds"])) {
        this.entityIds = [] as any;
        for (let item of _data["entityIds"]) this.entityIds!.push(item);
      }
      this.changedFrom = _data["changedFrom"]
        ? new Date(_data["changedFrom"].toString())
        : <any>undefined;
      this.entityType = _data["entityType"];
      if (Array.isArray(_data["ids"])) {
        this.ids = [] as any;
        for (let item of _data["ids"]) this.ids!.push(item);
      }
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): TaggedItemSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new TaggedItemSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["entityId"] = this.entityId;
    if (Array.isArray(this.entityIds)) {
      data["entityIds"] = [];
      for (let item of this.entityIds) data["entityIds"].push(item);
    }
    data["changedFrom"] = this.changedFrom
      ? this.changedFrom.toISOString()
      : <any>undefined;
    data["entityType"] = this.entityType;
    if (Array.isArray(this.ids)) {
      data["ids"] = [];
      for (let item of this.ids) data["ids"].push(item);
    }
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface ITaggedItemSearchCriteria {
  entityId?: string | undefined;
  entityIds?: string[] | undefined;
  changedFrom?: Date | undefined;
  entityType?: string | undefined;
  ids?: string[] | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class TaggedItemSearchResult implements ITaggedItemSearchResult {
  totalCount?: number;
  results?: TaggedItem[] | undefined;

  constructor(data?: ITaggedItemSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(TaggedItem.fromJS(item));
      }
    }
  }

  static fromJS(data: any): TaggedItemSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new TaggedItemSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface ITaggedItemSearchResult {
  totalCount?: number;
  results?: TaggedItem[] | undefined;
}

export class TaggedItemOutlineSyncPushNotification
  implements ITaggedItemOutlineSyncPushNotification
{
  jobId?: string | undefined;
  finished?: Date | undefined;
  totalCount?: number;
  processedCount?: number;
  readonly errorCount?: number;
  errors?: string[] | undefined;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;

  constructor(data?: ITaggedItemOutlineSyncPushNotification) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.jobId = _data["jobId"];
      this.finished = _data["finished"]
        ? new Date(_data["finished"].toString())
        : <any>undefined;
      this.totalCount = _data["totalCount"];
      this.processedCount = _data["processedCount"];
      (<any>this).errorCount = _data["errorCount"];
      if (Array.isArray(_data["errors"])) {
        this.errors = [] as any;
        for (let item of _data["errors"]) this.errors!.push(item);
      }
      this.serverId = _data["serverId"];
      this.creator = _data["creator"];
      this.created = _data["created"]
        ? new Date(_data["created"].toString())
        : <any>undefined;
      this.isNew = _data["isNew"];
      this.notifyType = _data["notifyType"];
      this.description = _data["description"];
      this.title = _data["title"];
      this.repeatCount = _data["repeatCount"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): TaggedItemOutlineSyncPushNotification {
    data = typeof data === "object" ? data : {};
    let result = new TaggedItemOutlineSyncPushNotification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["jobId"] = this.jobId;
    data["finished"] = this.finished
      ? this.finished.toISOString()
      : <any>undefined;
    data["totalCount"] = this.totalCount;
    data["processedCount"] = this.processedCount;
    data["errorCount"] = this.errorCount;
    if (Array.isArray(this.errors)) {
      data["errors"] = [];
      for (let item of this.errors) data["errors"].push(item);
    }
    data["serverId"] = this.serverId;
    data["creator"] = this.creator;
    data["created"] = this.created
      ? this.created.toISOString()
      : <any>undefined;
    data["isNew"] = this.isNew;
    data["notifyType"] = this.notifyType;
    data["description"] = this.description;
    data["title"] = this.title;
    data["repeatCount"] = this.repeatCount;
    data["id"] = this.id;
    return data;
  }
}

export interface ITaggedItemOutlineSyncPushNotification {
  jobId?: string | undefined;
  finished?: Date | undefined;
  totalCount?: number;
  processedCount?: number;
  errorCount?: number;
  errors?: string[] | undefined;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;
}

export class TaggedItemOutlinesSynchronizationRequest
  implements ITaggedItemOutlinesSynchronizationRequest
{
  jobId?: string | undefined;

  constructor(data?: ITaggedItemOutlinesSynchronizationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.jobId = _data["jobId"];
    }
  }

  static fromJS(data: any): TaggedItemOutlinesSynchronizationRequest {
    data = typeof data === "object" ? data : {};
    let result = new TaggedItemOutlinesSynchronizationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["jobId"] = this.jobId;
    return data;
  }
}

export interface ITaggedItemOutlinesSynchronizationRequest {
  jobId?: string | undefined;
}

export class ContentStatistic implements IContentStatistic {
  activeThemeName?: string | undefined;
  themesCount?: number;
  pagesCount?: number;
  blogsCount?: number;

  constructor(data?: IContentStatistic) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.activeThemeName = _data["activeThemeName"];
      this.themesCount = _data["themesCount"];
      this.pagesCount = _data["pagesCount"];
      this.blogsCount = _data["blogsCount"];
    }
  }

  static fromJS(data: any): ContentStatistic {
    data = typeof data === "object" ? data : {};
    let result = new ContentStatistic();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["activeThemeName"] = this.activeThemeName;
    data["themesCount"] = this.themesCount;
    data["pagesCount"] = this.pagesCount;
    data["blogsCount"] = this.blogsCount;
    return data;
  }
}

export interface IContentStatistic {
  activeThemeName?: string | undefined;
  themesCount?: number;
  pagesCount?: number;
  blogsCount?: number;
}

export class ContentItem implements IContentItem {
  name?: string | undefined;
  type?: string | undefined;
  url?: string | undefined;
  relativeUrl?: string | undefined;
  parentUrl?: string | undefined;
  modifiedDate?: Date | undefined;
  createdDate?: Date | undefined;

  constructor(data?: IContentItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.type = _data["type"];
      this.url = _data["url"];
      this.relativeUrl = _data["relativeUrl"];
      this.parentUrl = _data["parentUrl"];
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): ContentItem {
    data = typeof data === "object" ? data : {};
    let result = new ContentItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["type"] = this.type;
    data["url"] = this.url;
    data["relativeUrl"] = this.relativeUrl;
    data["parentUrl"] = this.parentUrl;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    return data;
  }
}

export interface IContentItem {
  name?: string | undefined;
  type?: string | undefined;
  url?: string | undefined;
  relativeUrl?: string | undefined;
  parentUrl?: string | undefined;
  modifiedDate?: Date | undefined;
  createdDate?: Date | undefined;
}

export class ContentFolder implements IContentFolder {
  name?: string | undefined;
  type?: string | undefined;
  url?: string | undefined;
  relativeUrl?: string | undefined;
  parentUrl?: string | undefined;
  modifiedDate?: Date | undefined;
  createdDate?: Date | undefined;

  constructor(data?: IContentFolder) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.type = _data["type"];
      this.url = _data["url"];
      this.relativeUrl = _data["relativeUrl"];
      this.parentUrl = _data["parentUrl"];
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): ContentFolder {
    data = typeof data === "object" ? data : {};
    let result = new ContentFolder();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["type"] = this.type;
    data["url"] = this.url;
    data["relativeUrl"] = this.relativeUrl;
    data["parentUrl"] = this.parentUrl;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    return data;
  }
}

export interface IContentFolder {
  name?: string | undefined;
  type?: string | undefined;
  url?: string | undefined;
  relativeUrl?: string | undefined;
  parentUrl?: string | undefined;
  modifiedDate?: Date | undefined;
  createdDate?: Date | undefined;
}

export class MenuLink implements IMenuLink {
  title?: string | undefined;
  url?: string | undefined;
  priority?: number;
  menuLinkListId?: string | undefined;
  associatedObjectId?: string | undefined;
  associatedObjectName?: string | undefined;
  associatedObjectType?: string | undefined;
  securityScopes?: string[] | undefined;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IMenuLink) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data["title"];
      this.url = _data["url"];
      this.priority = _data["priority"];
      this.menuLinkListId = _data["menuLinkListId"];
      this.associatedObjectId = _data["associatedObjectId"];
      this.associatedObjectName = _data["associatedObjectName"];
      this.associatedObjectType = _data["associatedObjectType"];
      if (Array.isArray(_data["securityScopes"])) {
        this.securityScopes = [] as any;
        for (let item of _data["securityScopes"])
          this.securityScopes!.push(item);
      }
      this.outerId = _data["outerId"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): MenuLink {
    data = typeof data === "object" ? data : {};
    let result = new MenuLink();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["title"] = this.title;
    data["url"] = this.url;
    data["priority"] = this.priority;
    data["menuLinkListId"] = this.menuLinkListId;
    data["associatedObjectId"] = this.associatedObjectId;
    data["associatedObjectName"] = this.associatedObjectName;
    data["associatedObjectType"] = this.associatedObjectType;
    if (Array.isArray(this.securityScopes)) {
      data["securityScopes"] = [];
      for (let item of this.securityScopes) data["securityScopes"].push(item);
    }
    data["outerId"] = this.outerId;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IMenuLink {
  title?: string | undefined;
  url?: string | undefined;
  priority?: number;
  menuLinkListId?: string | undefined;
  associatedObjectId?: string | undefined;
  associatedObjectName?: string | undefined;
  associatedObjectType?: string | undefined;
  securityScopes?: string[] | undefined;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class MenuLinkList implements IMenuLinkList {
  name?: string | undefined;
  storeId?: string | undefined;
  language?: string | undefined;
  menuLinks?: MenuLink[] | undefined;
  securityScopes?: string[] | undefined;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IMenuLinkList) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.storeId = _data["storeId"];
      this.language = _data["language"];
      if (Array.isArray(_data["menuLinks"])) {
        this.menuLinks = [] as any;
        for (let item of _data["menuLinks"])
          this.menuLinks!.push(MenuLink.fromJS(item));
      }
      if (Array.isArray(_data["securityScopes"])) {
        this.securityScopes = [] as any;
        for (let item of _data["securityScopes"])
          this.securityScopes!.push(item);
      }
      this.outerId = _data["outerId"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): MenuLinkList {
    data = typeof data === "object" ? data : {};
    let result = new MenuLinkList();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["storeId"] = this.storeId;
    data["language"] = this.language;
    if (Array.isArray(this.menuLinks)) {
      data["menuLinks"] = [];
      for (let item of this.menuLinks) data["menuLinks"].push(item.toJSON());
    }
    if (Array.isArray(this.securityScopes)) {
      data["securityScopes"] = [];
      for (let item of this.securityScopes) data["securityScopes"].push(item);
    }
    data["outerId"] = this.outerId;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IMenuLinkList {
  name?: string | undefined;
  storeId?: string | undefined;
  language?: string | undefined;
  menuLinks?: MenuLink[] | undefined;
  securityScopes?: string[] | undefined;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export enum DigitShapes {
  Context = "Context",
  None = "None",
  NativeNational = "NativeNational",
}

export class NumberFormatInfo implements INumberFormatInfo {
  currencyDecimalDigits?: number;
  currencyDecimalSeparator?: string | undefined;
  readonly isReadOnly?: boolean;
  currencyGroupSizes?: number[] | undefined;
  numberGroupSizes?: number[] | undefined;
  percentGroupSizes?: number[] | undefined;
  currencyGroupSeparator?: string | undefined;
  currencySymbol?: string | undefined;
  naNSymbol?: string | undefined;
  currencyNegativePattern?: number;
  numberNegativePattern?: number;
  percentPositivePattern?: number;
  percentNegativePattern?: number;
  negativeInfinitySymbol?: string | undefined;
  negativeSign?: string | undefined;
  numberDecimalDigits?: number;
  numberDecimalSeparator?: string | undefined;
  numberGroupSeparator?: string | undefined;
  currencyPositivePattern?: number;
  positiveInfinitySymbol?: string | undefined;
  positiveSign?: string | undefined;
  percentDecimalDigits?: number;
  percentDecimalSeparator?: string | undefined;
  percentGroupSeparator?: string | undefined;
  percentSymbol?: string | undefined;
  perMilleSymbol?: string | undefined;
  nativeDigits?: string[] | undefined;
  digitSubstitution?: DigitShapes;

  constructor(data?: INumberFormatInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currencyDecimalDigits = _data["currencyDecimalDigits"];
      this.currencyDecimalSeparator = _data["currencyDecimalSeparator"];
      (<any>this).isReadOnly = _data["isReadOnly"];
      if (Array.isArray(_data["currencyGroupSizes"])) {
        this.currencyGroupSizes = [] as any;
        for (let item of _data["currencyGroupSizes"])
          this.currencyGroupSizes!.push(item);
      }
      if (Array.isArray(_data["numberGroupSizes"])) {
        this.numberGroupSizes = [] as any;
        for (let item of _data["numberGroupSizes"])
          this.numberGroupSizes!.push(item);
      }
      if (Array.isArray(_data["percentGroupSizes"])) {
        this.percentGroupSizes = [] as any;
        for (let item of _data["percentGroupSizes"])
          this.percentGroupSizes!.push(item);
      }
      this.currencyGroupSeparator = _data["currencyGroupSeparator"];
      this.currencySymbol = _data["currencySymbol"];
      this.naNSymbol = _data["naNSymbol"];
      this.currencyNegativePattern = _data["currencyNegativePattern"];
      this.numberNegativePattern = _data["numberNegativePattern"];
      this.percentPositivePattern = _data["percentPositivePattern"];
      this.percentNegativePattern = _data["percentNegativePattern"];
      this.negativeInfinitySymbol = _data["negativeInfinitySymbol"];
      this.negativeSign = _data["negativeSign"];
      this.numberDecimalDigits = _data["numberDecimalDigits"];
      this.numberDecimalSeparator = _data["numberDecimalSeparator"];
      this.numberGroupSeparator = _data["numberGroupSeparator"];
      this.currencyPositivePattern = _data["currencyPositivePattern"];
      this.positiveInfinitySymbol = _data["positiveInfinitySymbol"];
      this.positiveSign = _data["positiveSign"];
      this.percentDecimalDigits = _data["percentDecimalDigits"];
      this.percentDecimalSeparator = _data["percentDecimalSeparator"];
      this.percentGroupSeparator = _data["percentGroupSeparator"];
      this.percentSymbol = _data["percentSymbol"];
      this.perMilleSymbol = _data["perMilleSymbol"];
      if (Array.isArray(_data["nativeDigits"])) {
        this.nativeDigits = [] as any;
        for (let item of _data["nativeDigits"]) this.nativeDigits!.push(item);
      }
      this.digitSubstitution = _data["digitSubstitution"];
    }
  }

  static fromJS(data: any): NumberFormatInfo {
    data = typeof data === "object" ? data : {};
    let result = new NumberFormatInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["currencyDecimalDigits"] = this.currencyDecimalDigits;
    data["currencyDecimalSeparator"] = this.currencyDecimalSeparator;
    data["isReadOnly"] = this.isReadOnly;
    if (Array.isArray(this.currencyGroupSizes)) {
      data["currencyGroupSizes"] = [];
      for (let item of this.currencyGroupSizes)
        data["currencyGroupSizes"].push(item);
    }
    if (Array.isArray(this.numberGroupSizes)) {
      data["numberGroupSizes"] = [];
      for (let item of this.numberGroupSizes)
        data["numberGroupSizes"].push(item);
    }
    if (Array.isArray(this.percentGroupSizes)) {
      data["percentGroupSizes"] = [];
      for (let item of this.percentGroupSizes)
        data["percentGroupSizes"].push(item);
    }
    data["currencyGroupSeparator"] = this.currencyGroupSeparator;
    data["currencySymbol"] = this.currencySymbol;
    data["naNSymbol"] = this.naNSymbol;
    data["currencyNegativePattern"] = this.currencyNegativePattern;
    data["numberNegativePattern"] = this.numberNegativePattern;
    data["percentPositivePattern"] = this.percentPositivePattern;
    data["percentNegativePattern"] = this.percentNegativePattern;
    data["negativeInfinitySymbol"] = this.negativeInfinitySymbol;
    data["negativeSign"] = this.negativeSign;
    data["numberDecimalDigits"] = this.numberDecimalDigits;
    data["numberDecimalSeparator"] = this.numberDecimalSeparator;
    data["numberGroupSeparator"] = this.numberGroupSeparator;
    data["currencyPositivePattern"] = this.currencyPositivePattern;
    data["positiveInfinitySymbol"] = this.positiveInfinitySymbol;
    data["positiveSign"] = this.positiveSign;
    data["percentDecimalDigits"] = this.percentDecimalDigits;
    data["percentDecimalSeparator"] = this.percentDecimalSeparator;
    data["percentGroupSeparator"] = this.percentGroupSeparator;
    data["percentSymbol"] = this.percentSymbol;
    data["perMilleSymbol"] = this.perMilleSymbol;
    if (Array.isArray(this.nativeDigits)) {
      data["nativeDigits"] = [];
      for (let item of this.nativeDigits) data["nativeDigits"].push(item);
    }
    data["digitSubstitution"] = this.digitSubstitution;
    return data;
  }
}

export interface INumberFormatInfo {
  currencyDecimalDigits?: number;
  currencyDecimalSeparator?: string | undefined;
  isReadOnly?: boolean;
  currencyGroupSizes?: number[] | undefined;
  numberGroupSizes?: number[] | undefined;
  percentGroupSizes?: number[] | undefined;
  currencyGroupSeparator?: string | undefined;
  currencySymbol?: string | undefined;
  naNSymbol?: string | undefined;
  currencyNegativePattern?: number;
  numberNegativePattern?: number;
  percentPositivePattern?: number;
  percentNegativePattern?: number;
  negativeInfinitySymbol?: string | undefined;
  negativeSign?: string | undefined;
  numberDecimalDigits?: number;
  numberDecimalSeparator?: string | undefined;
  numberGroupSeparator?: string | undefined;
  currencyPositivePattern?: number;
  positiveInfinitySymbol?: string | undefined;
  positiveSign?: string | undefined;
  percentDecimalDigits?: number;
  percentDecimalSeparator?: string | undefined;
  percentGroupSeparator?: string | undefined;
  percentSymbol?: string | undefined;
  perMilleSymbol?: string | undefined;
  nativeDigits?: string[] | undefined;
  digitSubstitution?: DigitShapes;
}

/** Currency */
export class Currency implements ICurrency {
  /** Currency code may be used ISO 4217. */
  code?: string | undefined;
  cultureName?: string | undefined;
  englishName?: string | undefined;
  numberFormat?: NumberFormatInfo;
  /** name of the currency */
  name?: string | undefined;
  /** Flag specifies that this is the primary currency */
  isPrimary?: boolean;
  /** The exchange rate against the primary exchange rate of the currency. */
  exchangeRate?: number;
  /** Currency symbol */
  symbol?: string | undefined;
  /** Custom formatting pattern */
  customFormatting?: string | undefined;

  constructor(data?: ICurrency) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.code = _data["code"];
      this.cultureName = _data["cultureName"];
      this.englishName = _data["englishName"];
      this.numberFormat = _data["numberFormat"]
        ? NumberFormatInfo.fromJS(_data["numberFormat"])
        : <any>undefined;
      this.name = _data["name"];
      this.isPrimary = _data["isPrimary"];
      this.exchangeRate = _data["exchangeRate"];
      this.symbol = _data["symbol"];
      this.customFormatting = _data["customFormatting"];
    }
  }

  static fromJS(data: any): Currency {
    data = typeof data === "object" ? data : {};
    let result = new Currency();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["code"] = this.code;
    data["cultureName"] = this.cultureName;
    data["englishName"] = this.englishName;
    data["numberFormat"] = this.numberFormat
      ? this.numberFormat.toJSON()
      : <any>undefined;
    data["name"] = this.name;
    data["isPrimary"] = this.isPrimary;
    data["exchangeRate"] = this.exchangeRate;
    data["symbol"] = this.symbol;
    data["customFormatting"] = this.customFormatting;
    return data;
  }
}

/** Currency */
export interface ICurrency {
  /** Currency code may be used ISO 4217. */
  code?: string | undefined;
  cultureName?: string | undefined;
  englishName?: string | undefined;
  numberFormat?: NumberFormatInfo;
  /** name of the currency */
  name?: string | undefined;
  /** Flag specifies that this is the primary currency */
  isPrimary?: boolean;
  /** The exchange rate against the primary exchange rate of the currency. */
  exchangeRate?: number;
  /** Currency symbol */
  symbol?: string | undefined;
  /** Custom formatting pattern */
  customFormatting?: string | undefined;
}

/** Represent predefined dimensions package type */
export class PackageType implements IPackageType {
  /** Package type name */
  name?: string | undefined;
  length?: number;
  width?: number;
  height?: number;
  measureUnit?: string | undefined;
  id?: string | undefined;

  constructor(data?: IPackageType) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.length = _data["length"];
      this.width = _data["width"];
      this.height = _data["height"];
      this.measureUnit = _data["measureUnit"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): PackageType {
    data = typeof data === "object" ? data : {};
    let result = new PackageType();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["length"] = this.length;
    data["width"] = this.width;
    data["height"] = this.height;
    data["measureUnit"] = this.measureUnit;
    data["id"] = this.id;
    return data;
  }
}

/** Represent predefined dimensions package type */
export interface IPackageType {
  /** Package type name */
  name?: string | undefined;
  length?: number;
  width?: number;
  height?: number;
  measureUnit?: string | undefined;
  id?: string | undefined;
}

export class Address implements IAddress {
  addressType?: AddressType;
  key?: string | undefined;
  name?: string | undefined;
  organization?: string | undefined;
  countryCode?: string | undefined;
  countryName?: string | undefined;
  city?: string | undefined;
  postalCode?: string | undefined;
  zip?: string | undefined;
  line1?: string | undefined;
  line2?: string | undefined;
  regionId?: string | undefined;
  regionName?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  email?: string | undefined;

  constructor(data?: IAddress) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.addressType = _data["addressType"];
      this.key = _data["key"];
      this.name = _data["name"];
      this.organization = _data["organization"];
      this.countryCode = _data["countryCode"];
      this.countryName = _data["countryName"];
      this.city = _data["city"];
      this.postalCode = _data["postalCode"];
      this.zip = _data["zip"];
      this.line1 = _data["line1"];
      this.line2 = _data["line2"];
      this.regionId = _data["regionId"];
      this.regionName = _data["regionName"];
      this.firstName = _data["firstName"];
      this.middleName = _data["middleName"];
      this.lastName = _data["lastName"];
      this.phone = _data["phone"];
      this.email = _data["email"];
    }
  }

  static fromJS(data: any): Address {
    data = typeof data === "object" ? data : {};
    let result = new Address();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["addressType"] = this.addressType;
    data["key"] = this.key;
    data["name"] = this.name;
    data["organization"] = this.organization;
    data["countryCode"] = this.countryCode;
    data["countryName"] = this.countryName;
    data["city"] = this.city;
    data["postalCode"] = this.postalCode;
    data["zip"] = this.zip;
    data["line1"] = this.line1;
    data["line2"] = this.line2;
    data["regionId"] = this.regionId;
    data["regionName"] = this.regionName;
    data["firstName"] = this.firstName;
    data["middleName"] = this.middleName;
    data["lastName"] = this.lastName;
    data["phone"] = this.phone;
    data["email"] = this.email;
    return data;
  }
}

export interface IAddress {
  addressType?: AddressType;
  key?: string | undefined;
  name?: string | undefined;
  organization?: string | undefined;
  countryCode?: string | undefined;
  countryName?: string | undefined;
  city?: string | undefined;
  postalCode?: string | undefined;
  zip?: string | undefined;
  line1?: string | undefined;
  line2?: string | undefined;
  regionId?: string | undefined;
  regionName?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  email?: string | undefined;
}

export class CustomerAddress implements ICustomerAddress {
  addressType?: AddressType;
  key?: string | undefined;
  name?: string | undefined;
  organization?: string | undefined;
  countryCode?: string | undefined;
  countryName?: string | undefined;
  city?: string | undefined;
  postalCode?: string | undefined;
  zip?: string | undefined;
  line1?: string | undefined;
  line2?: string | undefined;
  regionId?: string | undefined;
  regionName?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  email?: string | undefined;

  constructor(data?: ICustomerAddress) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.addressType = _data["addressType"];
      this.key = _data["key"];
      this.name = _data["name"];
      this.organization = _data["organization"];
      this.countryCode = _data["countryCode"];
      this.countryName = _data["countryName"];
      this.city = _data["city"];
      this.postalCode = _data["postalCode"];
      this.zip = _data["zip"];
      this.line1 = _data["line1"];
      this.line2 = _data["line2"];
      this.regionId = _data["regionId"];
      this.regionName = _data["regionName"];
      this.firstName = _data["firstName"];
      this.middleName = _data["middleName"];
      this.lastName = _data["lastName"];
      this.phone = _data["phone"];
      this.email = _data["email"];
    }
  }

  static fromJS(data: any): CustomerAddress {
    data = typeof data === "object" ? data : {};
    let result = new CustomerAddress();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["addressType"] = this.addressType;
    data["key"] = this.key;
    data["name"] = this.name;
    data["organization"] = this.organization;
    data["countryCode"] = this.countryCode;
    data["countryName"] = this.countryName;
    data["city"] = this.city;
    data["postalCode"] = this.postalCode;
    data["zip"] = this.zip;
    data["line1"] = this.line1;
    data["line2"] = this.line2;
    data["regionId"] = this.regionId;
    data["regionName"] = this.regionName;
    data["firstName"] = this.firstName;
    data["middleName"] = this.middleName;
    data["lastName"] = this.lastName;
    data["phone"] = this.phone;
    data["email"] = this.email;
    return data;
  }
}

export interface ICustomerAddress {
  addressType?: AddressType;
  key?: string | undefined;
  name?: string | undefined;
  organization?: string | undefined;
  countryCode?: string | undefined;
  countryName?: string | undefined;
  city?: string | undefined;
  postalCode?: string | undefined;
  zip?: string | undefined;
  line1?: string | undefined;
  line2?: string | undefined;
  regionId?: string | undefined;
  regionName?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  email?: string | undefined;
}

export class Note implements INote {
  title?: string | undefined;
  body?: string | undefined;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: INote) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data["title"];
      this.body = _data["body"];
      this.outerId = _data["outerId"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Note {
    data = typeof data === "object" ? data : {};
    let result = new Note();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["title"] = this.title;
    data["body"] = this.body;
    data["outerId"] = this.outerId;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface INote {
  title?: string | undefined;
  body?: string | undefined;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class Organization implements IOrganization {
  description?: string | undefined;
  businessCategory?: string | undefined;
  ownerId?: string | undefined;
  parentId?: string | undefined;
  readonly objectType?: string | undefined;
  name?: string | undefined;
  memberType?: string | undefined;
  outerId?: string | undefined;
  status?: string | undefined;
  addresses?: CustomerAddress[] | undefined;
  phones?: string[] | undefined;
  emails?: string[] | undefined;
  notes?: Note[] | undefined;
  groups?: string[] | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  readonly seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IOrganization) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data["description"];
      this.businessCategory = _data["businessCategory"];
      this.ownerId = _data["ownerId"];
      this.parentId = _data["parentId"];
      (<any>this).objectType = _data["objectType"];
      this.name = _data["name"];
      this.memberType = _data["memberType"];
      this.outerId = _data["outerId"];
      this.status = _data["status"];
      if (Array.isArray(_data["addresses"])) {
        this.addresses = [] as any;
        for (let item of _data["addresses"])
          this.addresses!.push(CustomerAddress.fromJS(item));
      }
      if (Array.isArray(_data["phones"])) {
        this.phones = [] as any;
        for (let item of _data["phones"]) this.phones!.push(item);
      }
      if (Array.isArray(_data["emails"])) {
        this.emails = [] as any;
        for (let item of _data["emails"]) this.emails!.push(item);
      }
      if (Array.isArray(_data["notes"])) {
        this.notes = [] as any;
        for (let item of _data["notes"]) this.notes!.push(Note.fromJS(item));
      }
      if (Array.isArray(_data["groups"])) {
        this.groups = [] as any;
        for (let item of _data["groups"]) this.groups!.push(item);
      }
      if (Array.isArray(_data["dynamicProperties"])) {
        this.dynamicProperties = [] as any;
        for (let item of _data["dynamicProperties"])
          this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
      }
      (<any>this).seoObjectType = _data["seoObjectType"];
      if (Array.isArray(_data["seoInfos"])) {
        this.seoInfos = [] as any;
        for (let item of _data["seoInfos"])
          this.seoInfos!.push(SeoInfo.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Organization {
    data = typeof data === "object" ? data : {};
    let result = new Organization();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["description"] = this.description;
    data["businessCategory"] = this.businessCategory;
    data["ownerId"] = this.ownerId;
    data["parentId"] = this.parentId;
    data["objectType"] = this.objectType;
    data["name"] = this.name;
    data["memberType"] = this.memberType;
    data["outerId"] = this.outerId;
    data["status"] = this.status;
    if (Array.isArray(this.addresses)) {
      data["addresses"] = [];
      for (let item of this.addresses) data["addresses"].push(item.toJSON());
    }
    if (Array.isArray(this.phones)) {
      data["phones"] = [];
      for (let item of this.phones) data["phones"].push(item);
    }
    if (Array.isArray(this.emails)) {
      data["emails"] = [];
      for (let item of this.emails) data["emails"].push(item);
    }
    if (Array.isArray(this.notes)) {
      data["notes"] = [];
      for (let item of this.notes) data["notes"].push(item.toJSON());
    }
    if (Array.isArray(this.groups)) {
      data["groups"] = [];
      for (let item of this.groups) data["groups"].push(item);
    }
    if (Array.isArray(this.dynamicProperties)) {
      data["dynamicProperties"] = [];
      for (let item of this.dynamicProperties)
        data["dynamicProperties"].push(item.toJSON());
    }
    data["seoObjectType"] = this.seoObjectType;
    if (Array.isArray(this.seoInfos)) {
      data["seoInfos"] = [];
      for (let item of this.seoInfos) data["seoInfos"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IOrganization {
  description?: string | undefined;
  businessCategory?: string | undefined;
  ownerId?: string | undefined;
  parentId?: string | undefined;
  objectType?: string | undefined;
  name?: string | undefined;
  memberType?: string | undefined;
  outerId?: string | undefined;
  status?: string | undefined;
  addresses?: CustomerAddress[] | undefined;
  phones?: string[] | undefined;
  emails?: string[] | undefined;
  notes?: Note[] | undefined;
  groups?: string[] | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class MembersSearchCriteria implements IMembersSearchCriteria {
  memberType?: string | undefined;
  memberTypes?: string[] | undefined;
  group?: string | undefined;
  groups?: string[] | undefined;
  memberId?: string | undefined;
  deepSearch?: boolean;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IMembersSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.memberType = _data["memberType"];
      if (Array.isArray(_data["memberTypes"])) {
        this.memberTypes = [] as any;
        for (let item of _data["memberTypes"]) this.memberTypes!.push(item);
      }
      this.group = _data["group"];
      if (Array.isArray(_data["groups"])) {
        this.groups = [] as any;
        for (let item of _data["groups"]) this.groups!.push(item);
      }
      this.memberId = _data["memberId"];
      this.deepSearch = _data["deepSearch"];
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): MembersSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new MembersSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["memberType"] = this.memberType;
    if (Array.isArray(this.memberTypes)) {
      data["memberTypes"] = [];
      for (let item of this.memberTypes) data["memberTypes"].push(item);
    }
    data["group"] = this.group;
    if (Array.isArray(this.groups)) {
      data["groups"] = [];
      for (let item of this.groups) data["groups"].push(item);
    }
    data["memberId"] = this.memberId;
    data["deepSearch"] = this.deepSearch;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IMembersSearchCriteria {
  memberType?: string | undefined;
  memberTypes?: string[] | undefined;
  group?: string | undefined;
  groups?: string[] | undefined;
  memberId?: string | undefined;
  deepSearch?: boolean;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class Member implements IMember {
  name?: string | undefined;
  memberType?: string | undefined;
  outerId?: string | undefined;
  status?: string | undefined;
  addresses?: CustomerAddress[] | undefined;
  phones?: string[] | undefined;
  emails?: string[] | undefined;
  notes?: Note[] | undefined;
  groups?: string[] | undefined;
  readonly objectType?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  readonly seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IMember) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.memberType = _data["memberType"];
      this.outerId = _data["outerId"];
      this.status = _data["status"];
      if (Array.isArray(_data["addresses"])) {
        this.addresses = [] as any;
        for (let item of _data["addresses"])
          this.addresses!.push(CustomerAddress.fromJS(item));
      }
      if (Array.isArray(_data["phones"])) {
        this.phones = [] as any;
        for (let item of _data["phones"]) this.phones!.push(item);
      }
      if (Array.isArray(_data["emails"])) {
        this.emails = [] as any;
        for (let item of _data["emails"]) this.emails!.push(item);
      }
      if (Array.isArray(_data["notes"])) {
        this.notes = [] as any;
        for (let item of _data["notes"]) this.notes!.push(Note.fromJS(item));
      }
      if (Array.isArray(_data["groups"])) {
        this.groups = [] as any;
        for (let item of _data["groups"]) this.groups!.push(item);
      }
      (<any>this).objectType = _data["objectType"];
      if (Array.isArray(_data["dynamicProperties"])) {
        this.dynamicProperties = [] as any;
        for (let item of _data["dynamicProperties"])
          this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
      }
      (<any>this).seoObjectType = _data["seoObjectType"];
      if (Array.isArray(_data["seoInfos"])) {
        this.seoInfos = [] as any;
        for (let item of _data["seoInfos"])
          this.seoInfos!.push(SeoInfo.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Member {
    data = typeof data === "object" ? data : {};
    let result = new Member();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["memberType"] = this.memberType;
    data["outerId"] = this.outerId;
    data["status"] = this.status;
    if (Array.isArray(this.addresses)) {
      data["addresses"] = [];
      for (let item of this.addresses) data["addresses"].push(item.toJSON());
    }
    if (Array.isArray(this.phones)) {
      data["phones"] = [];
      for (let item of this.phones) data["phones"].push(item);
    }
    if (Array.isArray(this.emails)) {
      data["emails"] = [];
      for (let item of this.emails) data["emails"].push(item);
    }
    if (Array.isArray(this.notes)) {
      data["notes"] = [];
      for (let item of this.notes) data["notes"].push(item.toJSON());
    }
    if (Array.isArray(this.groups)) {
      data["groups"] = [];
      for (let item of this.groups) data["groups"].push(item);
    }
    data["objectType"] = this.objectType;
    if (Array.isArray(this.dynamicProperties)) {
      data["dynamicProperties"] = [];
      for (let item of this.dynamicProperties)
        data["dynamicProperties"].push(item.toJSON());
    }
    data["seoObjectType"] = this.seoObjectType;
    if (Array.isArray(this.seoInfos)) {
      data["seoInfos"] = [];
      for (let item of this.seoInfos) data["seoInfos"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IMember {
  name?: string | undefined;
  memberType?: string | undefined;
  outerId?: string | undefined;
  status?: string | undefined;
  addresses?: CustomerAddress[] | undefined;
  phones?: string[] | undefined;
  emails?: string[] | undefined;
  notes?: Note[] | undefined;
  groups?: string[] | undefined;
  objectType?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class MemberSearchResult implements IMemberSearchResult {
  totalCount?: number;
  results?: Member[] | undefined;

  constructor(data?: IMemberSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(Member.fromJS(item));
      }
    }
  }

  static fromJS(data: any): MemberSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new MemberSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IMemberSearchResult {
  totalCount?: number;
  results?: Member[] | undefined;
}

export class Contact implements IContact {
  salutation?: string | undefined;
  fullName?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  birthDate?: Date | undefined;
  defaultLanguage?: string | undefined;
  timeZone?: string | undefined;
  organizations?: string[] | undefined;
  associatedOrganizations?: string[] | undefined;
  taxPayerId?: string | undefined;
  preferredDelivery?: string | undefined;
  preferredCommunication?: string | undefined;
  defaultShippingAddressId?: string | undefined;
  defaultBillingAddressId?: string | undefined;
  photoUrl?: string | undefined;
  readonly objectType?: string | undefined;
  securityAccounts?: ApplicationUser[] | undefined;
  name?: string | undefined;
  memberType?: string | undefined;
  outerId?: string | undefined;
  status?: string | undefined;
  addresses?: CustomerAddress[] | undefined;
  phones?: string[] | undefined;
  emails?: string[] | undefined;
  notes?: Note[] | undefined;
  groups?: string[] | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  readonly seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IContact) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.salutation = _data["salutation"];
      this.fullName = _data["fullName"];
      this.firstName = _data["firstName"];
      this.middleName = _data["middleName"];
      this.lastName = _data["lastName"];
      this.birthDate = _data["birthDate"]
        ? new Date(_data["birthDate"].toString())
        : <any>undefined;
      this.defaultLanguage = _data["defaultLanguage"];
      this.timeZone = _data["timeZone"];
      if (Array.isArray(_data["organizations"])) {
        this.organizations = [] as any;
        for (let item of _data["organizations"]) this.organizations!.push(item);
      }
      if (Array.isArray(_data["associatedOrganizations"])) {
        this.associatedOrganizations = [] as any;
        for (let item of _data["associatedOrganizations"])
          this.associatedOrganizations!.push(item);
      }
      this.taxPayerId = _data["taxPayerId"];
      this.preferredDelivery = _data["preferredDelivery"];
      this.preferredCommunication = _data["preferredCommunication"];
      this.defaultShippingAddressId = _data["defaultShippingAddressId"];
      this.defaultBillingAddressId = _data["defaultBillingAddressId"];
      this.photoUrl = _data["photoUrl"];
      (<any>this).objectType = _data["objectType"];
      if (Array.isArray(_data["securityAccounts"])) {
        this.securityAccounts = [] as any;
        for (let item of _data["securityAccounts"])
          this.securityAccounts!.push(ApplicationUser.fromJS(item));
      }
      this.name = _data["name"];
      this.memberType = _data["memberType"];
      this.outerId = _data["outerId"];
      this.status = _data["status"];
      if (Array.isArray(_data["addresses"])) {
        this.addresses = [] as any;
        for (let item of _data["addresses"])
          this.addresses!.push(CustomerAddress.fromJS(item));
      }
      if (Array.isArray(_data["phones"])) {
        this.phones = [] as any;
        for (let item of _data["phones"]) this.phones!.push(item);
      }
      if (Array.isArray(_data["emails"])) {
        this.emails = [] as any;
        for (let item of _data["emails"]) this.emails!.push(item);
      }
      if (Array.isArray(_data["notes"])) {
        this.notes = [] as any;
        for (let item of _data["notes"]) this.notes!.push(Note.fromJS(item));
      }
      if (Array.isArray(_data["groups"])) {
        this.groups = [] as any;
        for (let item of _data["groups"]) this.groups!.push(item);
      }
      if (Array.isArray(_data["dynamicProperties"])) {
        this.dynamicProperties = [] as any;
        for (let item of _data["dynamicProperties"])
          this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
      }
      (<any>this).seoObjectType = _data["seoObjectType"];
      if (Array.isArray(_data["seoInfos"])) {
        this.seoInfos = [] as any;
        for (let item of _data["seoInfos"])
          this.seoInfos!.push(SeoInfo.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Contact {
    data = typeof data === "object" ? data : {};
    let result = new Contact();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["salutation"] = this.salutation;
    data["fullName"] = this.fullName;
    data["firstName"] = this.firstName;
    data["middleName"] = this.middleName;
    data["lastName"] = this.lastName;
    data["birthDate"] = this.birthDate
      ? this.birthDate.toISOString()
      : <any>undefined;
    data["defaultLanguage"] = this.defaultLanguage;
    data["timeZone"] = this.timeZone;
    if (Array.isArray(this.organizations)) {
      data["organizations"] = [];
      for (let item of this.organizations) data["organizations"].push(item);
    }
    if (Array.isArray(this.associatedOrganizations)) {
      data["associatedOrganizations"] = [];
      for (let item of this.associatedOrganizations)
        data["associatedOrganizations"].push(item);
    }
    data["taxPayerId"] = this.taxPayerId;
    data["preferredDelivery"] = this.preferredDelivery;
    data["preferredCommunication"] = this.preferredCommunication;
    data["defaultShippingAddressId"] = this.defaultShippingAddressId;
    data["defaultBillingAddressId"] = this.defaultBillingAddressId;
    data["photoUrl"] = this.photoUrl;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.securityAccounts)) {
      data["securityAccounts"] = [];
      for (let item of this.securityAccounts)
        data["securityAccounts"].push(item.toJSON());
    }
    data["name"] = this.name;
    data["memberType"] = this.memberType;
    data["outerId"] = this.outerId;
    data["status"] = this.status;
    if (Array.isArray(this.addresses)) {
      data["addresses"] = [];
      for (let item of this.addresses) data["addresses"].push(item.toJSON());
    }
    if (Array.isArray(this.phones)) {
      data["phones"] = [];
      for (let item of this.phones) data["phones"].push(item);
    }
    if (Array.isArray(this.emails)) {
      data["emails"] = [];
      for (let item of this.emails) data["emails"].push(item);
    }
    if (Array.isArray(this.notes)) {
      data["notes"] = [];
      for (let item of this.notes) data["notes"].push(item.toJSON());
    }
    if (Array.isArray(this.groups)) {
      data["groups"] = [];
      for (let item of this.groups) data["groups"].push(item);
    }
    if (Array.isArray(this.dynamicProperties)) {
      data["dynamicProperties"] = [];
      for (let item of this.dynamicProperties)
        data["dynamicProperties"].push(item.toJSON());
    }
    data["seoObjectType"] = this.seoObjectType;
    if (Array.isArray(this.seoInfos)) {
      data["seoInfos"] = [];
      for (let item of this.seoInfos) data["seoInfos"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IContact {
  salutation?: string | undefined;
  fullName?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  birthDate?: Date | undefined;
  defaultLanguage?: string | undefined;
  timeZone?: string | undefined;
  organizations?: string[] | undefined;
  associatedOrganizations?: string[] | undefined;
  taxPayerId?: string | undefined;
  preferredDelivery?: string | undefined;
  preferredCommunication?: string | undefined;
  defaultShippingAddressId?: string | undefined;
  defaultBillingAddressId?: string | undefined;
  photoUrl?: string | undefined;
  objectType?: string | undefined;
  securityAccounts?: ApplicationUser[] | undefined;
  name?: string | undefined;
  memberType?: string | undefined;
  outerId?: string | undefined;
  status?: string | undefined;
  addresses?: CustomerAddress[] | undefined;
  phones?: string[] | undefined;
  emails?: string[] | undefined;
  notes?: Note[] | undefined;
  groups?: string[] | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class OrganizationSearchResult implements IOrganizationSearchResult {
  totalCount?: number;
  results?: Organization[] | undefined;

  constructor(data?: IOrganizationSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(Organization.fromJS(item));
      }
    }
  }

  static fromJS(data: any): OrganizationSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new OrganizationSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IOrganizationSearchResult {
  totalCount?: number;
  results?: Organization[] | undefined;
}

export class ContactSearchResult implements IContactSearchResult {
  totalCount?: number;
  results?: Contact[] | undefined;

  constructor(data?: IContactSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(Contact.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ContactSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new ContactSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IContactSearchResult {
  totalCount?: number;
  results?: Contact[] | undefined;
}

export class Vendor implements IVendor {
  description?: string | undefined;
  siteUrl?: string | undefined;
  logoUrl?: string | undefined;
  groupName?: string | undefined;
  readonly objectType?: string | undefined;
  name?: string | undefined;
  memberType?: string | undefined;
  outerId?: string | undefined;
  status?: string | undefined;
  addresses?: CustomerAddress[] | undefined;
  phones?: string[] | undefined;
  emails?: string[] | undefined;
  notes?: Note[] | undefined;
  groups?: string[] | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  readonly seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IVendor) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data["description"];
      this.siteUrl = _data["siteUrl"];
      this.logoUrl = _data["logoUrl"];
      this.groupName = _data["groupName"];
      (<any>this).objectType = _data["objectType"];
      this.name = _data["name"];
      this.memberType = _data["memberType"];
      this.outerId = _data["outerId"];
      this.status = _data["status"];
      if (Array.isArray(_data["addresses"])) {
        this.addresses = [] as any;
        for (let item of _data["addresses"])
          this.addresses!.push(CustomerAddress.fromJS(item));
      }
      if (Array.isArray(_data["phones"])) {
        this.phones = [] as any;
        for (let item of _data["phones"]) this.phones!.push(item);
      }
      if (Array.isArray(_data["emails"])) {
        this.emails = [] as any;
        for (let item of _data["emails"]) this.emails!.push(item);
      }
      if (Array.isArray(_data["notes"])) {
        this.notes = [] as any;
        for (let item of _data["notes"]) this.notes!.push(Note.fromJS(item));
      }
      if (Array.isArray(_data["groups"])) {
        this.groups = [] as any;
        for (let item of _data["groups"]) this.groups!.push(item);
      }
      if (Array.isArray(_data["dynamicProperties"])) {
        this.dynamicProperties = [] as any;
        for (let item of _data["dynamicProperties"])
          this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
      }
      (<any>this).seoObjectType = _data["seoObjectType"];
      if (Array.isArray(_data["seoInfos"])) {
        this.seoInfos = [] as any;
        for (let item of _data["seoInfos"])
          this.seoInfos!.push(SeoInfo.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Vendor {
    data = typeof data === "object" ? data : {};
    let result = new Vendor();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["description"] = this.description;
    data["siteUrl"] = this.siteUrl;
    data["logoUrl"] = this.logoUrl;
    data["groupName"] = this.groupName;
    data["objectType"] = this.objectType;
    data["name"] = this.name;
    data["memberType"] = this.memberType;
    data["outerId"] = this.outerId;
    data["status"] = this.status;
    if (Array.isArray(this.addresses)) {
      data["addresses"] = [];
      for (let item of this.addresses) data["addresses"].push(item.toJSON());
    }
    if (Array.isArray(this.phones)) {
      data["phones"] = [];
      for (let item of this.phones) data["phones"].push(item);
    }
    if (Array.isArray(this.emails)) {
      data["emails"] = [];
      for (let item of this.emails) data["emails"].push(item);
    }
    if (Array.isArray(this.notes)) {
      data["notes"] = [];
      for (let item of this.notes) data["notes"].push(item.toJSON());
    }
    if (Array.isArray(this.groups)) {
      data["groups"] = [];
      for (let item of this.groups) data["groups"].push(item);
    }
    if (Array.isArray(this.dynamicProperties)) {
      data["dynamicProperties"] = [];
      for (let item of this.dynamicProperties)
        data["dynamicProperties"].push(item.toJSON());
    }
    data["seoObjectType"] = this.seoObjectType;
    if (Array.isArray(this.seoInfos)) {
      data["seoInfos"] = [];
      for (let item of this.seoInfos) data["seoInfos"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IVendor {
  description?: string | undefined;
  siteUrl?: string | undefined;
  logoUrl?: string | undefined;
  groupName?: string | undefined;
  objectType?: string | undefined;
  name?: string | undefined;
  memberType?: string | undefined;
  outerId?: string | undefined;
  status?: string | undefined;
  addresses?: CustomerAddress[] | undefined;
  phones?: string[] | undefined;
  emails?: string[] | undefined;
  notes?: Note[] | undefined;
  groups?: string[] | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class VendorSearchResult implements IVendorSearchResult {
  readonly vendors?: Vendor[] | undefined;
  totalCount?: number;
  results?: Vendor[] | undefined;

  constructor(data?: IVendorSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["vendors"])) {
        (<any>this).vendors = [] as any;
        for (let item of _data["vendors"])
          (<any>this).vendors!.push(Vendor.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(Vendor.fromJS(item));
      }
    }
  }

  static fromJS(data: any): VendorSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new VendorSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.vendors)) {
      data["vendors"] = [];
      for (let item of this.vendors) data["vendors"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IVendorSearchResult {
  vendors?: Vendor[] | undefined;
  totalCount?: number;
  results?: Vendor[] | undefined;
}

export class Employee implements IEmployee {
  salutation?: string | undefined;
  fullName?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  birthDate?: Date | undefined;
  defaultLanguage?: string | undefined;
  timeZone?: string | undefined;
  organizations?: string[] | undefined;
  employeeType?: string | undefined;
  isActive?: boolean;
  photoUrl?: string | undefined;
  readonly objectType?: string | undefined;
  securityAccounts?: ApplicationUser[] | undefined;
  name?: string | undefined;
  memberType?: string | undefined;
  outerId?: string | undefined;
  status?: string | undefined;
  addresses?: CustomerAddress[] | undefined;
  phones?: string[] | undefined;
  emails?: string[] | undefined;
  notes?: Note[] | undefined;
  groups?: string[] | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  readonly seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IEmployee) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.salutation = _data["salutation"];
      this.fullName = _data["fullName"];
      this.firstName = _data["firstName"];
      this.middleName = _data["middleName"];
      this.lastName = _data["lastName"];
      this.birthDate = _data["birthDate"]
        ? new Date(_data["birthDate"].toString())
        : <any>undefined;
      this.defaultLanguage = _data["defaultLanguage"];
      this.timeZone = _data["timeZone"];
      if (Array.isArray(_data["organizations"])) {
        this.organizations = [] as any;
        for (let item of _data["organizations"]) this.organizations!.push(item);
      }
      this.employeeType = _data["employeeType"];
      this.isActive = _data["isActive"];
      this.photoUrl = _data["photoUrl"];
      (<any>this).objectType = _data["objectType"];
      if (Array.isArray(_data["securityAccounts"])) {
        this.securityAccounts = [] as any;
        for (let item of _data["securityAccounts"])
          this.securityAccounts!.push(ApplicationUser.fromJS(item));
      }
      this.name = _data["name"];
      this.memberType = _data["memberType"];
      this.outerId = _data["outerId"];
      this.status = _data["status"];
      if (Array.isArray(_data["addresses"])) {
        this.addresses = [] as any;
        for (let item of _data["addresses"])
          this.addresses!.push(CustomerAddress.fromJS(item));
      }
      if (Array.isArray(_data["phones"])) {
        this.phones = [] as any;
        for (let item of _data["phones"]) this.phones!.push(item);
      }
      if (Array.isArray(_data["emails"])) {
        this.emails = [] as any;
        for (let item of _data["emails"]) this.emails!.push(item);
      }
      if (Array.isArray(_data["notes"])) {
        this.notes = [] as any;
        for (let item of _data["notes"]) this.notes!.push(Note.fromJS(item));
      }
      if (Array.isArray(_data["groups"])) {
        this.groups = [] as any;
        for (let item of _data["groups"]) this.groups!.push(item);
      }
      if (Array.isArray(_data["dynamicProperties"])) {
        this.dynamicProperties = [] as any;
        for (let item of _data["dynamicProperties"])
          this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
      }
      (<any>this).seoObjectType = _data["seoObjectType"];
      if (Array.isArray(_data["seoInfos"])) {
        this.seoInfos = [] as any;
        for (let item of _data["seoInfos"])
          this.seoInfos!.push(SeoInfo.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Employee {
    data = typeof data === "object" ? data : {};
    let result = new Employee();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["salutation"] = this.salutation;
    data["fullName"] = this.fullName;
    data["firstName"] = this.firstName;
    data["middleName"] = this.middleName;
    data["lastName"] = this.lastName;
    data["birthDate"] = this.birthDate
      ? this.birthDate.toISOString()
      : <any>undefined;
    data["defaultLanguage"] = this.defaultLanguage;
    data["timeZone"] = this.timeZone;
    if (Array.isArray(this.organizations)) {
      data["organizations"] = [];
      for (let item of this.organizations) data["organizations"].push(item);
    }
    data["employeeType"] = this.employeeType;
    data["isActive"] = this.isActive;
    data["photoUrl"] = this.photoUrl;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.securityAccounts)) {
      data["securityAccounts"] = [];
      for (let item of this.securityAccounts)
        data["securityAccounts"].push(item.toJSON());
    }
    data["name"] = this.name;
    data["memberType"] = this.memberType;
    data["outerId"] = this.outerId;
    data["status"] = this.status;
    if (Array.isArray(this.addresses)) {
      data["addresses"] = [];
      for (let item of this.addresses) data["addresses"].push(item.toJSON());
    }
    if (Array.isArray(this.phones)) {
      data["phones"] = [];
      for (let item of this.phones) data["phones"].push(item);
    }
    if (Array.isArray(this.emails)) {
      data["emails"] = [];
      for (let item of this.emails) data["emails"].push(item);
    }
    if (Array.isArray(this.notes)) {
      data["notes"] = [];
      for (let item of this.notes) data["notes"].push(item.toJSON());
    }
    if (Array.isArray(this.groups)) {
      data["groups"] = [];
      for (let item of this.groups) data["groups"].push(item);
    }
    if (Array.isArray(this.dynamicProperties)) {
      data["dynamicProperties"] = [];
      for (let item of this.dynamicProperties)
        data["dynamicProperties"].push(item.toJSON());
    }
    data["seoObjectType"] = this.seoObjectType;
    if (Array.isArray(this.seoInfos)) {
      data["seoInfos"] = [];
      for (let item of this.seoInfos) data["seoInfos"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IEmployee {
  salutation?: string | undefined;
  fullName?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  birthDate?: Date | undefined;
  defaultLanguage?: string | undefined;
  timeZone?: string | undefined;
  organizations?: string[] | undefined;
  employeeType?: string | undefined;
  isActive?: boolean;
  photoUrl?: string | undefined;
  objectType?: string | undefined;
  securityAccounts?: ApplicationUser[] | undefined;
  name?: string | undefined;
  memberType?: string | undefined;
  outerId?: string | undefined;
  status?: string | undefined;
  addresses?: CustomerAddress[] | undefined;
  phones?: string[] | undefined;
  emails?: string[] | undefined;
  notes?: Note[] | undefined;
  groups?: string[] | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class AssociationSearchCriteria implements IAssociationSearchCriteria {
  storeIds?: string[] | undefined;
  groups?: string[] | undefined;
  isActive?: boolean | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IAssociationSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["storeIds"])) {
        this.storeIds = [] as any;
        for (let item of _data["storeIds"]) this.storeIds!.push(item);
      }
      if (Array.isArray(_data["groups"])) {
        this.groups = [] as any;
        for (let item of _data["groups"]) this.groups!.push(item);
      }
      this.isActive = _data["isActive"];
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): AssociationSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new AssociationSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.storeIds)) {
      data["storeIds"] = [];
      for (let item of this.storeIds) data["storeIds"].push(item);
    }
    if (Array.isArray(this.groups)) {
      data["groups"] = [];
      for (let item of this.groups) data["groups"].push(item);
    }
    data["isActive"] = this.isActive;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IAssociationSearchCriteria {
  storeIds?: string[] | undefined;
  groups?: string[] | undefined;
  isActive?: boolean | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class AssociationRuleTree implements IAssociationRuleTree {
  readonly id?: string | undefined;
  availableChildren?: IConditionTree[] | undefined;
  children?: IConditionTree[] | undefined;

  constructor(data?: IAssociationRuleTree) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).id = _data["id"];
      if (Array.isArray(_data["availableChildren"])) {
        this.availableChildren = [] as any;
        for (let item of _data["availableChildren"])
          this.availableChildren!.push(IConditionTree.fromJS(item));
      }
      if (Array.isArray(_data["children"])) {
        this.children = [] as any;
        for (let item of _data["children"])
          this.children!.push(IConditionTree.fromJS(item));
      }
    }
  }

  static fromJS(data: any): AssociationRuleTree {
    data = typeof data === "object" ? data : {};
    let result = new AssociationRuleTree();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    if (Array.isArray(this.availableChildren)) {
      data["availableChildren"] = [];
      for (let item of this.availableChildren)
        data["availableChildren"].push(item.toJSON());
    }
    if (Array.isArray(this.children)) {
      data["children"] = [];
      for (let item of this.children) data["children"].push(item.toJSON());
    }
    return data;
  }
}

export interface IAssociationRuleTree {
  id?: string | undefined;
  availableChildren?: IConditionTree[] | undefined;
  children?: IConditionTree[] | undefined;
}

export class Association implements IAssociation {
  associationType?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  isActive?: boolean;
  storeId?: string | undefined;
  priority?: number;
  outerId?: string | undefined;
  expressionTree?: AssociationRuleTree;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IAssociation) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.associationType = _data["associationType"];
      this.name = _data["name"];
      this.description = _data["description"];
      this.startDate = _data["startDate"]
        ? new Date(_data["startDate"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? new Date(_data["endDate"].toString())
        : <any>undefined;
      this.isActive = _data["isActive"];
      this.storeId = _data["storeId"];
      this.priority = _data["priority"];
      this.outerId = _data["outerId"];
      this.expressionTree = _data["expressionTree"]
        ? AssociationRuleTree.fromJS(_data["expressionTree"])
        : <any>undefined;
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Association {
    data = typeof data === "object" ? data : {};
    let result = new Association();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["associationType"] = this.associationType;
    data["name"] = this.name;
    data["description"] = this.description;
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    data["isActive"] = this.isActive;
    data["storeId"] = this.storeId;
    data["priority"] = this.priority;
    data["outerId"] = this.outerId;
    data["expressionTree"] = this.expressionTree
      ? this.expressionTree.toJSON()
      : <any>undefined;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IAssociation {
  associationType?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  isActive?: boolean;
  storeId?: string | undefined;
  priority?: number;
  outerId?: string | undefined;
  expressionTree?: AssociationRuleTree;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class AssociationSearchResult implements IAssociationSearchResult {
  totalCount?: number;
  results?: Association[] | undefined;

  constructor(data?: IAssociationSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(Association.fromJS(item));
      }
    }
  }

  static fromJS(data: any): AssociationSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new AssociationSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IAssociationSearchResult {
  totalCount?: number;
  results?: Association[] | undefined;
}

export class AssociationEvaluationContext
  implements IAssociationEvaluationContext
{
  storeId?: string | undefined;
  productsToMatch?: string[] | undefined;
  group?: string | undefined;
  take?: number;
  skip?: number;

  constructor(data?: IAssociationEvaluationContext) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.storeId = _data["storeId"];
      if (Array.isArray(_data["productsToMatch"])) {
        this.productsToMatch = [] as any;
        for (let item of _data["productsToMatch"])
          this.productsToMatch!.push(item);
      }
      this.group = _data["group"];
      this.take = _data["take"];
      this.skip = _data["skip"];
    }
  }

  static fromJS(data: any): AssociationEvaluationContext {
    data = typeof data === "object" ? data : {};
    let result = new AssociationEvaluationContext();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["storeId"] = this.storeId;
    if (Array.isArray(this.productsToMatch)) {
      data["productsToMatch"] = [];
      for (let item of this.productsToMatch) data["productsToMatch"].push(item);
    }
    data["group"] = this.group;
    data["take"] = this.take;
    data["skip"] = this.skip;
    return data;
  }
}

export interface IAssociationEvaluationContext {
  storeId?: string | undefined;
  productsToMatch?: string[] | undefined;
  group?: string | undefined;
  take?: number;
  skip?: number;
}

export class AssociationConditionEvaluationRequest
  implements IAssociationConditionEvaluationRequest
{
  keyword?: string | undefined;
  catalogId?: string | undefined;
  categoryIds?: string[] | undefined;
  propertyValues?: { [key: string]: string[] } | undefined;
  sort?: string | undefined;
  take?: number;
  skip?: number;

  constructor(data?: IAssociationConditionEvaluationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.keyword = _data["keyword"];
      this.catalogId = _data["catalogId"];
      if (Array.isArray(_data["categoryIds"])) {
        this.categoryIds = [] as any;
        for (let item of _data["categoryIds"]) this.categoryIds!.push(item);
      }
      if (_data["propertyValues"]) {
        this.propertyValues = {} as any;
        for (let key in _data["propertyValues"]) {
          if (_data["propertyValues"].hasOwnProperty(key))
            (<any>this.propertyValues)![key] =
              _data["propertyValues"][key] !== undefined
                ? _data["propertyValues"][key]
                : [];
        }
      }
      this.sort = _data["sort"];
      this.take = _data["take"];
      this.skip = _data["skip"];
    }
  }

  static fromJS(data: any): AssociationConditionEvaluationRequest {
    data = typeof data === "object" ? data : {};
    let result = new AssociationConditionEvaluationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["keyword"] = this.keyword;
    data["catalogId"] = this.catalogId;
    if (Array.isArray(this.categoryIds)) {
      data["categoryIds"] = [];
      for (let item of this.categoryIds) data["categoryIds"].push(item);
    }
    if (this.propertyValues) {
      data["propertyValues"] = {};
      for (let key in this.propertyValues) {
        if (this.propertyValues.hasOwnProperty(key))
          (<any>data["propertyValues"])[key] = this.propertyValues[key];
      }
    }
    data["sort"] = this.sort;
    data["take"] = this.take;
    data["skip"] = this.skip;
    return data;
  }
}

export interface IAssociationConditionEvaluationRequest {
  keyword?: string | undefined;
  catalogId?: string | undefined;
  categoryIds?: string[] | undefined;
  propertyValues?: { [key: string]: string[] } | undefined;
  sort?: string | undefined;
  take?: number;
  skip?: number;
}

/** Export property information */
export class ExportedTypePropertyInfo implements IExportedTypePropertyInfo {
  /** Property name with the path from the exportable entity (e.g. for entity containing PropertyA with nested properties it could be "PropertyA.PropertyB.PropertyC"). */
  fullName?: string | undefined;
  /** Property group. Properties can be divided into different groups to simplify selection.
  Group could be used for grouping property infos. */
  group?: string | undefined;
  /** User-friendly name for this property */
  displayName?: string | undefined;
  /** * Reserved for future use */
  isRequired?: boolean;

  constructor(data?: IExportedTypePropertyInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fullName = _data["fullName"];
      this.group = _data["group"];
      this.displayName = _data["displayName"];
      this.isRequired = _data["isRequired"];
    }
  }

  static fromJS(data: any): ExportedTypePropertyInfo {
    data = typeof data === "object" ? data : {};
    let result = new ExportedTypePropertyInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["fullName"] = this.fullName;
    data["group"] = this.group;
    data["displayName"] = this.displayName;
    data["isRequired"] = this.isRequired;
    return data;
  }
}

/** Export property information */
export interface IExportedTypePropertyInfo {
  /** Property name with the path from the exportable entity (e.g. for entity containing PropertyA with nested properties it could be "PropertyA.PropertyB.PropertyC"). */
  fullName?: string | undefined;
  /** Property group. Properties can be divided into different groups to simplify selection.
  Group could be used for grouping property infos. */
  group?: string | undefined;
  /** User-friendly name for this property */
  displayName?: string | undefined;
  /** * Reserved for future use */
  isRequired?: boolean;
}

/** Metadata for exported type: properties information and version */
export class ExportedTypeMetadata implements IExportedTypeMetadata {
  version?: string | undefined;
  /** Exportable property infos array */
  propertyInfos?: ExportedTypePropertyInfo[] | undefined;

  constructor(data?: IExportedTypeMetadata) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.version = _data["version"];
      if (Array.isArray(_data["propertyInfos"])) {
        this.propertyInfos = [] as any;
        for (let item of _data["propertyInfos"])
          this.propertyInfos!.push(ExportedTypePropertyInfo.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ExportedTypeMetadata {
    data = typeof data === "object" ? data : {};
    let result = new ExportedTypeMetadata();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["version"] = this.version;
    if (Array.isArray(this.propertyInfos)) {
      data["propertyInfos"] = [];
      for (let item of this.propertyInfos)
        data["propertyInfos"].push(item.toJSON());
    }
    return data;
  }
}

/** Metadata for exported type: properties information and version */
export interface IExportedTypeMetadata {
  version?: string | undefined;
  /** Exportable property infos array */
  propertyInfos?: ExportedTypePropertyInfo[] | undefined;
}

/** Definition of exported entity type */
export class ExportedTypeDefinition implements IExportedTypeDefinition {
  /** Logical type name, given during registration. It could be non-equal to exportable type name. */
  typeName?: string | undefined;
  /** Logical group name. Entity types can be divided into different groups to simplify selection. */
  group?: string | undefined;
  metaData?: ExportedTypeMetadata;
  tabularMetaData?: ExportedTypeMetadata;
  /** Specific type name with which we could query exported type data. */
  exportDataQueryType?: string | undefined;
  /** Returns true if tabular export supported, VirtoCommerce.ExportModule.Core.Model.ExportedTypeDefinition.TabularMetaData is set . */
  readonly isTabularExportSupported?: boolean;
  /** Restrict access to select data for export */
  restrictDataSelectivity?: boolean;

  constructor(data?: IExportedTypeDefinition) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.typeName = _data["typeName"];
      this.group = _data["group"];
      this.metaData = _data["metaData"]
        ? ExportedTypeMetadata.fromJS(_data["metaData"])
        : <any>undefined;
      this.tabularMetaData = _data["tabularMetaData"]
        ? ExportedTypeMetadata.fromJS(_data["tabularMetaData"])
        : <any>undefined;
      this.exportDataQueryType = _data["exportDataQueryType"];
      (<any>this).isTabularExportSupported = _data["isTabularExportSupported"];
      this.restrictDataSelectivity = _data["restrictDataSelectivity"];
    }
  }

  static fromJS(data: any): ExportedTypeDefinition {
    data = typeof data === "object" ? data : {};
    let result = new ExportedTypeDefinition();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["typeName"] = this.typeName;
    data["group"] = this.group;
    data["metaData"] = this.metaData ? this.metaData.toJSON() : <any>undefined;
    data["tabularMetaData"] = this.tabularMetaData
      ? this.tabularMetaData.toJSON()
      : <any>undefined;
    data["exportDataQueryType"] = this.exportDataQueryType;
    data["isTabularExportSupported"] = this.isTabularExportSupported;
    data["restrictDataSelectivity"] = this.restrictDataSelectivity;
    return data;
  }
}

/** Definition of exported entity type */
export interface IExportedTypeDefinition {
  /** Logical type name, given during registration. It could be non-equal to exportable type name. */
  typeName?: string | undefined;
  /** Logical group name. Entity types can be divided into different groups to simplify selection. */
  group?: string | undefined;
  metaData?: ExportedTypeMetadata;
  tabularMetaData?: ExportedTypeMetadata;
  /** Specific type name with which we could query exported type data. */
  exportDataQueryType?: string | undefined;
  /** Returns true if tabular export supported, VirtoCommerce.ExportModule.Core.Model.ExportedTypeDefinition.TabularMetaData is set . */
  isTabularExportSupported?: boolean;
  /** Restrict access to select data for export */
  restrictDataSelectivity?: boolean;
}

export class IExportProviderConfiguration
  implements IIExportProviderConfiguration
{
  /** Type discriminator to instantiate proper descendant (e.g. thru the universal PolymorphJsonConverter) */
  type?: string | undefined;

  constructor(data?: IIExportProviderConfiguration) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data["type"];
    }
  }

  static fromJS(data: any): IExportProviderConfiguration {
    data = typeof data === "object" ? data : {};
    let result = new IExportProviderConfiguration();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["type"] = this.type;
    return data;
  }
}

export interface IIExportProviderConfiguration {
  /** Type discriminator to instantiate proper descendant (e.g. thru the universal PolymorphJsonConverter) */
  type?: string | undefined;
}

/** Interface for export provider implementation. The export provider allows to write object using the given TextWriter. */
export class IExportProvider implements IIExportProvider {
  /** Provider name. */
  readonly typeName?: string | undefined;
  /** Extension for resulting export file. */
  readonly exportedFileExtension?: string | undefined;
  /** Returns true if provider supports only plain tabular objects (without nested entities). */
  readonly isTabular?: boolean;
  configuration?: IExportProviderConfiguration;

  constructor(data?: IIExportProvider) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).typeName = _data["typeName"];
      (<any>this).exportedFileExtension = _data["exportedFileExtension"];
      (<any>this).isTabular = _data["isTabular"];
      this.configuration = _data["configuration"]
        ? IExportProviderConfiguration.fromJS(_data["configuration"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): IExportProvider {
    data = typeof data === "object" ? data : {};
    let result = new IExportProvider();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["typeName"] = this.typeName;
    data["exportedFileExtension"] = this.exportedFileExtension;
    data["isTabular"] = this.isTabular;
    data["configuration"] = this.configuration
      ? this.configuration.toJSON()
      : <any>undefined;
    return data;
  }
}

/** Interface for export provider implementation. The export provider allows to write object using the given TextWriter. */
export interface IIExportProvider {
  /** Provider name. */
  typeName?: string | undefined;
  /** Extension for resulting export file. */
  exportedFileExtension?: string | undefined;
  /** Returns true if provider supports only plain tabular objects (without nested entities). */
  isTabular?: boolean;
  configuration?: IExportProviderConfiguration;
}

/** Basic query information for data sources to retrieve exported data: included properties, paging, sorting, etc... Applied data sources expand it by adding certain criteria (for example, additional information for searching) */
export class ExportDataQuery implements IExportDataQuery {
  /** This used to instantiate a data query of this type at export start. */
  readonly exportTypeName?: string | undefined;
  /** Keyword to search data */
  keyword?: string | undefined;
  /** Object keys to search data */
  objectIds?: string[] | undefined;
  /** How to sort the dataset matching a query */
  sort?: string | undefined;
  /** User selected properties to export */
  includedProperties?: ExportedTypePropertyInfo[] | undefined;
  /** Paging: skip records */
  skip?: number | undefined;
  /** Paging: records in one page */
  take?: number | undefined;
  /** True means preview (lightweight) data is queried, false - full version requested */
  isPreview?: boolean;

  constructor(data?: IExportDataQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).exportTypeName = _data["exportTypeName"];
      this.keyword = _data["keyword"];
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.sort = _data["sort"];
      if (Array.isArray(_data["includedProperties"])) {
        this.includedProperties = [] as any;
        for (let item of _data["includedProperties"])
          this.includedProperties!.push(ExportedTypePropertyInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
      this.isPreview = _data["isPreview"];
    }
  }

  static fromJS(data: any): ExportDataQuery {
    data = typeof data === "object" ? data : {};
    let result = new ExportDataQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["exportTypeName"] = this.exportTypeName;
    data["keyword"] = this.keyword;
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["sort"] = this.sort;
    if (Array.isArray(this.includedProperties)) {
      data["includedProperties"] = [];
      for (let item of this.includedProperties)
        data["includedProperties"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    data["isPreview"] = this.isPreview;
    return data;
  }
}

/** Basic query information for data sources to retrieve exported data: included properties, paging, sorting, etc... Applied data sources expand it by adding certain criteria (for example, additional information for searching) */
export interface IExportDataQuery {
  /** This used to instantiate a data query of this type at export start. */
  exportTypeName?: string | undefined;
  /** Keyword to search data */
  keyword?: string | undefined;
  /** Object keys to search data */
  objectIds?: string[] | undefined;
  /** How to sort the dataset matching a query */
  sort?: string | undefined;
  /** User selected properties to export */
  includedProperties?: ExportedTypePropertyInfo[] | undefined;
  /** Paging: skip records */
  skip?: number | undefined;
  /** Paging: records in one page */
  take?: number | undefined;
  /** True means preview (lightweight) data is queried, false - full version requested */
  isPreview?: boolean;
}

/** Incapsulates data required to start export: export type, query for data to export, provider to record */
export class ExportDataRequest implements IExportDataRequest {
  /** Full type name of exportable entity */
  exportTypeName?: string | undefined;
  dataQuery?: ExportDataQuery;
  providerConfig?: IExportProviderConfiguration;
  /** Selected export provider name */
  providerName?: string | undefined;

  constructor(data?: IExportDataRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.exportTypeName = _data["exportTypeName"];
      this.dataQuery = _data["dataQuery"]
        ? ExportDataQuery.fromJS(_data["dataQuery"])
        : <any>undefined;
      this.providerConfig = _data["providerConfig"]
        ? IExportProviderConfiguration.fromJS(_data["providerConfig"])
        : <any>undefined;
      this.providerName = _data["providerName"];
    }
  }

  static fromJS(data: any): ExportDataRequest {
    data = typeof data === "object" ? data : {};
    let result = new ExportDataRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["exportTypeName"] = this.exportTypeName;
    data["dataQuery"] = this.dataQuery
      ? this.dataQuery.toJSON()
      : <any>undefined;
    data["providerConfig"] = this.providerConfig
      ? this.providerConfig.toJSON()
      : <any>undefined;
    data["providerName"] = this.providerName;
    return data;
  }
}

/** Incapsulates data required to start export: export type, query for data to export, provider to record */
export interface IExportDataRequest {
  /** Full type name of exportable entity */
  exportTypeName?: string | undefined;
  dataQuery?: ExportDataQuery;
  providerConfig?: IExportProviderConfiguration;
  /** Selected export provider name */
  providerName?: string | undefined;
}

/** Interface to implement exportаble entities. */
export class IExportable implements IIExportable {
  id?: string | undefined;

  constructor(data?: IIExportable) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): IExportable {
    data = typeof data === "object" ? data : {};
    let result = new IExportable();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    return data;
  }
}

/** Interface to implement exportаble entities. */
export interface IIExportable {
  id?: string | undefined;
}

/** Exportable entities search result. */
export class ExportableSearchResult implements IExportableSearchResult {
  totalCount?: number;
  results?: IExportable[] | undefined;

  constructor(data?: IExportableSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(IExportable.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ExportableSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new ExportableSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

/** Exportable entities search result. */
export interface IExportableSearchResult {
  totalCount?: number;
  results?: IExportable[] | undefined;
}

export class PlatformExportPushNotification
  implements IPlatformExportPushNotification
{
  downloadUrl?: string | undefined;
  jobId?: string | undefined;
  finished?: Date | undefined;
  totalCount?: number;
  processedCount?: number;
  readonly errorCount?: number;
  errors?: string[] | undefined;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;

  constructor(data?: IPlatformExportPushNotification) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.downloadUrl = _data["downloadUrl"];
      this.jobId = _data["jobId"];
      this.finished = _data["finished"]
        ? new Date(_data["finished"].toString())
        : <any>undefined;
      this.totalCount = _data["totalCount"];
      this.processedCount = _data["processedCount"];
      (<any>this).errorCount = _data["errorCount"];
      if (Array.isArray(_data["errors"])) {
        this.errors = [] as any;
        for (let item of _data["errors"]) this.errors!.push(item);
      }
      this.serverId = _data["serverId"];
      this.creator = _data["creator"];
      this.created = _data["created"]
        ? new Date(_data["created"].toString())
        : <any>undefined;
      this.isNew = _data["isNew"];
      this.notifyType = _data["notifyType"];
      this.description = _data["description"];
      this.title = _data["title"];
      this.repeatCount = _data["repeatCount"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): PlatformExportPushNotification {
    data = typeof data === "object" ? data : {};
    let result = new PlatformExportPushNotification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["downloadUrl"] = this.downloadUrl;
    data["jobId"] = this.jobId;
    data["finished"] = this.finished
      ? this.finished.toISOString()
      : <any>undefined;
    data["totalCount"] = this.totalCount;
    data["processedCount"] = this.processedCount;
    data["errorCount"] = this.errorCount;
    if (Array.isArray(this.errors)) {
      data["errors"] = [];
      for (let item of this.errors) data["errors"].push(item);
    }
    data["serverId"] = this.serverId;
    data["creator"] = this.creator;
    data["created"] = this.created
      ? this.created.toISOString()
      : <any>undefined;
    data["isNew"] = this.isNew;
    data["notifyType"] = this.notifyType;
    data["description"] = this.description;
    data["title"] = this.title;
    data["repeatCount"] = this.repeatCount;
    data["id"] = this.id;
    return data;
  }
}

export interface IPlatformExportPushNotification {
  downloadUrl?: string | undefined;
  jobId?: string | undefined;
  finished?: Date | undefined;
  totalCount?: number;
  processedCount?: number;
  errorCount?: number;
  errors?: string[] | undefined;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;
}

export class ExportCancellationRequest implements IExportCancellationRequest {
  jobId?: string | undefined;

  constructor(data?: IExportCancellationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.jobId = _data["jobId"];
    }
  }

  static fromJS(data: any): ExportCancellationRequest {
    data = typeof data === "object" ? data : {};
    let result = new ExportCancellationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["jobId"] = this.jobId;
    return data;
  }
}

export interface IExportCancellationRequest {
  jobId?: string | undefined;
}

export enum ResizeMethod {
  FixedSize = "FixedSize",
  FixedWidth = "FixedWidth",
  FixedHeight = "FixedHeight",
  Crop = "Crop",
}

export enum AnchorPosition {
  TopLeft = "TopLeft",
  TopCenter = "TopCenter",
  TopRight = "TopRight",
  CenterLeft = "CenterLeft",
  Center = "Center",
  CenterRight = "CenterRight",
  BottomLeft = "BottomLeft",
  BottomCenter = "BottomCenter",
  BottomRight = "BottomRight",
}

export enum JpegQuality {
  Low = "Low",
  Medium = "Medium",
  High = "High",
  VeryHigh = "VeryHigh",
}

export class ThumbnailOption implements IThumbnailOption {
  name?: string | undefined;
  fileSuffix?: string | undefined;
  resizeMethod?: ResizeMethod;
  width?: number | undefined;
  height?: number | undefined;
  backgroundColor?: string | undefined;
  anchorPosition?: AnchorPosition;
  jpegQuality?: JpegQuality;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IThumbnailOption) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.fileSuffix = _data["fileSuffix"];
      this.resizeMethod = _data["resizeMethod"];
      this.width = _data["width"];
      this.height = _data["height"];
      this.backgroundColor = _data["backgroundColor"];
      this.anchorPosition = _data["anchorPosition"];
      this.jpegQuality = _data["jpegQuality"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): ThumbnailOption {
    data = typeof data === "object" ? data : {};
    let result = new ThumbnailOption();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["fileSuffix"] = this.fileSuffix;
    data["resizeMethod"] = this.resizeMethod;
    data["width"] = this.width;
    data["height"] = this.height;
    data["backgroundColor"] = this.backgroundColor;
    data["anchorPosition"] = this.anchorPosition;
    data["jpegQuality"] = this.jpegQuality;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IThumbnailOption {
  name?: string | undefined;
  fileSuffix?: string | undefined;
  resizeMethod?: ResizeMethod;
  width?: number | undefined;
  height?: number | undefined;
  backgroundColor?: string | undefined;
  anchorPosition?: AnchorPosition;
  jpegQuality?: JpegQuality;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class ThumbnailOptionSearchCriteria
  implements IThumbnailOptionSearchCriteria
{
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IThumbnailOptionSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): ThumbnailOptionSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new ThumbnailOptionSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IThumbnailOptionSearchCriteria {
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class ThumbnailOptionSearchResult
  implements IThumbnailOptionSearchResult
{
  totalCount?: number;
  results?: ThumbnailOption[] | undefined;

  constructor(data?: IThumbnailOptionSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(ThumbnailOption.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ThumbnailOptionSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new ThumbnailOptionSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IThumbnailOptionSearchResult {
  totalCount?: number;
  results?: ThumbnailOption[] | undefined;
}

export class ThumbnailTask implements IThumbnailTask {
  name?: string | undefined;
  lastRun?: Date | undefined;
  workPath?: string | undefined;
  thumbnailOptions?: ThumbnailOption[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IThumbnailTask) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.lastRun = _data["lastRun"]
        ? new Date(_data["lastRun"].toString())
        : <any>undefined;
      this.workPath = _data["workPath"];
      if (Array.isArray(_data["thumbnailOptions"])) {
        this.thumbnailOptions = [] as any;
        for (let item of _data["thumbnailOptions"])
          this.thumbnailOptions!.push(ThumbnailOption.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): ThumbnailTask {
    data = typeof data === "object" ? data : {};
    let result = new ThumbnailTask();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["lastRun"] = this.lastRun
      ? this.lastRun.toISOString()
      : <any>undefined;
    data["workPath"] = this.workPath;
    if (Array.isArray(this.thumbnailOptions)) {
      data["thumbnailOptions"] = [];
      for (let item of this.thumbnailOptions)
        data["thumbnailOptions"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IThumbnailTask {
  name?: string | undefined;
  lastRun?: Date | undefined;
  workPath?: string | undefined;
  thumbnailOptions?: ThumbnailOption[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class ThumbnailTaskSearchCriteria
  implements IThumbnailTaskSearchCriteria
{
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IThumbnailTaskSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): ThumbnailTaskSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new ThumbnailTaskSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IThumbnailTaskSearchCriteria {
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class ThumbnailTaskSearchResult implements IThumbnailTaskSearchResult {
  totalCount?: number;
  results?: ThumbnailTask[] | undefined;

  constructor(data?: IThumbnailTaskSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(ThumbnailTask.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ThumbnailTaskSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new ThumbnailTaskSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IThumbnailTaskSearchResult {
  totalCount?: number;
  results?: ThumbnailTask[] | undefined;
}

export class ThumbnailsTaskRunRequest implements IThumbnailsTaskRunRequest {
  taskIds?: string[] | undefined;
  regenerate?: boolean;

  constructor(data?: IThumbnailsTaskRunRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["taskIds"])) {
        this.taskIds = [] as any;
        for (let item of _data["taskIds"]) this.taskIds!.push(item);
      }
      this.regenerate = _data["regenerate"];
    }
  }

  static fromJS(data: any): ThumbnailsTaskRunRequest {
    data = typeof data === "object" ? data : {};
    let result = new ThumbnailsTaskRunRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.taskIds)) {
      data["taskIds"] = [];
      for (let item of this.taskIds) data["taskIds"].push(item);
    }
    data["regenerate"] = this.regenerate;
    return data;
  }
}

export interface IThumbnailsTaskRunRequest {
  taskIds?: string[] | undefined;
  regenerate?: boolean;
}

export class ThumbnailProcessNotification
  implements IThumbnailProcessNotification
{
  jobId?: string | undefined;
  finished?: Date | undefined;
  totalCount?: number;
  processedCount?: number;
  errorCount?: number;
  errors?: string[] | undefined;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;

  constructor(data?: IThumbnailProcessNotification) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.jobId = _data["jobId"];
      this.finished = _data["finished"]
        ? new Date(_data["finished"].toString())
        : <any>undefined;
      this.totalCount = _data["totalCount"];
      this.processedCount = _data["processedCount"];
      this.errorCount = _data["errorCount"];
      if (Array.isArray(_data["errors"])) {
        this.errors = [] as any;
        for (let item of _data["errors"]) this.errors!.push(item);
      }
      this.serverId = _data["serverId"];
      this.creator = _data["creator"];
      this.created = _data["created"]
        ? new Date(_data["created"].toString())
        : <any>undefined;
      this.isNew = _data["isNew"];
      this.notifyType = _data["notifyType"];
      this.description = _data["description"];
      this.title = _data["title"];
      this.repeatCount = _data["repeatCount"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): ThumbnailProcessNotification {
    data = typeof data === "object" ? data : {};
    let result = new ThumbnailProcessNotification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["jobId"] = this.jobId;
    data["finished"] = this.finished
      ? this.finished.toISOString()
      : <any>undefined;
    data["totalCount"] = this.totalCount;
    data["processedCount"] = this.processedCount;
    data["errorCount"] = this.errorCount;
    if (Array.isArray(this.errors)) {
      data["errors"] = [];
      for (let item of this.errors) data["errors"].push(item);
    }
    data["serverId"] = this.serverId;
    data["creator"] = this.creator;
    data["created"] = this.created
      ? this.created.toISOString()
      : <any>undefined;
    data["isNew"] = this.isNew;
    data["notifyType"] = this.notifyType;
    data["description"] = this.description;
    data["title"] = this.title;
    data["repeatCount"] = this.repeatCount;
    data["id"] = this.id;
    return data;
  }
}

export interface IThumbnailProcessNotification {
  jobId?: string | undefined;
  finished?: Date | undefined;
  totalCount?: number;
  processedCount?: number;
  errorCount?: number;
  errors?: string[] | undefined;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;
}

export class InventorySearchCriteria implements IInventorySearchCriteria {
  fulfillmentCenterIds?: string[] | undefined;
  productIds?: string[] | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IInventorySearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["fulfillmentCenterIds"])) {
        this.fulfillmentCenterIds = [] as any;
        for (let item of _data["fulfillmentCenterIds"])
          this.fulfillmentCenterIds!.push(item);
      }
      if (Array.isArray(_data["productIds"])) {
        this.productIds = [] as any;
        for (let item of _data["productIds"]) this.productIds!.push(item);
      }
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): InventorySearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new InventorySearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.fulfillmentCenterIds)) {
      data["fulfillmentCenterIds"] = [];
      for (let item of this.fulfillmentCenterIds)
        data["fulfillmentCenterIds"].push(item);
    }
    if (Array.isArray(this.productIds)) {
      data["productIds"] = [];
      for (let item of this.productIds) data["productIds"].push(item);
    }
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IInventorySearchCriteria {
  fulfillmentCenterIds?: string[] | undefined;
  productIds?: string[] | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class InventoryAddress implements IInventoryAddress {
  addressType?: AddressType;
  key?: string | undefined;
  name?: string | undefined;
  organization?: string | undefined;
  countryCode?: string | undefined;
  countryName?: string | undefined;
  city?: string | undefined;
  postalCode?: string | undefined;
  zip?: string | undefined;
  line1?: string | undefined;
  line2?: string | undefined;
  regionId?: string | undefined;
  regionName?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  email?: string | undefined;

  constructor(data?: IInventoryAddress) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.addressType = _data["addressType"];
      this.key = _data["key"];
      this.name = _data["name"];
      this.organization = _data["organization"];
      this.countryCode = _data["countryCode"];
      this.countryName = _data["countryName"];
      this.city = _data["city"];
      this.postalCode = _data["postalCode"];
      this.zip = _data["zip"];
      this.line1 = _data["line1"];
      this.line2 = _data["line2"];
      this.regionId = _data["regionId"];
      this.regionName = _data["regionName"];
      this.firstName = _data["firstName"];
      this.middleName = _data["middleName"];
      this.lastName = _data["lastName"];
      this.phone = _data["phone"];
      this.email = _data["email"];
    }
  }

  static fromJS(data: any): InventoryAddress {
    data = typeof data === "object" ? data : {};
    let result = new InventoryAddress();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["addressType"] = this.addressType;
    data["key"] = this.key;
    data["name"] = this.name;
    data["organization"] = this.organization;
    data["countryCode"] = this.countryCode;
    data["countryName"] = this.countryName;
    data["city"] = this.city;
    data["postalCode"] = this.postalCode;
    data["zip"] = this.zip;
    data["line1"] = this.line1;
    data["line2"] = this.line2;
    data["regionId"] = this.regionId;
    data["regionName"] = this.regionName;
    data["firstName"] = this.firstName;
    data["middleName"] = this.middleName;
    data["lastName"] = this.lastName;
    data["phone"] = this.phone;
    data["email"] = this.email;
    return data;
  }
}

export interface IInventoryAddress {
  addressType?: AddressType;
  key?: string | undefined;
  name?: string | undefined;
  organization?: string | undefined;
  countryCode?: string | undefined;
  countryName?: string | undefined;
  city?: string | undefined;
  postalCode?: string | undefined;
  zip?: string | undefined;
  line1?: string | undefined;
  line2?: string | undefined;
  regionId?: string | undefined;
  regionName?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  email?: string | undefined;
}

export class FulfillmentCenter implements IFulfillmentCenter {
  name?: string | undefined;
  description?: string | undefined;
  geoLocation?: string | undefined;
  address?: InventoryAddress;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IFulfillmentCenter) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.description = _data["description"];
      this.geoLocation = _data["geoLocation"];
      this.address = _data["address"]
        ? InventoryAddress.fromJS(_data["address"])
        : <any>undefined;
      this.outerId = _data["outerId"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): FulfillmentCenter {
    data = typeof data === "object" ? data : {};
    let result = new FulfillmentCenter();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["description"] = this.description;
    data["geoLocation"] = this.geoLocation;
    data["address"] = this.address ? this.address.toJSON() : <any>undefined;
    data["outerId"] = this.outerId;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IFulfillmentCenter {
  name?: string | undefined;
  description?: string | undefined;
  geoLocation?: string | undefined;
  address?: InventoryAddress;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export enum InventoryStatus {
  Disabled = "Disabled",
  Enabled = "Enabled",
  Ignored = "Ignored",
}

export class InventoryInfo implements IInventoryInfo {
  fulfillmentCenterId?: string | undefined;
  fulfillmentCenterName?: string | undefined;
  fulfillmentCenter?: FulfillmentCenter;
  productId?: string | undefined;
  inStockQuantity?: number;
  reservedQuantity?: number;
  reorderMinQuantity?: number;
  preorderQuantity?: number;
  backorderQuantity?: number;
  allowBackorder?: boolean;
  allowPreorder?: boolean;
  inTransit?: number;
  preorderAvailabilityDate?: Date | undefined;
  backorderAvailabilityDate?: Date | undefined;
  status?: InventoryStatus;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IInventoryInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fulfillmentCenterId = _data["fulfillmentCenterId"];
      this.fulfillmentCenterName = _data["fulfillmentCenterName"];
      this.fulfillmentCenter = _data["fulfillmentCenter"]
        ? FulfillmentCenter.fromJS(_data["fulfillmentCenter"])
        : <any>undefined;
      this.productId = _data["productId"];
      this.inStockQuantity = _data["inStockQuantity"];
      this.reservedQuantity = _data["reservedQuantity"];
      this.reorderMinQuantity = _data["reorderMinQuantity"];
      this.preorderQuantity = _data["preorderQuantity"];
      this.backorderQuantity = _data["backorderQuantity"];
      this.allowBackorder = _data["allowBackorder"];
      this.allowPreorder = _data["allowPreorder"];
      this.inTransit = _data["inTransit"];
      this.preorderAvailabilityDate = _data["preorderAvailabilityDate"]
        ? new Date(_data["preorderAvailabilityDate"].toString())
        : <any>undefined;
      this.backorderAvailabilityDate = _data["backorderAvailabilityDate"]
        ? new Date(_data["backorderAvailabilityDate"].toString())
        : <any>undefined;
      this.status = _data["status"];
      this.outerId = _data["outerId"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): InventoryInfo {
    data = typeof data === "object" ? data : {};
    let result = new InventoryInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["fulfillmentCenterId"] = this.fulfillmentCenterId;
    data["fulfillmentCenterName"] = this.fulfillmentCenterName;
    data["fulfillmentCenter"] = this.fulfillmentCenter
      ? this.fulfillmentCenter.toJSON()
      : <any>undefined;
    data["productId"] = this.productId;
    data["inStockQuantity"] = this.inStockQuantity;
    data["reservedQuantity"] = this.reservedQuantity;
    data["reorderMinQuantity"] = this.reorderMinQuantity;
    data["preorderQuantity"] = this.preorderQuantity;
    data["backorderQuantity"] = this.backorderQuantity;
    data["allowBackorder"] = this.allowBackorder;
    data["allowPreorder"] = this.allowPreorder;
    data["inTransit"] = this.inTransit;
    data["preorderAvailabilityDate"] = this.preorderAvailabilityDate
      ? this.preorderAvailabilityDate.toISOString()
      : <any>undefined;
    data["backorderAvailabilityDate"] = this.backorderAvailabilityDate
      ? this.backorderAvailabilityDate.toISOString()
      : <any>undefined;
    data["status"] = this.status;
    data["outerId"] = this.outerId;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IInventoryInfo {
  fulfillmentCenterId?: string | undefined;
  fulfillmentCenterName?: string | undefined;
  fulfillmentCenter?: FulfillmentCenter;
  productId?: string | undefined;
  inStockQuantity?: number;
  reservedQuantity?: number;
  reorderMinQuantity?: number;
  preorderQuantity?: number;
  backorderQuantity?: number;
  allowBackorder?: boolean;
  allowPreorder?: boolean;
  inTransit?: number;
  preorderAvailabilityDate?: Date | undefined;
  backorderAvailabilityDate?: Date | undefined;
  status?: InventoryStatus;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class InventoryInfoSearchResult implements IInventoryInfoSearchResult {
  totalCount?: number;
  results?: InventoryInfo[] | undefined;

  constructor(data?: IInventoryInfoSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(InventoryInfo.fromJS(item));
      }
    }
  }

  static fromJS(data: any): InventoryInfoSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new InventoryInfoSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IInventoryInfoSearchResult {
  totalCount?: number;
  results?: InventoryInfo[] | undefined;
}

export class ProductInventorySearchCriteria
  implements IProductInventorySearchCriteria
{
  productId?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IProductInventorySearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data["productId"];
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): ProductInventorySearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new ProductInventorySearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["productId"] = this.productId;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IProductInventorySearchCriteria {
  productId?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class FulfillmentCenterSearchCriteria
  implements IFulfillmentCenterSearchCriteria
{
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IFulfillmentCenterSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): FulfillmentCenterSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new FulfillmentCenterSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IFulfillmentCenterSearchCriteria {
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class FulfillmentCenterSearchResult
  implements IFulfillmentCenterSearchResult
{
  totalCount?: number;
  results?: FulfillmentCenter[] | undefined;

  constructor(data?: IFulfillmentCenterSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(FulfillmentCenter.fromJS(item));
      }
    }
  }

  static fromJS(data: any): FulfillmentCenterSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new FulfillmentCenterSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IFulfillmentCenterSearchResult {
  totalCount?: number;
  results?: FulfillmentCenter[] | undefined;
}

export class DynamicContentPlaceSearchCriteria
  implements IDynamicContentPlaceSearchCriteria
{
  folderId?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IDynamicContentPlaceSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.folderId = _data["folderId"];
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): DynamicContentPlaceSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new DynamicContentPlaceSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["folderId"] = this.folderId;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IDynamicContentPlaceSearchCriteria {
  folderId?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class DynamicContentListEntry implements IDynamicContentListEntry {
  /** Gets or sets the type. E.g. "folder", "content-item", "content-place" */
  objectType?: string | undefined;
  /** Gets or sets the image URL. */
  imageUrl?: string | undefined;
  /** Gets or sets the name. */
  name?: string | undefined;
  description?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IDynamicContentListEntry) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.objectType = _data["objectType"];
      this.imageUrl = _data["imageUrl"];
      this.name = _data["name"];
      this.description = _data["description"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): DynamicContentListEntry {
    data = typeof data === "object" ? data : {};
    let result = new DynamicContentListEntry();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["objectType"] = this.objectType;
    data["imageUrl"] = this.imageUrl;
    data["name"] = this.name;
    data["description"] = this.description;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IDynamicContentListEntry {
  /** Gets or sets the type. E.g. "folder", "content-item", "content-place" */
  objectType?: string | undefined;
  /** Gets or sets the image URL. */
  imageUrl?: string | undefined;
  /** Gets or sets the name. */
  name?: string | undefined;
  description?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class DynamicContentListEntrySearchResult
  implements IDynamicContentListEntrySearchResult
{
  totalCount?: number;
  results?: DynamicContentListEntry[] | undefined;

  constructor(data?: IDynamicContentListEntrySearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(DynamicContentListEntry.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DynamicContentListEntrySearchResult {
    data = typeof data === "object" ? data : {};
    let result = new DynamicContentListEntrySearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IDynamicContentListEntrySearchResult {
  totalCount?: number;
  results?: DynamicContentListEntry[] | undefined;
}

export class DynamicContentFolder implements IDynamicContentFolder {
  /** all parent folders names concatenated (Root\Child\Child2) */
  readonly path?: string | undefined;
  /** all parent folders ids concatenated (1;21;344) */
  readonly outline?: string | undefined;
  parentFolderId?: string | undefined;
  parentFolder?: DynamicContentFolder;
  readonly objectType?: string | undefined;
  /** Gets or sets the image URL. */
  imageUrl?: string | undefined;
  /** Gets or sets the name. */
  name?: string | undefined;
  description?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IDynamicContentFolder) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).path = _data["path"];
      (<any>this).outline = _data["outline"];
      this.parentFolderId = _data["parentFolderId"];
      this.parentFolder = _data["parentFolder"]
        ? DynamicContentFolder.fromJS(_data["parentFolder"])
        : <any>undefined;
      (<any>this).objectType = _data["objectType"];
      this.imageUrl = _data["imageUrl"];
      this.name = _data["name"];
      this.description = _data["description"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): DynamicContentFolder {
    data = typeof data === "object" ? data : {};
    let result = new DynamicContentFolder();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["path"] = this.path;
    data["outline"] = this.outline;
    data["parentFolderId"] = this.parentFolderId;
    data["parentFolder"] = this.parentFolder
      ? this.parentFolder.toJSON()
      : <any>undefined;
    data["objectType"] = this.objectType;
    data["imageUrl"] = this.imageUrl;
    data["name"] = this.name;
    data["description"] = this.description;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IDynamicContentFolder {
  /** all parent folders names concatenated (Root\Child\Child2) */
  path?: string | undefined;
  /** all parent folders ids concatenated (1;21;344) */
  outline?: string | undefined;
  parentFolderId?: string | undefined;
  parentFolder?: DynamicContentFolder;
  objectType?: string | undefined;
  /** Gets or sets the image URL. */
  imageUrl?: string | undefined;
  /** Gets or sets the name. */
  name?: string | undefined;
  description?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class DynamicContentPlace implements IDynamicContentPlace {
  /** all parent folders ids concatenated (1;21;344) */
  readonly outline?: string | undefined;
  /** all parent folders names concatenated (Root\Child\Child2) */
  readonly path?: string | undefined;
  folderId?: string | undefined;
  folder?: DynamicContentFolder;
  /** Gets or sets the type. E.g. "folder", "content-item", "content-place" */
  objectType?: string | undefined;
  /** Gets or sets the image URL. */
  imageUrl?: string | undefined;
  /** Gets or sets the name. */
  name?: string | undefined;
  description?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IDynamicContentPlace) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).outline = _data["outline"];
      (<any>this).path = _data["path"];
      this.folderId = _data["folderId"];
      this.folder = _data["folder"]
        ? DynamicContentFolder.fromJS(_data["folder"])
        : <any>undefined;
      this.objectType = _data["objectType"];
      this.imageUrl = _data["imageUrl"];
      this.name = _data["name"];
      this.description = _data["description"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): DynamicContentPlace {
    data = typeof data === "object" ? data : {};
    let result = new DynamicContentPlace();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["outline"] = this.outline;
    data["path"] = this.path;
    data["folderId"] = this.folderId;
    data["folder"] = this.folder ? this.folder.toJSON() : <any>undefined;
    data["objectType"] = this.objectType;
    data["imageUrl"] = this.imageUrl;
    data["name"] = this.name;
    data["description"] = this.description;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IDynamicContentPlace {
  /** all parent folders ids concatenated (1;21;344) */
  outline?: string | undefined;
  /** all parent folders names concatenated (Root\Child\Child2) */
  path?: string | undefined;
  folderId?: string | undefined;
  folder?: DynamicContentFolder;
  /** Gets or sets the type. E.g. "folder", "content-item", "content-place" */
  objectType?: string | undefined;
  /** Gets or sets the image URL. */
  imageUrl?: string | undefined;
  /** Gets or sets the name. */
  name?: string | undefined;
  description?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class DynamicContentPlaceSearchResult
  implements IDynamicContentPlaceSearchResult
{
  totalCount?: number;
  results?: DynamicContentPlace[] | undefined;

  constructor(data?: IDynamicContentPlaceSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(DynamicContentPlace.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DynamicContentPlaceSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new DynamicContentPlaceSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IDynamicContentPlaceSearchResult {
  totalCount?: number;
  results?: DynamicContentPlace[] | undefined;
}

export class DynamicContentItemSearchCriteria
  implements IDynamicContentItemSearchCriteria
{
  folderId?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IDynamicContentItemSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.folderId = _data["folderId"];
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): DynamicContentItemSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new DynamicContentItemSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["folderId"] = this.folderId;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IDynamicContentItemSearchCriteria {
  folderId?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class DynamicContentItem implements IDynamicContentItem {
  contentType?: string | undefined;
  priority?: number;
  /** all parent folders ids concatenated (1;21;344) */
  readonly outline?: string | undefined;
  /** all parent folders names concatenated (Root\Child\Child2) */
  readonly path?: string | undefined;
  folderId?: string | undefined;
  folder?: DynamicContentFolder;
  readonly objectType?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  /** Gets or sets the image URL. */
  imageUrl?: string | undefined;
  /** Gets or sets the name. */
  name?: string | undefined;
  description?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IDynamicContentItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.contentType = _data["contentType"];
      this.priority = _data["priority"];
      (<any>this).outline = _data["outline"];
      (<any>this).path = _data["path"];
      this.folderId = _data["folderId"];
      this.folder = _data["folder"]
        ? DynamicContentFolder.fromJS(_data["folder"])
        : <any>undefined;
      (<any>this).objectType = _data["objectType"];
      if (Array.isArray(_data["dynamicProperties"])) {
        this.dynamicProperties = [] as any;
        for (let item of _data["dynamicProperties"])
          this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
      }
      this.imageUrl = _data["imageUrl"];
      this.name = _data["name"];
      this.description = _data["description"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): DynamicContentItem {
    data = typeof data === "object" ? data : {};
    let result = new DynamicContentItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["contentType"] = this.contentType;
    data["priority"] = this.priority;
    data["outline"] = this.outline;
    data["path"] = this.path;
    data["folderId"] = this.folderId;
    data["folder"] = this.folder ? this.folder.toJSON() : <any>undefined;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.dynamicProperties)) {
      data["dynamicProperties"] = [];
      for (let item of this.dynamicProperties)
        data["dynamicProperties"].push(item.toJSON());
    }
    data["imageUrl"] = this.imageUrl;
    data["name"] = this.name;
    data["description"] = this.description;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IDynamicContentItem {
  contentType?: string | undefined;
  priority?: number;
  /** all parent folders ids concatenated (1;21;344) */
  outline?: string | undefined;
  /** all parent folders names concatenated (Root\Child\Child2) */
  path?: string | undefined;
  folderId?: string | undefined;
  folder?: DynamicContentFolder;
  objectType?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  /** Gets or sets the image URL. */
  imageUrl?: string | undefined;
  /** Gets or sets the name. */
  name?: string | undefined;
  description?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class DynamicContentItemSearchResult
  implements IDynamicContentItemSearchResult
{
  totalCount?: number;
  results?: DynamicContentItem[] | undefined;

  constructor(data?: IDynamicContentItemSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(DynamicContentItem.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DynamicContentItemSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new DynamicContentItemSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IDynamicContentItemSearchResult {
  totalCount?: number;
  results?: DynamicContentItem[] | undefined;
}

export class DynamicContentPublicationSearchCriteria
  implements IDynamicContentPublicationSearchCriteria
{
  onlyActive?: boolean;
  store?: string | undefined;
  placeName?: string | undefined;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  folderId?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IDynamicContentPublicationSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.onlyActive = _data["onlyActive"];
      this.store = _data["store"];
      this.placeName = _data["placeName"];
      this.startDate = _data["startDate"]
        ? new Date(_data["startDate"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? new Date(_data["endDate"].toString())
        : <any>undefined;
      this.folderId = _data["folderId"];
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): DynamicContentPublicationSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new DynamicContentPublicationSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["onlyActive"] = this.onlyActive;
    data["store"] = this.store;
    data["placeName"] = this.placeName;
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    data["folderId"] = this.folderId;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IDynamicContentPublicationSearchCriteria {
  onlyActive?: boolean;
  store?: string | undefined;
  placeName?: string | undefined;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  folderId?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class DynamicContentConditionTree
  implements IDynamicContentConditionTree
{
  all?: boolean;
  not?: boolean;
  readonly id?: string | undefined;
  availableChildren?: IConditionTree[] | undefined;
  children?: IConditionTree[] | undefined;

  constructor(data?: IDynamicContentConditionTree) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.all = _data["all"];
      this.not = _data["not"];
      (<any>this).id = _data["id"];
      if (Array.isArray(_data["availableChildren"])) {
        this.availableChildren = [] as any;
        for (let item of _data["availableChildren"])
          this.availableChildren!.push(IConditionTree.fromJS(item));
      }
      if (Array.isArray(_data["children"])) {
        this.children = [] as any;
        for (let item of _data["children"])
          this.children!.push(IConditionTree.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DynamicContentConditionTree {
    data = typeof data === "object" ? data : {};
    let result = new DynamicContentConditionTree();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["all"] = this.all;
    data["not"] = this.not;
    data["id"] = this.id;
    if (Array.isArray(this.availableChildren)) {
      data["availableChildren"] = [];
      for (let item of this.availableChildren)
        data["availableChildren"].push(item.toJSON());
    }
    if (Array.isArray(this.children)) {
      data["children"] = [];
      for (let item of this.children) data["children"].push(item.toJSON());
    }
    return data;
  }
}

export interface IDynamicContentConditionTree {
  all?: boolean;
  not?: boolean;
  id?: string | undefined;
  availableChildren?: IConditionTree[] | undefined;
  children?: IConditionTree[] | undefined;
}

export class DynamicContentPublication implements IDynamicContentPublication {
  name?: string | undefined;
  description?: string | undefined;
  priority?: number;
  isActive?: boolean;
  storeId?: string | undefined;
  dynamicExpression?: DynamicContentConditionTree;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  outerId?: string | undefined;
  contentItems?: DynamicContentItem[] | undefined;
  contentPlaces?: DynamicContentPlace[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IDynamicContentPublication) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.description = _data["description"];
      this.priority = _data["priority"];
      this.isActive = _data["isActive"];
      this.storeId = _data["storeId"];
      this.dynamicExpression = _data["dynamicExpression"]
        ? DynamicContentConditionTree.fromJS(_data["dynamicExpression"])
        : <any>undefined;
      this.startDate = _data["startDate"]
        ? new Date(_data["startDate"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? new Date(_data["endDate"].toString())
        : <any>undefined;
      this.outerId = _data["outerId"];
      if (Array.isArray(_data["contentItems"])) {
        this.contentItems = [] as any;
        for (let item of _data["contentItems"])
          this.contentItems!.push(DynamicContentItem.fromJS(item));
      }
      if (Array.isArray(_data["contentPlaces"])) {
        this.contentPlaces = [] as any;
        for (let item of _data["contentPlaces"])
          this.contentPlaces!.push(DynamicContentPlace.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): DynamicContentPublication {
    data = typeof data === "object" ? data : {};
    let result = new DynamicContentPublication();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["description"] = this.description;
    data["priority"] = this.priority;
    data["isActive"] = this.isActive;
    data["storeId"] = this.storeId;
    data["dynamicExpression"] = this.dynamicExpression
      ? this.dynamicExpression.toJSON()
      : <any>undefined;
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    data["outerId"] = this.outerId;
    if (Array.isArray(this.contentItems)) {
      data["contentItems"] = [];
      for (let item of this.contentItems)
        data["contentItems"].push(item.toJSON());
    }
    if (Array.isArray(this.contentPlaces)) {
      data["contentPlaces"] = [];
      for (let item of this.contentPlaces)
        data["contentPlaces"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IDynamicContentPublication {
  name?: string | undefined;
  description?: string | undefined;
  priority?: number;
  isActive?: boolean;
  storeId?: string | undefined;
  dynamicExpression?: DynamicContentConditionTree;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  outerId?: string | undefined;
  contentItems?: DynamicContentItem[] | undefined;
  contentPlaces?: DynamicContentPlace[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class DynamicContentPublicationSearchResult
  implements IDynamicContentPublicationSearchResult
{
  totalCount?: number;
  results?: DynamicContentPublication[] | undefined;

  constructor(data?: IDynamicContentPublicationSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(DynamicContentPublication.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DynamicContentPublicationSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new DynamicContentPublicationSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IDynamicContentPublicationSearchResult {
  totalCount?: number;
  results?: DynamicContentPublication[] | undefined;
}

export class DynamicContentEvaluationContext
  implements IDynamicContentEvaluationContext
{
  storeId?: string | undefined;
  placeName?: string | undefined;
  tags?: string[] | undefined;
  toDate?: Date;
  contextObject?: any | undefined;
  geoCity?: string | undefined;
  geoState?: string | undefined;
  geoCountry?: string | undefined;
  geoContinent?: string | undefined;
  geoZipCode?: string | undefined;
  geoConnectionType?: string | undefined;
  geoTimeZone?: string | undefined;
  geoIpRoutingType?: string | undefined;
  geoIspSecondLevel?: string | undefined;
  geoIspTopLevel?: string | undefined;
  shopperAge?: number;
  shopperGender?: string | undefined;
  language?: string | undefined;
  /** Any tags or groups belongs to user such as VIP, Wholesaler etc */
  userGroups?: string[] | undefined;
  shopperSearchedPhraseInStore?: string | undefined;
  shopperSearchedPhraseOnInternet?: string | undefined;
  currentUrl?: string | undefined;
  referredUrl?: string | undefined;

  constructor(data?: IDynamicContentEvaluationContext) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.storeId = _data["storeId"];
      this.placeName = _data["placeName"];
      if (Array.isArray(_data["tags"])) {
        this.tags = [] as any;
        for (let item of _data["tags"]) this.tags!.push(item);
      }
      this.toDate = _data["toDate"]
        ? new Date(_data["toDate"].toString())
        : <any>undefined;
      this.contextObject = _data["contextObject"];
      this.geoCity = _data["geoCity"];
      this.geoState = _data["geoState"];
      this.geoCountry = _data["geoCountry"];
      this.geoContinent = _data["geoContinent"];
      this.geoZipCode = _data["geoZipCode"];
      this.geoConnectionType = _data["geoConnectionType"];
      this.geoTimeZone = _data["geoTimeZone"];
      this.geoIpRoutingType = _data["geoIpRoutingType"];
      this.geoIspSecondLevel = _data["geoIspSecondLevel"];
      this.geoIspTopLevel = _data["geoIspTopLevel"];
      this.shopperAge = _data["shopperAge"];
      this.shopperGender = _data["shopperGender"];
      this.language = _data["language"];
      if (Array.isArray(_data["userGroups"])) {
        this.userGroups = [] as any;
        for (let item of _data["userGroups"]) this.userGroups!.push(item);
      }
      this.shopperSearchedPhraseInStore = _data["shopperSearchedPhraseInStore"];
      this.shopperSearchedPhraseOnInternet =
        _data["shopperSearchedPhraseOnInternet"];
      this.currentUrl = _data["currentUrl"];
      this.referredUrl = _data["referredUrl"];
    }
  }

  static fromJS(data: any): DynamicContentEvaluationContext {
    data = typeof data === "object" ? data : {};
    let result = new DynamicContentEvaluationContext();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["storeId"] = this.storeId;
    data["placeName"] = this.placeName;
    if (Array.isArray(this.tags)) {
      data["tags"] = [];
      for (let item of this.tags) data["tags"].push(item);
    }
    data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
    data["contextObject"] = this.contextObject;
    data["geoCity"] = this.geoCity;
    data["geoState"] = this.geoState;
    data["geoCountry"] = this.geoCountry;
    data["geoContinent"] = this.geoContinent;
    data["geoZipCode"] = this.geoZipCode;
    data["geoConnectionType"] = this.geoConnectionType;
    data["geoTimeZone"] = this.geoTimeZone;
    data["geoIpRoutingType"] = this.geoIpRoutingType;
    data["geoIspSecondLevel"] = this.geoIspSecondLevel;
    data["geoIspTopLevel"] = this.geoIspTopLevel;
    data["shopperAge"] = this.shopperAge;
    data["shopperGender"] = this.shopperGender;
    data["language"] = this.language;
    if (Array.isArray(this.userGroups)) {
      data["userGroups"] = [];
      for (let item of this.userGroups) data["userGroups"].push(item);
    }
    data["shopperSearchedPhraseInStore"] = this.shopperSearchedPhraseInStore;
    data["shopperSearchedPhraseOnInternet"] =
      this.shopperSearchedPhraseOnInternet;
    data["currentUrl"] = this.currentUrl;
    data["referredUrl"] = this.referredUrl;
    return data;
  }
}

export interface IDynamicContentEvaluationContext {
  storeId?: string | undefined;
  placeName?: string | undefined;
  tags?: string[] | undefined;
  toDate?: Date;
  contextObject?: any | undefined;
  geoCity?: string | undefined;
  geoState?: string | undefined;
  geoCountry?: string | undefined;
  geoContinent?: string | undefined;
  geoZipCode?: string | undefined;
  geoConnectionType?: string | undefined;
  geoTimeZone?: string | undefined;
  geoIpRoutingType?: string | undefined;
  geoIspSecondLevel?: string | undefined;
  geoIspTopLevel?: string | undefined;
  shopperAge?: number;
  shopperGender?: string | undefined;
  language?: string | undefined;
  /** Any tags or groups belongs to user such as VIP, Wholesaler etc */
  userGroups?: string[] | undefined;
  shopperSearchedPhraseInStore?: string | undefined;
  shopperSearchedPhraseOnInternet?: string | undefined;
  currentUrl?: string | undefined;
  referredUrl?: string | undefined;
}

export class PromotionSearchCriteria implements IPromotionSearchCriteria {
  onlyActive?: boolean;
  store?: string | undefined;
  storeIds?: string[] | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IPromotionSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.onlyActive = _data["onlyActive"];
      this.store = _data["store"];
      if (Array.isArray(_data["storeIds"])) {
        this.storeIds = [] as any;
        for (let item of _data["storeIds"]) this.storeIds!.push(item);
      }
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): PromotionSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new PromotionSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["onlyActive"] = this.onlyActive;
    data["store"] = this.store;
    if (Array.isArray(this.storeIds)) {
      data["storeIds"] = [];
      for (let item of this.storeIds) data["storeIds"].push(item);
    }
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IPromotionSearchCriteria {
  onlyActive?: boolean;
  store?: string | undefined;
  storeIds?: string[] | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class PromotionConditionAndRewardTree
  implements IPromotionConditionAndRewardTree
{
  all?: boolean;
  not?: boolean;
  readonly id?: string | undefined;
  availableChildren?: IConditionTree[] | undefined;
  children?: IConditionTree[] | undefined;

  constructor(data?: IPromotionConditionAndRewardTree) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.all = _data["all"];
      this.not = _data["not"];
      (<any>this).id = _data["id"];
      if (Array.isArray(_data["availableChildren"])) {
        this.availableChildren = [] as any;
        for (let item of _data["availableChildren"])
          this.availableChildren!.push(IConditionTree.fromJS(item));
      }
      if (Array.isArray(_data["children"])) {
        this.children = [] as any;
        for (let item of _data["children"])
          this.children!.push(IConditionTree.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PromotionConditionAndRewardTree {
    data = typeof data === "object" ? data : {};
    let result = new PromotionConditionAndRewardTree();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["all"] = this.all;
    data["not"] = this.not;
    data["id"] = this.id;
    if (Array.isArray(this.availableChildren)) {
      data["availableChildren"] = [];
      for (let item of this.availableChildren)
        data["availableChildren"].push(item.toJSON());
    }
    if (Array.isArray(this.children)) {
      data["children"] = [];
      for (let item of this.children) data["children"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPromotionConditionAndRewardTree {
  all?: boolean;
  not?: boolean;
  id?: string | undefined;
  availableChildren?: IConditionTree[] | undefined;
  children?: IConditionTree[] | undefined;
}

export class Promotion implements IPromotion {
  /** If this flag is set to true, it allows this promotion to combine with itself.
  Special for case when need to return same promotion rewards for multiple coupons */
  isAllowCombiningWithSelf?: boolean;
  dynamicExpression?: PromotionConditionAndRewardTree;
  store?: string | undefined;
  storeIds?: string[] | undefined;
  /** Promotion name */
  name?: string | undefined;
  /** Required for UI. TODO: remove later */
  type?: string | undefined;
  isActive?: boolean;
  /** Represents a promotion priority, for combination policies when it is necessary to select a promotion with a higher priority */
  priority?: number;
  /** If a promotion with this setting is applied, no other promotions can be applied to the order. */
  isExclusive?: boolean;
  hasCoupons?: boolean;
  description?: string | undefined;
  /** Maximum redemptions for this promotion */
  maxUsageCount?: number;
  /** Maximum redemptions on a single order */
  maxUsageOnOrder?: number;
  /** Maximum redemptions by a single customer */
  maxPersonalUsageCount?: number;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IPromotion) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isAllowCombiningWithSelf = _data["isAllowCombiningWithSelf"];
      this.dynamicExpression = _data["dynamicExpression"]
        ? PromotionConditionAndRewardTree.fromJS(_data["dynamicExpression"])
        : <any>undefined;
      this.store = _data["store"];
      if (Array.isArray(_data["storeIds"])) {
        this.storeIds = [] as any;
        for (let item of _data["storeIds"]) this.storeIds!.push(item);
      }
      this.name = _data["name"];
      this.type = _data["type"];
      this.isActive = _data["isActive"];
      this.priority = _data["priority"];
      this.isExclusive = _data["isExclusive"];
      this.hasCoupons = _data["hasCoupons"];
      this.description = _data["description"];
      this.maxUsageCount = _data["maxUsageCount"];
      this.maxUsageOnOrder = _data["maxUsageOnOrder"];
      this.maxPersonalUsageCount = _data["maxPersonalUsageCount"];
      this.startDate = _data["startDate"]
        ? new Date(_data["startDate"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? new Date(_data["endDate"].toString())
        : <any>undefined;
      this.outerId = _data["outerId"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Promotion {
    data = typeof data === "object" ? data : {};
    let result = new Promotion();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["isAllowCombiningWithSelf"] = this.isAllowCombiningWithSelf;
    data["dynamicExpression"] = this.dynamicExpression
      ? this.dynamicExpression.toJSON()
      : <any>undefined;
    data["store"] = this.store;
    if (Array.isArray(this.storeIds)) {
      data["storeIds"] = [];
      for (let item of this.storeIds) data["storeIds"].push(item);
    }
    data["name"] = this.name;
    data["type"] = this.type;
    data["isActive"] = this.isActive;
    data["priority"] = this.priority;
    data["isExclusive"] = this.isExclusive;
    data["hasCoupons"] = this.hasCoupons;
    data["description"] = this.description;
    data["maxUsageCount"] = this.maxUsageCount;
    data["maxUsageOnOrder"] = this.maxUsageOnOrder;
    data["maxPersonalUsageCount"] = this.maxPersonalUsageCount;
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    data["outerId"] = this.outerId;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IPromotion {
  /** If this flag is set to true, it allows this promotion to combine with itself.
  Special for case when need to return same promotion rewards for multiple coupons */
  isAllowCombiningWithSelf?: boolean;
  dynamicExpression?: PromotionConditionAndRewardTree;
  store?: string | undefined;
  storeIds?: string[] | undefined;
  /** Promotion name */
  name?: string | undefined;
  /** Required for UI. TODO: remove later */
  type?: string | undefined;
  isActive?: boolean;
  /** Represents a promotion priority, for combination policies when it is necessary to select a promotion with a higher priority */
  priority?: number;
  /** If a promotion with this setting is applied, no other promotions can be applied to the order. */
  isExclusive?: boolean;
  hasCoupons?: boolean;
  description?: string | undefined;
  /** Maximum redemptions for this promotion */
  maxUsageCount?: number;
  /** Maximum redemptions on a single order */
  maxUsageOnOrder?: number;
  /** Maximum redemptions by a single customer */
  maxPersonalUsageCount?: number;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class PromotionSearchResult implements IPromotionSearchResult {
  totalCount?: number;
  results?: Promotion[] | undefined;

  constructor(data?: IPromotionSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(Promotion.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PromotionSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new PromotionSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPromotionSearchResult {
  totalCount?: number;
  results?: Promotion[] | undefined;
}

export class ProductPromoEntry implements IProductPromoEntry {
  code?: string | undefined;
  quantity?: number;
  inStockQuantity?: number;
  price?: number;
  listPrice?: number;
  discount?: number;
  catalogId?: string | undefined;
  categoryId?: string | undefined;
  productId?: string | undefined;
  owner?: any | undefined;
  outline?: string | undefined;
  variations?: ProductPromoEntry[] | undefined;
  attributes?: { [key: string]: string } | undefined;

  constructor(data?: IProductPromoEntry) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.code = _data["code"];
      this.quantity = _data["quantity"];
      this.inStockQuantity = _data["inStockQuantity"];
      this.price = _data["price"];
      this.listPrice = _data["listPrice"];
      this.discount = _data["discount"];
      this.catalogId = _data["catalogId"];
      this.categoryId = _data["categoryId"];
      this.productId = _data["productId"];
      this.owner = _data["owner"];
      this.outline = _data["outline"];
      if (Array.isArray(_data["variations"])) {
        this.variations = [] as any;
        for (let item of _data["variations"])
          this.variations!.push(ProductPromoEntry.fromJS(item));
      }
      if (_data["attributes"]) {
        this.attributes = {} as any;
        for (let key in _data["attributes"]) {
          if (_data["attributes"].hasOwnProperty(key))
            (<any>this.attributes)![key] = _data["attributes"][key];
        }
      }
    }
  }

  static fromJS(data: any): ProductPromoEntry {
    data = typeof data === "object" ? data : {};
    let result = new ProductPromoEntry();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["code"] = this.code;
    data["quantity"] = this.quantity;
    data["inStockQuantity"] = this.inStockQuantity;
    data["price"] = this.price;
    data["listPrice"] = this.listPrice;
    data["discount"] = this.discount;
    data["catalogId"] = this.catalogId;
    data["categoryId"] = this.categoryId;
    data["productId"] = this.productId;
    data["owner"] = this.owner;
    data["outline"] = this.outline;
    if (Array.isArray(this.variations)) {
      data["variations"] = [];
      for (let item of this.variations) data["variations"].push(item.toJSON());
    }
    if (this.attributes) {
      data["attributes"] = {};
      for (let key in this.attributes) {
        if (this.attributes.hasOwnProperty(key))
          (<any>data["attributes"])[key] = this.attributes[key];
      }
    }
    return data;
  }
}

export interface IProductPromoEntry {
  code?: string | undefined;
  quantity?: number;
  inStockQuantity?: number;
  price?: number;
  listPrice?: number;
  discount?: number;
  catalogId?: string | undefined;
  categoryId?: string | undefined;
  productId?: string | undefined;
  owner?: any | undefined;
  outline?: string | undefined;
  variations?: ProductPromoEntry[] | undefined;
  attributes?: { [key: string]: string } | undefined;
}

export class PromotionEvaluationContext implements IPromotionEvaluationContext {
  refusedGiftIds?: string[] | undefined;
  storeId?: string | undefined;
  currency?: string | undefined;
  /** Customer id */
  customerId?: string | undefined;
  isRegisteredUser?: boolean;
  /** Has user made any orders */
  isFirstTimeBuyer?: boolean;
  isEveryone?: boolean;
  cartTotal?: number;
  /** Current shipment method */
  shipmentMethodCode?: string | undefined;
  shipmentMethodOption?: string | undefined;
  shipmentMethodPrice?: number;
  availableShipmentMethodCodes?: string[] | undefined;
  /** Current payment method */
  paymentMethodCode?: string | undefined;
  paymentMethodPrice?: number;
  availablePaymentMethodCodes?: string[] | undefined;
  /** Entered coupon */
  coupon?: string | undefined;
  coupons?: string[] | undefined;
  /** List of product promo in cart */
  cartPromoEntries?: ProductPromoEntry[] | undefined;
  /** List of products for promo evaluation */
  promoEntries?: ProductPromoEntry[] | undefined;
  promoEntry?: ProductPromoEntry;
  contextObject?: any | undefined;
  geoCity?: string | undefined;
  geoState?: string | undefined;
  geoCountry?: string | undefined;
  geoContinent?: string | undefined;
  geoZipCode?: string | undefined;
  geoConnectionType?: string | undefined;
  geoTimeZone?: string | undefined;
  geoIpRoutingType?: string | undefined;
  geoIspSecondLevel?: string | undefined;
  geoIspTopLevel?: string | undefined;
  shopperAge?: number;
  shopperGender?: string | undefined;
  language?: string | undefined;
  /** Any tags or groups belongs to user such as VIP, Wholesaler etc */
  userGroups?: string[] | undefined;
  shopperSearchedPhraseInStore?: string | undefined;
  shopperSearchedPhraseOnInternet?: string | undefined;
  currentUrl?: string | undefined;
  referredUrl?: string | undefined;

  constructor(data?: IPromotionEvaluationContext) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["refusedGiftIds"])) {
        this.refusedGiftIds = [] as any;
        for (let item of _data["refusedGiftIds"])
          this.refusedGiftIds!.push(item);
      }
      this.storeId = _data["storeId"];
      this.currency = _data["currency"];
      this.customerId = _data["customerId"];
      this.isRegisteredUser = _data["isRegisteredUser"];
      this.isFirstTimeBuyer = _data["isFirstTimeBuyer"];
      this.isEveryone = _data["isEveryone"];
      this.cartTotal = _data["cartTotal"];
      this.shipmentMethodCode = _data["shipmentMethodCode"];
      this.shipmentMethodOption = _data["shipmentMethodOption"];
      this.shipmentMethodPrice = _data["shipmentMethodPrice"];
      if (Array.isArray(_data["availableShipmentMethodCodes"])) {
        this.availableShipmentMethodCodes = [] as any;
        for (let item of _data["availableShipmentMethodCodes"])
          this.availableShipmentMethodCodes!.push(item);
      }
      this.paymentMethodCode = _data["paymentMethodCode"];
      this.paymentMethodPrice = _data["paymentMethodPrice"];
      if (Array.isArray(_data["availablePaymentMethodCodes"])) {
        this.availablePaymentMethodCodes = [] as any;
        for (let item of _data["availablePaymentMethodCodes"])
          this.availablePaymentMethodCodes!.push(item);
      }
      this.coupon = _data["coupon"];
      if (Array.isArray(_data["coupons"])) {
        this.coupons = [] as any;
        for (let item of _data["coupons"]) this.coupons!.push(item);
      }
      if (Array.isArray(_data["cartPromoEntries"])) {
        this.cartPromoEntries = [] as any;
        for (let item of _data["cartPromoEntries"])
          this.cartPromoEntries!.push(ProductPromoEntry.fromJS(item));
      }
      if (Array.isArray(_data["promoEntries"])) {
        this.promoEntries = [] as any;
        for (let item of _data["promoEntries"])
          this.promoEntries!.push(ProductPromoEntry.fromJS(item));
      }
      this.promoEntry = _data["promoEntry"]
        ? ProductPromoEntry.fromJS(_data["promoEntry"])
        : <any>undefined;
      this.contextObject = _data["contextObject"];
      this.geoCity = _data["geoCity"];
      this.geoState = _data["geoState"];
      this.geoCountry = _data["geoCountry"];
      this.geoContinent = _data["geoContinent"];
      this.geoZipCode = _data["geoZipCode"];
      this.geoConnectionType = _data["geoConnectionType"];
      this.geoTimeZone = _data["geoTimeZone"];
      this.geoIpRoutingType = _data["geoIpRoutingType"];
      this.geoIspSecondLevel = _data["geoIspSecondLevel"];
      this.geoIspTopLevel = _data["geoIspTopLevel"];
      this.shopperAge = _data["shopperAge"];
      this.shopperGender = _data["shopperGender"];
      this.language = _data["language"];
      if (Array.isArray(_data["userGroups"])) {
        this.userGroups = [] as any;
        for (let item of _data["userGroups"]) this.userGroups!.push(item);
      }
      this.shopperSearchedPhraseInStore = _data["shopperSearchedPhraseInStore"];
      this.shopperSearchedPhraseOnInternet =
        _data["shopperSearchedPhraseOnInternet"];
      this.currentUrl = _data["currentUrl"];
      this.referredUrl = _data["referredUrl"];
    }
  }

  static fromJS(data: any): PromotionEvaluationContext {
    data = typeof data === "object" ? data : {};
    let result = new PromotionEvaluationContext();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.refusedGiftIds)) {
      data["refusedGiftIds"] = [];
      for (let item of this.refusedGiftIds) data["refusedGiftIds"].push(item);
    }
    data["storeId"] = this.storeId;
    data["currency"] = this.currency;
    data["customerId"] = this.customerId;
    data["isRegisteredUser"] = this.isRegisteredUser;
    data["isFirstTimeBuyer"] = this.isFirstTimeBuyer;
    data["isEveryone"] = this.isEveryone;
    data["cartTotal"] = this.cartTotal;
    data["shipmentMethodCode"] = this.shipmentMethodCode;
    data["shipmentMethodOption"] = this.shipmentMethodOption;
    data["shipmentMethodPrice"] = this.shipmentMethodPrice;
    if (Array.isArray(this.availableShipmentMethodCodes)) {
      data["availableShipmentMethodCodes"] = [];
      for (let item of this.availableShipmentMethodCodes)
        data["availableShipmentMethodCodes"].push(item);
    }
    data["paymentMethodCode"] = this.paymentMethodCode;
    data["paymentMethodPrice"] = this.paymentMethodPrice;
    if (Array.isArray(this.availablePaymentMethodCodes)) {
      data["availablePaymentMethodCodes"] = [];
      for (let item of this.availablePaymentMethodCodes)
        data["availablePaymentMethodCodes"].push(item);
    }
    data["coupon"] = this.coupon;
    if (Array.isArray(this.coupons)) {
      data["coupons"] = [];
      for (let item of this.coupons) data["coupons"].push(item);
    }
    if (Array.isArray(this.cartPromoEntries)) {
      data["cartPromoEntries"] = [];
      for (let item of this.cartPromoEntries)
        data["cartPromoEntries"].push(item.toJSON());
    }
    if (Array.isArray(this.promoEntries)) {
      data["promoEntries"] = [];
      for (let item of this.promoEntries)
        data["promoEntries"].push(item.toJSON());
    }
    data["promoEntry"] = this.promoEntry
      ? this.promoEntry.toJSON()
      : <any>undefined;
    data["contextObject"] = this.contextObject;
    data["geoCity"] = this.geoCity;
    data["geoState"] = this.geoState;
    data["geoCountry"] = this.geoCountry;
    data["geoContinent"] = this.geoContinent;
    data["geoZipCode"] = this.geoZipCode;
    data["geoConnectionType"] = this.geoConnectionType;
    data["geoTimeZone"] = this.geoTimeZone;
    data["geoIpRoutingType"] = this.geoIpRoutingType;
    data["geoIspSecondLevel"] = this.geoIspSecondLevel;
    data["geoIspTopLevel"] = this.geoIspTopLevel;
    data["shopperAge"] = this.shopperAge;
    data["shopperGender"] = this.shopperGender;
    data["language"] = this.language;
    if (Array.isArray(this.userGroups)) {
      data["userGroups"] = [];
      for (let item of this.userGroups) data["userGroups"].push(item);
    }
    data["shopperSearchedPhraseInStore"] = this.shopperSearchedPhraseInStore;
    data["shopperSearchedPhraseOnInternet"] =
      this.shopperSearchedPhraseOnInternet;
    data["currentUrl"] = this.currentUrl;
    data["referredUrl"] = this.referredUrl;
    return data;
  }
}

export interface IPromotionEvaluationContext {
  refusedGiftIds?: string[] | undefined;
  storeId?: string | undefined;
  currency?: string | undefined;
  /** Customer id */
  customerId?: string | undefined;
  isRegisteredUser?: boolean;
  /** Has user made any orders */
  isFirstTimeBuyer?: boolean;
  isEveryone?: boolean;
  cartTotal?: number;
  /** Current shipment method */
  shipmentMethodCode?: string | undefined;
  shipmentMethodOption?: string | undefined;
  shipmentMethodPrice?: number;
  availableShipmentMethodCodes?: string[] | undefined;
  /** Current payment method */
  paymentMethodCode?: string | undefined;
  paymentMethodPrice?: number;
  availablePaymentMethodCodes?: string[] | undefined;
  /** Entered coupon */
  coupon?: string | undefined;
  coupons?: string[] | undefined;
  /** List of product promo in cart */
  cartPromoEntries?: ProductPromoEntry[] | undefined;
  /** List of products for promo evaluation */
  promoEntries?: ProductPromoEntry[] | undefined;
  promoEntry?: ProductPromoEntry;
  contextObject?: any | undefined;
  geoCity?: string | undefined;
  geoState?: string | undefined;
  geoCountry?: string | undefined;
  geoContinent?: string | undefined;
  geoZipCode?: string | undefined;
  geoConnectionType?: string | undefined;
  geoTimeZone?: string | undefined;
  geoIpRoutingType?: string | undefined;
  geoIspSecondLevel?: string | undefined;
  geoIspTopLevel?: string | undefined;
  shopperAge?: number;
  shopperGender?: string | undefined;
  language?: string | undefined;
  /** Any tags or groups belongs to user such as VIP, Wholesaler etc */
  userGroups?: string[] | undefined;
  shopperSearchedPhraseInStore?: string | undefined;
  shopperSearchedPhraseOnInternet?: string | undefined;
  currentUrl?: string | undefined;
  referredUrl?: string | undefined;
}

export enum RewardAmountType {
  Absolute = "Absolute",
  Relative = "Relative",
}

/** need to backward compatibility with v.2 */
export class PromotionReward implements IPromotionReward {
  /** Gets or sets the flag of promotion reward is valid. Also used as a flag for applicability (applied or potential) */
  isValid?: boolean;
  /** Gets or sets the value of promotion reward description */
  description?: string | undefined;
  /** Gets or sets the value of coupon amount */
  couponAmount?: number;
  /** Gets or sets the value of coupon code */
  coupon?: string | undefined;
  /** Gets or sets the value of minimum order total cost for applying coupon */
  couponMinOrderAmount?: number | undefined;
  /** Gets or sets the value of promotion id */
  promotionId?: string | undefined;
  promotion?: Promotion;
  /** Gets or sets the value of promotion reward type */
  rewardType?: string | undefined;
  amountType?: RewardAmountType;
  /** Gets or sets the value of promotion reward amount */
  amount?: number;
  /** Gets or sets the value of line item quantity for applying promotion reward */
  quantity?: number;
  /** Gets or sets the value of line item id */
  lineItemId?: string | undefined;
  /** Gets or sets the value of product id */
  productId?: string | undefined;
  /** Conditional product
  For N items of entry ProductId  in every Y items of entry ConditionalProductId get %X off */
  conditionalProductId?: string | undefined;
  /** Gets or sets the value of category id */
  categoryId?: string | undefined;
  /** Gets or sets the value of measurement unit */
  measureUnit?: string | undefined;
  /** Gets or sets the value of promotion reward logo absolute URL */
  imageUrl?: string | undefined;
  /** Gets or sets the value of reward shipping method code */
  shippingMethod?: string | undefined;
  /** Gets or sets the value of reward payment method code */
  paymentMethod?: string | undefined;
  /** Gets or sets the max limit for relative rewards */
  maxLimit?: number;
  forNthQuantity?: number;
  inEveryNthQuantity?: number;

  constructor(data?: IPromotionReward) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isValid = _data["isValid"];
      this.description = _data["description"];
      this.couponAmount = _data["couponAmount"];
      this.coupon = _data["coupon"];
      this.couponMinOrderAmount = _data["couponMinOrderAmount"];
      this.promotionId = _data["promotionId"];
      this.promotion = _data["promotion"]
        ? Promotion.fromJS(_data["promotion"])
        : <any>undefined;
      this.rewardType = _data["rewardType"];
      this.amountType = _data["amountType"];
      this.amount = _data["amount"];
      this.quantity = _data["quantity"];
      this.lineItemId = _data["lineItemId"];
      this.productId = _data["productId"];
      this.conditionalProductId = _data["conditionalProductId"];
      this.categoryId = _data["categoryId"];
      this.measureUnit = _data["measureUnit"];
      this.imageUrl = _data["imageUrl"];
      this.shippingMethod = _data["shippingMethod"];
      this.paymentMethod = _data["paymentMethod"];
      this.maxLimit = _data["maxLimit"];
      this.forNthQuantity = _data["forNthQuantity"];
      this.inEveryNthQuantity = _data["inEveryNthQuantity"];
    }
  }

  static fromJS(data: any): PromotionReward {
    data = typeof data === "object" ? data : {};
    let result = new PromotionReward();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["isValid"] = this.isValid;
    data["description"] = this.description;
    data["couponAmount"] = this.couponAmount;
    data["coupon"] = this.coupon;
    data["couponMinOrderAmount"] = this.couponMinOrderAmount;
    data["promotionId"] = this.promotionId;
    data["promotion"] = this.promotion
      ? this.promotion.toJSON()
      : <any>undefined;
    data["rewardType"] = this.rewardType;
    data["amountType"] = this.amountType;
    data["amount"] = this.amount;
    data["quantity"] = this.quantity;
    data["lineItemId"] = this.lineItemId;
    data["productId"] = this.productId;
    data["conditionalProductId"] = this.conditionalProductId;
    data["categoryId"] = this.categoryId;
    data["measureUnit"] = this.measureUnit;
    data["imageUrl"] = this.imageUrl;
    data["shippingMethod"] = this.shippingMethod;
    data["paymentMethod"] = this.paymentMethod;
    data["maxLimit"] = this.maxLimit;
    data["forNthQuantity"] = this.forNthQuantity;
    data["inEveryNthQuantity"] = this.inEveryNthQuantity;
    return data;
  }
}

/** need to backward compatibility with v.2 */
export interface IPromotionReward {
  /** Gets or sets the flag of promotion reward is valid. Also used as a flag for applicability (applied or potential) */
  isValid?: boolean;
  /** Gets or sets the value of promotion reward description */
  description?: string | undefined;
  /** Gets or sets the value of coupon amount */
  couponAmount?: number;
  /** Gets or sets the value of coupon code */
  coupon?: string | undefined;
  /** Gets or sets the value of minimum order total cost for applying coupon */
  couponMinOrderAmount?: number | undefined;
  /** Gets or sets the value of promotion id */
  promotionId?: string | undefined;
  promotion?: Promotion;
  /** Gets or sets the value of promotion reward type */
  rewardType?: string | undefined;
  amountType?: RewardAmountType;
  /** Gets or sets the value of promotion reward amount */
  amount?: number;
  /** Gets or sets the value of line item quantity for applying promotion reward */
  quantity?: number;
  /** Gets or sets the value of line item id */
  lineItemId?: string | undefined;
  /** Gets or sets the value of product id */
  productId?: string | undefined;
  /** Conditional product
  For N items of entry ProductId  in every Y items of entry ConditionalProductId get %X off */
  conditionalProductId?: string | undefined;
  /** Gets or sets the value of category id */
  categoryId?: string | undefined;
  /** Gets or sets the value of measurement unit */
  measureUnit?: string | undefined;
  /** Gets or sets the value of promotion reward logo absolute URL */
  imageUrl?: string | undefined;
  /** Gets or sets the value of reward shipping method code */
  shippingMethod?: string | undefined;
  /** Gets or sets the value of reward payment method code */
  paymentMethod?: string | undefined;
  /** Gets or sets the max limit for relative rewards */
  maxLimit?: number;
  forNthQuantity?: number;
  inEveryNthQuantity?: number;
}

export class CouponSearchCriteria implements ICouponSearchCriteria {
  code?: string | undefined;
  codes?: string[] | undefined;
  promotionId?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: ICouponSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.code = _data["code"];
      if (Array.isArray(_data["codes"])) {
        this.codes = [] as any;
        for (let item of _data["codes"]) this.codes!.push(item);
      }
      this.promotionId = _data["promotionId"];
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): CouponSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new CouponSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["code"] = this.code;
    if (Array.isArray(this.codes)) {
      data["codes"] = [];
      for (let item of this.codes) data["codes"].push(item);
    }
    data["promotionId"] = this.promotionId;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface ICouponSearchCriteria {
  code?: string | undefined;
  codes?: string[] | undefined;
  promotionId?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class Coupon implements ICoupon {
  /** Restriction of total coupon usages
  0 infinitive */
  maxUsesNumber?: number;
  /** Maximum number of uses per registered user
  0 infinitive */
  maxUsesPerUser?: number;
  expirationDate?: Date | undefined;
  /** coupon code */
  code?: string | undefined;
  promotionId?: string | undefined;
  /** Total number of uses */
  totalUsesCount?: number;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: ICoupon) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.maxUsesNumber = _data["maxUsesNumber"];
      this.maxUsesPerUser = _data["maxUsesPerUser"];
      this.expirationDate = _data["expirationDate"]
        ? new Date(_data["expirationDate"].toString())
        : <any>undefined;
      this.code = _data["code"];
      this.promotionId = _data["promotionId"];
      this.totalUsesCount = _data["totalUsesCount"];
      this.outerId = _data["outerId"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Coupon {
    data = typeof data === "object" ? data : {};
    let result = new Coupon();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["maxUsesNumber"] = this.maxUsesNumber;
    data["maxUsesPerUser"] = this.maxUsesPerUser;
    data["expirationDate"] = this.expirationDate
      ? this.expirationDate.toISOString()
      : <any>undefined;
    data["code"] = this.code;
    data["promotionId"] = this.promotionId;
    data["totalUsesCount"] = this.totalUsesCount;
    data["outerId"] = this.outerId;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface ICoupon {
  /** Restriction of total coupon usages
  0 infinitive */
  maxUsesNumber?: number;
  /** Maximum number of uses per registered user
  0 infinitive */
  maxUsesPerUser?: number;
  expirationDate?: Date | undefined;
  /** coupon code */
  code?: string | undefined;
  promotionId?: string | undefined;
  /** Total number of uses */
  totalUsesCount?: number;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class CouponSearchResult implements ICouponSearchResult {
  totalCount?: number;
  results?: Coupon[] | undefined;

  constructor(data?: ICouponSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(Coupon.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CouponSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new CouponSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface ICouponSearchResult {
  totalCount?: number;
  results?: Coupon[] | undefined;
}

export class ImportRequest implements IImportRequest {
  fileUrl?: string | undefined;
  delimiter?: string | undefined;
  promotionId?: string | undefined;
  expirationDate?: Date | undefined;

  constructor(data?: IImportRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fileUrl = _data["fileUrl"];
      this.delimiter = _data["delimiter"];
      this.promotionId = _data["promotionId"];
      this.expirationDate = _data["expirationDate"]
        ? new Date(_data["expirationDate"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): ImportRequest {
    data = typeof data === "object" ? data : {};
    let result = new ImportRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["fileUrl"] = this.fileUrl;
    data["delimiter"] = this.delimiter;
    data["promotionId"] = this.promotionId;
    data["expirationDate"] = this.expirationDate
      ? this.expirationDate.toISOString()
      : <any>undefined;
    return data;
  }
}

export interface IImportRequest {
  fileUrl?: string | undefined;
  delimiter?: string | undefined;
  promotionId?: string | undefined;
  expirationDate?: Date | undefined;
}

export class ImportNotification implements IImportNotification {
  finished?: Date | undefined;
  totalCount?: number;
  processedCount?: number;
  errorCount?: number;
  errors?: string[] | undefined;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;

  constructor(data?: IImportNotification) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.finished = _data["finished"]
        ? new Date(_data["finished"].toString())
        : <any>undefined;
      this.totalCount = _data["totalCount"];
      this.processedCount = _data["processedCount"];
      this.errorCount = _data["errorCount"];
      if (Array.isArray(_data["errors"])) {
        this.errors = [] as any;
        for (let item of _data["errors"]) this.errors!.push(item);
      }
      this.serverId = _data["serverId"];
      this.creator = _data["creator"];
      this.created = _data["created"]
        ? new Date(_data["created"].toString())
        : <any>undefined;
      this.isNew = _data["isNew"];
      this.notifyType = _data["notifyType"];
      this.description = _data["description"];
      this.title = _data["title"];
      this.repeatCount = _data["repeatCount"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): ImportNotification {
    data = typeof data === "object" ? data : {};
    let result = new ImportNotification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["finished"] = this.finished
      ? this.finished.toISOString()
      : <any>undefined;
    data["totalCount"] = this.totalCount;
    data["processedCount"] = this.processedCount;
    data["errorCount"] = this.errorCount;
    if (Array.isArray(this.errors)) {
      data["errors"] = [];
      for (let item of this.errors) data["errors"].push(item);
    }
    data["serverId"] = this.serverId;
    data["creator"] = this.creator;
    data["created"] = this.created
      ? this.created.toISOString()
      : <any>undefined;
    data["isNew"] = this.isNew;
    data["notifyType"] = this.notifyType;
    data["description"] = this.description;
    data["title"] = this.title;
    data["repeatCount"] = this.repeatCount;
    data["id"] = this.id;
    return data;
  }
}

export interface IImportNotification {
  finished?: Date | undefined;
  totalCount?: number;
  processedCount?: number;
  errorCount?: number;
  errors?: string[] | undefined;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;
}

/** Criteria for searching */
export class NotificationSearchCriteria implements INotificationSearchCriteria {
  notificationType?: string | undefined;
  /** Owner Id of Notification */
  tenantId?: string | undefined;
  /** Owner Type of Notification */
  tenantType?: string | undefined;
  /** only active notification */
  isActive?: boolean;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: INotificationSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.notificationType = _data["notificationType"];
      this.tenantId = _data["tenantId"];
      this.tenantType = _data["tenantType"];
      this.isActive = _data["isActive"];
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): NotificationSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new NotificationSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["notificationType"] = this.notificationType;
    data["tenantId"] = this.tenantId;
    data["tenantType"] = this.tenantType;
    data["isActive"] = this.isActive;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

/** Criteria for searching */
export interface INotificationSearchCriteria {
  notificationType?: string | undefined;
  /** Owner Id of Notification */
  tenantId?: string | undefined;
  /** Owner Type of Notification */
  tenantType?: string | undefined;
  /** only active notification */
  isActive?: boolean;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

/** Template of Notification with a different language */
export class NotificationTemplate implements INotificationTemplate {
  /** Code of Language */
  languageCode?: string | undefined;
  /** For detecting kind of notifications (email, sms and etc.) */
  readonly kind?: string | undefined;
  isReadonly?: boolean;
  outerId?: string | undefined;
  isPredefined?: boolean;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: INotificationTemplate) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.languageCode = _data["languageCode"];
      (<any>this).kind = _data["kind"];
      this.isReadonly = _data["isReadonly"];
      this.outerId = _data["outerId"];
      this.isPredefined = _data["isPredefined"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): NotificationTemplate {
    data = typeof data === "object" ? data : {};
    let result = new NotificationTemplate();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["languageCode"] = this.languageCode;
    data["kind"] = this.kind;
    data["isReadonly"] = this.isReadonly;
    data["outerId"] = this.outerId;
    data["isPredefined"] = this.isPredefined;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

/** Template of Notification with a different language */
export interface INotificationTemplate {
  /** Code of Language */
  languageCode?: string | undefined;
  /** For detecting kind of notifications (email, sms and etc.) */
  kind?: string | undefined;
  isReadonly?: boolean;
  outerId?: string | undefined;
  isPredefined?: boolean;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

/** Base class for Notification */
export class Notification implements INotification {
  tenantIdentity?: TenantIdentity;
  isActive?: boolean | undefined;
  languageCode?: string | undefined;
  /** This field represents an alias for the notification type
  and is used only for backward compatibility with old notification names
  that are stored and used by API clients. */
  alias?: string | undefined;
  /** Type of notifications, like Identifier */
  type?: string | undefined;
  /** For detecting kind of notifications (email, sms and etc.) */
  readonly kind?: string | undefined;
  outerId?: string | undefined;
  templates?: NotificationTemplate[] | undefined;
  /** need for saving validation errors
  if the property is not empty then the notification is not sent
  for seting use SetCustomValidationError */
  readonly customValidationError?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: INotification) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantIdentity = _data["tenantIdentity"]
        ? TenantIdentity.fromJS(_data["tenantIdentity"])
        : <any>undefined;
      this.isActive = _data["isActive"];
      this.languageCode = _data["languageCode"];
      this.alias = _data["alias"];
      this.type = _data["type"];
      (<any>this).kind = _data["kind"];
      this.outerId = _data["outerId"];
      if (Array.isArray(_data["templates"])) {
        this.templates = [] as any;
        for (let item of _data["templates"])
          this.templates!.push(NotificationTemplate.fromJS(item));
      }
      (<any>this).customValidationError = _data["customValidationError"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Notification {
    data = typeof data === "object" ? data : {};
    let result = new Notification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["tenantIdentity"] = this.tenantIdentity
      ? this.tenantIdentity.toJSON()
      : <any>undefined;
    data["isActive"] = this.isActive;
    data["languageCode"] = this.languageCode;
    data["alias"] = this.alias;
    data["type"] = this.type;
    data["kind"] = this.kind;
    data["outerId"] = this.outerId;
    if (Array.isArray(this.templates)) {
      data["templates"] = [];
      for (let item of this.templates) data["templates"].push(item.toJSON());
    }
    data["customValidationError"] = this.customValidationError;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

/** Base class for Notification */
export interface INotification {
  tenantIdentity?: TenantIdentity;
  isActive?: boolean | undefined;
  languageCode?: string | undefined;
  /** This field represents an alias for the notification type
  and is used only for backward compatibility with old notification names
  that are stored and used by API clients. */
  alias?: string | undefined;
  /** Type of notifications, like Identifier */
  type?: string | undefined;
  /** For detecting kind of notifications (email, sms and etc.) */
  kind?: string | undefined;
  outerId?: string | undefined;
  templates?: NotificationTemplate[] | undefined;
  /** need for saving validation errors
  if the property is not empty then the notification is not sent
  for seting use SetCustomValidationError */
  customValidationError?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class NotificationSearchResult implements INotificationSearchResult {
  totalCount?: number;
  results?: Notification[] | undefined;

  constructor(data?: INotificationSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(Notification.fromJS(item));
      }
    }
  }

  static fromJS(data: any): NotificationSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new NotificationSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface INotificationSearchResult {
  totalCount?: number;
  results?: Notification[] | undefined;
}

export class NotificationTemplateRequest
  implements INotificationTemplateRequest
{
  text?: string | undefined;
  data?: Notification;

  constructor(data?: INotificationTemplateRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.text = _data["text"];
      this.data = _data["data"]
        ? Notification.fromJS(_data["data"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): NotificationTemplateRequest {
    data = typeof data === "object" ? data : {};
    let result = new NotificationTemplateRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["text"] = this.text;
    data["data"] = this.data ? this.data.toJSON() : <any>undefined;
    return data;
  }
}

export interface INotificationTemplateRequest {
  text?: string | undefined;
  data?: Notification;
}

/** Result of notification sending */
export class NotificationSendResult implements INotificationSendResult {
  errorMessage?: string | undefined;
  isSuccess?: boolean;

  constructor(data?: INotificationSendResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.errorMessage = _data["errorMessage"];
      this.isSuccess = _data["isSuccess"];
    }
  }

  static fromJS(data: any): NotificationSendResult {
    data = typeof data === "object" ? data : {};
    let result = new NotificationSendResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["errorMessage"] = this.errorMessage;
    data["isSuccess"] = this.isSuccess;
    return data;
  }
}

/** Result of notification sending */
export interface INotificationSendResult {
  errorMessage?: string | undefined;
  isSuccess?: boolean;
}

export enum NotificationParameterValueType {
  String = "String",
  Integer = "Integer",
  Decimal = "Decimal",
  DateTime = "DateTime",
  Boolean = "Boolean",
}

export class NotificationParameter implements INotificationParameter {
  parameterName?: string | undefined;
  parameterDescription?: string | undefined;
  parameterCodeInView?: string | undefined;
  isDictionary?: boolean;
  isArray?: boolean;
  type?: NotificationParameterValueType;
  value?: any | undefined;

  constructor(data?: INotificationParameter) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.parameterName = _data["parameterName"];
      this.parameterDescription = _data["parameterDescription"];
      this.parameterCodeInView = _data["parameterCodeInView"];
      this.isDictionary = _data["isDictionary"];
      this.isArray = _data["isArray"];
      this.type = _data["type"];
      this.value = _data["value"];
    }
  }

  static fromJS(data: any): NotificationParameter {
    data = typeof data === "object" ? data : {};
    let result = new NotificationParameter();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["parameterName"] = this.parameterName;
    data["parameterDescription"] = this.parameterDescription;
    data["parameterCodeInView"] = this.parameterCodeInView;
    data["isDictionary"] = this.isDictionary;
    data["isArray"] = this.isArray;
    data["type"] = this.type;
    data["value"] = this.value;
    return data;
  }
}

export interface INotificationParameter {
  parameterName?: string | undefined;
  parameterDescription?: string | undefined;
  parameterCodeInView?: string | undefined;
  isDictionary?: boolean;
  isArray?: boolean;
  type?: NotificationParameterValueType;
  value?: any | undefined;
}

export class NotificationRequest implements INotificationRequest {
  type?: string | undefined;
  objectId?: string | undefined;
  objectTypeId?: string | undefined;
  language?: string | undefined;
  notificationParameters?: NotificationParameter[] | undefined;

  constructor(data?: INotificationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data["type"];
      this.objectId = _data["objectId"];
      this.objectTypeId = _data["objectTypeId"];
      this.language = _data["language"];
      if (Array.isArray(_data["notificationParameters"])) {
        this.notificationParameters = [] as any;
        for (let item of _data["notificationParameters"])
          this.notificationParameters!.push(NotificationParameter.fromJS(item));
      }
    }
  }

  static fromJS(data: any): NotificationRequest {
    data = typeof data === "object" ? data : {};
    let result = new NotificationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["type"] = this.type;
    data["objectId"] = this.objectId;
    data["objectTypeId"] = this.objectTypeId;
    data["language"] = this.language;
    if (Array.isArray(this.notificationParameters)) {
      data["notificationParameters"] = [];
      for (let item of this.notificationParameters)
        data["notificationParameters"].push(item.toJSON());
    }
    return data;
  }
}

export interface INotificationRequest {
  type?: string | undefined;
  objectId?: string | undefined;
  objectTypeId?: string | undefined;
  language?: string | undefined;
  notificationParameters?: NotificationParameter[] | undefined;
}

export class NotificationMessageSearchCriteria
  implements INotificationMessageSearchCriteria
{
  notificationType?: string | undefined;
  status?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: INotificationMessageSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.notificationType = _data["notificationType"];
      this.status = _data["status"];
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): NotificationMessageSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new NotificationMessageSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["notificationType"] = this.notificationType;
    data["status"] = this.status;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface INotificationMessageSearchCriteria {
  notificationType?: string | undefined;
  status?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export enum NotificationMessageStatus {
  Pending = "Pending",
  Sent = "Sent",
  Error = "Error",
}

/** Base class for message of a notification with information about sending */
export class NotificationMessage implements INotificationMessage {
  readonly kind?: string | undefined;
  tenantIdentity?: TenantIdentity;
  /** Id of Notification */
  notificationId?: string | undefined;
  /** Type of Notification */
  notificationType?: string | undefined;
  /** Count of sending attempt */
  sendAttemptCount?: number;
  /** Max count of sending attempt */
  maxSendAttemptCount?: number;
  /** The last error of sending */
  lastSendError?: string | undefined;
  /** The last date of sending attempt */
  lastSendAttemptDate?: Date | undefined;
  /** Date of sending */
  sendDate?: Date | undefined;
  /** Code of language */
  languageCode?: string | undefined;
  status?: NotificationMessageStatus;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: INotificationMessage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).kind = _data["kind"];
      this.tenantIdentity = _data["tenantIdentity"]
        ? TenantIdentity.fromJS(_data["tenantIdentity"])
        : <any>undefined;
      this.notificationId = _data["notificationId"];
      this.notificationType = _data["notificationType"];
      this.sendAttemptCount = _data["sendAttemptCount"];
      this.maxSendAttemptCount = _data["maxSendAttemptCount"];
      this.lastSendError = _data["lastSendError"];
      this.lastSendAttemptDate = _data["lastSendAttemptDate"]
        ? new Date(_data["lastSendAttemptDate"].toString())
        : <any>undefined;
      this.sendDate = _data["sendDate"]
        ? new Date(_data["sendDate"].toString())
        : <any>undefined;
      this.languageCode = _data["languageCode"];
      this.status = _data["status"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): NotificationMessage {
    data = typeof data === "object" ? data : {};
    let result = new NotificationMessage();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["kind"] = this.kind;
    data["tenantIdentity"] = this.tenantIdentity
      ? this.tenantIdentity.toJSON()
      : <any>undefined;
    data["notificationId"] = this.notificationId;
    data["notificationType"] = this.notificationType;
    data["sendAttemptCount"] = this.sendAttemptCount;
    data["maxSendAttemptCount"] = this.maxSendAttemptCount;
    data["lastSendError"] = this.lastSendError;
    data["lastSendAttemptDate"] = this.lastSendAttemptDate
      ? this.lastSendAttemptDate.toISOString()
      : <any>undefined;
    data["sendDate"] = this.sendDate
      ? this.sendDate.toISOString()
      : <any>undefined;
    data["languageCode"] = this.languageCode;
    data["status"] = this.status;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

/** Base class for message of a notification with information about sending */
export interface INotificationMessage {
  kind?: string | undefined;
  tenantIdentity?: TenantIdentity;
  /** Id of Notification */
  notificationId?: string | undefined;
  /** Type of Notification */
  notificationType?: string | undefined;
  /** Count of sending attempt */
  sendAttemptCount?: number;
  /** Max count of sending attempt */
  maxSendAttemptCount?: number;
  /** The last error of sending */
  lastSendError?: string | undefined;
  /** The last date of sending attempt */
  lastSendAttemptDate?: Date | undefined;
  /** Date of sending */
  sendDate?: Date | undefined;
  /** Code of language */
  languageCode?: string | undefined;
  status?: NotificationMessageStatus;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class NotificationMessageSearchResult
  implements INotificationMessageSearchResult
{
  totalCount?: number;
  results?: NotificationMessage[] | undefined;

  constructor(data?: INotificationMessageSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(NotificationMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): NotificationMessageSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new NotificationMessageSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface INotificationMessageSearchResult {
  totalCount?: number;
  results?: NotificationMessage[] | undefined;
}

export class CustomerOrderSearchCriteria
  implements ICustomerOrderSearchCriteria
{
  /** Search orders with flag IsPrototype */
  withPrototypes?: boolean;
  /** Search only recurring orders created by subscription */
  onlyRecurring?: boolean;
  /** Search orders with given subscription */
  subscriptionId?: string | undefined;
  subscriptionIds?: string[] | undefined;
  /** It used to limit search within an operation (customer order for example) */
  operationId?: string | undefined;
  customerId?: string | undefined;
  customerIds?: string[] | undefined;
  ids?: string[] | undefined;
  employeeId?: string | undefined;
  storeIds?: string[] | undefined;
  /** Search by status */
  status?: string | undefined;
  statuses?: string[] | undefined;
  /** Search by numbers */
  number?: string | undefined;
  numbers?: string[] | undefined;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: ICustomerOrderSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.withPrototypes = _data["withPrototypes"];
      this.onlyRecurring = _data["onlyRecurring"];
      this.subscriptionId = _data["subscriptionId"];
      if (Array.isArray(_data["subscriptionIds"])) {
        this.subscriptionIds = [] as any;
        for (let item of _data["subscriptionIds"])
          this.subscriptionIds!.push(item);
      }
      this.operationId = _data["operationId"];
      this.customerId = _data["customerId"];
      if (Array.isArray(_data["customerIds"])) {
        this.customerIds = [] as any;
        for (let item of _data["customerIds"]) this.customerIds!.push(item);
      }
      if (Array.isArray(_data["ids"])) {
        this.ids = [] as any;
        for (let item of _data["ids"]) this.ids!.push(item);
      }
      this.employeeId = _data["employeeId"];
      if (Array.isArray(_data["storeIds"])) {
        this.storeIds = [] as any;
        for (let item of _data["storeIds"]) this.storeIds!.push(item);
      }
      this.status = _data["status"];
      if (Array.isArray(_data["statuses"])) {
        this.statuses = [] as any;
        for (let item of _data["statuses"]) this.statuses!.push(item);
      }
      this.number = _data["number"];
      if (Array.isArray(_data["numbers"])) {
        this.numbers = [] as any;
        for (let item of _data["numbers"]) this.numbers!.push(item);
      }
      this.startDate = _data["startDate"]
        ? new Date(_data["startDate"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? new Date(_data["endDate"].toString())
        : <any>undefined;
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): CustomerOrderSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new CustomerOrderSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["withPrototypes"] = this.withPrototypes;
    data["onlyRecurring"] = this.onlyRecurring;
    data["subscriptionId"] = this.subscriptionId;
    if (Array.isArray(this.subscriptionIds)) {
      data["subscriptionIds"] = [];
      for (let item of this.subscriptionIds) data["subscriptionIds"].push(item);
    }
    data["operationId"] = this.operationId;
    data["customerId"] = this.customerId;
    if (Array.isArray(this.customerIds)) {
      data["customerIds"] = [];
      for (let item of this.customerIds) data["customerIds"].push(item);
    }
    if (Array.isArray(this.ids)) {
      data["ids"] = [];
      for (let item of this.ids) data["ids"].push(item);
    }
    data["employeeId"] = this.employeeId;
    if (Array.isArray(this.storeIds)) {
      data["storeIds"] = [];
      for (let item of this.storeIds) data["storeIds"].push(item);
    }
    data["status"] = this.status;
    if (Array.isArray(this.statuses)) {
      data["statuses"] = [];
      for (let item of this.statuses) data["statuses"].push(item);
    }
    data["number"] = this.number;
    if (Array.isArray(this.numbers)) {
      data["numbers"] = [];
      for (let item of this.numbers) data["numbers"].push(item);
    }
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface ICustomerOrderSearchCriteria {
  /** Search orders with flag IsPrototype */
  withPrototypes?: boolean;
  /** Search only recurring orders created by subscription */
  onlyRecurring?: boolean;
  /** Search orders with given subscription */
  subscriptionId?: string | undefined;
  subscriptionIds?: string[] | undefined;
  /** It used to limit search within an operation (customer order for example) */
  operationId?: string | undefined;
  customerId?: string | undefined;
  customerIds?: string[] | undefined;
  ids?: string[] | undefined;
  employeeId?: string | undefined;
  storeIds?: string[] | undefined;
  /** Search by status */
  status?: string | undefined;
  statuses?: string[] | undefined;
  /** Search by numbers */
  number?: string | undefined;
  numbers?: string[] | undefined;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class OrderAddress implements IOrderAddress {
  addressType?: AddressType;
  key?: string | undefined;
  name?: string | undefined;
  organization?: string | undefined;
  countryCode?: string | undefined;
  countryName?: string | undefined;
  city?: string | undefined;
  postalCode?: string | undefined;
  zip?: string | undefined;
  line1?: string | undefined;
  line2?: string | undefined;
  regionId?: string | undefined;
  regionName?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  email?: string | undefined;

  constructor(data?: IOrderAddress) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.addressType = _data["addressType"];
      this.key = _data["key"];
      this.name = _data["name"];
      this.organization = _data["organization"];
      this.countryCode = _data["countryCode"];
      this.countryName = _data["countryName"];
      this.city = _data["city"];
      this.postalCode = _data["postalCode"];
      this.zip = _data["zip"];
      this.line1 = _data["line1"];
      this.line2 = _data["line2"];
      this.regionId = _data["regionId"];
      this.regionName = _data["regionName"];
      this.firstName = _data["firstName"];
      this.middleName = _data["middleName"];
      this.lastName = _data["lastName"];
      this.phone = _data["phone"];
      this.email = _data["email"];
    }
  }

  static fromJS(data: any): OrderAddress {
    data = typeof data === "object" ? data : {};
    let result = new OrderAddress();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["addressType"] = this.addressType;
    data["key"] = this.key;
    data["name"] = this.name;
    data["organization"] = this.organization;
    data["countryCode"] = this.countryCode;
    data["countryName"] = this.countryName;
    data["city"] = this.city;
    data["postalCode"] = this.postalCode;
    data["zip"] = this.zip;
    data["line1"] = this.line1;
    data["line2"] = this.line2;
    data["regionId"] = this.regionId;
    data["regionName"] = this.regionName;
    data["firstName"] = this.firstName;
    data["middleName"] = this.middleName;
    data["lastName"] = this.lastName;
    data["phone"] = this.phone;
    data["email"] = this.email;
    return data;
  }
}

export interface IOrderAddress {
  addressType?: AddressType;
  key?: string | undefined;
  name?: string | undefined;
  organization?: string | undefined;
  countryCode?: string | undefined;
  countryName?: string | undefined;
  city?: string | undefined;
  postalCode?: string | undefined;
  zip?: string | undefined;
  line1?: string | undefined;
  line2?: string | undefined;
  regionId?: string | undefined;
  regionName?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  email?: string | undefined;
}

export enum PaymentStatus {
  New = "New",
  Pending = "Pending",
  Authorized = "Authorized",
  Paid = "Paid",
  PartiallyRefunded = "PartiallyRefunded",
  Refunded = "Refunded",
  Voided = "Voided",
  Custom = "Custom",
  Cancelled = "Cancelled",
  Declined = "Declined",
  Error = "Error",
}

export class ProcessPaymentRequestResult
  implements IProcessPaymentRequestResult
{
  redirectUrl?: string | undefined;
  htmlForm?: string | undefined;
  outerId?: string | undefined;
  paymentMethod?: PaymentMethod;
  isSuccess?: boolean;
  errorMessage?: string | undefined;
  newPaymentStatus?: PaymentStatus;

  constructor(data?: IProcessPaymentRequestResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.redirectUrl = _data["redirectUrl"];
      this.htmlForm = _data["htmlForm"];
      this.outerId = _data["outerId"];
      this.paymentMethod = _data["paymentMethod"]
        ? PaymentMethod.fromJS(_data["paymentMethod"])
        : <any>undefined;
      this.isSuccess = _data["isSuccess"];
      this.errorMessage = _data["errorMessage"];
      this.newPaymentStatus = _data["newPaymentStatus"];
    }
  }

  static fromJS(data: any): ProcessPaymentRequestResult {
    data = typeof data === "object" ? data : {};
    let result = new ProcessPaymentRequestResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["redirectUrl"] = this.redirectUrl;
    data["htmlForm"] = this.htmlForm;
    data["outerId"] = this.outerId;
    data["paymentMethod"] = this.paymentMethod
      ? this.paymentMethod.toJSON()
      : <any>undefined;
    data["isSuccess"] = this.isSuccess;
    data["errorMessage"] = this.errorMessage;
    data["newPaymentStatus"] = this.newPaymentStatus;
    return data;
  }
}

export interface IProcessPaymentRequestResult {
  redirectUrl?: string | undefined;
  htmlForm?: string | undefined;
  outerId?: string | undefined;
  paymentMethod?: PaymentMethod;
  isSuccess?: boolean;
  errorMessage?: string | undefined;
  newPaymentStatus?: PaymentStatus;
}

export class PaymentGatewayTransaction implements IPaymentGatewayTransaction {
  amount?: number;
  currencyCode?: string | undefined;
  /** Flag represent that current transaction is processed */
  isProcessed?: boolean;
  /** Date when this transaction was handled */
  processedDate?: Date | undefined;
  processError?: string | undefined;
  processAttemptCount?: number;
  /** Raw request data */
  requestData?: string | undefined;
  /** Raw response data */
  responseData?: string | undefined;
  /** Gateway or VC response status code */
  responseCode?: string | undefined;
  /** Gateway IP address */
  gatewayIpAddress?: string | undefined;
  /** The type of payment interaction.The payment can be Capture or CheckReceived. 
  The value also includes customer payment interactions such as Website, Call, Store, or Unknown. */
  type?: string | undefined;
  /** "Active", "Expired", and "Inactive" or other */
  status?: string | undefined;
  note?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IPaymentGatewayTransaction) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.amount = _data["amount"];
      this.currencyCode = _data["currencyCode"];
      this.isProcessed = _data["isProcessed"];
      this.processedDate = _data["processedDate"]
        ? new Date(_data["processedDate"].toString())
        : <any>undefined;
      this.processError = _data["processError"];
      this.processAttemptCount = _data["processAttemptCount"];
      this.requestData = _data["requestData"];
      this.responseData = _data["responseData"];
      this.responseCode = _data["responseCode"];
      this.gatewayIpAddress = _data["gatewayIpAddress"];
      this.type = _data["type"];
      this.status = _data["status"];
      this.note = _data["note"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): PaymentGatewayTransaction {
    data = typeof data === "object" ? data : {};
    let result = new PaymentGatewayTransaction();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["amount"] = this.amount;
    data["currencyCode"] = this.currencyCode;
    data["isProcessed"] = this.isProcessed;
    data["processedDate"] = this.processedDate
      ? this.processedDate.toISOString()
      : <any>undefined;
    data["processError"] = this.processError;
    data["processAttemptCount"] = this.processAttemptCount;
    data["requestData"] = this.requestData;
    data["responseData"] = this.responseData;
    data["responseCode"] = this.responseCode;
    data["gatewayIpAddress"] = this.gatewayIpAddress;
    data["type"] = this.type;
    data["status"] = this.status;
    data["note"] = this.note;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IPaymentGatewayTransaction {
  amount?: number;
  currencyCode?: string | undefined;
  /** Flag represent that current transaction is processed */
  isProcessed?: boolean;
  /** Date when this transaction was handled */
  processedDate?: Date | undefined;
  processError?: string | undefined;
  processAttemptCount?: number;
  /** Raw request data */
  requestData?: string | undefined;
  /** Raw response data */
  responseData?: string | undefined;
  /** Gateway or VC response status code */
  responseCode?: string | undefined;
  /** Gateway IP address */
  gatewayIpAddress?: string | undefined;
  /** The type of payment interaction.The payment can be Capture or CheckReceived. 
  The value also includes customer payment interactions such as Website, Call, Store, or Unknown. */
  type?: string | undefined;
  /** "Active", "Expired", and "Inactive" or other */
  status?: string | undefined;
  note?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class IOperation implements IIOperation {
  operationType?: string | undefined;
  parentOperationId?: string | undefined;
  number?: string | undefined;
  isApproved?: boolean;
  status?: string | undefined;
  comment?: string | undefined;
  currency?: string | undefined;
  childrenOperations?: IOperation[] | undefined;
  id?: string | undefined;

  constructor(data?: IIOperation) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.operationType = _data["operationType"];
      this.parentOperationId = _data["parentOperationId"];
      this.number = _data["number"];
      this.isApproved = _data["isApproved"];
      this.status = _data["status"];
      this.comment = _data["comment"];
      this.currency = _data["currency"];
      if (Array.isArray(_data["childrenOperations"])) {
        this.childrenOperations = [] as any;
        for (let item of _data["childrenOperations"])
          this.childrenOperations!.push(IOperation.fromJS(item));
      }
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): IOperation {
    data = typeof data === "object" ? data : {};
    let result = new IOperation();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["operationType"] = this.operationType;
    data["parentOperationId"] = this.parentOperationId;
    data["number"] = this.number;
    data["isApproved"] = this.isApproved;
    data["status"] = this.status;
    data["comment"] = this.comment;
    data["currency"] = this.currency;
    if (Array.isArray(this.childrenOperations)) {
      data["childrenOperations"] = [];
      for (let item of this.childrenOperations)
        data["childrenOperations"].push(item.toJSON());
    }
    data["id"] = this.id;
    return data;
  }
}

export interface IIOperation {
  operationType?: string | undefined;
  parentOperationId?: string | undefined;
  number?: string | undefined;
  isApproved?: boolean;
  status?: string | undefined;
  comment?: string | undefined;
  currency?: string | undefined;
  childrenOperations?: IOperation[] | undefined;
  id?: string | undefined;
}

export class PaymentIn implements IPaymentIn {
  orderId?: string | undefined;
  purpose?: string | undefined;
  /** Payment method (gateway) code */
  gatewayCode?: string | undefined;
  paymentMethod?: PaymentMethod;
  organizationId?: string | undefined;
  organizationName?: string | undefined;
  customerId?: string | undefined;
  customerName?: string | undefined;
  incomingDate?: Date | undefined;
  billingAddress?: OrderAddress;
  paymentStatus?: PaymentStatus;
  authorizedDate?: Date | undefined;
  capturedDate?: Date | undefined;
  voidedDate?: Date | undefined;
  processPaymentResult?: ProcessPaymentRequestResult;
  price?: number;
  priceWithTax?: number;
  total?: number;
  totalWithTax?: number;
  discountAmount?: number;
  discountAmountWithTax?: number;
  objectType?: string | undefined;
  /** Tax category or type */
  taxType?: string | undefined;
  taxTotal?: number;
  taxPercentRate?: number;
  taxDetails?: TaxDetail[] | undefined;
  discounts?: Discount[] | undefined;
  transactions?: PaymentGatewayTransaction[] | undefined;
  operationType?: string | undefined;
  parentOperationId?: string | undefined;
  number?: string | undefined;
  isApproved?: boolean;
  status?: string | undefined;
  comment?: string | undefined;
  currency?: string | undefined;
  sum?: number;
  outerId?: string | undefined;
  isCancelled?: boolean;
  cancelledDate?: Date | undefined;
  cancelReason?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  operationsLog?: OperationLog[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IPaymentIn) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.orderId = _data["orderId"];
      this.purpose = _data["purpose"];
      this.gatewayCode = _data["gatewayCode"];
      this.paymentMethod = _data["paymentMethod"]
        ? PaymentMethod.fromJS(_data["paymentMethod"])
        : <any>undefined;
      this.organizationId = _data["organizationId"];
      this.organizationName = _data["organizationName"];
      this.customerId = _data["customerId"];
      this.customerName = _data["customerName"];
      this.incomingDate = _data["incomingDate"]
        ? new Date(_data["incomingDate"].toString())
        : <any>undefined;
      this.billingAddress = _data["billingAddress"]
        ? OrderAddress.fromJS(_data["billingAddress"])
        : <any>undefined;
      this.paymentStatus = _data["paymentStatus"];
      this.authorizedDate = _data["authorizedDate"]
        ? new Date(_data["authorizedDate"].toString())
        : <any>undefined;
      this.capturedDate = _data["capturedDate"]
        ? new Date(_data["capturedDate"].toString())
        : <any>undefined;
      this.voidedDate = _data["voidedDate"]
        ? new Date(_data["voidedDate"].toString())
        : <any>undefined;
      this.processPaymentResult = _data["processPaymentResult"]
        ? ProcessPaymentRequestResult.fromJS(_data["processPaymentResult"])
        : <any>undefined;
      this.price = _data["price"];
      this.priceWithTax = _data["priceWithTax"];
      this.total = _data["total"];
      this.totalWithTax = _data["totalWithTax"];
      this.discountAmount = _data["discountAmount"];
      this.discountAmountWithTax = _data["discountAmountWithTax"];
      this.objectType = _data["objectType"];
      this.taxType = _data["taxType"];
      this.taxTotal = _data["taxTotal"];
      this.taxPercentRate = _data["taxPercentRate"];
      if (Array.isArray(_data["taxDetails"])) {
        this.taxDetails = [] as any;
        for (let item of _data["taxDetails"])
          this.taxDetails!.push(TaxDetail.fromJS(item));
      }
      if (Array.isArray(_data["discounts"])) {
        this.discounts = [] as any;
        for (let item of _data["discounts"])
          this.discounts!.push(Discount.fromJS(item));
      }
      if (Array.isArray(_data["transactions"])) {
        this.transactions = [] as any;
        for (let item of _data["transactions"])
          this.transactions!.push(PaymentGatewayTransaction.fromJS(item));
      }
      this.operationType = _data["operationType"];
      this.parentOperationId = _data["parentOperationId"];
      this.number = _data["number"];
      this.isApproved = _data["isApproved"];
      this.status = _data["status"];
      this.comment = _data["comment"];
      this.currency = _data["currency"];
      this.sum = _data["sum"];
      this.outerId = _data["outerId"];
      this.isCancelled = _data["isCancelled"];
      this.cancelledDate = _data["cancelledDate"]
        ? new Date(_data["cancelledDate"].toString())
        : <any>undefined;
      this.cancelReason = _data["cancelReason"];
      if (Array.isArray(_data["dynamicProperties"])) {
        this.dynamicProperties = [] as any;
        for (let item of _data["dynamicProperties"])
          this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
      }
      if (Array.isArray(_data["operationsLog"])) {
        this.operationsLog = [] as any;
        for (let item of _data["operationsLog"])
          this.operationsLog!.push(OperationLog.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): PaymentIn {
    data = typeof data === "object" ? data : {};
    let result = new PaymentIn();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["orderId"] = this.orderId;
    data["purpose"] = this.purpose;
    data["gatewayCode"] = this.gatewayCode;
    data["paymentMethod"] = this.paymentMethod
      ? this.paymentMethod.toJSON()
      : <any>undefined;
    data["organizationId"] = this.organizationId;
    data["organizationName"] = this.organizationName;
    data["customerId"] = this.customerId;
    data["customerName"] = this.customerName;
    data["incomingDate"] = this.incomingDate
      ? this.incomingDate.toISOString()
      : <any>undefined;
    data["billingAddress"] = this.billingAddress
      ? this.billingAddress.toJSON()
      : <any>undefined;
    data["paymentStatus"] = this.paymentStatus;
    data["authorizedDate"] = this.authorizedDate
      ? this.authorizedDate.toISOString()
      : <any>undefined;
    data["capturedDate"] = this.capturedDate
      ? this.capturedDate.toISOString()
      : <any>undefined;
    data["voidedDate"] = this.voidedDate
      ? this.voidedDate.toISOString()
      : <any>undefined;
    data["processPaymentResult"] = this.processPaymentResult
      ? this.processPaymentResult.toJSON()
      : <any>undefined;
    data["price"] = this.price;
    data["priceWithTax"] = this.priceWithTax;
    data["total"] = this.total;
    data["totalWithTax"] = this.totalWithTax;
    data["discountAmount"] = this.discountAmount;
    data["discountAmountWithTax"] = this.discountAmountWithTax;
    data["objectType"] = this.objectType;
    data["taxType"] = this.taxType;
    data["taxTotal"] = this.taxTotal;
    data["taxPercentRate"] = this.taxPercentRate;
    if (Array.isArray(this.taxDetails)) {
      data["taxDetails"] = [];
      for (let item of this.taxDetails) data["taxDetails"].push(item.toJSON());
    }
    if (Array.isArray(this.discounts)) {
      data["discounts"] = [];
      for (let item of this.discounts) data["discounts"].push(item.toJSON());
    }
    if (Array.isArray(this.transactions)) {
      data["transactions"] = [];
      for (let item of this.transactions)
        data["transactions"].push(item.toJSON());
    }
    data["operationType"] = this.operationType;
    data["parentOperationId"] = this.parentOperationId;
    data["number"] = this.number;
    data["isApproved"] = this.isApproved;
    data["status"] = this.status;
    data["comment"] = this.comment;
    data["currency"] = this.currency;
    data["sum"] = this.sum;
    data["outerId"] = this.outerId;
    data["isCancelled"] = this.isCancelled;
    data["cancelledDate"] = this.cancelledDate
      ? this.cancelledDate.toISOString()
      : <any>undefined;
    data["cancelReason"] = this.cancelReason;
    if (Array.isArray(this.dynamicProperties)) {
      data["dynamicProperties"] = [];
      for (let item of this.dynamicProperties)
        data["dynamicProperties"].push(item.toJSON());
    }
    if (Array.isArray(this.operationsLog)) {
      data["operationsLog"] = [];
      for (let item of this.operationsLog)
        data["operationsLog"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IPaymentIn {
  orderId?: string | undefined;
  purpose?: string | undefined;
  /** Payment method (gateway) code */
  gatewayCode?: string | undefined;
  paymentMethod?: PaymentMethod;
  organizationId?: string | undefined;
  organizationName?: string | undefined;
  customerId?: string | undefined;
  customerName?: string | undefined;
  incomingDate?: Date | undefined;
  billingAddress?: OrderAddress;
  paymentStatus?: PaymentStatus;
  authorizedDate?: Date | undefined;
  capturedDate?: Date | undefined;
  voidedDate?: Date | undefined;
  processPaymentResult?: ProcessPaymentRequestResult;
  price?: number;
  priceWithTax?: number;
  total?: number;
  totalWithTax?: number;
  discountAmount?: number;
  discountAmountWithTax?: number;
  objectType?: string | undefined;
  /** Tax category or type */
  taxType?: string | undefined;
  taxTotal?: number;
  taxPercentRate?: number;
  taxDetails?: TaxDetail[] | undefined;
  discounts?: Discount[] | undefined;
  transactions?: PaymentGatewayTransaction[] | undefined;
  operationType?: string | undefined;
  parentOperationId?: string | undefined;
  number?: string | undefined;
  isApproved?: boolean;
  status?: string | undefined;
  comment?: string | undefined;
  currency?: string | undefined;
  sum?: number;
  outerId?: string | undefined;
  isCancelled?: boolean;
  cancelledDate?: Date | undefined;
  cancelReason?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  operationsLog?: OperationLog[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class OrderLineItem implements IOrderLineItem {
  /** Price id */
  priceId?: string | undefined;
  currency?: string | undefined;
  /** unit price without discount and tax */
  price?: number;
  priceWithTax?: number;
  /** Resulting price with discount for one unit */
  placedPrice?: number;
  placedPriceWithTax?: number;
  extendedPrice?: number;
  extendedPriceWithTax?: number;
  /** Gets the value of the single qty line item discount amount */
  discountAmount?: number;
  discountAmountWithTax?: number;
  discountTotal?: number;
  discountTotalWithTax?: number;
  fee?: number;
  feeWithTax?: number;
  /** Tax category or type */
  taxType?: string | undefined;
  taxTotal?: number;
  taxPercentRate?: number;
  /** Reserve quantity */
  reserveQuantity?: number;
  quantity?: number;
  productId?: string | undefined;
  sku?: string | undefined;
  productType?: string | undefined;
  catalogId?: string | undefined;
  categoryId?: string | undefined;
  name?: string | undefined;
  comment?: string | undefined;
  imageUrl?: string | undefined;
  isGift?: boolean | undefined;
  shippingMethodCode?: string | undefined;
  fulfillmentLocationCode?: string | undefined;
  fulfillmentCenterId?: string | undefined;
  fulfillmentCenterName?: string | undefined;
  outerId?: string | undefined;
  weightUnit?: string | undefined;
  weight?: number | undefined;
  measureUnit?: string | undefined;
  height?: number | undefined;
  length?: number | undefined;
  width?: number | undefined;
  isCancelled?: boolean;
  cancelledDate?: Date | undefined;
  cancelReason?: string | undefined;
  readonly objectType?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  discounts?: Discount[] | undefined;
  taxDetails?: TaxDetail[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IOrderLineItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.priceId = _data["priceId"];
      this.currency = _data["currency"];
      this.price = _data["price"];
      this.priceWithTax = _data["priceWithTax"];
      this.placedPrice = _data["placedPrice"];
      this.placedPriceWithTax = _data["placedPriceWithTax"];
      this.extendedPrice = _data["extendedPrice"];
      this.extendedPriceWithTax = _data["extendedPriceWithTax"];
      this.discountAmount = _data["discountAmount"];
      this.discountAmountWithTax = _data["discountAmountWithTax"];
      this.discountTotal = _data["discountTotal"];
      this.discountTotalWithTax = _data["discountTotalWithTax"];
      this.fee = _data["fee"];
      this.feeWithTax = _data["feeWithTax"];
      this.taxType = _data["taxType"];
      this.taxTotal = _data["taxTotal"];
      this.taxPercentRate = _data["taxPercentRate"];
      this.reserveQuantity = _data["reserveQuantity"];
      this.quantity = _data["quantity"];
      this.productId = _data["productId"];
      this.sku = _data["sku"];
      this.productType = _data["productType"];
      this.catalogId = _data["catalogId"];
      this.categoryId = _data["categoryId"];
      this.name = _data["name"];
      this.comment = _data["comment"];
      this.imageUrl = _data["imageUrl"];
      this.isGift = _data["isGift"];
      this.shippingMethodCode = _data["shippingMethodCode"];
      this.fulfillmentLocationCode = _data["fulfillmentLocationCode"];
      this.fulfillmentCenterId = _data["fulfillmentCenterId"];
      this.fulfillmentCenterName = _data["fulfillmentCenterName"];
      this.outerId = _data["outerId"];
      this.weightUnit = _data["weightUnit"];
      this.weight = _data["weight"];
      this.measureUnit = _data["measureUnit"];
      this.height = _data["height"];
      this.length = _data["length"];
      this.width = _data["width"];
      this.isCancelled = _data["isCancelled"];
      this.cancelledDate = _data["cancelledDate"]
        ? new Date(_data["cancelledDate"].toString())
        : <any>undefined;
      this.cancelReason = _data["cancelReason"];
      (<any>this).objectType = _data["objectType"];
      if (Array.isArray(_data["dynamicProperties"])) {
        this.dynamicProperties = [] as any;
        for (let item of _data["dynamicProperties"])
          this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
      }
      if (Array.isArray(_data["discounts"])) {
        this.discounts = [] as any;
        for (let item of _data["discounts"])
          this.discounts!.push(Discount.fromJS(item));
      }
      if (Array.isArray(_data["taxDetails"])) {
        this.taxDetails = [] as any;
        for (let item of _data["taxDetails"])
          this.taxDetails!.push(TaxDetail.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): OrderLineItem {
    data = typeof data === "object" ? data : {};
    let result = new OrderLineItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["priceId"] = this.priceId;
    data["currency"] = this.currency;
    data["price"] = this.price;
    data["priceWithTax"] = this.priceWithTax;
    data["placedPrice"] = this.placedPrice;
    data["placedPriceWithTax"] = this.placedPriceWithTax;
    data["extendedPrice"] = this.extendedPrice;
    data["extendedPriceWithTax"] = this.extendedPriceWithTax;
    data["discountAmount"] = this.discountAmount;
    data["discountAmountWithTax"] = this.discountAmountWithTax;
    data["discountTotal"] = this.discountTotal;
    data["discountTotalWithTax"] = this.discountTotalWithTax;
    data["fee"] = this.fee;
    data["feeWithTax"] = this.feeWithTax;
    data["taxType"] = this.taxType;
    data["taxTotal"] = this.taxTotal;
    data["taxPercentRate"] = this.taxPercentRate;
    data["reserveQuantity"] = this.reserveQuantity;
    data["quantity"] = this.quantity;
    data["productId"] = this.productId;
    data["sku"] = this.sku;
    data["productType"] = this.productType;
    data["catalogId"] = this.catalogId;
    data["categoryId"] = this.categoryId;
    data["name"] = this.name;
    data["comment"] = this.comment;
    data["imageUrl"] = this.imageUrl;
    data["isGift"] = this.isGift;
    data["shippingMethodCode"] = this.shippingMethodCode;
    data["fulfillmentLocationCode"] = this.fulfillmentLocationCode;
    data["fulfillmentCenterId"] = this.fulfillmentCenterId;
    data["fulfillmentCenterName"] = this.fulfillmentCenterName;
    data["outerId"] = this.outerId;
    data["weightUnit"] = this.weightUnit;
    data["weight"] = this.weight;
    data["measureUnit"] = this.measureUnit;
    data["height"] = this.height;
    data["length"] = this.length;
    data["width"] = this.width;
    data["isCancelled"] = this.isCancelled;
    data["cancelledDate"] = this.cancelledDate
      ? this.cancelledDate.toISOString()
      : <any>undefined;
    data["cancelReason"] = this.cancelReason;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.dynamicProperties)) {
      data["dynamicProperties"] = [];
      for (let item of this.dynamicProperties)
        data["dynamicProperties"].push(item.toJSON());
    }
    if (Array.isArray(this.discounts)) {
      data["discounts"] = [];
      for (let item of this.discounts) data["discounts"].push(item.toJSON());
    }
    if (Array.isArray(this.taxDetails)) {
      data["taxDetails"] = [];
      for (let item of this.taxDetails) data["taxDetails"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IOrderLineItem {
  /** Price id */
  priceId?: string | undefined;
  currency?: string | undefined;
  /** unit price without discount and tax */
  price?: number;
  priceWithTax?: number;
  /** Resulting price with discount for one unit */
  placedPrice?: number;
  placedPriceWithTax?: number;
  extendedPrice?: number;
  extendedPriceWithTax?: number;
  /** Gets the value of the single qty line item discount amount */
  discountAmount?: number;
  discountAmountWithTax?: number;
  discountTotal?: number;
  discountTotalWithTax?: number;
  fee?: number;
  feeWithTax?: number;
  /** Tax category or type */
  taxType?: string | undefined;
  taxTotal?: number;
  taxPercentRate?: number;
  /** Reserve quantity */
  reserveQuantity?: number;
  quantity?: number;
  productId?: string | undefined;
  sku?: string | undefined;
  productType?: string | undefined;
  catalogId?: string | undefined;
  categoryId?: string | undefined;
  name?: string | undefined;
  comment?: string | undefined;
  imageUrl?: string | undefined;
  isGift?: boolean | undefined;
  shippingMethodCode?: string | undefined;
  fulfillmentLocationCode?: string | undefined;
  fulfillmentCenterId?: string | undefined;
  fulfillmentCenterName?: string | undefined;
  outerId?: string | undefined;
  weightUnit?: string | undefined;
  weight?: number | undefined;
  measureUnit?: string | undefined;
  height?: number | undefined;
  length?: number | undefined;
  width?: number | undefined;
  isCancelled?: boolean;
  cancelledDate?: Date | undefined;
  cancelReason?: string | undefined;
  objectType?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  discounts?: Discount[] | undefined;
  taxDetails?: TaxDetail[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class OrderShipmentItem implements IOrderShipmentItem {
  lineItemId?: string | undefined;
  lineItem?: OrderLineItem;
  barCode?: string | undefined;
  quantity?: number;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IOrderShipmentItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.lineItemId = _data["lineItemId"];
      this.lineItem = _data["lineItem"]
        ? OrderLineItem.fromJS(_data["lineItem"])
        : <any>undefined;
      this.barCode = _data["barCode"];
      this.quantity = _data["quantity"];
      this.outerId = _data["outerId"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): OrderShipmentItem {
    data = typeof data === "object" ? data : {};
    let result = new OrderShipmentItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["lineItemId"] = this.lineItemId;
    data["lineItem"] = this.lineItem ? this.lineItem.toJSON() : <any>undefined;
    data["barCode"] = this.barCode;
    data["quantity"] = this.quantity;
    data["outerId"] = this.outerId;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IOrderShipmentItem {
  lineItemId?: string | undefined;
  lineItem?: OrderLineItem;
  barCode?: string | undefined;
  quantity?: number;
  outerId?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class ShipmentPackage implements IShipmentPackage {
  barCode?: string | undefined;
  packageType?: string | undefined;
  items?: OrderShipmentItem[] | undefined;
  weightUnit?: string | undefined;
  weight?: number | undefined;
  measureUnit?: string | undefined;
  height?: number | undefined;
  length?: number | undefined;
  width?: number | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IShipmentPackage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.barCode = _data["barCode"];
      this.packageType = _data["packageType"];
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(OrderShipmentItem.fromJS(item));
      }
      this.weightUnit = _data["weightUnit"];
      this.weight = _data["weight"];
      this.measureUnit = _data["measureUnit"];
      this.height = _data["height"];
      this.length = _data["length"];
      this.width = _data["width"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): ShipmentPackage {
    data = typeof data === "object" ? data : {};
    let result = new ShipmentPackage();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["barCode"] = this.barCode;
    data["packageType"] = this.packageType;
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["weightUnit"] = this.weightUnit;
    data["weight"] = this.weight;
    data["measureUnit"] = this.measureUnit;
    data["height"] = this.height;
    data["length"] = this.length;
    data["width"] = this.width;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IShipmentPackage {
  barCode?: string | undefined;
  packageType?: string | undefined;
  items?: OrderShipmentItem[] | undefined;
  weightUnit?: string | undefined;
  weight?: number | undefined;
  measureUnit?: string | undefined;
  height?: number | undefined;
  length?: number | undefined;
  width?: number | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class OrderShipment implements IOrderShipment {
  organizationId?: string | undefined;
  organizationName?: string | undefined;
  fulfillmentCenterId?: string | undefined;
  fulfillmentCenterName?: string | undefined;
  employeeId?: string | undefined;
  employeeName?: string | undefined;
  /** Current shipment method code */
  shipmentMethodCode?: string | undefined;
  /** Current shipment option code */
  shipmentMethodOption?: string | undefined;
  shippingMethod?: ShippingMethod;
  customerOrderId?: string | undefined;
  customerOrder?: CustomerOrder;
  items?: OrderShipmentItem[] | undefined;
  packages?: ShipmentPackage[] | undefined;
  inPayments?: PaymentIn[] | undefined;
  weightUnit?: string | undefined;
  weight?: number | undefined;
  measureUnit?: string | undefined;
  height?: number | undefined;
  length?: number | undefined;
  width?: number | undefined;
  discounts?: Discount[] | undefined;
  deliveryAddress?: OrderAddress;
  price?: number;
  priceWithTax?: number;
  total?: number;
  totalWithTax?: number;
  discountAmount?: number;
  discountAmountWithTax?: number;
  fee?: number;
  feeWithTax?: number;
  objectType?: string | undefined;
  /** Tax category or type */
  taxType?: string | undefined;
  taxTotal?: number;
  taxPercentRate?: number;
  taxDetails?: TaxDetail[] | undefined;
  operationType?: string | undefined;
  parentOperationId?: string | undefined;
  number?: string | undefined;
  isApproved?: boolean;
  status?: string | undefined;
  comment?: string | undefined;
  currency?: string | undefined;
  sum?: number;
  outerId?: string | undefined;
  isCancelled?: boolean;
  cancelledDate?: Date | undefined;
  cancelReason?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  operationsLog?: OperationLog[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IOrderShipment) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.organizationId = _data["organizationId"];
      this.organizationName = _data["organizationName"];
      this.fulfillmentCenterId = _data["fulfillmentCenterId"];
      this.fulfillmentCenterName = _data["fulfillmentCenterName"];
      this.employeeId = _data["employeeId"];
      this.employeeName = _data["employeeName"];
      this.shipmentMethodCode = _data["shipmentMethodCode"];
      this.shipmentMethodOption = _data["shipmentMethodOption"];
      this.shippingMethod = _data["shippingMethod"]
        ? ShippingMethod.fromJS(_data["shippingMethod"])
        : <any>undefined;
      this.customerOrderId = _data["customerOrderId"];
      this.customerOrder = _data["customerOrder"]
        ? CustomerOrder.fromJS(_data["customerOrder"])
        : <any>undefined;
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(OrderShipmentItem.fromJS(item));
      }
      if (Array.isArray(_data["packages"])) {
        this.packages = [] as any;
        for (let item of _data["packages"])
          this.packages!.push(ShipmentPackage.fromJS(item));
      }
      if (Array.isArray(_data["inPayments"])) {
        this.inPayments = [] as any;
        for (let item of _data["inPayments"])
          this.inPayments!.push(PaymentIn.fromJS(item));
      }
      this.weightUnit = _data["weightUnit"];
      this.weight = _data["weight"];
      this.measureUnit = _data["measureUnit"];
      this.height = _data["height"];
      this.length = _data["length"];
      this.width = _data["width"];
      if (Array.isArray(_data["discounts"])) {
        this.discounts = [] as any;
        for (let item of _data["discounts"])
          this.discounts!.push(Discount.fromJS(item));
      }
      this.deliveryAddress = _data["deliveryAddress"]
        ? OrderAddress.fromJS(_data["deliveryAddress"])
        : <any>undefined;
      this.price = _data["price"];
      this.priceWithTax = _data["priceWithTax"];
      this.total = _data["total"];
      this.totalWithTax = _data["totalWithTax"];
      this.discountAmount = _data["discountAmount"];
      this.discountAmountWithTax = _data["discountAmountWithTax"];
      this.fee = _data["fee"];
      this.feeWithTax = _data["feeWithTax"];
      this.objectType = _data["objectType"];
      this.taxType = _data["taxType"];
      this.taxTotal = _data["taxTotal"];
      this.taxPercentRate = _data["taxPercentRate"];
      if (Array.isArray(_data["taxDetails"])) {
        this.taxDetails = [] as any;
        for (let item of _data["taxDetails"])
          this.taxDetails!.push(TaxDetail.fromJS(item));
      }
      this.operationType = _data["operationType"];
      this.parentOperationId = _data["parentOperationId"];
      this.number = _data["number"];
      this.isApproved = _data["isApproved"];
      this.status = _data["status"];
      this.comment = _data["comment"];
      this.currency = _data["currency"];
      this.sum = _data["sum"];
      this.outerId = _data["outerId"];
      this.isCancelled = _data["isCancelled"];
      this.cancelledDate = _data["cancelledDate"]
        ? new Date(_data["cancelledDate"].toString())
        : <any>undefined;
      this.cancelReason = _data["cancelReason"];
      if (Array.isArray(_data["dynamicProperties"])) {
        this.dynamicProperties = [] as any;
        for (let item of _data["dynamicProperties"])
          this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
      }
      if (Array.isArray(_data["operationsLog"])) {
        this.operationsLog = [] as any;
        for (let item of _data["operationsLog"])
          this.operationsLog!.push(OperationLog.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): OrderShipment {
    data = typeof data === "object" ? data : {};
    let result = new OrderShipment();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["organizationId"] = this.organizationId;
    data["organizationName"] = this.organizationName;
    data["fulfillmentCenterId"] = this.fulfillmentCenterId;
    data["fulfillmentCenterName"] = this.fulfillmentCenterName;
    data["employeeId"] = this.employeeId;
    data["employeeName"] = this.employeeName;
    data["shipmentMethodCode"] = this.shipmentMethodCode;
    data["shipmentMethodOption"] = this.shipmentMethodOption;
    data["shippingMethod"] = this.shippingMethod
      ? this.shippingMethod.toJSON()
      : <any>undefined;
    data["customerOrderId"] = this.customerOrderId;
    data["customerOrder"] = this.customerOrder
      ? this.customerOrder.toJSON()
      : <any>undefined;
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    if (Array.isArray(this.packages)) {
      data["packages"] = [];
      for (let item of this.packages) data["packages"].push(item.toJSON());
    }
    if (Array.isArray(this.inPayments)) {
      data["inPayments"] = [];
      for (let item of this.inPayments) data["inPayments"].push(item.toJSON());
    }
    data["weightUnit"] = this.weightUnit;
    data["weight"] = this.weight;
    data["measureUnit"] = this.measureUnit;
    data["height"] = this.height;
    data["length"] = this.length;
    data["width"] = this.width;
    if (Array.isArray(this.discounts)) {
      data["discounts"] = [];
      for (let item of this.discounts) data["discounts"].push(item.toJSON());
    }
    data["deliveryAddress"] = this.deliveryAddress
      ? this.deliveryAddress.toJSON()
      : <any>undefined;
    data["price"] = this.price;
    data["priceWithTax"] = this.priceWithTax;
    data["total"] = this.total;
    data["totalWithTax"] = this.totalWithTax;
    data["discountAmount"] = this.discountAmount;
    data["discountAmountWithTax"] = this.discountAmountWithTax;
    data["fee"] = this.fee;
    data["feeWithTax"] = this.feeWithTax;
    data["objectType"] = this.objectType;
    data["taxType"] = this.taxType;
    data["taxTotal"] = this.taxTotal;
    data["taxPercentRate"] = this.taxPercentRate;
    if (Array.isArray(this.taxDetails)) {
      data["taxDetails"] = [];
      for (let item of this.taxDetails) data["taxDetails"].push(item.toJSON());
    }
    data["operationType"] = this.operationType;
    data["parentOperationId"] = this.parentOperationId;
    data["number"] = this.number;
    data["isApproved"] = this.isApproved;
    data["status"] = this.status;
    data["comment"] = this.comment;
    data["currency"] = this.currency;
    data["sum"] = this.sum;
    data["outerId"] = this.outerId;
    data["isCancelled"] = this.isCancelled;
    data["cancelledDate"] = this.cancelledDate
      ? this.cancelledDate.toISOString()
      : <any>undefined;
    data["cancelReason"] = this.cancelReason;
    if (Array.isArray(this.dynamicProperties)) {
      data["dynamicProperties"] = [];
      for (let item of this.dynamicProperties)
        data["dynamicProperties"].push(item.toJSON());
    }
    if (Array.isArray(this.operationsLog)) {
      data["operationsLog"] = [];
      for (let item of this.operationsLog)
        data["operationsLog"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IOrderShipment {
  organizationId?: string | undefined;
  organizationName?: string | undefined;
  fulfillmentCenterId?: string | undefined;
  fulfillmentCenterName?: string | undefined;
  employeeId?: string | undefined;
  employeeName?: string | undefined;
  /** Current shipment method code */
  shipmentMethodCode?: string | undefined;
  /** Current shipment option code */
  shipmentMethodOption?: string | undefined;
  shippingMethod?: ShippingMethod;
  customerOrderId?: string | undefined;
  customerOrder?: CustomerOrder;
  items?: OrderShipmentItem[] | undefined;
  packages?: ShipmentPackage[] | undefined;
  inPayments?: PaymentIn[] | undefined;
  weightUnit?: string | undefined;
  weight?: number | undefined;
  measureUnit?: string | undefined;
  height?: number | undefined;
  length?: number | undefined;
  width?: number | undefined;
  discounts?: Discount[] | undefined;
  deliveryAddress?: OrderAddress;
  price?: number;
  priceWithTax?: number;
  total?: number;
  totalWithTax?: number;
  discountAmount?: number;
  discountAmountWithTax?: number;
  fee?: number;
  feeWithTax?: number;
  objectType?: string | undefined;
  /** Tax category or type */
  taxType?: string | undefined;
  taxTotal?: number;
  taxPercentRate?: number;
  taxDetails?: TaxDetail[] | undefined;
  operationType?: string | undefined;
  parentOperationId?: string | undefined;
  number?: string | undefined;
  isApproved?: boolean;
  status?: string | undefined;
  comment?: string | undefined;
  currency?: string | undefined;
  sum?: number;
  outerId?: string | undefined;
  isCancelled?: boolean;
  cancelledDate?: Date | undefined;
  cancelReason?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  operationsLog?: OperationLog[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class CustomerOrder implements ICustomerOrder {
  customerId?: string | undefined;
  customerName?: string | undefined;
  channelId?: string | undefined;
  storeId?: string | undefined;
  storeName?: string | undefined;
  organizationId?: string | undefined;
  organizationName?: string | undefined;
  employeeId?: string | undefined;
  employeeName?: string | undefined;
  /** The basis shopping cart id of which the order was created */
  shoppingCartId?: string | undefined;
  /** Flag determines that the order is the prototype */
  isPrototype?: boolean;
  /** Internal number of order provided by customer */
  purchaseOrderNumber?: string | undefined;
  /** Number for subscription  associated with this order */
  subscriptionNumber?: string | undefined;
  /** Identifier for subscription  associated with this order */
  subscriptionId?: string | undefined;
  objectType?: string | undefined;
  addresses?: OrderAddress[] | undefined;
  inPayments?: PaymentIn[] | undefined;
  items?: OrderLineItem[] | undefined;
  shipments?: OrderShipment[] | undefined;
  discounts?: Discount[] | undefined;
  /** When a discount is applied to the order, the tax calculation has already been applied, and is reflected in the tax.
  Therefore, a discount applying to the order  will occur after tax. 
  For instance, if the cart subtotal is $100, and $15 is the tax subtotal, a cart-wide discount of 10% will yield a total of $105 ($100 subtotal – $10 discount + $15 tax on the original $100). */
  discountAmount?: number;
  taxDetails?: TaxDetail[] | undefined;
  scopes?: string[] | undefined;
  /** Grand order total */
  total?: number;
  subTotal?: number;
  subTotalWithTax?: number;
  subTotalDiscount?: number;
  subTotalDiscountWithTax?: number;
  subTotalTaxTotal?: number;
  shippingTotal?: number;
  shippingTotalWithTax?: number;
  shippingSubTotal?: number;
  shippingSubTotalWithTax?: number;
  shippingDiscountTotal?: number;
  shippingDiscountTotalWithTax?: number;
  shippingTaxTotal?: number;
  paymentTotal?: number;
  paymentTotalWithTax?: number;
  paymentSubTotal?: number;
  paymentSubTotalWithTax?: number;
  paymentDiscountTotal?: number;
  paymentDiscountTotalWithTax?: number;
  paymentTaxTotal?: number;
  discountTotal?: number;
  discountTotalWithTax?: number;
  fee?: number;
  feeWithTax?: number;
  feeTotal?: number;
  feeTotalWithTax?: number;
  /** Tax category or type */
  taxType?: string | undefined;
  taxTotal?: number;
  taxPercentRate?: number;
  languageCode?: string | undefined;
  operationType?: string | undefined;
  parentOperationId?: string | undefined;
  number?: string | undefined;
  isApproved?: boolean;
  status?: string | undefined;
  comment?: string | undefined;
  currency?: string | undefined;
  sum?: number;
  outerId?: string | undefined;
  isCancelled?: boolean;
  cancelledDate?: Date | undefined;
  cancelReason?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  operationsLog?: OperationLog[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: ICustomerOrder) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.customerId = _data["customerId"];
      this.customerName = _data["customerName"];
      this.channelId = _data["channelId"];
      this.storeId = _data["storeId"];
      this.storeName = _data["storeName"];
      this.organizationId = _data["organizationId"];
      this.organizationName = _data["organizationName"];
      this.employeeId = _data["employeeId"];
      this.employeeName = _data["employeeName"];
      this.shoppingCartId = _data["shoppingCartId"];
      this.isPrototype = _data["isPrototype"];
      this.purchaseOrderNumber = _data["purchaseOrderNumber"];
      this.subscriptionNumber = _data["subscriptionNumber"];
      this.subscriptionId = _data["subscriptionId"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["addresses"])) {
        this.addresses = [] as any;
        for (let item of _data["addresses"])
          this.addresses!.push(OrderAddress.fromJS(item));
      }
      if (Array.isArray(_data["inPayments"])) {
        this.inPayments = [] as any;
        for (let item of _data["inPayments"])
          this.inPayments!.push(PaymentIn.fromJS(item));
      }
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(OrderLineItem.fromJS(item));
      }
      if (Array.isArray(_data["shipments"])) {
        this.shipments = [] as any;
        for (let item of _data["shipments"])
          this.shipments!.push(OrderShipment.fromJS(item));
      }
      if (Array.isArray(_data["discounts"])) {
        this.discounts = [] as any;
        for (let item of _data["discounts"])
          this.discounts!.push(Discount.fromJS(item));
      }
      this.discountAmount = _data["discountAmount"];
      if (Array.isArray(_data["taxDetails"])) {
        this.taxDetails = [] as any;
        for (let item of _data["taxDetails"])
          this.taxDetails!.push(TaxDetail.fromJS(item));
      }
      if (Array.isArray(_data["scopes"])) {
        this.scopes = [] as any;
        for (let item of _data["scopes"]) this.scopes!.push(item);
      }
      this.total = _data["total"];
      this.subTotal = _data["subTotal"];
      this.subTotalWithTax = _data["subTotalWithTax"];
      this.subTotalDiscount = _data["subTotalDiscount"];
      this.subTotalDiscountWithTax = _data["subTotalDiscountWithTax"];
      this.subTotalTaxTotal = _data["subTotalTaxTotal"];
      this.shippingTotal = _data["shippingTotal"];
      this.shippingTotalWithTax = _data["shippingTotalWithTax"];
      this.shippingSubTotal = _data["shippingSubTotal"];
      this.shippingSubTotalWithTax = _data["shippingSubTotalWithTax"];
      this.shippingDiscountTotal = _data["shippingDiscountTotal"];
      this.shippingDiscountTotalWithTax = _data["shippingDiscountTotalWithTax"];
      this.shippingTaxTotal = _data["shippingTaxTotal"];
      this.paymentTotal = _data["paymentTotal"];
      this.paymentTotalWithTax = _data["paymentTotalWithTax"];
      this.paymentSubTotal = _data["paymentSubTotal"];
      this.paymentSubTotalWithTax = _data["paymentSubTotalWithTax"];
      this.paymentDiscountTotal = _data["paymentDiscountTotal"];
      this.paymentDiscountTotalWithTax = _data["paymentDiscountTotalWithTax"];
      this.paymentTaxTotal = _data["paymentTaxTotal"];
      this.discountTotal = _data["discountTotal"];
      this.discountTotalWithTax = _data["discountTotalWithTax"];
      this.fee = _data["fee"];
      this.feeWithTax = _data["feeWithTax"];
      this.feeTotal = _data["feeTotal"];
      this.feeTotalWithTax = _data["feeTotalWithTax"];
      this.taxType = _data["taxType"];
      this.taxTotal = _data["taxTotal"];
      this.taxPercentRate = _data["taxPercentRate"];
      this.languageCode = _data["languageCode"];
      this.operationType = _data["operationType"];
      this.parentOperationId = _data["parentOperationId"];
      this.number = _data["number"];
      this.isApproved = _data["isApproved"];
      this.status = _data["status"];
      this.comment = _data["comment"];
      this.currency = _data["currency"];
      this.sum = _data["sum"];
      this.outerId = _data["outerId"];
      this.isCancelled = _data["isCancelled"];
      this.cancelledDate = _data["cancelledDate"]
        ? new Date(_data["cancelledDate"].toString())
        : <any>undefined;
      this.cancelReason = _data["cancelReason"];
      if (Array.isArray(_data["dynamicProperties"])) {
        this.dynamicProperties = [] as any;
        for (let item of _data["dynamicProperties"])
          this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
      }
      if (Array.isArray(_data["operationsLog"])) {
        this.operationsLog = [] as any;
        for (let item of _data["operationsLog"])
          this.operationsLog!.push(OperationLog.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): CustomerOrder {
    data = typeof data === "object" ? data : {};
    let result = new CustomerOrder();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["customerId"] = this.customerId;
    data["customerName"] = this.customerName;
    data["channelId"] = this.channelId;
    data["storeId"] = this.storeId;
    data["storeName"] = this.storeName;
    data["organizationId"] = this.organizationId;
    data["organizationName"] = this.organizationName;
    data["employeeId"] = this.employeeId;
    data["employeeName"] = this.employeeName;
    data["shoppingCartId"] = this.shoppingCartId;
    data["isPrototype"] = this.isPrototype;
    data["purchaseOrderNumber"] = this.purchaseOrderNumber;
    data["subscriptionNumber"] = this.subscriptionNumber;
    data["subscriptionId"] = this.subscriptionId;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.addresses)) {
      data["addresses"] = [];
      for (let item of this.addresses) data["addresses"].push(item.toJSON());
    }
    if (Array.isArray(this.inPayments)) {
      data["inPayments"] = [];
      for (let item of this.inPayments) data["inPayments"].push(item.toJSON());
    }
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    if (Array.isArray(this.shipments)) {
      data["shipments"] = [];
      for (let item of this.shipments) data["shipments"].push(item.toJSON());
    }
    if (Array.isArray(this.discounts)) {
      data["discounts"] = [];
      for (let item of this.discounts) data["discounts"].push(item.toJSON());
    }
    data["discountAmount"] = this.discountAmount;
    if (Array.isArray(this.taxDetails)) {
      data["taxDetails"] = [];
      for (let item of this.taxDetails) data["taxDetails"].push(item.toJSON());
    }
    if (Array.isArray(this.scopes)) {
      data["scopes"] = [];
      for (let item of this.scopes) data["scopes"].push(item);
    }
    data["total"] = this.total;
    data["subTotal"] = this.subTotal;
    data["subTotalWithTax"] = this.subTotalWithTax;
    data["subTotalDiscount"] = this.subTotalDiscount;
    data["subTotalDiscountWithTax"] = this.subTotalDiscountWithTax;
    data["subTotalTaxTotal"] = this.subTotalTaxTotal;
    data["shippingTotal"] = this.shippingTotal;
    data["shippingTotalWithTax"] = this.shippingTotalWithTax;
    data["shippingSubTotal"] = this.shippingSubTotal;
    data["shippingSubTotalWithTax"] = this.shippingSubTotalWithTax;
    data["shippingDiscountTotal"] = this.shippingDiscountTotal;
    data["shippingDiscountTotalWithTax"] = this.shippingDiscountTotalWithTax;
    data["shippingTaxTotal"] = this.shippingTaxTotal;
    data["paymentTotal"] = this.paymentTotal;
    data["paymentTotalWithTax"] = this.paymentTotalWithTax;
    data["paymentSubTotal"] = this.paymentSubTotal;
    data["paymentSubTotalWithTax"] = this.paymentSubTotalWithTax;
    data["paymentDiscountTotal"] = this.paymentDiscountTotal;
    data["paymentDiscountTotalWithTax"] = this.paymentDiscountTotalWithTax;
    data["paymentTaxTotal"] = this.paymentTaxTotal;
    data["discountTotal"] = this.discountTotal;
    data["discountTotalWithTax"] = this.discountTotalWithTax;
    data["fee"] = this.fee;
    data["feeWithTax"] = this.feeWithTax;
    data["feeTotal"] = this.feeTotal;
    data["feeTotalWithTax"] = this.feeTotalWithTax;
    data["taxType"] = this.taxType;
    data["taxTotal"] = this.taxTotal;
    data["taxPercentRate"] = this.taxPercentRate;
    data["languageCode"] = this.languageCode;
    data["operationType"] = this.operationType;
    data["parentOperationId"] = this.parentOperationId;
    data["number"] = this.number;
    data["isApproved"] = this.isApproved;
    data["status"] = this.status;
    data["comment"] = this.comment;
    data["currency"] = this.currency;
    data["sum"] = this.sum;
    data["outerId"] = this.outerId;
    data["isCancelled"] = this.isCancelled;
    data["cancelledDate"] = this.cancelledDate
      ? this.cancelledDate.toISOString()
      : <any>undefined;
    data["cancelReason"] = this.cancelReason;
    if (Array.isArray(this.dynamicProperties)) {
      data["dynamicProperties"] = [];
      for (let item of this.dynamicProperties)
        data["dynamicProperties"].push(item.toJSON());
    }
    if (Array.isArray(this.operationsLog)) {
      data["operationsLog"] = [];
      for (let item of this.operationsLog)
        data["operationsLog"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface ICustomerOrder {
  customerId?: string | undefined;
  customerName?: string | undefined;
  channelId?: string | undefined;
  storeId?: string | undefined;
  storeName?: string | undefined;
  organizationId?: string | undefined;
  organizationName?: string | undefined;
  employeeId?: string | undefined;
  employeeName?: string | undefined;
  /** The basis shopping cart id of which the order was created */
  shoppingCartId?: string | undefined;
  /** Flag determines that the order is the prototype */
  isPrototype?: boolean;
  /** Internal number of order provided by customer */
  purchaseOrderNumber?: string | undefined;
  /** Number for subscription  associated with this order */
  subscriptionNumber?: string | undefined;
  /** Identifier for subscription  associated with this order */
  subscriptionId?: string | undefined;
  objectType?: string | undefined;
  addresses?: OrderAddress[] | undefined;
  inPayments?: PaymentIn[] | undefined;
  items?: OrderLineItem[] | undefined;
  shipments?: OrderShipment[] | undefined;
  discounts?: Discount[] | undefined;
  /** When a discount is applied to the order, the tax calculation has already been applied, and is reflected in the tax.
  Therefore, a discount applying to the order  will occur after tax. 
  For instance, if the cart subtotal is $100, and $15 is the tax subtotal, a cart-wide discount of 10% will yield a total of $105 ($100 subtotal – $10 discount + $15 tax on the original $100). */
  discountAmount?: number;
  taxDetails?: TaxDetail[] | undefined;
  scopes?: string[] | undefined;
  /** Grand order total */
  total?: number;
  subTotal?: number;
  subTotalWithTax?: number;
  subTotalDiscount?: number;
  subTotalDiscountWithTax?: number;
  subTotalTaxTotal?: number;
  shippingTotal?: number;
  shippingTotalWithTax?: number;
  shippingSubTotal?: number;
  shippingSubTotalWithTax?: number;
  shippingDiscountTotal?: number;
  shippingDiscountTotalWithTax?: number;
  shippingTaxTotal?: number;
  paymentTotal?: number;
  paymentTotalWithTax?: number;
  paymentSubTotal?: number;
  paymentSubTotalWithTax?: number;
  paymentDiscountTotal?: number;
  paymentDiscountTotalWithTax?: number;
  paymentTaxTotal?: number;
  discountTotal?: number;
  discountTotalWithTax?: number;
  fee?: number;
  feeWithTax?: number;
  feeTotal?: number;
  feeTotalWithTax?: number;
  /** Tax category or type */
  taxType?: string | undefined;
  taxTotal?: number;
  taxPercentRate?: number;
  languageCode?: string | undefined;
  operationType?: string | undefined;
  parentOperationId?: string | undefined;
  number?: string | undefined;
  isApproved?: boolean;
  status?: string | undefined;
  comment?: string | undefined;
  currency?: string | undefined;
  sum?: number;
  outerId?: string | undefined;
  isCancelled?: boolean;
  cancelledDate?: Date | undefined;
  cancelReason?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  operationsLog?: OperationLog[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class CustomerOrderSearchResult implements ICustomerOrderSearchResult {
  readonly customerOrders?: CustomerOrder[] | undefined;
  totalCount?: number;
  results?: CustomerOrder[] | undefined;

  constructor(data?: ICustomerOrderSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["customerOrders"])) {
        (<any>this).customerOrders = [] as any;
        for (let item of _data["customerOrders"])
          (<any>this).customerOrders!.push(CustomerOrder.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(CustomerOrder.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CustomerOrderSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new CustomerOrderSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.customerOrders)) {
      data["customerOrders"] = [];
      for (let item of this.customerOrders)
        data["customerOrders"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface ICustomerOrderSearchResult {
  customerOrders?: CustomerOrder[] | undefined;
  totalCount?: number;
  results?: CustomerOrder[] | undefined;
}

export class BankCardInfo implements IBankCardInfo {
  bankCardNumber?: string | undefined;
  bankCardType?: string | undefined;
  bankCardMonth?: number;
  bankCardYear?: number;
  bankCardCVV2?: string | undefined;
  cardholderName?: string | undefined;

  constructor(data?: IBankCardInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.bankCardNumber = _data["bankCardNumber"];
      this.bankCardType = _data["bankCardType"];
      this.bankCardMonth = _data["bankCardMonth"];
      this.bankCardYear = _data["bankCardYear"];
      this.bankCardCVV2 = _data["bankCardCVV2"];
      this.cardholderName = _data["cardholderName"];
    }
  }

  static fromJS(data: any): BankCardInfo {
    data = typeof data === "object" ? data : {};
    let result = new BankCardInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["bankCardNumber"] = this.bankCardNumber;
    data["bankCardType"] = this.bankCardType;
    data["bankCardMonth"] = this.bankCardMonth;
    data["bankCardYear"] = this.bankCardYear;
    data["bankCardCVV2"] = this.bankCardCVV2;
    data["cardholderName"] = this.cardholderName;
    return data;
  }
}

export interface IBankCardInfo {
  bankCardNumber?: string | undefined;
  bankCardType?: string | undefined;
  bankCardMonth?: number;
  bankCardYear?: number;
  bankCardCVV2?: string | undefined;
  cardholderName?: string | undefined;
}

export class Money implements IMoney {
  currency?: string | undefined;
  amount?: number;

  constructor(data?: IMoney) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currency = _data["currency"];
      this.amount = _data["amount"];
    }
  }

  static fromJS(data: any): Money {
    data = typeof data === "object" ? data : {};
    let result = new Money();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["currency"] = this.currency;
    data["amount"] = this.amount;
    return data;
  }
}

export interface IMoney {
  currency?: string | undefined;
  amount?: number;
}

export class QuarterPeriodMoney implements IQuarterPeriodMoney {
  year?: number;
  quarter?: number;
  currency?: string | undefined;
  amount?: number;

  constructor(data?: IQuarterPeriodMoney) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.year = _data["year"];
      this.quarter = _data["quarter"];
      this.currency = _data["currency"];
      this.amount = _data["amount"];
    }
  }

  static fromJS(data: any): QuarterPeriodMoney {
    data = typeof data === "object" ? data : {};
    let result = new QuarterPeriodMoney();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["year"] = this.year;
    data["quarter"] = this.quarter;
    data["currency"] = this.currency;
    data["amount"] = this.amount;
    return data;
  }
}

export interface IQuarterPeriodMoney {
  year?: number;
  quarter?: number;
  currency?: string | undefined;
  amount?: number;
}

export class DashboardStatisticsResult implements IDashboardStatisticsResult {
  startDate?: Date;
  endDate?: Date;
  revenue?: Money[] | undefined;
  revenuePeriodDetails?: QuarterPeriodMoney[] | undefined;
  orderCount?: number;
  customersCount?: number;
  revenuePerCustomer?: Money[] | undefined;
  avgOrderValue?: Money[] | undefined;
  avgOrderValuePeriodDetails?: QuarterPeriodMoney[] | undefined;
  itemsPurchased?: number;
  lineitemsPerOrder?: number;

  constructor(data?: IDashboardStatisticsResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.startDate = _data["startDate"]
        ? new Date(_data["startDate"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? new Date(_data["endDate"].toString())
        : <any>undefined;
      if (Array.isArray(_data["revenue"])) {
        this.revenue = [] as any;
        for (let item of _data["revenue"])
          this.revenue!.push(Money.fromJS(item));
      }
      if (Array.isArray(_data["revenuePeriodDetails"])) {
        this.revenuePeriodDetails = [] as any;
        for (let item of _data["revenuePeriodDetails"])
          this.revenuePeriodDetails!.push(QuarterPeriodMoney.fromJS(item));
      }
      this.orderCount = _data["orderCount"];
      this.customersCount = _data["customersCount"];
      if (Array.isArray(_data["revenuePerCustomer"])) {
        this.revenuePerCustomer = [] as any;
        for (let item of _data["revenuePerCustomer"])
          this.revenuePerCustomer!.push(Money.fromJS(item));
      }
      if (Array.isArray(_data["avgOrderValue"])) {
        this.avgOrderValue = [] as any;
        for (let item of _data["avgOrderValue"])
          this.avgOrderValue!.push(Money.fromJS(item));
      }
      if (Array.isArray(_data["avgOrderValuePeriodDetails"])) {
        this.avgOrderValuePeriodDetails = [] as any;
        for (let item of _data["avgOrderValuePeriodDetails"])
          this.avgOrderValuePeriodDetails!.push(
            QuarterPeriodMoney.fromJS(item)
          );
      }
      this.itemsPurchased = _data["itemsPurchased"];
      this.lineitemsPerOrder = _data["lineitemsPerOrder"];
    }
  }

  static fromJS(data: any): DashboardStatisticsResult {
    data = typeof data === "object" ? data : {};
    let result = new DashboardStatisticsResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    if (Array.isArray(this.revenue)) {
      data["revenue"] = [];
      for (let item of this.revenue) data["revenue"].push(item.toJSON());
    }
    if (Array.isArray(this.revenuePeriodDetails)) {
      data["revenuePeriodDetails"] = [];
      for (let item of this.revenuePeriodDetails)
        data["revenuePeriodDetails"].push(item.toJSON());
    }
    data["orderCount"] = this.orderCount;
    data["customersCount"] = this.customersCount;
    if (Array.isArray(this.revenuePerCustomer)) {
      data["revenuePerCustomer"] = [];
      for (let item of this.revenuePerCustomer)
        data["revenuePerCustomer"].push(item.toJSON());
    }
    if (Array.isArray(this.avgOrderValue)) {
      data["avgOrderValue"] = [];
      for (let item of this.avgOrderValue)
        data["avgOrderValue"].push(item.toJSON());
    }
    if (Array.isArray(this.avgOrderValuePeriodDetails)) {
      data["avgOrderValuePeriodDetails"] = [];
      for (let item of this.avgOrderValuePeriodDetails)
        data["avgOrderValuePeriodDetails"].push(item.toJSON());
    }
    data["itemsPurchased"] = this.itemsPurchased;
    data["lineitemsPerOrder"] = this.lineitemsPerOrder;
    return data;
  }
}

export interface IDashboardStatisticsResult {
  startDate?: Date;
  endDate?: Date;
  revenue?: Money[] | undefined;
  revenuePeriodDetails?: QuarterPeriodMoney[] | undefined;
  orderCount?: number;
  customersCount?: number;
  revenuePerCustomer?: Money[] | undefined;
  avgOrderValue?: Money[] | undefined;
  avgOrderValuePeriodDetails?: QuarterPeriodMoney[] | undefined;
  itemsPurchased?: number;
  lineitemsPerOrder?: number;
}

export class KeyValuePair implements IKeyValuePair {
  key?: string | undefined;
  value?: string | undefined;

  constructor(data?: IKeyValuePair) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.key = _data["key"];
      this.value = _data["value"];
    }
  }

  static fromJS(data: any): KeyValuePair {
    data = typeof data === "object" ? data : {};
    let result = new KeyValuePair();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["key"] = this.key;
    data["value"] = this.value;
    return data;
  }
}

export interface IKeyValuePair {
  key?: string | undefined;
  value?: string | undefined;
}

export class PaymentCallbackParameters implements IPaymentCallbackParameters {
  parameters?: KeyValuePair[] | undefined;

  constructor(data?: IPaymentCallbackParameters) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["parameters"])) {
        this.parameters = [] as any;
        for (let item of _data["parameters"])
          this.parameters!.push(KeyValuePair.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaymentCallbackParameters {
    data = typeof data === "object" ? data : {};
    let result = new PaymentCallbackParameters();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.parameters)) {
      data["parameters"] = [];
      for (let item of this.parameters) data["parameters"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaymentCallbackParameters {
  parameters?: KeyValuePair[] | undefined;
}

export class PostProcessPaymentRequestResult
  implements IPostProcessPaymentRequestResult
{
  returnUrl?: string | undefined;
  orderId?: string | undefined;
  outerId?: string | undefined;
  paymentMethod?: PaymentMethod;
  isSuccess?: boolean;
  errorMessage?: string | undefined;
  newPaymentStatus?: PaymentStatus;

  constructor(data?: IPostProcessPaymentRequestResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.returnUrl = _data["returnUrl"];
      this.orderId = _data["orderId"];
      this.outerId = _data["outerId"];
      this.paymentMethod = _data["paymentMethod"]
        ? PaymentMethod.fromJS(_data["paymentMethod"])
        : <any>undefined;
      this.isSuccess = _data["isSuccess"];
      this.errorMessage = _data["errorMessage"];
      this.newPaymentStatus = _data["newPaymentStatus"];
    }
  }

  static fromJS(data: any): PostProcessPaymentRequestResult {
    data = typeof data === "object" ? data : {};
    let result = new PostProcessPaymentRequestResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["returnUrl"] = this.returnUrl;
    data["orderId"] = this.orderId;
    data["outerId"] = this.outerId;
    data["paymentMethod"] = this.paymentMethod
      ? this.paymentMethod.toJSON()
      : <any>undefined;
    data["isSuccess"] = this.isSuccess;
    data["errorMessage"] = this.errorMessage;
    data["newPaymentStatus"] = this.newPaymentStatus;
    return data;
  }
}

export interface IPostProcessPaymentRequestResult {
  returnUrl?: string | undefined;
  orderId?: string | undefined;
  outerId?: string | undefined;
  paymentMethod?: PaymentMethod;
  isSuccess?: boolean;
  errorMessage?: string | undefined;
  newPaymentStatus?: PaymentStatus;
}

export class CustomerOrderHistorySearchCriteria
  implements ICustomerOrderHistorySearchCriteria
{
  orderId?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: ICustomerOrderHistorySearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.orderId = _data["orderId"];
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): CustomerOrderHistorySearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new CustomerOrderHistorySearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["orderId"] = this.orderId;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface ICustomerOrderHistorySearchCriteria {
  orderId?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class CustomerOrderIndexedSearchCriteria
  implements ICustomerOrderIndexedSearchCriteria
{
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: ICustomerOrderIndexedSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): CustomerOrderIndexedSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new CustomerOrderIndexedSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface ICustomerOrderIndexedSearchCriteria {
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class PaymentSearchCriteria implements IPaymentSearchCriteria {
  /** It used to limit search within a customer order id */
  orderId?: string | undefined;
  /** It used to limit search within a customer order number */
  orderNumber?: string | undefined;
  /** Filter payments by customer */
  customerId?: string | undefined;
  capturedStartDate?: Date | undefined;
  capturedEndDate?: Date | undefined;
  authorizedStartDate?: Date | undefined;
  authorizedEndDate?: Date | undefined;
  ids?: string[] | undefined;
  employeeId?: string | undefined;
  storeIds?: string[] | undefined;
  /** Search by status */
  status?: string | undefined;
  statuses?: string[] | undefined;
  /** Search by numbers */
  number?: string | undefined;
  numbers?: string[] | undefined;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IPaymentSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.orderId = _data["orderId"];
      this.orderNumber = _data["orderNumber"];
      this.customerId = _data["customerId"];
      this.capturedStartDate = _data["capturedStartDate"]
        ? new Date(_data["capturedStartDate"].toString())
        : <any>undefined;
      this.capturedEndDate = _data["capturedEndDate"]
        ? new Date(_data["capturedEndDate"].toString())
        : <any>undefined;
      this.authorizedStartDate = _data["authorizedStartDate"]
        ? new Date(_data["authorizedStartDate"].toString())
        : <any>undefined;
      this.authorizedEndDate = _data["authorizedEndDate"]
        ? new Date(_data["authorizedEndDate"].toString())
        : <any>undefined;
      if (Array.isArray(_data["ids"])) {
        this.ids = [] as any;
        for (let item of _data["ids"]) this.ids!.push(item);
      }
      this.employeeId = _data["employeeId"];
      if (Array.isArray(_data["storeIds"])) {
        this.storeIds = [] as any;
        for (let item of _data["storeIds"]) this.storeIds!.push(item);
      }
      this.status = _data["status"];
      if (Array.isArray(_data["statuses"])) {
        this.statuses = [] as any;
        for (let item of _data["statuses"]) this.statuses!.push(item);
      }
      this.number = _data["number"];
      if (Array.isArray(_data["numbers"])) {
        this.numbers = [] as any;
        for (let item of _data["numbers"]) this.numbers!.push(item);
      }
      this.startDate = _data["startDate"]
        ? new Date(_data["startDate"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? new Date(_data["endDate"].toString())
        : <any>undefined;
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): PaymentSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new PaymentSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["orderId"] = this.orderId;
    data["orderNumber"] = this.orderNumber;
    data["customerId"] = this.customerId;
    data["capturedStartDate"] = this.capturedStartDate
      ? this.capturedStartDate.toISOString()
      : <any>undefined;
    data["capturedEndDate"] = this.capturedEndDate
      ? this.capturedEndDate.toISOString()
      : <any>undefined;
    data["authorizedStartDate"] = this.authorizedStartDate
      ? this.authorizedStartDate.toISOString()
      : <any>undefined;
    data["authorizedEndDate"] = this.authorizedEndDate
      ? this.authorizedEndDate.toISOString()
      : <any>undefined;
    if (Array.isArray(this.ids)) {
      data["ids"] = [];
      for (let item of this.ids) data["ids"].push(item);
    }
    data["employeeId"] = this.employeeId;
    if (Array.isArray(this.storeIds)) {
      data["storeIds"] = [];
      for (let item of this.storeIds) data["storeIds"].push(item);
    }
    data["status"] = this.status;
    if (Array.isArray(this.statuses)) {
      data["statuses"] = [];
      for (let item of this.statuses) data["statuses"].push(item);
    }
    data["number"] = this.number;
    if (Array.isArray(this.numbers)) {
      data["numbers"] = [];
      for (let item of this.numbers) data["numbers"].push(item);
    }
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IPaymentSearchCriteria {
  /** It used to limit search within a customer order id */
  orderId?: string | undefined;
  /** It used to limit search within a customer order number */
  orderNumber?: string | undefined;
  /** Filter payments by customer */
  customerId?: string | undefined;
  capturedStartDate?: Date | undefined;
  capturedEndDate?: Date | undefined;
  authorizedStartDate?: Date | undefined;
  authorizedEndDate?: Date | undefined;
  ids?: string[] | undefined;
  employeeId?: string | undefined;
  storeIds?: string[] | undefined;
  /** Search by status */
  status?: string | undefined;
  statuses?: string[] | undefined;
  /** Search by numbers */
  number?: string | undefined;
  numbers?: string[] | undefined;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class PaymentSearchResult implements IPaymentSearchResult {
  totalCount?: number;
  results?: PaymentIn[] | undefined;

  constructor(data?: IPaymentSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(PaymentIn.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaymentSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new PaymentSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaymentSearchResult {
  totalCount?: number;
  results?: PaymentIn[] | undefined;
}

export class PaymentMethodsSearchCriteria
  implements IPaymentMethodsSearchCriteria
{
  storeId?: string | undefined;
  codes?: string[] | undefined;
  isActive?: boolean | undefined;
  withoutTransient?: boolean;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IPaymentMethodsSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.storeId = _data["storeId"];
      if (Array.isArray(_data["codes"])) {
        this.codes = [] as any;
        for (let item of _data["codes"]) this.codes!.push(item);
      }
      this.isActive = _data["isActive"];
      this.withoutTransient = _data["withoutTransient"];
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): PaymentMethodsSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new PaymentMethodsSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["storeId"] = this.storeId;
    if (Array.isArray(this.codes)) {
      data["codes"] = [];
      for (let item of this.codes) data["codes"].push(item);
    }
    data["isActive"] = this.isActive;
    data["withoutTransient"] = this.withoutTransient;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IPaymentMethodsSearchCriteria {
  storeId?: string | undefined;
  codes?: string[] | undefined;
  isActive?: boolean | undefined;
  withoutTransient?: boolean;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class PaymentMethodsSearchResult implements IPaymentMethodsSearchResult {
  totalCount?: number;
  results?: PaymentMethod[] | undefined;

  constructor(data?: IPaymentMethodsSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(PaymentMethod.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaymentMethodsSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new PaymentMethodsSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaymentMethodsSearchResult {
  totalCount?: number;
  results?: PaymentMethod[] | undefined;
}

export class PriceEvaluationContext implements IPriceEvaluationContext {
  storeId?: string | undefined;
  catalogId?: string | undefined;
  productIds?: string[] | undefined;
  pricelistIds?: string[] | undefined;
  returnAllMatchedPrices?: boolean;
  quantity?: number;
  customerId?: string | undefined;
  organizationId?: string | undefined;
  certainDate?: Date | undefined;
  currency?: string | undefined;
  contextObject?: any | undefined;
  geoCity?: string | undefined;
  geoState?: string | undefined;
  geoCountry?: string | undefined;
  geoContinent?: string | undefined;
  geoZipCode?: string | undefined;
  geoConnectionType?: string | undefined;
  geoTimeZone?: string | undefined;
  geoIpRoutingType?: string | undefined;
  geoIspSecondLevel?: string | undefined;
  geoIspTopLevel?: string | undefined;
  shopperAge?: number;
  shopperGender?: string | undefined;
  language?: string | undefined;
  /** Any tags or groups belongs to user such as VIP, Wholesaler etc */
  userGroups?: string[] | undefined;
  shopperSearchedPhraseInStore?: string | undefined;
  shopperSearchedPhraseOnInternet?: string | undefined;
  currentUrl?: string | undefined;
  referredUrl?: string | undefined;

  constructor(data?: IPriceEvaluationContext) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.storeId = _data["storeId"];
      this.catalogId = _data["catalogId"];
      if (Array.isArray(_data["productIds"])) {
        this.productIds = [] as any;
        for (let item of _data["productIds"]) this.productIds!.push(item);
      }
      if (Array.isArray(_data["pricelistIds"])) {
        this.pricelistIds = [] as any;
        for (let item of _data["pricelistIds"]) this.pricelistIds!.push(item);
      }
      this.returnAllMatchedPrices = _data["returnAllMatchedPrices"];
      this.quantity = _data["quantity"];
      this.customerId = _data["customerId"];
      this.organizationId = _data["organizationId"];
      this.certainDate = _data["certainDate"]
        ? new Date(_data["certainDate"].toString())
        : <any>undefined;
      this.currency = _data["currency"];
      this.contextObject = _data["contextObject"];
      this.geoCity = _data["geoCity"];
      this.geoState = _data["geoState"];
      this.geoCountry = _data["geoCountry"];
      this.geoContinent = _data["geoContinent"];
      this.geoZipCode = _data["geoZipCode"];
      this.geoConnectionType = _data["geoConnectionType"];
      this.geoTimeZone = _data["geoTimeZone"];
      this.geoIpRoutingType = _data["geoIpRoutingType"];
      this.geoIspSecondLevel = _data["geoIspSecondLevel"];
      this.geoIspTopLevel = _data["geoIspTopLevel"];
      this.shopperAge = _data["shopperAge"];
      this.shopperGender = _data["shopperGender"];
      this.language = _data["language"];
      if (Array.isArray(_data["userGroups"])) {
        this.userGroups = [] as any;
        for (let item of _data["userGroups"]) this.userGroups!.push(item);
      }
      this.shopperSearchedPhraseInStore = _data["shopperSearchedPhraseInStore"];
      this.shopperSearchedPhraseOnInternet =
        _data["shopperSearchedPhraseOnInternet"];
      this.currentUrl = _data["currentUrl"];
      this.referredUrl = _data["referredUrl"];
    }
  }

  static fromJS(data: any): PriceEvaluationContext {
    data = typeof data === "object" ? data : {};
    let result = new PriceEvaluationContext();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["storeId"] = this.storeId;
    data["catalogId"] = this.catalogId;
    if (Array.isArray(this.productIds)) {
      data["productIds"] = [];
      for (let item of this.productIds) data["productIds"].push(item);
    }
    if (Array.isArray(this.pricelistIds)) {
      data["pricelistIds"] = [];
      for (let item of this.pricelistIds) data["pricelistIds"].push(item);
    }
    data["returnAllMatchedPrices"] = this.returnAllMatchedPrices;
    data["quantity"] = this.quantity;
    data["customerId"] = this.customerId;
    data["organizationId"] = this.organizationId;
    data["certainDate"] = this.certainDate
      ? this.certainDate.toISOString()
      : <any>undefined;
    data["currency"] = this.currency;
    data["contextObject"] = this.contextObject;
    data["geoCity"] = this.geoCity;
    data["geoState"] = this.geoState;
    data["geoCountry"] = this.geoCountry;
    data["geoContinent"] = this.geoContinent;
    data["geoZipCode"] = this.geoZipCode;
    data["geoConnectionType"] = this.geoConnectionType;
    data["geoTimeZone"] = this.geoTimeZone;
    data["geoIpRoutingType"] = this.geoIpRoutingType;
    data["geoIspSecondLevel"] = this.geoIspSecondLevel;
    data["geoIspTopLevel"] = this.geoIspTopLevel;
    data["shopperAge"] = this.shopperAge;
    data["shopperGender"] = this.shopperGender;
    data["language"] = this.language;
    if (Array.isArray(this.userGroups)) {
      data["userGroups"] = [];
      for (let item of this.userGroups) data["userGroups"].push(item);
    }
    data["shopperSearchedPhraseInStore"] = this.shopperSearchedPhraseInStore;
    data["shopperSearchedPhraseOnInternet"] =
      this.shopperSearchedPhraseOnInternet;
    data["currentUrl"] = this.currentUrl;
    data["referredUrl"] = this.referredUrl;
    return data;
  }
}

export interface IPriceEvaluationContext {
  storeId?: string | undefined;
  catalogId?: string | undefined;
  productIds?: string[] | undefined;
  pricelistIds?: string[] | undefined;
  returnAllMatchedPrices?: boolean;
  quantity?: number;
  customerId?: string | undefined;
  organizationId?: string | undefined;
  certainDate?: Date | undefined;
  currency?: string | undefined;
  contextObject?: any | undefined;
  geoCity?: string | undefined;
  geoState?: string | undefined;
  geoCountry?: string | undefined;
  geoContinent?: string | undefined;
  geoZipCode?: string | undefined;
  geoConnectionType?: string | undefined;
  geoTimeZone?: string | undefined;
  geoIpRoutingType?: string | undefined;
  geoIspSecondLevel?: string | undefined;
  geoIspTopLevel?: string | undefined;
  shopperAge?: number;
  shopperGender?: string | undefined;
  language?: string | undefined;
  /** Any tags or groups belongs to user such as VIP, Wholesaler etc */
  userGroups?: string[] | undefined;
  shopperSearchedPhraseInStore?: string | undefined;
  shopperSearchedPhraseOnInternet?: string | undefined;
  currentUrl?: string | undefined;
  referredUrl?: string | undefined;
}

export class PricelistSearchResult implements IPricelistSearchResult {
  totalCount?: number;
  results?: Pricelist[] | undefined;

  constructor(data?: IPricelistSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(Pricelist.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PricelistSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new PricelistSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPricelistSearchResult {
  totalCount?: number;
  results?: Pricelist[] | undefined;
}

export class PricelistAssignmentSearchResult
  implements IPricelistAssignmentSearchResult
{
  totalCount?: number;
  results?: PricelistAssignment[] | undefined;

  constructor(data?: IPricelistAssignmentSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(PricelistAssignment.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PricelistAssignmentSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new PricelistAssignmentSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPricelistAssignmentSearchResult {
  totalCount?: number;
  results?: PricelistAssignment[] | undefined;
}

export class ProductPrice implements IProductPrice {
  productId?: string | undefined;
  product?: CatalogProduct;
  /** List prices for the products. It includes tiered prices also. (Depending on the quantity, for example) */
  prices?: Price[] | undefined;

  constructor(data?: IProductPrice) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data["productId"];
      this.product = _data["product"]
        ? CatalogProduct.fromJS(_data["product"])
        : <any>undefined;
      if (Array.isArray(_data["prices"])) {
        this.prices = [] as any;
        for (let item of _data["prices"]) this.prices!.push(Price.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ProductPrice {
    data = typeof data === "object" ? data : {};
    let result = new ProductPrice();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["productId"] = this.productId;
    data["product"] = this.product ? this.product.toJSON() : <any>undefined;
    if (Array.isArray(this.prices)) {
      data["prices"] = [];
      for (let item of this.prices) data["prices"].push(item.toJSON());
    }
    return data;
  }
}

export interface IProductPrice {
  productId?: string | undefined;
  product?: CatalogProduct;
  /** List prices for the products. It includes tiered prices also. (Depending on the quantity, for example) */
  prices?: Price[] | undefined;
}

export class ProductPriceSearchResult implements IProductPriceSearchResult {
  totalCount?: number;
  results?: ProductPrice[] | undefined;

  constructor(data?: IProductPriceSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(ProductPrice.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ProductPriceSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new ProductPriceSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IProductPriceSearchResult {
  totalCount?: number;
  results?: ProductPrice[] | undefined;
}

export class PricesSearchCriteria implements IPricesSearchCriteria {
  groupByProducts?: boolean;
  priceListId?: string | undefined;
  priceListIds?: string[] | undefined;
  productId?: string | undefined;
  productIds?: string[] | undefined;
  modifiedSince?: Date | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IPricesSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.groupByProducts = _data["groupByProducts"];
      this.priceListId = _data["priceListId"];
      if (Array.isArray(_data["priceListIds"])) {
        this.priceListIds = [] as any;
        for (let item of _data["priceListIds"]) this.priceListIds!.push(item);
      }
      this.productId = _data["productId"];
      if (Array.isArray(_data["productIds"])) {
        this.productIds = [] as any;
        for (let item of _data["productIds"]) this.productIds!.push(item);
      }
      this.modifiedSince = _data["modifiedSince"]
        ? new Date(_data["modifiedSince"].toString())
        : <any>undefined;
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): PricesSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new PricesSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["groupByProducts"] = this.groupByProducts;
    data["priceListId"] = this.priceListId;
    if (Array.isArray(this.priceListIds)) {
      data["priceListIds"] = [];
      for (let item of this.priceListIds) data["priceListIds"].push(item);
    }
    data["productId"] = this.productId;
    if (Array.isArray(this.productIds)) {
      data["productIds"] = [];
      for (let item of this.productIds) data["productIds"].push(item);
    }
    data["modifiedSince"] = this.modifiedSince
      ? this.modifiedSince.toISOString()
      : <any>undefined;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IPricesSearchCriteria {
  groupByProducts?: boolean;
  priceListId?: string | undefined;
  priceListIds?: string[] | undefined;
  productId?: string | undefined;
  productIds?: string[] | undefined;
  modifiedSince?: Date | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class QuoteRequestSearchCriteria implements IQuoteRequestSearchCriteria {
  number?: string | undefined;
  customerId?: string | undefined;
  storeId?: string | undefined;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  status?: string | undefined;
  tag?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IQuoteRequestSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.number = _data["number"];
      this.customerId = _data["customerId"];
      this.storeId = _data["storeId"];
      this.startDate = _data["startDate"]
        ? new Date(_data["startDate"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? new Date(_data["endDate"].toString())
        : <any>undefined;
      this.status = _data["status"];
      this.tag = _data["tag"];
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): QuoteRequestSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new QuoteRequestSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["number"] = this.number;
    data["customerId"] = this.customerId;
    data["storeId"] = this.storeId;
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    data["status"] = this.status;
    data["tag"] = this.tag;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IQuoteRequestSearchCriteria {
  number?: string | undefined;
  customerId?: string | undefined;
  storeId?: string | undefined;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  status?: string | undefined;
  tag?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class QuoteRequestTotals implements IQuoteRequestTotals {
  originalSubTotalExlTax?: number;
  subTotalExlTax?: number;
  shippingTotal?: number;
  discountTotal?: number;
  taxTotal?: number;
  readonly adjustmentQuoteExlTax?: number;
  readonly grandTotalExlTax?: number;
  readonly grandTotalInclTax?: number;

  constructor(data?: IQuoteRequestTotals) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.originalSubTotalExlTax = _data["originalSubTotalExlTax"];
      this.subTotalExlTax = _data["subTotalExlTax"];
      this.shippingTotal = _data["shippingTotal"];
      this.discountTotal = _data["discountTotal"];
      this.taxTotal = _data["taxTotal"];
      (<any>this).adjustmentQuoteExlTax = _data["adjustmentQuoteExlTax"];
      (<any>this).grandTotalExlTax = _data["grandTotalExlTax"];
      (<any>this).grandTotalInclTax = _data["grandTotalInclTax"];
    }
  }

  static fromJS(data: any): QuoteRequestTotals {
    data = typeof data === "object" ? data : {};
    let result = new QuoteRequestTotals();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["originalSubTotalExlTax"] = this.originalSubTotalExlTax;
    data["subTotalExlTax"] = this.subTotalExlTax;
    data["shippingTotal"] = this.shippingTotal;
    data["discountTotal"] = this.discountTotal;
    data["taxTotal"] = this.taxTotal;
    data["adjustmentQuoteExlTax"] = this.adjustmentQuoteExlTax;
    data["grandTotalExlTax"] = this.grandTotalExlTax;
    data["grandTotalInclTax"] = this.grandTotalInclTax;
    return data;
  }
}

export interface IQuoteRequestTotals {
  originalSubTotalExlTax?: number;
  subTotalExlTax?: number;
  shippingTotal?: number;
  discountTotal?: number;
  taxTotal?: number;
  adjustmentQuoteExlTax?: number;
  grandTotalExlTax?: number;
  grandTotalInclTax?: number;
}

export class ShipmentMethod implements IShipmentMethod {
  shipmentMethodCode?: string | undefined;
  optionName?: string | undefined;
  logoUrl?: string | undefined;
  currency?: string | undefined;
  price?: number;

  constructor(data?: IShipmentMethod) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.shipmentMethodCode = _data["shipmentMethodCode"];
      this.optionName = _data["optionName"];
      this.logoUrl = _data["logoUrl"];
      this.currency = _data["currency"];
      this.price = _data["price"];
    }
  }

  static fromJS(data: any): ShipmentMethod {
    data = typeof data === "object" ? data : {};
    let result = new ShipmentMethod();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["shipmentMethodCode"] = this.shipmentMethodCode;
    data["optionName"] = this.optionName;
    data["logoUrl"] = this.logoUrl;
    data["currency"] = this.currency;
    data["price"] = this.price;
    return data;
  }
}

export interface IShipmentMethod {
  shipmentMethodCode?: string | undefined;
  optionName?: string | undefined;
  logoUrl?: string | undefined;
  currency?: string | undefined;
  price?: number;
}

export class QuoteAddress implements IQuoteAddress {
  addressType?: AddressType;
  key?: string | undefined;
  name?: string | undefined;
  organization?: string | undefined;
  countryCode?: string | undefined;
  countryName?: string | undefined;
  city?: string | undefined;
  postalCode?: string | undefined;
  zip?: string | undefined;
  line1?: string | undefined;
  line2?: string | undefined;
  regionId?: string | undefined;
  regionName?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  email?: string | undefined;

  constructor(data?: IQuoteAddress) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.addressType = _data["addressType"];
      this.key = _data["key"];
      this.name = _data["name"];
      this.organization = _data["organization"];
      this.countryCode = _data["countryCode"];
      this.countryName = _data["countryName"];
      this.city = _data["city"];
      this.postalCode = _data["postalCode"];
      this.zip = _data["zip"];
      this.line1 = _data["line1"];
      this.line2 = _data["line2"];
      this.regionId = _data["regionId"];
      this.regionName = _data["regionName"];
      this.firstName = _data["firstName"];
      this.middleName = _data["middleName"];
      this.lastName = _data["lastName"];
      this.phone = _data["phone"];
      this.email = _data["email"];
    }
  }

  static fromJS(data: any): QuoteAddress {
    data = typeof data === "object" ? data : {};
    let result = new QuoteAddress();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["addressType"] = this.addressType;
    data["key"] = this.key;
    data["name"] = this.name;
    data["organization"] = this.organization;
    data["countryCode"] = this.countryCode;
    data["countryName"] = this.countryName;
    data["city"] = this.city;
    data["postalCode"] = this.postalCode;
    data["zip"] = this.zip;
    data["line1"] = this.line1;
    data["line2"] = this.line2;
    data["regionId"] = this.regionId;
    data["regionName"] = this.regionName;
    data["firstName"] = this.firstName;
    data["middleName"] = this.middleName;
    data["lastName"] = this.lastName;
    data["phone"] = this.phone;
    data["email"] = this.email;
    return data;
  }
}

export interface IQuoteAddress {
  addressType?: AddressType;
  key?: string | undefined;
  name?: string | undefined;
  organization?: string | undefined;
  countryCode?: string | undefined;
  countryName?: string | undefined;
  city?: string | undefined;
  postalCode?: string | undefined;
  zip?: string | undefined;
  line1?: string | undefined;
  line2?: string | undefined;
  regionId?: string | undefined;
  regionName?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  email?: string | undefined;
}

export class TierPrice implements ITierPrice {
  price?: number;
  quantity?: number;

  constructor(data?: ITierPrice) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.price = _data["price"];
      this.quantity = _data["quantity"];
    }
  }

  static fromJS(data: any): TierPrice {
    data = typeof data === "object" ? data : {};
    let result = new TierPrice();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["price"] = this.price;
    data["quantity"] = this.quantity;
    return data;
  }
}

export interface ITierPrice {
  price?: number;
  quantity?: number;
}

export class QuoteItem implements IQuoteItem {
  currency?: string | undefined;
  listPrice?: number;
  salePrice?: number;
  sku?: string | undefined;
  productId?: string | undefined;
  product?: CatalogProduct;
  catalogId?: string | undefined;
  categoryId?: string | undefined;
  name?: string | undefined;
  comment?: string | undefined;
  imageUrl?: string | undefined;
  taxType?: string | undefined;
  selectedTierPrice?: TierPrice;
  proposalPrices?: TierPrice[] | undefined;
  id?: string | undefined;

  constructor(data?: IQuoteItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currency = _data["currency"];
      this.listPrice = _data["listPrice"];
      this.salePrice = _data["salePrice"];
      this.sku = _data["sku"];
      this.productId = _data["productId"];
      this.product = _data["product"]
        ? CatalogProduct.fromJS(_data["product"])
        : <any>undefined;
      this.catalogId = _data["catalogId"];
      this.categoryId = _data["categoryId"];
      this.name = _data["name"];
      this.comment = _data["comment"];
      this.imageUrl = _data["imageUrl"];
      this.taxType = _data["taxType"];
      this.selectedTierPrice = _data["selectedTierPrice"]
        ? TierPrice.fromJS(_data["selectedTierPrice"])
        : <any>undefined;
      if (Array.isArray(_data["proposalPrices"])) {
        this.proposalPrices = [] as any;
        for (let item of _data["proposalPrices"])
          this.proposalPrices!.push(TierPrice.fromJS(item));
      }
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): QuoteItem {
    data = typeof data === "object" ? data : {};
    let result = new QuoteItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["currency"] = this.currency;
    data["listPrice"] = this.listPrice;
    data["salePrice"] = this.salePrice;
    data["sku"] = this.sku;
    data["productId"] = this.productId;
    data["product"] = this.product ? this.product.toJSON() : <any>undefined;
    data["catalogId"] = this.catalogId;
    data["categoryId"] = this.categoryId;
    data["name"] = this.name;
    data["comment"] = this.comment;
    data["imageUrl"] = this.imageUrl;
    data["taxType"] = this.taxType;
    data["selectedTierPrice"] = this.selectedTierPrice
      ? this.selectedTierPrice.toJSON()
      : <any>undefined;
    if (Array.isArray(this.proposalPrices)) {
      data["proposalPrices"] = [];
      for (let item of this.proposalPrices)
        data["proposalPrices"].push(item.toJSON());
    }
    data["id"] = this.id;
    return data;
  }
}

export interface IQuoteItem {
  currency?: string | undefined;
  listPrice?: number;
  salePrice?: number;
  sku?: string | undefined;
  productId?: string | undefined;
  product?: CatalogProduct;
  catalogId?: string | undefined;
  categoryId?: string | undefined;
  name?: string | undefined;
  comment?: string | undefined;
  imageUrl?: string | undefined;
  taxType?: string | undefined;
  selectedTierPrice?: TierPrice;
  proposalPrices?: TierPrice[] | undefined;
  id?: string | undefined;
}

export class QuoteAttachment implements IQuoteAttachment {
  name?: string | undefined;
  url?: string | undefined;
  mimeType?: string | undefined;
  size?: number;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IQuoteAttachment) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.url = _data["url"];
      this.mimeType = _data["mimeType"];
      this.size = _data["size"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): QuoteAttachment {
    data = typeof data === "object" ? data : {};
    let result = new QuoteAttachment();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["url"] = this.url;
    data["mimeType"] = this.mimeType;
    data["size"] = this.size;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IQuoteAttachment {
  name?: string | undefined;
  url?: string | undefined;
  mimeType?: string | undefined;
  size?: number;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class QuoteRequest implements IQuoteRequest {
  number?: string | undefined;
  storeId?: string | undefined;
  channelId?: string | undefined;
  isAnonymous?: boolean;
  customerId?: string | undefined;
  customerName?: string | undefined;
  organizationName?: string | undefined;
  organizationId?: string | undefined;
  employeeId?: string | undefined;
  employeeName?: string | undefined;
  expirationDate?: Date | undefined;
  reminderDate?: Date | undefined;
  enableNotification?: boolean;
  isLocked?: boolean;
  status?: string | undefined;
  tag?: string | undefined;
  comment?: string | undefined;
  innerComment?: string | undefined;
  currency?: string | undefined;
  coupon?: string | undefined;
  manualShippingTotal?: number;
  manualSubTotal?: number;
  manualRelDiscountAmount?: number;
  totals?: QuoteRequestTotals;
  shipmentMethod?: ShipmentMethod;
  addresses?: QuoteAddress[] | undefined;
  items?: QuoteItem[] | undefined;
  attachments?: QuoteAttachment[] | undefined;
  operationsLog?: OperationLog[] | undefined;
  languageCode?: string | undefined;
  taxDetails?: TaxDetail[] | undefined;
  isCancelled?: boolean;
  cancelledDate?: Date | undefined;
  cancelReason?: string | undefined;
  readonly objectType?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IQuoteRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.number = _data["number"];
      this.storeId = _data["storeId"];
      this.channelId = _data["channelId"];
      this.isAnonymous = _data["isAnonymous"];
      this.customerId = _data["customerId"];
      this.customerName = _data["customerName"];
      this.organizationName = _data["organizationName"];
      this.organizationId = _data["organizationId"];
      this.employeeId = _data["employeeId"];
      this.employeeName = _data["employeeName"];
      this.expirationDate = _data["expirationDate"]
        ? new Date(_data["expirationDate"].toString())
        : <any>undefined;
      this.reminderDate = _data["reminderDate"]
        ? new Date(_data["reminderDate"].toString())
        : <any>undefined;
      this.enableNotification = _data["enableNotification"];
      this.isLocked = _data["isLocked"];
      this.status = _data["status"];
      this.tag = _data["tag"];
      this.comment = _data["comment"];
      this.innerComment = _data["innerComment"];
      this.currency = _data["currency"];
      this.coupon = _data["coupon"];
      this.manualShippingTotal = _data["manualShippingTotal"];
      this.manualSubTotal = _data["manualSubTotal"];
      this.manualRelDiscountAmount = _data["manualRelDiscountAmount"];
      this.totals = _data["totals"]
        ? QuoteRequestTotals.fromJS(_data["totals"])
        : <any>undefined;
      this.shipmentMethod = _data["shipmentMethod"]
        ? ShipmentMethod.fromJS(_data["shipmentMethod"])
        : <any>undefined;
      if (Array.isArray(_data["addresses"])) {
        this.addresses = [] as any;
        for (let item of _data["addresses"])
          this.addresses!.push(QuoteAddress.fromJS(item));
      }
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(QuoteItem.fromJS(item));
      }
      if (Array.isArray(_data["attachments"])) {
        this.attachments = [] as any;
        for (let item of _data["attachments"])
          this.attachments!.push(QuoteAttachment.fromJS(item));
      }
      if (Array.isArray(_data["operationsLog"])) {
        this.operationsLog = [] as any;
        for (let item of _data["operationsLog"])
          this.operationsLog!.push(OperationLog.fromJS(item));
      }
      this.languageCode = _data["languageCode"];
      if (Array.isArray(_data["taxDetails"])) {
        this.taxDetails = [] as any;
        for (let item of _data["taxDetails"])
          this.taxDetails!.push(TaxDetail.fromJS(item));
      }
      this.isCancelled = _data["isCancelled"];
      this.cancelledDate = _data["cancelledDate"]
        ? new Date(_data["cancelledDate"].toString())
        : <any>undefined;
      this.cancelReason = _data["cancelReason"];
      (<any>this).objectType = _data["objectType"];
      if (Array.isArray(_data["dynamicProperties"])) {
        this.dynamicProperties = [] as any;
        for (let item of _data["dynamicProperties"])
          this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): QuoteRequest {
    data = typeof data === "object" ? data : {};
    let result = new QuoteRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["number"] = this.number;
    data["storeId"] = this.storeId;
    data["channelId"] = this.channelId;
    data["isAnonymous"] = this.isAnonymous;
    data["customerId"] = this.customerId;
    data["customerName"] = this.customerName;
    data["organizationName"] = this.organizationName;
    data["organizationId"] = this.organizationId;
    data["employeeId"] = this.employeeId;
    data["employeeName"] = this.employeeName;
    data["expirationDate"] = this.expirationDate
      ? this.expirationDate.toISOString()
      : <any>undefined;
    data["reminderDate"] = this.reminderDate
      ? this.reminderDate.toISOString()
      : <any>undefined;
    data["enableNotification"] = this.enableNotification;
    data["isLocked"] = this.isLocked;
    data["status"] = this.status;
    data["tag"] = this.tag;
    data["comment"] = this.comment;
    data["innerComment"] = this.innerComment;
    data["currency"] = this.currency;
    data["coupon"] = this.coupon;
    data["manualShippingTotal"] = this.manualShippingTotal;
    data["manualSubTotal"] = this.manualSubTotal;
    data["manualRelDiscountAmount"] = this.manualRelDiscountAmount;
    data["totals"] = this.totals ? this.totals.toJSON() : <any>undefined;
    data["shipmentMethod"] = this.shipmentMethod
      ? this.shipmentMethod.toJSON()
      : <any>undefined;
    if (Array.isArray(this.addresses)) {
      data["addresses"] = [];
      for (let item of this.addresses) data["addresses"].push(item.toJSON());
    }
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    if (Array.isArray(this.attachments)) {
      data["attachments"] = [];
      for (let item of this.attachments)
        data["attachments"].push(item.toJSON());
    }
    if (Array.isArray(this.operationsLog)) {
      data["operationsLog"] = [];
      for (let item of this.operationsLog)
        data["operationsLog"].push(item.toJSON());
    }
    data["languageCode"] = this.languageCode;
    if (Array.isArray(this.taxDetails)) {
      data["taxDetails"] = [];
      for (let item of this.taxDetails) data["taxDetails"].push(item.toJSON());
    }
    data["isCancelled"] = this.isCancelled;
    data["cancelledDate"] = this.cancelledDate
      ? this.cancelledDate.toISOString()
      : <any>undefined;
    data["cancelReason"] = this.cancelReason;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.dynamicProperties)) {
      data["dynamicProperties"] = [];
      for (let item of this.dynamicProperties)
        data["dynamicProperties"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IQuoteRequest {
  number?: string | undefined;
  storeId?: string | undefined;
  channelId?: string | undefined;
  isAnonymous?: boolean;
  customerId?: string | undefined;
  customerName?: string | undefined;
  organizationName?: string | undefined;
  organizationId?: string | undefined;
  employeeId?: string | undefined;
  employeeName?: string | undefined;
  expirationDate?: Date | undefined;
  reminderDate?: Date | undefined;
  enableNotification?: boolean;
  isLocked?: boolean;
  status?: string | undefined;
  tag?: string | undefined;
  comment?: string | undefined;
  innerComment?: string | undefined;
  currency?: string | undefined;
  coupon?: string | undefined;
  manualShippingTotal?: number;
  manualSubTotal?: number;
  manualRelDiscountAmount?: number;
  totals?: QuoteRequestTotals;
  shipmentMethod?: ShipmentMethod;
  addresses?: QuoteAddress[] | undefined;
  items?: QuoteItem[] | undefined;
  attachments?: QuoteAttachment[] | undefined;
  operationsLog?: OperationLog[] | undefined;
  languageCode?: string | undefined;
  taxDetails?: TaxDetail[] | undefined;
  isCancelled?: boolean;
  cancelledDate?: Date | undefined;
  cancelReason?: string | undefined;
  objectType?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class QuoteRequestSearchResult implements IQuoteRequestSearchResult {
  readonly quoteRequests?: QuoteRequest[] | undefined;
  totalCount?: number;
  results?: QuoteRequest[] | undefined;

  constructor(data?: IQuoteRequestSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["quoteRequests"])) {
        (<any>this).quoteRequests = [] as any;
        for (let item of _data["quoteRequests"])
          (<any>this).quoteRequests!.push(QuoteRequest.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(QuoteRequest.fromJS(item));
      }
    }
  }

  static fromJS(data: any): QuoteRequestSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new QuoteRequestSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.quoteRequests)) {
      data["quoteRequests"] = [];
      for (let item of this.quoteRequests)
        data["quoteRequests"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IQuoteRequestSearchResult {
  quoteRequests?: QuoteRequest[] | undefined;
  totalCount?: number;
  results?: QuoteRequest[] | undefined;
}

export class IndexState implements IIndexState {
  provider?: string | undefined;
  scope?: string | undefined;
  documentType?: string | undefined;
  indexedDocumentsCount?: number | undefined;
  lastIndexationDate?: Date | undefined;

  constructor(data?: IIndexState) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.provider = _data["provider"];
      this.scope = _data["scope"];
      this.documentType = _data["documentType"];
      this.indexedDocumentsCount = _data["indexedDocumentsCount"];
      this.lastIndexationDate = _data["lastIndexationDate"]
        ? new Date(_data["lastIndexationDate"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): IndexState {
    data = typeof data === "object" ? data : {};
    let result = new IndexState();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["provider"] = this.provider;
    data["scope"] = this.scope;
    data["documentType"] = this.documentType;
    data["indexedDocumentsCount"] = this.indexedDocumentsCount;
    data["lastIndexationDate"] = this.lastIndexationDate
      ? this.lastIndexationDate.toISOString()
      : <any>undefined;
    return data;
  }
}

export interface IIndexState {
  provider?: string | undefined;
  scope?: string | undefined;
  documentType?: string | undefined;
  indexedDocumentsCount?: number | undefined;
  lastIndexationDate?: Date | undefined;
}

export enum IndexDocumentFieldValueType {
  Undefined = "Undefined",
  String = "String",
  Char = "Char",
  Guid = "Guid",
  Integer = "Integer",
  Double = "Double",
  Short = "Short",
  Byte = "Byte",
  Long = "Long",
  Float = "Float",
  Decimal = "Decimal",
  DateTime = "DateTime",
  Boolean = "Boolean",
  GeoPoint = "GeoPoint",
  Complex = "Complex",
}

export class IndexDocumentField implements IIndexDocumentField {
  name?: string | undefined;
  values?: any[] | undefined;
  value?: any | undefined;
  isRetrievable?: boolean;
  isFilterable?: boolean;
  isSearchable?: boolean;
  isCollection?: boolean;
  valueType?: IndexDocumentFieldValueType;

  constructor(data?: IIndexDocumentField) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      if (Array.isArray(_data["values"])) {
        this.values = [] as any;
        for (let item of _data["values"]) this.values!.push(item);
      }
      this.value = _data["value"];
      this.isRetrievable = _data["isRetrievable"];
      this.isFilterable = _data["isFilterable"];
      this.isSearchable = _data["isSearchable"];
      this.isCollection = _data["isCollection"];
      this.valueType = _data["valueType"];
    }
  }

  static fromJS(data: any): IndexDocumentField {
    data = typeof data === "object" ? data : {};
    let result = new IndexDocumentField();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    if (Array.isArray(this.values)) {
      data["values"] = [];
      for (let item of this.values) data["values"].push(item);
    }
    data["value"] = this.value;
    data["isRetrievable"] = this.isRetrievable;
    data["isFilterable"] = this.isFilterable;
    data["isSearchable"] = this.isSearchable;
    data["isCollection"] = this.isCollection;
    data["valueType"] = this.valueType;
    return data;
  }
}

export interface IIndexDocumentField {
  name?: string | undefined;
  values?: any[] | undefined;
  value?: any | undefined;
  isRetrievable?: boolean;
  isFilterable?: boolean;
  isSearchable?: boolean;
  isCollection?: boolean;
  valueType?: IndexDocumentFieldValueType;
}

export class IndexDocument implements IIndexDocument {
  fields?: IndexDocumentField[] | undefined;
  id?: string | undefined;

  constructor(data?: IIndexDocument) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["fields"])) {
        this.fields = [] as any;
        for (let item of _data["fields"])
          this.fields!.push(IndexDocumentField.fromJS(item));
      }
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): IndexDocument {
    data = typeof data === "object" ? data : {};
    let result = new IndexDocument();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.fields)) {
      data["fields"] = [];
      for (let item of this.fields) data["fields"].push(item.toJSON());
    }
    data["id"] = this.id;
    return data;
  }
}

export interface IIndexDocument {
  fields?: IndexDocumentField[] | undefined;
  id?: string | undefined;
}

export class IndexingOptions implements IIndexingOptions {
  documentType?: string | undefined;
  documentIds?: string[] | undefined;
  deleteExistingIndex?: boolean;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  batchSize?: number | undefined;

  constructor(data?: IIndexingOptions) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.documentType = _data["documentType"];
      if (Array.isArray(_data["documentIds"])) {
        this.documentIds = [] as any;
        for (let item of _data["documentIds"]) this.documentIds!.push(item);
      }
      this.deleteExistingIndex = _data["deleteExistingIndex"];
      this.startDate = _data["startDate"]
        ? new Date(_data["startDate"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? new Date(_data["endDate"].toString())
        : <any>undefined;
      this.batchSize = _data["batchSize"];
    }
  }

  static fromJS(data: any): IndexingOptions {
    data = typeof data === "object" ? data : {};
    let result = new IndexingOptions();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["documentType"] = this.documentType;
    if (Array.isArray(this.documentIds)) {
      data["documentIds"] = [];
      for (let item of this.documentIds) data["documentIds"].push(item);
    }
    data["deleteExistingIndex"] = this.deleteExistingIndex;
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    data["batchSize"] = this.batchSize;
    return data;
  }
}

export interface IIndexingOptions {
  documentType?: string | undefined;
  documentIds?: string[] | undefined;
  deleteExistingIndex?: boolean;
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  batchSize?: number | undefined;
}

export class IndexProgressPushNotification
  implements IIndexProgressPushNotification
{
  documentType?: string | undefined;
  finished?: Date | undefined;
  totalCount?: number;
  processedCount?: number;
  errorCount?: number;
  errors?: string[] | undefined;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;

  constructor(data?: IIndexProgressPushNotification) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.documentType = _data["documentType"];
      this.finished = _data["finished"]
        ? new Date(_data["finished"].toString())
        : <any>undefined;
      this.totalCount = _data["totalCount"];
      this.processedCount = _data["processedCount"];
      this.errorCount = _data["errorCount"];
      if (Array.isArray(_data["errors"])) {
        this.errors = [] as any;
        for (let item of _data["errors"]) this.errors!.push(item);
      }
      this.serverId = _data["serverId"];
      this.creator = _data["creator"];
      this.created = _data["created"]
        ? new Date(_data["created"].toString())
        : <any>undefined;
      this.isNew = _data["isNew"];
      this.notifyType = _data["notifyType"];
      this.description = _data["description"];
      this.title = _data["title"];
      this.repeatCount = _data["repeatCount"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): IndexProgressPushNotification {
    data = typeof data === "object" ? data : {};
    let result = new IndexProgressPushNotification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["documentType"] = this.documentType;
    data["finished"] = this.finished
      ? this.finished.toISOString()
      : <any>undefined;
    data["totalCount"] = this.totalCount;
    data["processedCount"] = this.processedCount;
    data["errorCount"] = this.errorCount;
    if (Array.isArray(this.errors)) {
      data["errors"] = [];
      for (let item of this.errors) data["errors"].push(item);
    }
    data["serverId"] = this.serverId;
    data["creator"] = this.creator;
    data["created"] = this.created
      ? this.created.toISOString()
      : <any>undefined;
    data["isNew"] = this.isNew;
    data["notifyType"] = this.notifyType;
    data["description"] = this.description;
    data["title"] = this.title;
    data["repeatCount"] = this.repeatCount;
    data["id"] = this.id;
    return data;
  }
}

export interface IIndexProgressPushNotification {
  documentType?: string | undefined;
  finished?: Date | undefined;
  totalCount?: number;
  processedCount?: number;
  errorCount?: number;
  errors?: string[] | undefined;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;
}

export class ShippingMethodsSearchCriteria
  implements IShippingMethodsSearchCriteria
{
  storeId?: string | undefined;
  codes?: string[] | undefined;
  isActive?: boolean | undefined;
  taxType?: string | undefined;
  withoutTransient?: boolean;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IShippingMethodsSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.storeId = _data["storeId"];
      if (Array.isArray(_data["codes"])) {
        this.codes = [] as any;
        for (let item of _data["codes"]) this.codes!.push(item);
      }
      this.isActive = _data["isActive"];
      this.taxType = _data["taxType"];
      this.withoutTransient = _data["withoutTransient"];
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): ShippingMethodsSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new ShippingMethodsSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["storeId"] = this.storeId;
    if (Array.isArray(this.codes)) {
      data["codes"] = [];
      for (let item of this.codes) data["codes"].push(item);
    }
    data["isActive"] = this.isActive;
    data["taxType"] = this.taxType;
    data["withoutTransient"] = this.withoutTransient;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IShippingMethodsSearchCriteria {
  storeId?: string | undefined;
  codes?: string[] | undefined;
  isActive?: boolean | undefined;
  taxType?: string | undefined;
  withoutTransient?: boolean;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class ShippingMethodsSearchResult
  implements IShippingMethodsSearchResult
{
  totalCount?: number;
  results?: ShippingMethod[] | undefined;

  constructor(data?: IShippingMethodsSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(ShippingMethod.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ShippingMethodsSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new ShippingMethodsSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IShippingMethodsSearchResult {
  totalCount?: number;
  results?: ShippingMethod[] | undefined;
}

export class SitemapSearchCriteria implements ISitemapSearchCriteria {
  storeId?: string | undefined;
  location?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: ISitemapSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.storeId = _data["storeId"];
      this.location = _data["location"];
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): SitemapSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new SitemapSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["storeId"] = this.storeId;
    data["location"] = this.location;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface ISitemapSearchCriteria {
  storeId?: string | undefined;
  location?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class SitemapItemAlternateLinkRecord
  implements ISitemapItemAlternateLinkRecord
{
  url?: string | undefined;
  language?: string | undefined;
  type?: string | undefined;

  constructor(data?: ISitemapItemAlternateLinkRecord) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.url = _data["url"];
      this.language = _data["language"];
      this.type = _data["type"];
    }
  }

  static fromJS(data: any): SitemapItemAlternateLinkRecord {
    data = typeof data === "object" ? data : {};
    let result = new SitemapItemAlternateLinkRecord();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["url"] = this.url;
    data["language"] = this.language;
    data["type"] = this.type;
    return data;
  }
}

export interface ISitemapItemAlternateLinkRecord {
  url?: string | undefined;
  language?: string | undefined;
  type?: string | undefined;
}

export class SitemapItemRecord implements ISitemapItemRecord {
  url?: string | undefined;
  modifiedDate?: Date;
  updateFrequency?: string | undefined;
  priority?: number;
  alternates?: SitemapItemAlternateLinkRecord[] | undefined;

  constructor(data?: ISitemapItemRecord) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.url = _data["url"];
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.updateFrequency = _data["updateFrequency"];
      this.priority = _data["priority"];
      if (Array.isArray(_data["alternates"])) {
        this.alternates = [] as any;
        for (let item of _data["alternates"])
          this.alternates!.push(SitemapItemAlternateLinkRecord.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SitemapItemRecord {
    data = typeof data === "object" ? data : {};
    let result = new SitemapItemRecord();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["url"] = this.url;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["updateFrequency"] = this.updateFrequency;
    data["priority"] = this.priority;
    if (Array.isArray(this.alternates)) {
      data["alternates"] = [];
      for (let item of this.alternates) data["alternates"].push(item.toJSON());
    }
    return data;
  }
}

export interface ISitemapItemRecord {
  url?: string | undefined;
  modifiedDate?: Date;
  updateFrequency?: string | undefined;
  priority?: number;
  alternates?: SitemapItemAlternateLinkRecord[] | undefined;
}

export class SitemapItem implements ISitemapItem {
  sitemapId?: string | undefined;
  title?: string | undefined;
  imageUrl?: string | undefined;
  objectId?: string | undefined;
  objectType?: string | undefined;
  urlTemplate?: string | undefined;
  itemsRecords?: SitemapItemRecord[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: ISitemapItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.sitemapId = _data["sitemapId"];
      this.title = _data["title"];
      this.imageUrl = _data["imageUrl"];
      this.objectId = _data["objectId"];
      this.objectType = _data["objectType"];
      this.urlTemplate = _data["urlTemplate"];
      if (Array.isArray(_data["itemsRecords"])) {
        this.itemsRecords = [] as any;
        for (let item of _data["itemsRecords"])
          this.itemsRecords!.push(SitemapItemRecord.fromJS(item));
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): SitemapItem {
    data = typeof data === "object" ? data : {};
    let result = new SitemapItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["sitemapId"] = this.sitemapId;
    data["title"] = this.title;
    data["imageUrl"] = this.imageUrl;
    data["objectId"] = this.objectId;
    data["objectType"] = this.objectType;
    data["urlTemplate"] = this.urlTemplate;
    if (Array.isArray(this.itemsRecords)) {
      data["itemsRecords"] = [];
      for (let item of this.itemsRecords)
        data["itemsRecords"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface ISitemapItem {
  sitemapId?: string | undefined;
  title?: string | undefined;
  imageUrl?: string | undefined;
  objectId?: string | undefined;
  objectType?: string | undefined;
  urlTemplate?: string | undefined;
  itemsRecords?: SitemapItemRecord[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class Sitemap implements ISitemap {
  location?: string | undefined;
  storeId?: string | undefined;
  items?: SitemapItem[] | undefined;
  urlTemplate?: string | undefined;
  totalItemsCount?: number;
  pagedLocations?: string[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: ISitemap) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.location = _data["location"];
      this.storeId = _data["storeId"];
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(SitemapItem.fromJS(item));
      }
      this.urlTemplate = _data["urlTemplate"];
      this.totalItemsCount = _data["totalItemsCount"];
      if (Array.isArray(_data["pagedLocations"])) {
        this.pagedLocations = [] as any;
        for (let item of _data["pagedLocations"])
          this.pagedLocations!.push(item);
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Sitemap {
    data = typeof data === "object" ? data : {};
    let result = new Sitemap();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["location"] = this.location;
    data["storeId"] = this.storeId;
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["urlTemplate"] = this.urlTemplate;
    data["totalItemsCount"] = this.totalItemsCount;
    if (Array.isArray(this.pagedLocations)) {
      data["pagedLocations"] = [];
      for (let item of this.pagedLocations) data["pagedLocations"].push(item);
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface ISitemap {
  location?: string | undefined;
  storeId?: string | undefined;
  items?: SitemapItem[] | undefined;
  urlTemplate?: string | undefined;
  totalItemsCount?: number;
  pagedLocations?: string[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class SitemapSearchResult implements ISitemapSearchResult {
  totalCount?: number;
  results?: Sitemap[] | undefined;

  constructor(data?: ISitemapSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(Sitemap.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SitemapSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new SitemapSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface ISitemapSearchResult {
  totalCount?: number;
  results?: Sitemap[] | undefined;
}

export class SitemapItemSearchCriteria implements ISitemapItemSearchCriteria {
  sitemapId?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: ISitemapItemSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.sitemapId = _data["sitemapId"];
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): SitemapItemSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new SitemapItemSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["sitemapId"] = this.sitemapId;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface ISitemapItemSearchCriteria {
  sitemapId?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class SitemapItemsSearchResult implements ISitemapItemsSearchResult {
  totalCount?: number;
  results?: SitemapItem[] | undefined;

  constructor(data?: ISitemapItemsSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(SitemapItem.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SitemapItemsSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new SitemapItemsSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface ISitemapItemsSearchResult {
  totalCount?: number;
  results?: SitemapItem[] | undefined;
}

export class SitemapDownloadNotification
  implements ISitemapDownloadNotification
{
  finished?: Date | undefined;
  totalCount?: number;
  processedCount?: number;
  readonly errorCount?: number;
  errors?: string[] | undefined;
  downloadUrl?: string | undefined;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;

  constructor(data?: ISitemapDownloadNotification) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.finished = _data["finished"]
        ? new Date(_data["finished"].toString())
        : <any>undefined;
      this.totalCount = _data["totalCount"];
      this.processedCount = _data["processedCount"];
      (<any>this).errorCount = _data["errorCount"];
      if (Array.isArray(_data["errors"])) {
        this.errors = [] as any;
        for (let item of _data["errors"]) this.errors!.push(item);
      }
      this.downloadUrl = _data["downloadUrl"];
      this.serverId = _data["serverId"];
      this.creator = _data["creator"];
      this.created = _data["created"]
        ? new Date(_data["created"].toString())
        : <any>undefined;
      this.isNew = _data["isNew"];
      this.notifyType = _data["notifyType"];
      this.description = _data["description"];
      this.title = _data["title"];
      this.repeatCount = _data["repeatCount"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): SitemapDownloadNotification {
    data = typeof data === "object" ? data : {};
    let result = new SitemapDownloadNotification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["finished"] = this.finished
      ? this.finished.toISOString()
      : <any>undefined;
    data["totalCount"] = this.totalCount;
    data["processedCount"] = this.processedCount;
    data["errorCount"] = this.errorCount;
    if (Array.isArray(this.errors)) {
      data["errors"] = [];
      for (let item of this.errors) data["errors"].push(item);
    }
    data["downloadUrl"] = this.downloadUrl;
    data["serverId"] = this.serverId;
    data["creator"] = this.creator;
    data["created"] = this.created
      ? this.created.toISOString()
      : <any>undefined;
    data["isNew"] = this.isNew;
    data["notifyType"] = this.notifyType;
    data["description"] = this.description;
    data["title"] = this.title;
    data["repeatCount"] = this.repeatCount;
    data["id"] = this.id;
    return data;
  }
}

export interface ISitemapDownloadNotification {
  finished?: Date | undefined;
  totalCount?: number;
  processedCount?: number;
  errorCount?: number;
  errors?: string[] | undefined;
  downloadUrl?: string | undefined;
  serverId?: string | undefined;
  creator?: string | undefined;
  created?: Date;
  isNew?: boolean;
  notifyType?: string | undefined;
  description?: string | undefined;
  title?: string | undefined;
  repeatCount?: number;
  id?: string | undefined;
}

export enum StoreState {
  Open = "Open",
  Closed = "Closed",
  RestrictedAccess = "RestrictedAccess",
}

export class StoreSearchCriteria implements IStoreSearchCriteria {
  storeIds?: string[] | undefined;
  storeStates?: StoreState[] | undefined;
  fulfillmentCenterIds?: string[] | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: IStoreSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["storeIds"])) {
        this.storeIds = [] as any;
        for (let item of _data["storeIds"]) this.storeIds!.push(item);
      }
      if (Array.isArray(_data["storeStates"])) {
        this.storeStates = [] as any;
        for (let item of _data["storeStates"]) this.storeStates!.push(item);
      }
      if (Array.isArray(_data["fulfillmentCenterIds"])) {
        this.fulfillmentCenterIds = [] as any;
        for (let item of _data["fulfillmentCenterIds"])
          this.fulfillmentCenterIds!.push(item);
      }
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): StoreSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new StoreSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.storeIds)) {
      data["storeIds"] = [];
      for (let item of this.storeIds) data["storeIds"].push(item);
    }
    if (Array.isArray(this.storeStates)) {
      data["storeStates"] = [];
      for (let item of this.storeStates) data["storeStates"].push(item);
    }
    if (Array.isArray(this.fulfillmentCenterIds)) {
      data["fulfillmentCenterIds"] = [];
      for (let item of this.fulfillmentCenterIds)
        data["fulfillmentCenterIds"].push(item);
    }
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface IStoreSearchCriteria {
  storeIds?: string[] | undefined;
  storeStates?: StoreState[] | undefined;
  fulfillmentCenterIds?: string[] | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class Store implements IStore {
  name?: string | undefined;
  description?: string | undefined;
  storeState?: StoreState;
  timeZone?: string | undefined;
  country?: string | undefined;
  region?: string | undefined;
  defaultLanguage?: string | undefined;
  defaultCurrency?: string | undefined;
  /** Catalog id used as primary store catalog */
  catalog?: string | undefined;
  creditCardSavePolicy?: boolean;
  /** Store storefront url */
  url?: string | undefined;
  /** Store storefront https url */
  secureUrl?: string | undefined;
  /** Primary store contact email can be used for store event notifications and for feed back */
  email?: string | undefined;
  adminEmail?: string | undefined;
  emailName?: string | undefined;
  adminEmailName?: string | undefined;
  displayOutOfStock?: boolean;
  outerId?: string | undefined;
  /** Primary (default) fulfillment center id */
  mainFulfillmentCenterId?: string | undefined;
  /** Alternate fulfillment centers ids */
  additionalFulfillmentCenterIds?: string[] | undefined;
  /** Primary (default) fulfillment center for order return */
  mainReturnsFulfillmentCenterId?: string | undefined;
  /** Alternate fulfillment centers for order return */
  returnsFulfillmentCenterIds?: string[] | undefined;
  /** All store supported languages */
  languages?: string[] | undefined;
  /** All store supported currencies */
  currencies?: string[] | undefined;
  /** All store trusted groups (group of stores that shared the user logins) */
  trustedGroups?: string[] | undefined;
  readonly seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  readonly objectType?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  settings?: ObjectSettingEntry[] | undefined;
  readonly typeName?: string | undefined;
  scopes?: string[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IStore) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.description = _data["description"];
      this.storeState = _data["storeState"];
      this.timeZone = _data["timeZone"];
      this.country = _data["country"];
      this.region = _data["region"];
      this.defaultLanguage = _data["defaultLanguage"];
      this.defaultCurrency = _data["defaultCurrency"];
      this.catalog = _data["catalog"];
      this.creditCardSavePolicy = _data["creditCardSavePolicy"];
      this.url = _data["url"];
      this.secureUrl = _data["secureUrl"];
      this.email = _data["email"];
      this.adminEmail = _data["adminEmail"];
      this.emailName = _data["emailName"];
      this.adminEmailName = _data["adminEmailName"];
      this.displayOutOfStock = _data["displayOutOfStock"];
      this.outerId = _data["outerId"];
      this.mainFulfillmentCenterId = _data["mainFulfillmentCenterId"];
      if (Array.isArray(_data["additionalFulfillmentCenterIds"])) {
        this.additionalFulfillmentCenterIds = [] as any;
        for (let item of _data["additionalFulfillmentCenterIds"])
          this.additionalFulfillmentCenterIds!.push(item);
      }
      this.mainReturnsFulfillmentCenterId =
        _data["mainReturnsFulfillmentCenterId"];
      if (Array.isArray(_data["returnsFulfillmentCenterIds"])) {
        this.returnsFulfillmentCenterIds = [] as any;
        for (let item of _data["returnsFulfillmentCenterIds"])
          this.returnsFulfillmentCenterIds!.push(item);
      }
      if (Array.isArray(_data["languages"])) {
        this.languages = [] as any;
        for (let item of _data["languages"]) this.languages!.push(item);
      }
      if (Array.isArray(_data["currencies"])) {
        this.currencies = [] as any;
        for (let item of _data["currencies"]) this.currencies!.push(item);
      }
      if (Array.isArray(_data["trustedGroups"])) {
        this.trustedGroups = [] as any;
        for (let item of _data["trustedGroups"]) this.trustedGroups!.push(item);
      }
      (<any>this).seoObjectType = _data["seoObjectType"];
      if (Array.isArray(_data["seoInfos"])) {
        this.seoInfos = [] as any;
        for (let item of _data["seoInfos"])
          this.seoInfos!.push(SeoInfo.fromJS(item));
      }
      (<any>this).objectType = _data["objectType"];
      if (Array.isArray(_data["dynamicProperties"])) {
        this.dynamicProperties = [] as any;
        for (let item of _data["dynamicProperties"])
          this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
      }
      if (Array.isArray(_data["settings"])) {
        this.settings = [] as any;
        for (let item of _data["settings"])
          this.settings!.push(ObjectSettingEntry.fromJS(item));
      }
      (<any>this).typeName = _data["typeName"];
      if (Array.isArray(_data["scopes"])) {
        this.scopes = [] as any;
        for (let item of _data["scopes"]) this.scopes!.push(item);
      }
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Store {
    data = typeof data === "object" ? data : {};
    let result = new Store();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["description"] = this.description;
    data["storeState"] = this.storeState;
    data["timeZone"] = this.timeZone;
    data["country"] = this.country;
    data["region"] = this.region;
    data["defaultLanguage"] = this.defaultLanguage;
    data["defaultCurrency"] = this.defaultCurrency;
    data["catalog"] = this.catalog;
    data["creditCardSavePolicy"] = this.creditCardSavePolicy;
    data["url"] = this.url;
    data["secureUrl"] = this.secureUrl;
    data["email"] = this.email;
    data["adminEmail"] = this.adminEmail;
    data["emailName"] = this.emailName;
    data["adminEmailName"] = this.adminEmailName;
    data["displayOutOfStock"] = this.displayOutOfStock;
    data["outerId"] = this.outerId;
    data["mainFulfillmentCenterId"] = this.mainFulfillmentCenterId;
    if (Array.isArray(this.additionalFulfillmentCenterIds)) {
      data["additionalFulfillmentCenterIds"] = [];
      for (let item of this.additionalFulfillmentCenterIds)
        data["additionalFulfillmentCenterIds"].push(item);
    }
    data["mainReturnsFulfillmentCenterId"] =
      this.mainReturnsFulfillmentCenterId;
    if (Array.isArray(this.returnsFulfillmentCenterIds)) {
      data["returnsFulfillmentCenterIds"] = [];
      for (let item of this.returnsFulfillmentCenterIds)
        data["returnsFulfillmentCenterIds"].push(item);
    }
    if (Array.isArray(this.languages)) {
      data["languages"] = [];
      for (let item of this.languages) data["languages"].push(item);
    }
    if (Array.isArray(this.currencies)) {
      data["currencies"] = [];
      for (let item of this.currencies) data["currencies"].push(item);
    }
    if (Array.isArray(this.trustedGroups)) {
      data["trustedGroups"] = [];
      for (let item of this.trustedGroups) data["trustedGroups"].push(item);
    }
    data["seoObjectType"] = this.seoObjectType;
    if (Array.isArray(this.seoInfos)) {
      data["seoInfos"] = [];
      for (let item of this.seoInfos) data["seoInfos"].push(item.toJSON());
    }
    data["objectType"] = this.objectType;
    if (Array.isArray(this.dynamicProperties)) {
      data["dynamicProperties"] = [];
      for (let item of this.dynamicProperties)
        data["dynamicProperties"].push(item.toJSON());
    }
    if (Array.isArray(this.settings)) {
      data["settings"] = [];
      for (let item of this.settings) data["settings"].push(item.toJSON());
    }
    data["typeName"] = this.typeName;
    if (Array.isArray(this.scopes)) {
      data["scopes"] = [];
      for (let item of this.scopes) data["scopes"].push(item);
    }
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IStore {
  name?: string | undefined;
  description?: string | undefined;
  storeState?: StoreState;
  timeZone?: string | undefined;
  country?: string | undefined;
  region?: string | undefined;
  defaultLanguage?: string | undefined;
  defaultCurrency?: string | undefined;
  /** Catalog id used as primary store catalog */
  catalog?: string | undefined;
  creditCardSavePolicy?: boolean;
  /** Store storefront url */
  url?: string | undefined;
  /** Store storefront https url */
  secureUrl?: string | undefined;
  /** Primary store contact email can be used for store event notifications and for feed back */
  email?: string | undefined;
  adminEmail?: string | undefined;
  emailName?: string | undefined;
  adminEmailName?: string | undefined;
  displayOutOfStock?: boolean;
  outerId?: string | undefined;
  /** Primary (default) fulfillment center id */
  mainFulfillmentCenterId?: string | undefined;
  /** Alternate fulfillment centers ids */
  additionalFulfillmentCenterIds?: string[] | undefined;
  /** Primary (default) fulfillment center for order return */
  mainReturnsFulfillmentCenterId?: string | undefined;
  /** Alternate fulfillment centers for order return */
  returnsFulfillmentCenterIds?: string[] | undefined;
  /** All store supported languages */
  languages?: string[] | undefined;
  /** All store supported currencies */
  currencies?: string[] | undefined;
  /** All store trusted groups (group of stores that shared the user logins) */
  trustedGroups?: string[] | undefined;
  seoObjectType?: string | undefined;
  seoInfos?: SeoInfo[] | undefined;
  objectType?: string | undefined;
  dynamicProperties?: DynamicObjectProperty[] | undefined;
  settings?: ObjectSettingEntry[] | undefined;
  typeName?: string | undefined;
  scopes?: string[] | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class StoreSearchResult implements IStoreSearchResult {
  readonly stores?: Store[] | undefined;
  totalCount?: number;
  results?: Store[] | undefined;

  constructor(data?: IStoreSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["stores"])) {
        (<any>this).stores = [] as any;
        for (let item of _data["stores"])
          (<any>this).stores!.push(Store.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(Store.fromJS(item));
      }
    }
  }

  static fromJS(data: any): StoreSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new StoreSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.stores)) {
      data["stores"] = [];
      for (let item of this.stores) data["stores"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IStoreSearchResult {
  stores?: Store[] | undefined;
  totalCount?: number;
  results?: Store[] | undefined;
}

export class SendDynamicNotificationRequest
  implements ISendDynamicNotificationRequest
{
  storeId?: string | undefined;
  type?: string | undefined;
  fields?: { [key: string]: string } | undefined;
  language?: string | undefined;

  constructor(data?: ISendDynamicNotificationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.storeId = _data["storeId"];
      this.type = _data["type"];
      if (_data["fields"]) {
        this.fields = {} as any;
        for (let key in _data["fields"]) {
          if (_data["fields"].hasOwnProperty(key))
            (<any>this.fields)![key] = _data["fields"][key];
        }
      }
      this.language = _data["language"];
    }
  }

  static fromJS(data: any): SendDynamicNotificationRequest {
    data = typeof data === "object" ? data : {};
    let result = new SendDynamicNotificationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["storeId"] = this.storeId;
    data["type"] = this.type;
    if (this.fields) {
      data["fields"] = {};
      for (let key in this.fields) {
        if (this.fields.hasOwnProperty(key))
          (<any>data["fields"])[key] = this.fields[key];
      }
    }
    data["language"] = this.language;
    return data;
  }
}

export interface ISendDynamicNotificationRequest {
  storeId?: string | undefined;
  type?: string | undefined;
  fields?: { [key: string]: string } | undefined;
  language?: string | undefined;
}

/** Represent result for checking of possibility login on behalf request */
export class LoginOnBehalfInfo implements ILoginOnBehalfInfo {
  userName?: string | undefined;
  canLoginOnBehalf?: boolean;

  constructor(data?: ILoginOnBehalfInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userName = _data["userName"];
      this.canLoginOnBehalf = _data["canLoginOnBehalf"];
    }
  }

  static fromJS(data: any): LoginOnBehalfInfo {
    data = typeof data === "object" ? data : {};
    let result = new LoginOnBehalfInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userName"] = this.userName;
    data["canLoginOnBehalf"] = this.canLoginOnBehalf;
    return data;
  }
}

/** Represent result for checking of possibility login on behalf request */
export interface ILoginOnBehalfInfo {
  userName?: string | undefined;
  canLoginOnBehalf?: boolean;
}

export class SubscriptionSearchCriteria implements ISubscriptionSearchCriteria {
  /** Search within specified store */
  storeId?: string | undefined;
  /** Search by subscription number */
  number?: string | undefined;
  /** Search subscription for related order id */
  customerOrderId?: string | undefined;
  /** Search subscription in StartDate and EndDate range inclusive */
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  modifiedSinceDate?: Date | undefined;
  customerId?: string | undefined;
  /** Search with specified statuses */
  statuses?: string[] | undefined;
  /** Search by external subscription system id */
  outerId?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: ISubscriptionSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.storeId = _data["storeId"];
      this.number = _data["number"];
      this.customerOrderId = _data["customerOrderId"];
      this.startDate = _data["startDate"]
        ? new Date(_data["startDate"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? new Date(_data["endDate"].toString())
        : <any>undefined;
      this.modifiedSinceDate = _data["modifiedSinceDate"]
        ? new Date(_data["modifiedSinceDate"].toString())
        : <any>undefined;
      this.customerId = _data["customerId"];
      if (Array.isArray(_data["statuses"])) {
        this.statuses = [] as any;
        for (let item of _data["statuses"]) this.statuses!.push(item);
      }
      this.outerId = _data["outerId"];
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): SubscriptionSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new SubscriptionSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["storeId"] = this.storeId;
    data["number"] = this.number;
    data["customerOrderId"] = this.customerOrderId;
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    data["modifiedSinceDate"] = this.modifiedSinceDate
      ? this.modifiedSinceDate.toISOString()
      : <any>undefined;
    data["customerId"] = this.customerId;
    if (Array.isArray(this.statuses)) {
      data["statuses"] = [];
      for (let item of this.statuses) data["statuses"].push(item);
    }
    data["outerId"] = this.outerId;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface ISubscriptionSearchCriteria {
  /** Search within specified store */
  storeId?: string | undefined;
  /** Search by subscription number */
  number?: string | undefined;
  /** Search subscription for related order id */
  customerOrderId?: string | undefined;
  /** Search subscription in StartDate and EndDate range inclusive */
  startDate?: Date | undefined;
  endDate?: Date | undefined;
  modifiedSinceDate?: Date | undefined;
  customerId?: string | undefined;
  /** Search with specified statuses */
  statuses?: string[] | undefined;
  /** Search by external subscription system id */
  outerId?: string | undefined;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export enum PaymentInterval {
  Days = "Days",
  Weeks = "Weeks",
  Months = "Months",
  Years = "Years",
}

export enum SubscriptionStatus {
  Active = "Active",
  Trialing = "Trialing",
  PastDue = "PastDue",
  Cancelled = "Cancelled",
  Unpaid = "Unpaid",
}

export class Subscription implements ISubscription {
  storeId?: string | undefined;
  customerId?: string | undefined;
  customerName?: string | undefined;
  /** Subscription actual balance */
  balance?: number;
  /** Subscription number */
  number?: string | undefined;
  interval?: PaymentInterval;
  /** - to set more customized intervals (every 5 month) */
  intervalCount?: number;
  /** subscription trial period in days */
  trialPeriodDays?: number;
  subscriptionStatus?: SubscriptionStatus;
  customerOrderPrototypeId?: string | undefined;
  customerOrderPrototype?: CustomerOrder;
  /** List of all orders ids created on the basis of the subscription */
  customerOrdersIds?: string[] | undefined;
  /** List of all orders  created on the basis of the subscription */
  customerOrders?: CustomerOrder[] | undefined;
  /** Date the most recent update to this subscription started. */
  startDate?: Date | undefined;
  /** The date the subscription ended */
  endDate?: Date | undefined;
  trialSart?: Date | undefined;
  trialEnd?: Date | undefined;
  currentPeriodStart?: Date | undefined;
  currentPeriodEnd?: Date | undefined;
  /** External Subscrption entity system Id */
  outerId?: string | undefined;
  /** The subscription comment */
  comment?: string | undefined;
  operationsLog?: OperationLog[] | undefined;
  isCancelled?: boolean;
  cancelledDate?: Date | undefined;
  cancelReason?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: ISubscription) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.storeId = _data["storeId"];
      this.customerId = _data["customerId"];
      this.customerName = _data["customerName"];
      this.balance = _data["balance"];
      this.number = _data["number"];
      this.interval = _data["interval"];
      this.intervalCount = _data["intervalCount"];
      this.trialPeriodDays = _data["trialPeriodDays"];
      this.subscriptionStatus = _data["subscriptionStatus"];
      this.customerOrderPrototypeId = _data["customerOrderPrototypeId"];
      this.customerOrderPrototype = _data["customerOrderPrototype"]
        ? CustomerOrder.fromJS(_data["customerOrderPrototype"])
        : <any>undefined;
      if (Array.isArray(_data["customerOrdersIds"])) {
        this.customerOrdersIds = [] as any;
        for (let item of _data["customerOrdersIds"])
          this.customerOrdersIds!.push(item);
      }
      if (Array.isArray(_data["customerOrders"])) {
        this.customerOrders = [] as any;
        for (let item of _data["customerOrders"])
          this.customerOrders!.push(CustomerOrder.fromJS(item));
      }
      this.startDate = _data["startDate"]
        ? new Date(_data["startDate"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? new Date(_data["endDate"].toString())
        : <any>undefined;
      this.trialSart = _data["trialSart"]
        ? new Date(_data["trialSart"].toString())
        : <any>undefined;
      this.trialEnd = _data["trialEnd"]
        ? new Date(_data["trialEnd"].toString())
        : <any>undefined;
      this.currentPeriodStart = _data["currentPeriodStart"]
        ? new Date(_data["currentPeriodStart"].toString())
        : <any>undefined;
      this.currentPeriodEnd = _data["currentPeriodEnd"]
        ? new Date(_data["currentPeriodEnd"].toString())
        : <any>undefined;
      this.outerId = _data["outerId"];
      this.comment = _data["comment"];
      if (Array.isArray(_data["operationsLog"])) {
        this.operationsLog = [] as any;
        for (let item of _data["operationsLog"])
          this.operationsLog!.push(OperationLog.fromJS(item));
      }
      this.isCancelled = _data["isCancelled"];
      this.cancelledDate = _data["cancelledDate"]
        ? new Date(_data["cancelledDate"].toString())
        : <any>undefined;
      this.cancelReason = _data["cancelReason"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Subscription {
    data = typeof data === "object" ? data : {};
    let result = new Subscription();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["storeId"] = this.storeId;
    data["customerId"] = this.customerId;
    data["customerName"] = this.customerName;
    data["balance"] = this.balance;
    data["number"] = this.number;
    data["interval"] = this.interval;
    data["intervalCount"] = this.intervalCount;
    data["trialPeriodDays"] = this.trialPeriodDays;
    data["subscriptionStatus"] = this.subscriptionStatus;
    data["customerOrderPrototypeId"] = this.customerOrderPrototypeId;
    data["customerOrderPrototype"] = this.customerOrderPrototype
      ? this.customerOrderPrototype.toJSON()
      : <any>undefined;
    if (Array.isArray(this.customerOrdersIds)) {
      data["customerOrdersIds"] = [];
      for (let item of this.customerOrdersIds)
        data["customerOrdersIds"].push(item);
    }
    if (Array.isArray(this.customerOrders)) {
      data["customerOrders"] = [];
      for (let item of this.customerOrders)
        data["customerOrders"].push(item.toJSON());
    }
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    data["trialSart"] = this.trialSart
      ? this.trialSart.toISOString()
      : <any>undefined;
    data["trialEnd"] = this.trialEnd
      ? this.trialEnd.toISOString()
      : <any>undefined;
    data["currentPeriodStart"] = this.currentPeriodStart
      ? this.currentPeriodStart.toISOString()
      : <any>undefined;
    data["currentPeriodEnd"] = this.currentPeriodEnd
      ? this.currentPeriodEnd.toISOString()
      : <any>undefined;
    data["outerId"] = this.outerId;
    data["comment"] = this.comment;
    if (Array.isArray(this.operationsLog)) {
      data["operationsLog"] = [];
      for (let item of this.operationsLog)
        data["operationsLog"].push(item.toJSON());
    }
    data["isCancelled"] = this.isCancelled;
    data["cancelledDate"] = this.cancelledDate
      ? this.cancelledDate.toISOString()
      : <any>undefined;
    data["cancelReason"] = this.cancelReason;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface ISubscription {
  storeId?: string | undefined;
  customerId?: string | undefined;
  customerName?: string | undefined;
  /** Subscription actual balance */
  balance?: number;
  /** Subscription number */
  number?: string | undefined;
  interval?: PaymentInterval;
  /** - to set more customized intervals (every 5 month) */
  intervalCount?: number;
  /** subscription trial period in days */
  trialPeriodDays?: number;
  subscriptionStatus?: SubscriptionStatus;
  customerOrderPrototypeId?: string | undefined;
  customerOrderPrototype?: CustomerOrder;
  /** List of all orders ids created on the basis of the subscription */
  customerOrdersIds?: string[] | undefined;
  /** List of all orders  created on the basis of the subscription */
  customerOrders?: CustomerOrder[] | undefined;
  /** Date the most recent update to this subscription started. */
  startDate?: Date | undefined;
  /** The date the subscription ended */
  endDate?: Date | undefined;
  trialSart?: Date | undefined;
  trialEnd?: Date | undefined;
  currentPeriodStart?: Date | undefined;
  currentPeriodEnd?: Date | undefined;
  /** External Subscrption entity system Id */
  outerId?: string | undefined;
  /** The subscription comment */
  comment?: string | undefined;
  operationsLog?: OperationLog[] | undefined;
  isCancelled?: boolean;
  cancelledDate?: Date | undefined;
  cancelReason?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class SubscriptionSearchResult implements ISubscriptionSearchResult {
  readonly subscriptions?: Subscription[] | undefined;
  totalCount?: number;
  results?: Subscription[] | undefined;

  constructor(data?: ISubscriptionSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["subscriptions"])) {
        (<any>this).subscriptions = [] as any;
        for (let item of _data["subscriptions"])
          (<any>this).subscriptions!.push(Subscription.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(Subscription.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SubscriptionSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new SubscriptionSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.subscriptions)) {
      data["subscriptions"] = [];
      for (let item of this.subscriptions)
        data["subscriptions"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface ISubscriptionSearchResult {
  subscriptions?: Subscription[] | undefined;
  totalCount?: number;
  results?: Subscription[] | undefined;
}

export class SubscriptionCancelRequest implements ISubscriptionCancelRequest {
  subscriptionId?: string | undefined;
  cancelReason?: string | undefined;

  constructor(data?: ISubscriptionCancelRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.subscriptionId = _data["subscriptionId"];
      this.cancelReason = _data["cancelReason"];
    }
  }

  static fromJS(data: any): SubscriptionCancelRequest {
    data = typeof data === "object" ? data : {};
    let result = new SubscriptionCancelRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["subscriptionId"] = this.subscriptionId;
    data["cancelReason"] = this.cancelReason;
    return data;
  }
}

export interface ISubscriptionCancelRequest {
  subscriptionId?: string | undefined;
  cancelReason?: string | undefined;
}

export class PaymentPlan implements IPaymentPlan {
  interval?: PaymentInterval;
  /** - to set more customized intervals (every 5 month) */
  intervalCount?: number;
  /** subscription trial period in days */
  trialPeriodDays?: number;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;

  constructor(data?: IPaymentPlan) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.interval = _data["interval"];
      this.intervalCount = _data["intervalCount"];
      this.trialPeriodDays = _data["trialPeriodDays"];
      this.createdDate = _data["createdDate"]
        ? new Date(_data["createdDate"].toString())
        : <any>undefined;
      this.modifiedDate = _data["modifiedDate"]
        ? new Date(_data["modifiedDate"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.modifiedBy = _data["modifiedBy"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): PaymentPlan {
    data = typeof data === "object" ? data : {};
    let result = new PaymentPlan();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["interval"] = this.interval;
    data["intervalCount"] = this.intervalCount;
    data["trialPeriodDays"] = this.trialPeriodDays;
    data["createdDate"] = this.createdDate
      ? this.createdDate.toISOString()
      : <any>undefined;
    data["modifiedDate"] = this.modifiedDate
      ? this.modifiedDate.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["modifiedBy"] = this.modifiedBy;
    data["id"] = this.id;
    return data;
  }
}

export interface IPaymentPlan {
  interval?: PaymentInterval;
  /** - to set more customized intervals (every 5 month) */
  intervalCount?: number;
  /** subscription trial period in days */
  trialPeriodDays?: number;
  createdDate?: Date;
  modifiedDate?: Date | undefined;
  createdBy?: string | undefined;
  modifiedBy?: string | undefined;
  id?: string | undefined;
}

export class TaxProviderSearchCriteria implements ITaxProviderSearchCriteria {
  storeId?: string | undefined;
  storeIds?: string[] | undefined;
  withoutTransient?: boolean;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  readonly sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;

  constructor(data?: ITaxProviderSearchCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.storeId = _data["storeId"];
      if (Array.isArray(_data["storeIds"])) {
        this.storeIds = [] as any;
        for (let item of _data["storeIds"]) this.storeIds!.push(item);
      }
      this.withoutTransient = _data["withoutTransient"];
      this.responseGroup = _data["responseGroup"];
      this.objectType = _data["objectType"];
      if (Array.isArray(_data["objectTypes"])) {
        this.objectTypes = [] as any;
        for (let item of _data["objectTypes"]) this.objectTypes!.push(item);
      }
      if (Array.isArray(_data["objectIds"])) {
        this.objectIds = [] as any;
        for (let item of _data["objectIds"]) this.objectIds!.push(item);
      }
      this.keyword = _data["keyword"];
      this.searchPhrase = _data["searchPhrase"];
      this.languageCode = _data["languageCode"];
      this.sort = _data["sort"];
      if (Array.isArray(_data["sortInfos"])) {
        (<any>this).sortInfos = [] as any;
        for (let item of _data["sortInfos"])
          (<any>this).sortInfos!.push(SortInfo.fromJS(item));
      }
      this.skip = _data["skip"];
      this.take = _data["take"];
    }
  }

  static fromJS(data: any): TaxProviderSearchCriteria {
    data = typeof data === "object" ? data : {};
    let result = new TaxProviderSearchCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["storeId"] = this.storeId;
    if (Array.isArray(this.storeIds)) {
      data["storeIds"] = [];
      for (let item of this.storeIds) data["storeIds"].push(item);
    }
    data["withoutTransient"] = this.withoutTransient;
    data["responseGroup"] = this.responseGroup;
    data["objectType"] = this.objectType;
    if (Array.isArray(this.objectTypes)) {
      data["objectTypes"] = [];
      for (let item of this.objectTypes) data["objectTypes"].push(item);
    }
    if (Array.isArray(this.objectIds)) {
      data["objectIds"] = [];
      for (let item of this.objectIds) data["objectIds"].push(item);
    }
    data["keyword"] = this.keyword;
    data["searchPhrase"] = this.searchPhrase;
    data["languageCode"] = this.languageCode;
    data["sort"] = this.sort;
    if (Array.isArray(this.sortInfos)) {
      data["sortInfos"] = [];
      for (let item of this.sortInfos) data["sortInfos"].push(item.toJSON());
    }
    data["skip"] = this.skip;
    data["take"] = this.take;
    return data;
  }
}

export interface ITaxProviderSearchCriteria {
  storeId?: string | undefined;
  storeIds?: string[] | undefined;
  withoutTransient?: boolean;
  responseGroup?: string | undefined;
  /** Search object type */
  objectType?: string | undefined;
  objectTypes?: string[] | undefined;
  objectIds?: string[] | undefined;
  /** Search phrase */
  keyword?: string | undefined;
  /** Property is left for backward compatibility */
  searchPhrase?: string | undefined;
  /** Search phrase language */
  languageCode?: string | undefined;
  sort?: string | undefined;
  sortInfos?: SortInfo[] | undefined;
  skip?: number;
  take?: number;
}

export class TaxProvider implements ITaxProvider {
  storeId?: string | undefined;
  code?: string | undefined;
  logoUrl?: string | undefined;
  isActive?: boolean;
  priority?: number;
  readonly typeName?: string | undefined;
  settings?: ObjectSettingEntry[] | undefined;
  id?: string | undefined;

  constructor(data?: ITaxProvider) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.storeId = _data["storeId"];
      this.code = _data["code"];
      this.logoUrl = _data["logoUrl"];
      this.isActive = _data["isActive"];
      this.priority = _data["priority"];
      (<any>this).typeName = _data["typeName"];
      if (Array.isArray(_data["settings"])) {
        this.settings = [] as any;
        for (let item of _data["settings"])
          this.settings!.push(ObjectSettingEntry.fromJS(item));
      }
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): TaxProvider {
    data = typeof data === "object" ? data : {};
    let result = new TaxProvider();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["storeId"] = this.storeId;
    data["code"] = this.code;
    data["logoUrl"] = this.logoUrl;
    data["isActive"] = this.isActive;
    data["priority"] = this.priority;
    data["typeName"] = this.typeName;
    if (Array.isArray(this.settings)) {
      data["settings"] = [];
      for (let item of this.settings) data["settings"].push(item.toJSON());
    }
    data["id"] = this.id;
    return data;
  }
}

export interface ITaxProvider {
  storeId?: string | undefined;
  code?: string | undefined;
  logoUrl?: string | undefined;
  isActive?: boolean;
  priority?: number;
  typeName?: string | undefined;
  settings?: ObjectSettingEntry[] | undefined;
  id?: string | undefined;
}

export class TaxProviderSearchResult implements ITaxProviderSearchResult {
  totalCount?: number;
  results?: TaxProvider[] | undefined;

  constructor(data?: ITaxProviderSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data["totalCount"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(TaxProvider.fromJS(item));
      }
    }
  }

  static fromJS(data: any): TaxProviderSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new TaxProviderSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] = this.totalCount;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results) data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface ITaxProviderSearchResult {
  totalCount?: number;
  results?: TaxProvider[] | undefined;
}

export class TaxStore implements ITaxStore {
  name?: string | undefined;
  outerId?: string | undefined;
  timeZone?: string | undefined;
  country?: string | undefined;
  region?: string | undefined;
  defaultLanguage?: string | undefined;
  defaultCurrency?: string | undefined;
  id?: string | undefined;

  constructor(data?: ITaxStore) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.outerId = _data["outerId"];
      this.timeZone = _data["timeZone"];
      this.country = _data["country"];
      this.region = _data["region"];
      this.defaultLanguage = _data["defaultLanguage"];
      this.defaultCurrency = _data["defaultCurrency"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): TaxStore {
    data = typeof data === "object" ? data : {};
    let result = new TaxStore();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["outerId"] = this.outerId;
    data["timeZone"] = this.timeZone;
    data["country"] = this.country;
    data["region"] = this.region;
    data["defaultLanguage"] = this.defaultLanguage;
    data["defaultCurrency"] = this.defaultCurrency;
    data["id"] = this.id;
    return data;
  }
}

export interface ITaxStore {
  name?: string | undefined;
  outerId?: string | undefined;
  timeZone?: string | undefined;
  country?: string | undefined;
  region?: string | undefined;
  defaultLanguage?: string | undefined;
  defaultCurrency?: string | undefined;
  id?: string | undefined;
}

export class TaxAddress implements ITaxAddress {
  addressType?: AddressType;
  key?: string | undefined;
  name?: string | undefined;
  organization?: string | undefined;
  countryCode?: string | undefined;
  countryName?: string | undefined;
  city?: string | undefined;
  postalCode?: string | undefined;
  zip?: string | undefined;
  line1?: string | undefined;
  line2?: string | undefined;
  regionId?: string | undefined;
  regionName?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  email?: string | undefined;

  constructor(data?: ITaxAddress) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.addressType = _data["addressType"];
      this.key = _data["key"];
      this.name = _data["name"];
      this.organization = _data["organization"];
      this.countryCode = _data["countryCode"];
      this.countryName = _data["countryName"];
      this.city = _data["city"];
      this.postalCode = _data["postalCode"];
      this.zip = _data["zip"];
      this.line1 = _data["line1"];
      this.line2 = _data["line2"];
      this.regionId = _data["regionId"];
      this.regionName = _data["regionName"];
      this.firstName = _data["firstName"];
      this.middleName = _data["middleName"];
      this.lastName = _data["lastName"];
      this.phone = _data["phone"];
      this.email = _data["email"];
    }
  }

  static fromJS(data: any): TaxAddress {
    data = typeof data === "object" ? data : {};
    let result = new TaxAddress();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["addressType"] = this.addressType;
    data["key"] = this.key;
    data["name"] = this.name;
    data["organization"] = this.organization;
    data["countryCode"] = this.countryCode;
    data["countryName"] = this.countryName;
    data["city"] = this.city;
    data["postalCode"] = this.postalCode;
    data["zip"] = this.zip;
    data["line1"] = this.line1;
    data["line2"] = this.line2;
    data["regionId"] = this.regionId;
    data["regionName"] = this.regionName;
    data["firstName"] = this.firstName;
    data["middleName"] = this.middleName;
    data["lastName"] = this.lastName;
    data["phone"] = this.phone;
    data["email"] = this.email;
    return data;
  }
}

export interface ITaxAddress {
  addressType?: AddressType;
  key?: string | undefined;
  name?: string | undefined;
  organization?: string | undefined;
  countryCode?: string | undefined;
  countryName?: string | undefined;
  city?: string | undefined;
  postalCode?: string | undefined;
  zip?: string | undefined;
  line1?: string | undefined;
  line2?: string | undefined;
  regionId?: string | undefined;
  regionName?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  email?: string | undefined;
}

export class TaxCustomer implements ITaxCustomer {
  name?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  outerId?: string | undefined;
  addresses?: TaxAddress[] | undefined;
  phones?: string[] | undefined;
  emails?: string[] | undefined;
  groups?: string[] | undefined;
  birthDate?: Date | undefined;
  defaultLanguage?: string | undefined;
  timeZone?: string | undefined;
  organizations?: string[] | undefined;
  taxPayerId?: string | undefined;
  id?: string | undefined;

  constructor(data?: ITaxCustomer) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.firstName = _data["firstName"];
      this.middleName = _data["middleName"];
      this.lastName = _data["lastName"];
      this.outerId = _data["outerId"];
      if (Array.isArray(_data["addresses"])) {
        this.addresses = [] as any;
        for (let item of _data["addresses"])
          this.addresses!.push(TaxAddress.fromJS(item));
      }
      if (Array.isArray(_data["phones"])) {
        this.phones = [] as any;
        for (let item of _data["phones"]) this.phones!.push(item);
      }
      if (Array.isArray(_data["emails"])) {
        this.emails = [] as any;
        for (let item of _data["emails"]) this.emails!.push(item);
      }
      if (Array.isArray(_data["groups"])) {
        this.groups = [] as any;
        for (let item of _data["groups"]) this.groups!.push(item);
      }
      this.birthDate = _data["birthDate"]
        ? new Date(_data["birthDate"].toString())
        : <any>undefined;
      this.defaultLanguage = _data["defaultLanguage"];
      this.timeZone = _data["timeZone"];
      if (Array.isArray(_data["organizations"])) {
        this.organizations = [] as any;
        for (let item of _data["organizations"]) this.organizations!.push(item);
      }
      this.taxPayerId = _data["taxPayerId"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): TaxCustomer {
    data = typeof data === "object" ? data : {};
    let result = new TaxCustomer();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["firstName"] = this.firstName;
    data["middleName"] = this.middleName;
    data["lastName"] = this.lastName;
    data["outerId"] = this.outerId;
    if (Array.isArray(this.addresses)) {
      data["addresses"] = [];
      for (let item of this.addresses) data["addresses"].push(item.toJSON());
    }
    if (Array.isArray(this.phones)) {
      data["phones"] = [];
      for (let item of this.phones) data["phones"].push(item);
    }
    if (Array.isArray(this.emails)) {
      data["emails"] = [];
      for (let item of this.emails) data["emails"].push(item);
    }
    if (Array.isArray(this.groups)) {
      data["groups"] = [];
      for (let item of this.groups) data["groups"].push(item);
    }
    data["birthDate"] = this.birthDate
      ? this.birthDate.toISOString()
      : <any>undefined;
    data["defaultLanguage"] = this.defaultLanguage;
    data["timeZone"] = this.timeZone;
    if (Array.isArray(this.organizations)) {
      data["organizations"] = [];
      for (let item of this.organizations) data["organizations"].push(item);
    }
    data["taxPayerId"] = this.taxPayerId;
    data["id"] = this.id;
    return data;
  }
}

export interface ITaxCustomer {
  name?: string | undefined;
  firstName?: string | undefined;
  middleName?: string | undefined;
  lastName?: string | undefined;
  outerId?: string | undefined;
  addresses?: TaxAddress[] | undefined;
  phones?: string[] | undefined;
  emails?: string[] | undefined;
  groups?: string[] | undefined;
  birthDate?: Date | undefined;
  defaultLanguage?: string | undefined;
  timeZone?: string | undefined;
  organizations?: string[] | undefined;
  taxPayerId?: string | undefined;
  id?: string | undefined;
}

export class TaxLine implements ITaxLine {
  code?: string | undefined;
  name?: string | undefined;
  typeName?: string | undefined;
  amount?: number;
  quantity?: number;
  price?: number;
  taxType?: string | undefined;
  id?: string | undefined;

  constructor(data?: ITaxLine) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.code = _data["code"];
      this.name = _data["name"];
      this.typeName = _data["typeName"];
      this.amount = _data["amount"];
      this.quantity = _data["quantity"];
      this.price = _data["price"];
      this.taxType = _data["taxType"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): TaxLine {
    data = typeof data === "object" ? data : {};
    let result = new TaxLine();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["code"] = this.code;
    data["name"] = this.name;
    data["typeName"] = this.typeName;
    data["amount"] = this.amount;
    data["quantity"] = this.quantity;
    data["price"] = this.price;
    data["taxType"] = this.taxType;
    data["id"] = this.id;
    return data;
  }
}

export interface ITaxLine {
  code?: string | undefined;
  name?: string | undefined;
  typeName?: string | undefined;
  amount?: number;
  quantity?: number;
  price?: number;
  taxType?: string | undefined;
  id?: string | undefined;
}

export class TaxEvaluationContext implements ITaxEvaluationContext {
  storeId?: string | undefined;
  store?: TaxStore;
  code?: string | undefined;
  type?: string | undefined;
  customerId?: string | undefined;
  customer?: TaxCustomer;
  organizationId?: string | undefined;
  address?: TaxAddress;
  currency?: string | undefined;
  lines?: TaxLine[] | undefined;
  id?: string | undefined;

  constructor(data?: ITaxEvaluationContext) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.storeId = _data["storeId"];
      this.store = _data["store"]
        ? TaxStore.fromJS(_data["store"])
        : <any>undefined;
      this.code = _data["code"];
      this.type = _data["type"];
      this.customerId = _data["customerId"];
      this.customer = _data["customer"]
        ? TaxCustomer.fromJS(_data["customer"])
        : <any>undefined;
      this.organizationId = _data["organizationId"];
      this.address = _data["address"]
        ? TaxAddress.fromJS(_data["address"])
        : <any>undefined;
      this.currency = _data["currency"];
      if (Array.isArray(_data["lines"])) {
        this.lines = [] as any;
        for (let item of _data["lines"]) this.lines!.push(TaxLine.fromJS(item));
      }
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): TaxEvaluationContext {
    data = typeof data === "object" ? data : {};
    let result = new TaxEvaluationContext();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["storeId"] = this.storeId;
    data["store"] = this.store ? this.store.toJSON() : <any>undefined;
    data["code"] = this.code;
    data["type"] = this.type;
    data["customerId"] = this.customerId;
    data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
    data["organizationId"] = this.organizationId;
    data["address"] = this.address ? this.address.toJSON() : <any>undefined;
    data["currency"] = this.currency;
    if (Array.isArray(this.lines)) {
      data["lines"] = [];
      for (let item of this.lines) data["lines"].push(item.toJSON());
    }
    data["id"] = this.id;
    return data;
  }
}

export interface ITaxEvaluationContext {
  storeId?: string | undefined;
  store?: TaxStore;
  code?: string | undefined;
  type?: string | undefined;
  customerId?: string | undefined;
  customer?: TaxCustomer;
  organizationId?: string | undefined;
  address?: TaxAddress;
  currency?: string | undefined;
  lines?: TaxLine[] | undefined;
  id?: string | undefined;
}

export class TaxRate implements ITaxRate {
  rate?: number;
  percentRate?: number;
  currency?: string | undefined;
  line?: TaxLine;
  taxProviderCode?: string | undefined;
  taxDetails?: TaxDetail[] | undefined;

  constructor(data?: ITaxRate) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.rate = _data["rate"];
      this.percentRate = _data["percentRate"];
      this.currency = _data["currency"];
      this.line = _data["line"]
        ? TaxLine.fromJS(_data["line"])
        : <any>undefined;
      this.taxProviderCode = _data["taxProviderCode"];
      if (Array.isArray(_data["taxDetails"])) {
        this.taxDetails = [] as any;
        for (let item of _data["taxDetails"])
          this.taxDetails!.push(TaxDetail.fromJS(item));
      }
    }
  }

  static fromJS(data: any): TaxRate {
    data = typeof data === "object" ? data : {};
    let result = new TaxRate();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["rate"] = this.rate;
    data["percentRate"] = this.percentRate;
    data["currency"] = this.currency;
    data["line"] = this.line ? this.line.toJSON() : <any>undefined;
    data["taxProviderCode"] = this.taxProviderCode;
    if (Array.isArray(this.taxDetails)) {
      data["taxDetails"] = [];
      for (let item of this.taxDetails) data["taxDetails"].push(item.toJSON());
    }
    return data;
  }
}

export interface ITaxRate {
  rate?: number;
  percentRate?: number;
  currency?: string | undefined;
  line?: TaxLine;
  taxProviderCode?: string | undefined;
  taxDetails?: TaxDetail[] | undefined;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}
