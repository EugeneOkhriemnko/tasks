//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AuthApiBase {
  authToken = "";
  protected constructor() {}

  setAuthToken(token: string) {
    this.authToken = token;
  }

  protected transformOptions(options: any): Promise<any> {
    options.headers['authorization'] =  `Bearer ${this.authToken}`;
    return Promise.resolve(options);
  }
}

export class AuthorizationClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    exchange(body: Body): Promise<OpenIddictResponse> {
        let url_ = this.baseUrl + "/connect/token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = Object.keys(body as any).map((key) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent((body as any)[key]);
        }).join('&')

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processExchange(_response);
        });
    }

    protected processExchange(response: Response): Promise<OpenIddictResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OpenIddictResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = OpenIddictResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OpenIddictResponse>(null as any);
    }
}

export class ExternalSignInClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param authenticationType (optional) 
     * @return Success
     */
    signIn(authenticationType: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/externalsignin?";
        if (authenticationType !== undefined && authenticationType !== null)
            url_ += "authenticationType=" + encodeURIComponent("" + authenticationType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSignIn(_response);
        });
    }

    protected processSignIn(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param returnUrl (optional) 
     * @return Success
     */
    signInCallback(returnUrl: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/externalsignin/callback?";
        if (returnUrl !== undefined && returnUrl !== null)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSignInCallback(_response);
        });
    }

    protected processSignInCallback(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getExternalLoginProviders(): Promise<void> {
        let url_ = this.baseUrl + "/externalsignin/providers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetExternalLoginProviders(_response);
        });
    }

    protected processGetExternalLoginProviders(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ChangeLogClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param scope (optional) 
     * @return Success
     */
    forceChanges(scope: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/changes/force?";
        if (scope !== undefined && scope !== null)
            url_ += "Scope=" + encodeURIComponent("" + scope) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processForceChanges(_response);
        });
    }

    protected processForceChanges(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    resetPlatformCache(): Promise<void> {
        let url_ = this.baseUrl + "/api/platform-cache/reset";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processResetPlatformCache(_response);
        });
    }

    protected processResetPlatformCache(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param scope (optional) 
     * @return Success
     */
    getLastModifiedDate(scope: string | null | undefined): Promise<LastModifiedResponse> {
        let url_ = this.baseUrl + "/api/changes/lastmodifieddate?";
        if (scope !== undefined && scope !== null)
            url_ += "scope=" + encodeURIComponent("" + scope) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetLastModifiedDate(_response);
        });
    }

    protected processGetLastModifiedDate(response: Response): Promise<LastModifiedResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LastModifiedResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LastModifiedResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getChangedEntities(body: ChangedEntitiesRequest | undefined): Promise<ChangedEntitiesResponse> {
        let url_ = this.baseUrl + "/api/changes/changed-entities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetChangedEntities(_response);
        });
    }

    protected processGetChangedEntities(response: Response): Promise<ChangedEntitiesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChangedEntitiesResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChangedEntitiesResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetChangedEntities(body: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/changes/changed-entities/reset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processResetChangedEntities(_response);
        });
    }

    protected processResetChangedEntities(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchChanges(body: ChangeLogSearchCriteria | undefined): Promise<ChangeLogSearchResult> {
        let url_ = this.baseUrl + "/api/platform/changelog/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchChanges(_response);
        });
    }

    protected processSearchChanges(response: Response): Promise<ChangeLogSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChangeLogSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChangeLogSearchResult>(null as any);
    }

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    searchTypeChangeHistory(type: string | null, start: Date | null | undefined, end: Date | null | undefined): Promise<OperationLog[]> {
        let url_ = this.baseUrl + "/api/platform/changelog/{type}/changes?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent(start ? "" + start.toISOString() : "") + "&";
        if (end !== undefined && end !== null)
            url_ += "end=" + encodeURIComponent(end ? "" + end.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchTypeChangeHistory(_response);
        });
    }

    protected processSearchTypeChangeHistory(response: Response): Promise<OperationLog[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OperationLog.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OperationLog[]>(null as any);
    }
}

export class DiagnosticsClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getSystemInfo(): Promise<SystemInfo> {
        let url_ = this.baseUrl + "/api/platform/diagnostics/systeminfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSystemInfo(_response);
        });
    }

    protected processGetSystemInfo(response: Response): Promise<SystemInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SystemInfo>(null as any);
    }

    /**
     * @return Success
     */
    getModulesErrors(): Promise<ModuleDescriptor[]> {
        let url_ = this.baseUrl + "/api/platform/diagnostics/errors";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetModulesErrors(_response);
        });
    }

    protected processGetModulesErrors(response: Response): Promise<ModuleDescriptor[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ModuleDescriptor.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleDescriptor[]>(null as any);
    }
}

export class DynamicPropertiesClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getObjectTypes(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/platform/dynamic/types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetObjectTypes(_response);
        });
    }

    protected processGetObjectTypes(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchDynamicProperties(body: DynamicPropertySearchCriteria | undefined): Promise<DynamicPropertySearchResult> {
        let url_ = this.baseUrl + "/api/platform/dynamic/properties/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchDynamicProperties(_response);
        });
    }

    protected processSearchDynamicProperties(response: Response): Promise<DynamicPropertySearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPropertySearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicPropertySearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProperty(body: DynamicProperty | undefined): Promise<DynamicProperty> {
        let url_ = this.baseUrl + "/api/platform/dynamic/properties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateProperty(_response);
        });
    }

    protected processCreateProperty(response: Response): Promise<DynamicProperty> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicProperty.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicProperty>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProperty(body: DynamicProperty | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/dynamic/properties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateProperty(_response);
        });
    }

    protected processUpdateProperty(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param propertyIds (optional) 
     * @return Success
     */
    deleteProperty(propertyIds: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/dynamic/properties?";
        if (propertyIds !== undefined && propertyIds !== null)
            propertyIds && propertyIds.forEach(item => { url_ += "propertyIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteProperty(_response);
        });
    }

    protected processDeleteProperty(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    exposeDynamicObjectProperty(): Promise<DynamicObjectProperty> {
        let url_ = this.baseUrl + "/api/platform/dynamic";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processExposeDynamicObjectProperty(_response);
        });
    }

    protected processExposeDynamicObjectProperty(response: Response): Promise<DynamicObjectProperty> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicObjectProperty.fromJS(resultData200);
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("Success", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicObjectProperty>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchDictionaryItems(body: DynamicPropertyDictionaryItemSearchCriteria | undefined): Promise<DynamicPropertyDictionaryItemSearchResult> {
        let url_ = this.baseUrl + "/api/platform/dynamic/dictionaryitems/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchDictionaryItems(_response);
        });
    }

    protected processSearchDictionaryItems(response: Response): Promise<DynamicPropertyDictionaryItemSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPropertyDictionaryItemSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicPropertyDictionaryItemSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveDictionaryItems(body: DynamicPropertyDictionaryItem[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/dynamic/dictionaryitems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSaveDictionaryItems(_response);
        });
    }

    protected processSaveDictionaryItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteDictionaryItem(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/dynamic/dictionaryitems?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteDictionaryItem(_response);
        });
    }

    protected processDeleteDictionaryItem(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class JobsClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getStatus(id: string | null): Promise<Job> {
        let url_ = this.baseUrl + "/api/platform/jobs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetStatus(_response);
        });
    }

    protected processGetStatus(response: Response): Promise<Job> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Job.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Job>(null as any);
    }
}

export class ModulesClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    reloadModules(): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/modules/reload";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processReloadModules(_response);
        });
    }

    protected processReloadModules(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getModules(): Promise<ModuleDescriptor[]> {
        let url_ = this.baseUrl + "/api/platform/modules";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetModules(_response);
        });
    }

    protected processGetModules(response: Response): Promise<ModuleDescriptor[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ModuleDescriptor.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleDescriptor[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getDependingModules(body: ModuleDescriptor[] | null | undefined): Promise<ModuleDescriptor[]> {
        let url_ = this.baseUrl + "/api/platform/modules/getdependents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDependingModules(_response);
        });
    }

    protected processGetDependingModules(response: Response): Promise<ModuleDescriptor[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ModuleDescriptor.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleDescriptor[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getMissingDependencies(body: ModuleDescriptor[] | null | undefined): Promise<ModuleDescriptor[]> {
        let url_ = this.baseUrl + "/api/platform/modules/getmissingdependencies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMissingDependencies(_response);
        });
    }

    protected processGetMissingDependencies(response: Response): Promise<ModuleDescriptor[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ModuleDescriptor.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleDescriptor[]>(null as any);
    }

    /**
     * @return Success
     */
    uploadModuleArchive(): Promise<ModuleDescriptor> {
        let url_ = this.baseUrl + "/api/platform/modules/localstorage";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUploadModuleArchive(_response);
        });
    }

    protected processUploadModuleArchive(response: Response): Promise<ModuleDescriptor> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleDescriptor.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleDescriptor>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    installModules(body: ModuleDescriptor[] | null | undefined): Promise<ModulePushNotification> {
        let url_ = this.baseUrl + "/api/platform/modules/install";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processInstallModules(_response);
        });
    }

    protected processInstallModules(response: Response): Promise<ModulePushNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModulePushNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModulePushNotification>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uninstallModule(body: ModuleDescriptor[] | null | undefined): Promise<ModulePushNotification> {
        let url_ = this.baseUrl + "/api/platform/modules/uninstall";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUninstallModule(_response);
        });
    }

    protected processUninstallModule(response: Response): Promise<ModulePushNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModulePushNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModulePushNotification>(null as any);
    }

    /**
     * @return Success
     */
    restart(): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/modules/restart";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRestart(_response);
        });
    }

    protected processRestart(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    tryToAutoInstallModules(): Promise<ModuleAutoInstallPushNotification> {
        let url_ = this.baseUrl + "/api/platform/modules/autoinstall";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTryToAutoInstallModules(_response);
        });
    }

    protected processTryToAutoInstallModules(response: Response): Promise<ModuleAutoInstallPushNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleAutoInstallPushNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleAutoInstallPushNotification>(null as any);
    }
}

export class OAuthAppsClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    new(): Promise<OpenIddictApplicationDescriptor> {
        let url_ = this.baseUrl + "/api/platform/oauthapps/new";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processNew(_response);
        });
    }

    protected processNew(response: Response): Promise<OpenIddictApplicationDescriptor> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OpenIddictApplicationDescriptor.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OpenIddictApplicationDescriptor>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: OpenIddictApplicationDescriptor | undefined): Promise<OpenIddictApplicationDescriptor> {
        let url_ = this.baseUrl + "/api/platform/oauthapps";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: Response): Promise<OpenIddictApplicationDescriptor> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OpenIddictApplicationDescriptor.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OpenIddictApplicationDescriptor>(null as any);
    }

    /**
     * @param clientIds (optional) 
     * @return Success
     */
    delete(clientIds: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/oauthapps?";
        if (clientIds !== undefined && clientIds !== null)
            clientIds && clientIds.forEach(item => { url_ += "clientIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    search(body: OAuthAppSearchCriteria | undefined): Promise<OAuthAppSearchResult> {
        let url_ = this.baseUrl + "/api/platform/oauthapps/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<OAuthAppSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OAuthAppSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OAuthAppSearchResult>(null as any);
    }
}

export class PushNotificationClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchPushNotification(body: PushNotificationSearchCriteria | undefined): Promise<PushNotificationSearchResult> {
        let url_ = this.baseUrl + "/api/platform/pushnotifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchPushNotification(_response);
        });
    }

    protected processSearchPushNotification(response: Response): Promise<PushNotificationSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PushNotificationSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PushNotificationSearchResult>(null as any);
    }

    /**
     * @return Success
     */
    markAllAsRead(): Promise<PushNotificationSearchResult> {
        let url_ = this.baseUrl + "/api/platform/pushnotifications/markAllAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMarkAllAsRead(_response);
        });
    }

    protected processMarkAllAsRead(response: Response): Promise<PushNotificationSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PushNotificationSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PushNotificationSearchResult>(null as any);
    }
}

export class SecurityClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginRequest | undefined): Promise<SignInResult> {
        let url_ = this.baseUrl + "/api/platform/security/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<SignInResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SignInResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SignInResult>(null as any);
    }

    /**
     * @return Success
     */
    logout(): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/security/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getCurrentUser(): Promise<UserDetail> {
        let url_ = this.baseUrl + "/api/platform/security/currentuser";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCurrentUser(_response);
        });
    }

    protected processGetCurrentUser(response: Response): Promise<UserDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetail.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetail>(null as any);
    }

    /**
     * @return Success
     */
    userinfo(): Promise<Claim[]> {
        let url_ = this.baseUrl + "/api/platform/security/userinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUserinfo(_response);
        });
    }

    protected processUserinfo(response: Response): Promise<Claim[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Claim.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Claim[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllRegisteredPermissions(): Promise<Permission[]> {
        let url_ = this.baseUrl + "/api/platform/security/permissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAllRegisteredPermissions(_response);
        });
    }

    protected processGetAllRegisteredPermissions(response: Response): Promise<Permission[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Permission.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Permission[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchRoles(body: RoleSearchCriteria | undefined): Promise<RoleSearchResult> {
        let url_ = this.baseUrl + "/api/platform/security/roles/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchRoles(_response);
        });
    }

    protected processSearchRoles(response: Response): Promise<RoleSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleSearchResult>(null as any);
    }

    /**
     * @return Success
     */
    getRole(roleName: string | null): Promise<Role> {
        let url_ = this.baseUrl + "/api/platform/security/roles/{roleName}";
        if (roleName === undefined || roleName === null)
            throw new Error("The parameter 'roleName' must be defined.");
        url_ = url_.replace("{roleName}", encodeURIComponent("" + roleName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRole(_response);
        });
    }

    protected processGetRole(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteRoles(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/security/roles?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteRoles(_response);
        });
    }

    protected processDeleteRoles(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateRole(body: Role | undefined): Promise<SecurityResult> {
        let url_ = this.baseUrl + "/api/platform/security/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateRole(_response);
        });
    }

    protected processUpdateRole(response: Response): Promise<SecurityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchUsers(body: UserSearchCriteria | undefined): Promise<UserSearchResult> {
        let url_ = this.baseUrl + "/api/platform/security/users/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchUsers(_response);
        });
    }

    protected processSearchUsers(response: Response): Promise<UserSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSearchResult>(null as any);
    }

    /**
     * @return Success
     */
    getUserByName(userName: string | null): Promise<ApplicationUser> {
        let url_ = this.baseUrl + "/api/platform/security/users/{userName}";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserByName(_response);
        });
    }

    protected processGetUserByName(response: Response): Promise<ApplicationUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationUser>(null as any);
    }

    /**
     * @return Success
     */
    getUserById(id: string | null): Promise<ApplicationUser> {
        let url_ = this.baseUrl + "/api/platform/security/users/id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserById(_response);
        });
    }

    protected processGetUserById(response: Response): Promise<ApplicationUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationUser>(null as any);
    }

    /**
     * @return Success
     */
    getUserByEmail(email: string | null): Promise<ApplicationUser> {
        let url_ = this.baseUrl + "/api/platform/security/users/email/{email}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserByEmail(_response);
        });
    }

    protected processGetUserByEmail(response: Response): Promise<ApplicationUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationUser>(null as any);
    }

    /**
     * @return Success
     */
    getUserByLogin(loginProvider: string | null, providerKey: string | null): Promise<ApplicationUser> {
        let url_ = this.baseUrl + "/api/platform/security/users/login/external/{loginProvider}/{providerKey}";
        if (loginProvider === undefined || loginProvider === null)
            throw new Error("The parameter 'loginProvider' must be defined.");
        url_ = url_.replace("{loginProvider}", encodeURIComponent("" + loginProvider));
        if (providerKey === undefined || providerKey === null)
            throw new Error("The parameter 'providerKey' must be defined.");
        url_ = url_.replace("{providerKey}", encodeURIComponent("" + providerKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserByLogin(_response);
        });
    }

    protected processGetUserByLogin(response: Response): Promise<ApplicationUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationUser>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: ApplicationUser | undefined): Promise<SecurityResult> {
        let url_ = this.baseUrl + "/api/platform/security/users/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<SecurityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeCurrentUserPassword(body: ChangePasswordRequest | undefined): Promise<SecurityResult> {
        let url_ = this.baseUrl + "/api/platform/security/currentuser/changepassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processChangeCurrentUserPassword(_response);
        });
    }

    protected processChangeCurrentUserPassword(response: Response): Promise<SecurityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(userName: string | null, body: ChangePasswordRequest | undefined): Promise<SecurityResult> {
        let url_ = this.baseUrl + "/api/platform/security/users/{userName}/changepassword";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: Response): Promise<SecurityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(userName: string | null, body: ResetPasswordConfirmRequest | undefined): Promise<SecurityResult> {
        let url_ = this.baseUrl + "/api/platform/security/users/{userName}/resetpassword";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<SecurityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPasswordByToken(userId: string | null, body: ResetPasswordConfirmRequest | undefined): Promise<SecurityResult> {
        let url_ = this.baseUrl + "/api/platform/security/users/{userId}/resetpasswordconfirm";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processResetPasswordByToken(_response);
        });
    }

    protected processResetPasswordByToken(response: Response): Promise<SecurityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validatePasswordResetToken(userId: string | null, body: ValidatePasswordResetTokenRequest | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/platform/security/users/{userId}/validatepasswordresettoken";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processValidatePasswordResetToken(_response);
        });
    }

    protected processValidatePasswordResetToken(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    requestPasswordReset(loginOrEmail: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/security/users/{loginOrEmail}/requestpasswordreset";
        if (loginOrEmail === undefined || loginOrEmail === null)
            throw new Error("The parameter 'loginOrEmail' must be defined.");
        url_ = url_.replace("{loginOrEmail}", encodeURIComponent("" + loginOrEmail));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRequestPasswordReset(_response);
        });
    }

    protected processRequestPasswordReset(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validatePassword(body: string | null | undefined): Promise<IdentityResult> {
        let url_ = this.baseUrl + "/api/platform/security/validatepassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processValidatePassword(_response);
        });
    }

    protected processValidatePassword(response: Response): Promise<IdentityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateUserPassword(body: ChangePasswordRequest | undefined): Promise<IdentityResult> {
        let url_ = this.baseUrl + "/api/platform/security/validateuserpassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processValidateUserPassword(_response);
        });
    }

    protected processValidateUserPassword(response: Response): Promise<IdentityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ApplicationUser | undefined): Promise<SecurityResult> {
        let url_ = this.baseUrl + "/api/platform/security/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<SecurityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityResult>(null as any);
    }

    /**
     * @param names (optional) 
     * @return Success
     */
    delete(names: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/security/users?";
        if (names !== undefined && names !== null)
            names && names.forEach(item => { url_ += "names=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    isUserLocked(id: string | null): Promise<UserLockedResult> {
        let url_ = this.baseUrl + "/api/platform/security/users/{id}/locked";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processIsUserLocked(_response);
        });
    }

    protected processIsUserLocked(response: Response): Promise<UserLockedResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserLockedResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserLockedResult>(null as any);
    }

    /**
     * @return Success
     */
    lockUser(id: string | null): Promise<SecurityResult> {
        let url_ = this.baseUrl + "/api/platform/security/users/{id}/lock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLockUser(_response);
        });
    }

    protected processLockUser(response: Response): Promise<SecurityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityResult>(null as any);
    }

    /**
     * @return Success
     */
    unlockUser(id: string | null): Promise<SecurityResult> {
        let url_ = this.baseUrl + "/api/platform/security/users/{id}/unlock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUnlockUser(_response);
        });
    }

    protected processUnlockUser(response: Response): Promise<SecurityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityResult>(null as any);
    }

    /**
     * @return Success
     */
    getUserApiKeys(id: string | null): Promise<UserApiKey[]> {
        let url_ = this.baseUrl + "/api/platform/security/users/{id}/apikeys";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserApiKeys(_response);
        });
    }

    protected processGetUserApiKeys(response: Response): Promise<UserApiKey[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserApiKey.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserApiKey[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserApiKey(body: UserApiKey | undefined): Promise<UserApiKey[]> {
        let url_ = this.baseUrl + "/api/platform/security/users/apikeys";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSaveUserApiKey(_response);
        });
    }

    protected processSaveUserApiKey(response: Response): Promise<UserApiKey[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserApiKey.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserApiKey[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserApiKey(body: UserApiKey | undefined): Promise<UserApiKey[]> {
        let url_ = this.baseUrl + "/api/platform/security/users/apikeys";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateUserApiKey(_response);
        });
    }

    protected processUpdateUserApiKey(response: Response): Promise<UserApiKey[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserApiKey.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserApiKey[]>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteUserApiKeys(ids: string[] | null | undefined): Promise<UserApiKey[]> {
        let url_ = this.baseUrl + "/api/platform/security/users/apikeys?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteUserApiKeys(_response);
        });
    }

    protected processDeleteUserApiKeys(response: Response): Promise<UserApiKey[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserApiKey.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserApiKey[]>(null as any);
    }

    /**
     * @return Success
     */
    getLoginTypes(): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/security/logintypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetLoginTypes(_response);
        });
    }

    protected processGetLoginTypes(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    sendVerificationEmail(userId: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/security/users/{userId}/sendVerificationEmail";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendVerificationEmail(_response);
        });
    }

    protected processSendVerificationEmail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class SettingClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllGlobalSettings(): Promise<ObjectSettingEntry> {
        let url_ = this.baseUrl + "/api/platform/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAllGlobalSettings(_response);
        });
    }

    protected processGetAllGlobalSettings(response: Response): Promise<ObjectSettingEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectSettingEntry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectSettingEntry>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ObjectSettingEntry[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getGlobalModuleSettings(id: string | null): Promise<ObjectSettingEntry[]> {
        let url_ = this.baseUrl + "/api/platform/settings/modules/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGlobalModuleSettings(_response);
        });
    }

    protected processGetGlobalModuleSettings(response: Response): Promise<ObjectSettingEntry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ObjectSettingEntry.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectSettingEntry[]>(null as any);
    }

    /**
     * @return Success
     */
    getGlobalSetting(name: string | null): Promise<ObjectSettingEntry> {
        let url_ = this.baseUrl + "/api/platform/settings/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGlobalSetting(_response);
        });
    }

    protected processGetGlobalSetting(response: Response): Promise<ObjectSettingEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectSettingEntry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectSettingEntry>(null as any);
    }

    /**
     * @return Success
     */
    getUICustomizationSetting(): Promise<ObjectSettingEntry> {
        let url_ = this.baseUrl + "/api/platform/settings/ui/customization";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUICustomizationSetting(_response);
        });
    }

    protected processGetUICustomizationSetting(response: Response): Promise<ObjectSettingEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectSettingEntry.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectSettingEntry>(null as any);
    }
}

export class AssetEntryClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    search(body: AssetEntrySearchCriteria | undefined): Promise<AssetEntrySearchResult> {
        let url_ = this.baseUrl + "/api/assetentries/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<AssetEntrySearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetEntrySearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssetEntrySearchResult>(null as any);
    }

    /**
     * @param idQuery (optional) 
     * @return Success
     */
    get(idQuery: string | null | undefined, idPath: string): Promise<AssetEntry> {
        let url_ = this.baseUrl + "/api/assetentries/{id}?";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        if (idQuery !== undefined && idQuery !== null)
            url_ += "id=" + encodeURIComponent("" + idQuery) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<AssetEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetEntry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssetEntry>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: AssetEntry | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/assetentries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    delete(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/assetentries?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AssetsClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    uploadAssetToLocalFileSystem(): Promise<BlobInfo[]> {
        let url_ = this.baseUrl + "/api/assets/localstorage";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUploadAssetToLocalFileSystem(_response);
        });
    }

    protected processUploadAssetToLocalFileSystem(response: Response): Promise<BlobInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BlobInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BlobInfo[]>(null as any);
    }

    /**
     * @param folderUrl (optional) 
     * @param url (optional) 
     * @param name (optional) 
     * @param uploadedFile (optional) Upload File
     * @return Success
     */
    uploadAsset(folderUrl: string | null | undefined, url: string | null | undefined, name: string | null | undefined, uploadedFile: string | undefined): Promise<BlobInfo[]> {
        let url_ = this.baseUrl + "/api/assets?";
        if (folderUrl !== undefined && folderUrl !== null)
            url_ += "folderUrl=" + encodeURIComponent("" + folderUrl) + "&";
        if (url !== undefined && url !== null)
            url_ += "url=" + encodeURIComponent("" + url) + "&";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (uploadedFile === null)
            throw new Error("The parameter 'uploadedFile' cannot be null.");
        else if (uploadedFile !== undefined)
            url_ += "uploadedFile=" + encodeURIComponent("" + uploadedFile) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUploadAsset(_response);
        });
    }

    protected processUploadAsset(response: Response): Promise<BlobInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BlobInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BlobInfo[]>(null as any);
    }

    /**
     * @param urls (optional) 
     * @return Success
     */
    deleteBlobs(urls: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/assets?";
        if (urls !== undefined && urls !== null)
            urls && urls.forEach(item => { url_ += "urls=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteBlobs(_response);
        });
    }

    protected processDeleteBlobs(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param folderUrl (optional) 
     * @param keyword (optional) 
     * @return Success
     */
    searchAssetItems(folderUrl: string | null | undefined, keyword: string | null | undefined): Promise<BlobEntrySearchResult> {
        let url_ = this.baseUrl + "/api/assets?";
        if (folderUrl !== undefined && folderUrl !== null)
            url_ += "folderUrl=" + encodeURIComponent("" + folderUrl) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchAssetItems(_response);
        });
    }

    protected processSearchAssetItems(response: Response): Promise<BlobEntrySearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BlobEntrySearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BlobEntrySearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createBlobFolder(body: BlobFolder | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/assets/folder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateBlobFolder(_response);
        });
    }

    protected processCreateBlobFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class BulkActionsClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param jobId (optional) 
     * @return Success
     */
    cancel(jobId: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/bulk/actions?";
        if (jobId !== undefined && jobId !== null)
            url_ += "jobId=" + encodeURIComponent("" + jobId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCancel(_response);
        });
    }

    protected processCancel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getRegisteredActions(): Promise<IBulkActionProvider[]> {
        let url_ = this.baseUrl + "/api/bulk/actions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRegisteredActions(_response);
        });
    }

    protected processGetRegisteredActions(response: Response): Promise<IBulkActionProvider[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IBulkActionProvider.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IBulkActionProvider[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    run(body: BulkActionContext | undefined): Promise<BulkActionPushNotification> {
        let url_ = this.baseUrl + "/api/bulk/actions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRun(_response);
        });
    }

    protected processRun(response: Response): Promise<BulkActionPushNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkActionPushNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BulkActionPushNotification>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getActionData(body: BulkActionContext | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/bulk/actions/data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetActionData(_response);
        });
    }

    protected processGetActionData(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CartModuleClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCart(storeId: string | null, customerId: string | null, cartName: string | null, currency: string | null, cultureName: string | null): Promise<ShoppingCart> {
        let url_ = this.baseUrl + "/api/carts/{storeId}/{customerId}/{cartName}/{currency}/{cultureName}/current";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        if (cartName === undefined || cartName === null)
            throw new Error("The parameter 'cartName' must be defined.");
        url_ = url_.replace("{cartName}", encodeURIComponent("" + cartName));
        if (currency === undefined || currency === null)
            throw new Error("The parameter 'currency' must be defined.");
        url_ = url_.replace("{currency}", encodeURIComponent("" + currency));
        if (cultureName === undefined || cultureName === null)
            throw new Error("The parameter 'cultureName' must be defined.");
        url_ = url_.replace("{cultureName}", encodeURIComponent("" + cultureName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCart(_response);
        });
    }

    protected processGetCart(response: Response): Promise<ShoppingCart> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShoppingCart.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShoppingCart>(null as any);
    }

    /**
     * @return Success
     */
    getCartItemsCount(cartId: string | null): Promise<number> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/itemscount";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCartItemsCount(_response);
        });
    }

    protected processGetCartItemsCount(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addItemToCart(cartId: string | null, body: CartLineItem | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/items";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddItemToCart(_response);
        });
    }

    protected processAddItemToCart(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param lineItemId (optional) 
     * @param quantity (optional) 
     * @return Success
     */
    changeCartItem(cartId: string | null, lineItemId: string | null | undefined, quantity: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/items?";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        if (lineItemId !== undefined && lineItemId !== null)
            url_ += "lineItemId=" + encodeURIComponent("" + lineItemId) + "&";
        if (quantity === null)
            throw new Error("The parameter 'quantity' cannot be null.");
        else if (quantity !== undefined)
            url_ += "quantity=" + encodeURIComponent("" + quantity) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processChangeCartItem(_response);
        });
    }

    protected processChangeCartItem(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    clearCart(cartId: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/items";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processClearCart(_response);
        });
    }

    protected processClearCart(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    removeCartItem(cartId: string | null, lineItemId: string | null): Promise<number> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/items/{lineItemId}";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        if (lineItemId === undefined || lineItemId === null)
            throw new Error("The parameter 'lineItemId' must be defined.");
        url_ = url_.replace("{lineItemId}", encodeURIComponent("" + lineItemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRemoveCartItem(_response);
        });
    }

    protected processRemoveCartItem(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mergeWithCart(cartId: string | null, body: ShoppingCart | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/carts/{cartId}";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMergeWithCart(_response);
        });
    }

    protected processMergeWithCart(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getCartById(cartId: string | null): Promise<ShoppingCart> {
        let url_ = this.baseUrl + "/api/carts/{cartId}";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCartById(_response);
        });
    }

    protected processGetCartById(response: Response): Promise<ShoppingCart> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShoppingCart.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShoppingCart>(null as any);
    }

    /**
     * @return Success
     */
    getAvailableShippingRates(cartId: string | null): Promise<ShippingRate[]> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/availshippingrates";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAvailableShippingRates(_response);
        });
    }

    protected processGetAvailableShippingRates(response: Response): Promise<ShippingRate[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ShippingRate.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShippingRate[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAvailableShippingRatesByContext(body: ShippingEvaluationContext | undefined): Promise<ShippingRate[]> {
        let url_ = this.baseUrl + "/api/carts/availshippingrates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAvailableShippingRatesByContext(_response);
        });
    }

    protected processGetAvailableShippingRatesByContext(response: Response): Promise<ShippingRate[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ShippingRate.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShippingRate[]>(null as any);
    }

    /**
     * @return Success
     */
    getAvailablePaymentMethods(cartId: string | null): Promise<PaymentMethod[]> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/availpaymentmethods";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAvailablePaymentMethods(_response);
        });
    }

    protected processGetAvailablePaymentMethods(response: Response): Promise<PaymentMethod[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentMethod.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentMethod[]>(null as any);
    }

    /**
     * @return Success
     */
    addCartCoupon(cartId: string | null, couponCode: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/coupons/{couponCode}";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        if (couponCode === undefined || couponCode === null)
            throw new Error("The parameter 'couponCode' must be defined.");
        url_ = url_.replace("{couponCode}", encodeURIComponent("" + couponCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddCartCoupon(_response);
        });
    }

    protected processAddCartCoupon(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    removeCartCoupon(cartId: string | null, couponCode: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/coupons/{couponCode}";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        if (couponCode === undefined || couponCode === null)
            throw new Error("The parameter 'couponCode' must be defined.");
        url_ = url_.replace("{couponCode}", encodeURIComponent("" + couponCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRemoveCartCoupon(_response);
        });
    }

    protected processRemoveCartCoupon(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateCartShipment(cartId: string | null, body: CartShipment | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/shipments";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateCartShipment(_response);
        });
    }

    protected processAddOrUpdateCartShipment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateCartPayment(cartId: string | null, body: Payment | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/payments";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddOrUpdateCartPayment(_response);
        });
    }

    protected processAddOrUpdateCartPayment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchShoppingCart(body: ShoppingCartSearchCriteria | undefined): Promise<ShoppingCartSearchResult> {
        let url_ = this.baseUrl + "/api/carts/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchShoppingCart(_response);
        });
    }

    protected processSearchShoppingCart(response: Response): Promise<ShoppingCartSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShoppingCartSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShoppingCartSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: ShoppingCart | undefined): Promise<ShoppingCart> {
        let url_ = this.baseUrl + "/api/carts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ShoppingCart> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShoppingCart.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShoppingCart>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateShoppingCart(body: ShoppingCart | undefined): Promise<ShoppingCart> {
        let url_ = this.baseUrl + "/api/carts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateShoppingCart(_response);
        });
    }

    protected processUpdateShoppingCart(response: Response): Promise<ShoppingCart> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShoppingCart.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShoppingCart>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteCarts(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/carts?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteCarts(_response);
        });
    }

    protected processDeleteCarts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    recalculateTotals(body: ShoppingCart | undefined): Promise<ShoppingCart> {
        let url_ = this.baseUrl + "/api/carts/recalculate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRecalculateTotals(_response);
        });
    }

    protected processRecalculateTotals(response: Response): Promise<ShoppingCart> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShoppingCart.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShoppingCart>(null as any);
    }
}

export class CatalogModuleAssociationsClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllAssociations(productId: string | null): Promise<ProductAssociation[]> {
        let url_ = this.baseUrl + "/api/catalog/products/associations/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAllAssociations(_response);
        });
    }

    protected processGetAllAssociations(response: Response): Promise<ProductAssociation[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductAssociation.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductAssociation[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAssociations(body: ProductAssociation[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/products/associations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateAssociations(_response);
        });
    }

    protected processUpdateAssociations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    delete(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/products/associations?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    search(body: ProductAssociationSearchCriteria | undefined): Promise<ProductAssociationSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/products/associations/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<ProductAssociationSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductAssociationSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductAssociationSearchResult>(null as any);
    }
}

export class CatalogModuleCatalogsClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchCatalogs(body: CatalogSearchCriteria | undefined): Promise<CatalogSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/catalogs/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchCatalogs(_response);
        });
    }

    protected processSearchCatalogs(response: Response): Promise<CatalogSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogSearchResult>(null as any);
    }

    /**
     * @return Success
     */
    getCatalog(id: string | null): Promise<Catalog> {
        let url_ = this.baseUrl + "/api/catalog/catalogs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCatalog(_response);
        });
    }

    protected processGetCatalog(response: Response): Promise<Catalog> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Catalog.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Catalog>(null as any);
    }

    /**
     * @return Success
     */
    deleteCatalog(id: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/catalogs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteCatalog(_response);
        });
    }

    protected processDeleteCatalog(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getNewCatalog(): Promise<Catalog> {
        let url_ = this.baseUrl + "/api/catalog/catalogs/getnew";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewCatalog(_response);
        });
    }

    protected processGetNewCatalog(response: Response): Promise<Catalog> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Catalog.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Catalog>(null as any);
    }

    /**
     * @return Success
     */
    getNewVirtualCatalog(): Promise<Catalog> {
        let url_ = this.baseUrl + "/api/catalog/catalogs/getnewvirtual";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewVirtualCatalog(_response);
        });
    }

    protected processGetNewVirtualCatalog(response: Response): Promise<Catalog> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Catalog.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Catalog>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCatalog(body: Catalog | undefined): Promise<Catalog> {
        let url_ = this.baseUrl + "/api/catalog/catalogs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateCatalog(_response);
        });
    }

    protected processCreateCatalog(response: Response): Promise<Catalog> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Catalog.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Catalog>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCatalog(body: Catalog | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/catalogs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateCatalog(_response);
        });
    }

    protected processUpdateCatalog(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CatalogModuleCategoriesClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCategory(id: string | null): Promise<Category> {
        let url_ = this.baseUrl + "/api/catalog/categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCategory(_response);
        });
    }

    protected processGetCategory(response: Response): Promise<Category> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category>(null as any);
    }

    /**
     * @param ids (optional) 
     * @param respGroup (optional) 
     * @return Success
     */
    getCategoriesByIds(ids: string[] | null | undefined, respGroup: string | null | undefined): Promise<Category[]> {
        let url_ = this.baseUrl + "/api/catalog/categories?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (respGroup !== undefined && respGroup !== null)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCategoriesByIds(_response);
        });
    }

    protected processGetCategoriesByIds(response: Response): Promise<Category[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Category.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateCategory(body: Category | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateOrUpdateCategory(_response);
        });
    }

    protected processCreateOrUpdateCategory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteCategory(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/categories?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteCategory(_response);
        });
    }

    protected processDeleteCategory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param respGroup (optional) 
     * @param body (optional) 
     * @return Success
     */
    getCategoriesByPlentyIds(respGroup: string | null | undefined, body: string[] | null | undefined): Promise<Category[]> {
        let url_ = this.baseUrl + "/api/catalog/categories/plenty?";
        if (respGroup !== undefined && respGroup !== null)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCategoriesByPlentyIds(_response);
        });
    }

    protected processGetCategoriesByPlentyIds(response: Response): Promise<Category[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Category.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category[]>(null as any);
    }

    /**
     * @param parentCategoryId (optional) 
     * @return Success
     */
    getNewCategory(catalogId: string | null, parentCategoryId: string | null | undefined): Promise<Category> {
        let url_ = this.baseUrl + "/api/catalog/{catalogId}/categories/newcategory?";
        if (catalogId === undefined || catalogId === null)
            throw new Error("The parameter 'catalogId' must be defined.");
        url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
        if (parentCategoryId !== undefined && parentCategoryId !== null)
            url_ += "parentCategoryId=" + encodeURIComponent("" + parentCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewCategory(_response);
        });
    }

    protected processGetNewCategory(response: Response): Promise<Category> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category>(null as any);
    }
}

export class CatalogModuleIndexedSearchClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchProducts(body: ProductIndexedSearchCriteria | undefined): Promise<ProductIndexedSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/search/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchProducts(_response);
        });
    }

    protected processSearchProducts(response: Response): Promise<ProductIndexedSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductIndexedSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductIndexedSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchCategories(body: CategoryIndexedSearchCriteria | undefined): Promise<CategoryIndexedSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/search/categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchCategories(_response);
        });
    }

    protected processSearchCategories(response: Response): Promise<CategoryIndexedSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryIndexedSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategoryIndexedSearchResult>(null as any);
    }
}

export class CatalogModuleListEntryClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listItemsSearch(body: CatalogListEntrySearchCriteria | undefined): Promise<ListEntrySearchResult> {
        let url_ = this.baseUrl + "/api/catalog/listentries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processListItemsSearch(_response);
        });
    }

    protected processListItemsSearch(response: Response): Promise<ListEntrySearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListEntrySearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListEntrySearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createLinks(body: CategoryLink[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/listentrylinks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateLinks(_response);
        });
    }

    protected processCreateLinks(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulkCreateLinks(body: BulkLinkCreationRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/listentrylinks/bulkcreate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBulkCreateLinks(_response);
        });
    }

    protected processBulkCreateLinks(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchLinks(body: LinkSearchCriteria | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/listentrylinks/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchLinks(_response);
        });
    }

    protected processSearchLinks(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteLinks(body: CategoryLink[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/listentrylinks/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteLinks(_response);
        });
    }

    protected processDeleteLinks(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    move(body: ListEntriesMoveRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/listentries/move";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMove(_response);
        });
    }

    protected processMove(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: CatalogListEntrySearchCriteria | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/listentries/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CatalogModuleProductsClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param respGroup (optional) 
     * @return Success
     */
    getProductById(id: string | null, respGroup: string | null | undefined): Promise<CatalogProduct> {
        let url_ = this.baseUrl + "/api/catalog/products/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (respGroup !== undefined && respGroup !== null)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProductById(_response);
        });
    }

    protected processGetProductById(response: Response): Promise<CatalogProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct>(null as any);
    }

    /**
     * @param ids (optional) 
     * @param respGroup (optional) 
     * @return Success
     */
    getProductByIds(ids: string[] | null | undefined, respGroup: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/products?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (respGroup !== undefined && respGroup !== null)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProductByIds(_response);
        });
    }

    protected processGetProductByIds(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveProduct(body: CatalogProduct | undefined): Promise<CatalogProduct> {
        let url_ = this.baseUrl + "/api/catalog/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSaveProduct(_response);
        });
    }

    protected processSaveProduct(response: Response): Promise<CatalogProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("Success", status, _responseText, _headers);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteProduct(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/products?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteProduct(_response);
        });
    }

    protected processDeleteProduct(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param respGroup (optional) 
     * @param body (optional) 
     * @return Success
     */
    getProductByPlentyIds(respGroup: string | null | undefined, body: string[] | null | undefined): Promise<CatalogProduct[]> {
        let url_ = this.baseUrl + "/api/catalog/products/plenty?";
        if (respGroup !== undefined && respGroup !== null)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProductByPlentyIds(_response);
        });
    }

    protected processGetProductByPlentyIds(response: Response): Promise<CatalogProduct[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CatalogProduct.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct[]>(null as any);
    }

    /**
     * @return Success
     */
    getNewProductByCatalog(catalogId: string | null): Promise<CatalogProduct> {
        let url_ = this.baseUrl + "/api/catalog/{catalogId}/products/getnew";
        if (catalogId === undefined || catalogId === null)
            throw new Error("The parameter 'catalogId' must be defined.");
        url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewProductByCatalog(_response);
        });
    }

    protected processGetNewProductByCatalog(response: Response): Promise<CatalogProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct>(null as any);
    }

    /**
     * @return Success
     */
    getNewProductByCatalogAndCategory(catalogId: string | null, categoryId: string | null): Promise<CatalogProduct> {
        let url_ = this.baseUrl + "/api/catalog/{catalogId}/categories/{categoryId}/products/getnew";
        if (catalogId === undefined || catalogId === null)
            throw new Error("The parameter 'catalogId' must be defined.");
        url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewProductByCatalogAndCategory(_response);
        });
    }

    protected processGetNewProductByCatalogAndCategory(response: Response): Promise<CatalogProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct>(null as any);
    }

    /**
     * @return Success
     */
    getNewVariation(productId: string | null): Promise<CatalogProduct> {
        let url_ = this.baseUrl + "/api/catalog/products/{productId}/getnewvariation";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewVariation(_response);
        });
    }

    protected processGetNewVariation(response: Response): Promise<CatalogProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct>(null as any);
    }

    /**
     * @return Success
     */
    cloneProduct(productId: string | null): Promise<CatalogProduct> {
        let url_ = this.baseUrl + "/api/catalog/products/{productId}/clone";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCloneProduct(_response);
        });
    }

    protected processCloneProduct(response: Response): Promise<CatalogProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveProducts(body: CatalogProduct[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/products/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSaveProducts(_response);
        });
    }

    protected processSaveProducts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CatalogModulePropertiesClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getProperty(propertyId: string | null): Promise<Property> {
        let url_ = this.baseUrl + "/api/catalog/properties/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProperty(_response);
        });
    }

    protected processGetProperty(response: Response): Promise<Property> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Property.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Property>(null as any);
    }

    /**
     * @return Success
     */
    getNewCatalogProperty(catalogId: string | null): Promise<Property> {
        let url_ = this.baseUrl + "/api/catalog/{catalogId}/properties/getnew";
        if (catalogId === undefined || catalogId === null)
            throw new Error("The parameter 'catalogId' must be defined.");
        url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewCatalogProperty(_response);
        });
    }

    protected processGetNewCatalogProperty(response: Response): Promise<Property> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Property.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Property>(null as any);
    }

    /**
     * @return Success
     */
    getNewCategoryProperty(categoryId: string | null): Promise<Property> {
        let url_ = this.baseUrl + "/api/catalog/categories/{categoryId}/properties/getnew";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewCategoryProperty(_response);
        });
    }

    protected processGetNewCategoryProperty(response: Response): Promise<Property> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Property.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Property>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveProperty(body: Property | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/properties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSaveProperty(_response);
        });
    }

    protected processSaveProperty(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param doDeleteValues (optional) 
     * @return Success
     */
    deleteProperty(id: string | null | undefined, doDeleteValues: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/properties?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (doDeleteValues === null)
            throw new Error("The parameter 'doDeleteValues' cannot be null.");
        else if (doDeleteValues !== undefined)
            url_ += "doDeleteValues=" + encodeURIComponent("" + doDeleteValues) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteProperty(_response);
        });
    }

    protected processDeleteProperty(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateName(body: PropertyValidationRequest | undefined): Promise<ValidationResult> {
        let url_ = this.baseUrl + "/api/catalog/properties/validate-name";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processValidateName(_response);
        });
    }

    protected processValidateName(response: Response): Promise<ValidationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValidationResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validatePropertyName(body: CategoryPropertyValidationRequest | undefined): Promise<ValidationResult> {
        let url_ = this.baseUrl + "/api/catalog/properties/validate-property-name";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processValidatePropertyName(_response);
        });
    }

    protected processValidatePropertyName(response: Response): Promise<ValidationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValidationResult>(null as any);
    }
}

export class CatalogModulePropertyDictionaryItemsClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchPropertyDictionaryItems(body: PropertyDictionaryItemSearchCriteria | undefined): Promise<PropertyDictionaryItemSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/dictionaryitems/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchPropertyDictionaryItems(_response);
        });
    }

    protected processSearchPropertyDictionaryItems(response: Response): Promise<PropertyDictionaryItemSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyDictionaryItemSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PropertyDictionaryItemSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveChanges(body: PropertyDictionaryItem[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/dictionaryitems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSaveChanges(_response);
        });
    }

    protected processSaveChanges(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deletePropertyDictionaryItems(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/dictionaryitems?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeletePropertyDictionaryItems(_response);
        });
    }

    protected processDeletePropertyDictionaryItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CatalogModuleVideosClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOptions(): Promise<VideoOptions> {
        let url_ = this.baseUrl + "/api/catalog/videos/options";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetOptions(_response);
        });
    }

    protected processGetOptions(response: Response): Promise<VideoOptions> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VideoOptions.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VideoOptions>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createVideo(body: VideoCreateRequest | undefined): Promise<Video> {
        let url_ = this.baseUrl + "/api/catalog/videos/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateVideo(_response);
        });
    }

    protected processCreateVideo(response: Response): Promise<Video> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Video.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Video>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchVideos(body: VideoSearchCriteria | undefined): Promise<VideoSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/videos/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchVideos(_response);
        });
    }

    protected processSearchVideos(response: Response): Promise<VideoSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VideoSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VideoSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: Video[] | null | undefined): Promise<Video[]> {
        let url_ = this.baseUrl + "/api/catalog/videos";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Video[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Video.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Video[]>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    delete(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/videos?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ExportImportClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    doExport(body: CsvExportInfo | undefined): Promise<ExportNotification> {
        let url_ = this.baseUrl + "/api/catalogcsvimport/export";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDoExport(_response);
        });
    }

    protected processDoExport(response: Response): Promise<ExportNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExportNotification>(null as any);
    }

    /**
     * @param fileUrl (optional) 
     * @param delimiter (optional) 
     * @return Success
     */
    getMappingConfiguration(fileUrl: string | null | undefined, delimiter: string | null | undefined): Promise<CsvProductMappingConfiguration> {
        let url_ = this.baseUrl + "/api/catalogcsvimport/import/mappingconfiguration?";
        if (fileUrl !== undefined && fileUrl !== null)
            url_ += "fileUrl=" + encodeURIComponent("" + fileUrl) + "&";
        if (delimiter !== undefined && delimiter !== null)
            url_ += "delimiter=" + encodeURIComponent("" + delimiter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMappingConfiguration(_response);
        });
    }

    protected processGetMappingConfiguration(response: Response): Promise<CsvProductMappingConfiguration> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CsvProductMappingConfiguration.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CsvProductMappingConfiguration>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    doImport(body: CsvImportInfo | undefined): Promise<CatalogCsvImportNotification> {
        let url_ = this.baseUrl + "/api/catalogcsvimport/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDoImport(_response);
        });
    }

    protected processDoImport(response: Response): Promise<CatalogCsvImportNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogCsvImportNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogCsvImportNotification>(null as any);
    }
}

export class ContentClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getStoreContentStats(storeId: string | null): Promise<ContentStatistic> {
        let url_ = this.baseUrl + "/api/content/{storeId}/stats";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetStoreContentStats(_response);
        });
    }

    protected processGetStoreContentStats(response: Response): Promise<ContentStatistic> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentStatistic.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentStatistic>(null as any);
    }

    /**
     * @param urls (optional) 
     * @return Success
     */
    deleteContent(contentType: string | null, storeId: string | null, urls: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}?";
        if (contentType === undefined || contentType === null)
            throw new Error("The parameter 'contentType' must be defined.");
        url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (urls !== undefined && urls !== null)
            urls && urls.forEach(item => { url_ += "urls=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteContent(_response);
        });
    }

    protected processDeleteContent(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param relativeUrl (optional) 
     * @return Success
     */
    getContentItemDataStream(contentType: string | null, storeId: string | null, relativeUrl: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}?";
        if (contentType === undefined || contentType === null)
            throw new Error("The parameter 'contentType' must be defined.");
        url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (relativeUrl !== undefined && relativeUrl !== null)
            url_ += "relativeUrl=" + encodeURIComponent("" + relativeUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetContentItemDataStream(_response);
        });
    }

    protected processGetContentItemDataStream(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    uploadContent(contentType: string | null, storeId: string | null, folderUrl: string | null | undefined, url: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}?";
        if (contentType === undefined || contentType === null)
            throw new Error("The parameter 'contentType' must be defined.");
        url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (folderUrl !== undefined && folderUrl !== null)
            url_ += "folderUrl=" + encodeURIComponent("" + folderUrl) + "&";
        if (url !== undefined && url !== null)
            url_ += "url=" + encodeURIComponent("" + url) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUploadContent(_response);
        });
    }

    protected processUploadContent(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method Not Allowed", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param folderUrl (optional) 
     * @param keyword (optional) 
     * @return Success
     */
    searchContent(contentType: string | null, storeId: string | null, folderUrl: string | null | undefined, keyword: string | null | undefined): Promise<ContentItem[]> {
        let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}/search?";
        if (contentType === undefined || contentType === null)
            throw new Error("The parameter 'contentType' must be defined.");
        url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (folderUrl !== undefined && folderUrl !== null)
            url_ += "folderUrl=" + encodeURIComponent("" + folderUrl) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchContent(_response);
        });
    }

    protected processSearchContent(response: Response): Promise<ContentItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContentItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentItem[]>(null as any);
    }

    /**
     * @param oldUrl (optional) 
     * @param newUrl (optional) 
     * @return Success
     */
    moveContent(contentType: string | null, storeId: string | null, oldUrl: string | null | undefined, newUrl: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}/move?";
        if (contentType === undefined || contentType === null)
            throw new Error("The parameter 'contentType' must be defined.");
        url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (oldUrl !== undefined && oldUrl !== null)
            url_ += "oldUrl=" + encodeURIComponent("" + oldUrl) + "&";
        if (newUrl !== undefined && newUrl !== null)
            url_ += "newUrl=" + encodeURIComponent("" + newUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMoveContent(_response);
        });
    }

    protected processMoveContent(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param srcPath (optional) 
     * @param destPath (optional) 
     * @return Success
     */
    copyContent(srcPath: string | null | undefined, destPath: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/content/copy?";
        if (srcPath !== undefined && srcPath !== null)
            url_ += "srcPath=" + encodeURIComponent("" + srcPath) + "&";
        if (destPath !== undefined && destPath !== null)
            url_ += "destPath=" + encodeURIComponent("" + destPath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCopyContent(_response);
        });
    }

    protected processCopyContent(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param archivePath (optional) 
     * @param destPath (optional) 
     * @return Success
     */
    unpack(contentType: string | null, storeId: string | null, archivePath: string | null | undefined, destPath: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}/unpack?";
        if (contentType === undefined || contentType === null)
            throw new Error("The parameter 'contentType' must be defined.");
        url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (archivePath !== undefined && archivePath !== null)
            url_ += "archivePath=" + encodeURIComponent("" + archivePath) + "&";
        if (destPath !== undefined && destPath !== null)
            url_ += "destPath=" + encodeURIComponent("" + destPath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUnpack(_response);
        });
    }

    protected processUnpack(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createContentFolder(contentType: string | null, storeId: string | null, body: ContentFolder | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}/folder";
        if (contentType === undefined || contentType === null)
            throw new Error("The parameter 'contentType' must be defined.");
        url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateContentFolder(_response);
        });
    }

    protected processCreateContentFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class MenuClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLists(storeId: string | null): Promise<MenuLinkList[]> {
        let url_ = this.baseUrl + "/api/cms/{storeId}/menu";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetLists(_response);
        });
    }

    protected processGetLists(response: Response): Promise<MenuLinkList[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuLinkList.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MenuLinkList[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMenuLinkList(storeId: string, body: MenuLinkList | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms/{storeId}/menu";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMenuLinkList(_response);
        });
    }

    protected processUpdateMenuLinkList(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param listIds (optional) 
     * @return Success
     */
    deleteMenuLinkLists(listIds: string[] | null | undefined, storeId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/cms/{storeId}/menu?";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (listIds !== undefined && listIds !== null)
            listIds && listIds.forEach(item => { url_ += "listIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteMenuLinkLists(_response);
        });
    }

    protected processDeleteMenuLinkLists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getList(storeId: string | null, listId: string | null): Promise<MenuLinkList> {
        let url_ = this.baseUrl + "/api/cms/{storeId}/menu/{listId}";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (listId === undefined || listId === null)
            throw new Error("The parameter 'listId' must be defined.");
        url_ = url_.replace("{listId}", encodeURIComponent("" + listId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: Response): Promise<MenuLinkList> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MenuLinkList.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MenuLinkList>(null as any);
    }

    /**
     * @param name (optional) 
     * @param language (optional) 
     * @param id (optional) 
     * @return Success
     */
    checkName(storeId: string | null, name: string | null | undefined, language: string | null | undefined, id: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/cms/{storeId}/menu/checkname?";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (language !== undefined && language !== null)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCheckName(_response);
        });
    }

    protected processCheckName(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class CommerceClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    batchUpdateSeoInfos(body: SeoInfo[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/seoinfos/batchupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBatchUpdateSeoInfos(_response);
        });
    }

    protected processBatchUpdateSeoInfos(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param objectId (optional) 
     * @param objectType (optional) 
     * @return Success
     */
    getSeoDuplicates(objectId: string | null | undefined, objectType: string | null | undefined): Promise<SeoInfo[]> {
        let url_ = this.baseUrl + "/api/seoinfos/duplicates?";
        if (objectId !== undefined && objectId !== null)
            url_ += "objectId=" + encodeURIComponent("" + objectId) + "&";
        if (objectType !== undefined && objectType !== null)
            url_ += "objectType=" + encodeURIComponent("" + objectType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSeoDuplicates(_response);
        });
    }

    protected processGetSeoDuplicates(response: Response): Promise<SeoInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SeoInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SeoInfo[]>(null as any);
    }

    /**
     * @return Success
     */
    getSeoInfoBySlug(slug: string | null): Promise<SeoInfo[]> {
        let url_ = this.baseUrl + "/api/seoinfos/{slug}";
        if (slug === undefined || slug === null)
            throw new Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSeoInfoBySlug(_response);
        });
    }

    protected processGetSeoInfoBySlug(response: Response): Promise<SeoInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SeoInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SeoInfo[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllCurrencies(): Promise<Currency[]> {
        let url_ = this.baseUrl + "/api/currencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAllCurrencies(_response);
        });
    }

    protected processGetAllCurrencies(response: Response): Promise<Currency[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Currency.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Currency[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCurrency(body: Currency | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/currencies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateCurrency(_response);
        });
    }

    protected processCreateCurrency(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCurrency(body: Currency | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/currencies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateCurrency(_response);
        });
    }

    protected processUpdateCurrency(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param codes (optional) 
     * @return Success
     */
    deleteCurrencies(codes: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/currencies?";
        if (codes !== undefined && codes !== null)
            codes && codes.forEach(item => { url_ += "codes=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteCurrencies(_response);
        });
    }

    protected processDeleteCurrencies(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getAllPackageTypes(): Promise<PackageType[]> {
        let url_ = this.baseUrl + "/api/packageTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAllPackageTypes(_response);
        });
    }

    protected processGetAllPackageTypes(response: Response): Promise<PackageType[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PackageType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PackageType[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePackageType(body: PackageType | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/packageTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdatePackageType(_response);
        });
    }

    protected processUpdatePackageType(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPackageType(body: PackageType | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/packageTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreatePackageType(_response);
        });
    }

    protected processCreatePackageType(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deletePackageTypes(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/packageTypes?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeletePackageTypes(_response);
        });
    }

    protected processDeletePackageTypes(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateAddress(body: Address | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processValidateAddress(_response);
        });
    }

    protected processValidateAddress(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class CustomerModuleClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    listOrganizations(): Promise<Organization[]> {
        let url_ = this.baseUrl + "/api/members/organizations";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processListOrganizations(_response);
        });
    }

    protected processListOrganizations(response: Response): Promise<Organization[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Organization.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchMember(body: MembersSearchCriteria | undefined): Promise<MemberSearchResult> {
        let url_ = this.baseUrl + "/api/members/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchMember(_response);
        });
    }

    protected processSearchMember(response: Response): Promise<MemberSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MemberSearchResult>(null as any);
    }

    /**
     * @param responseGroup (optional) 
     * @param memberType (optional) 
     * @return Success
     */
    getMemberById(id: string | null, responseGroup: string | null | undefined, memberType: string | null | undefined): Promise<Member> {
        let url_ = this.baseUrl + "/api/members/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (responseGroup !== undefined && responseGroup !== null)
            url_ += "responseGroup=" + encodeURIComponent("" + responseGroup) + "&";
        if (memberType !== undefined && memberType !== null)
            url_ += "memberType=" + encodeURIComponent("" + memberType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMemberById(_response);
        });
    }

    protected processGetMemberById(response: Response): Promise<Member> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Member.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Member>(null as any);
    }

    /**
     * @param ids (optional) 
     * @param responseGroup (optional) 
     * @param memberTypes (optional) 
     * @return Success
     */
    getMembersByIds(ids: string[] | null | undefined, responseGroup: string | null | undefined, memberTypes: string[] | null | undefined): Promise<Member[]> {
        let url_ = this.baseUrl + "/api/members?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (responseGroup !== undefined && responseGroup !== null)
            url_ += "responseGroup=" + encodeURIComponent("" + responseGroup) + "&";
        if (memberTypes !== undefined && memberTypes !== null)
            memberTypes && memberTypes.forEach(item => { url_ += "memberTypes=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMembersByIds(_response);
        });
    }

    protected processGetMembersByIds(response: Response): Promise<Member[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Member.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Member[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMember(body: Member | undefined): Promise<Member> {
        let url_ = this.baseUrl + "/api/members";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateMember(_response);
        });
    }

    protected processCreateMember(response: Response): Promise<Member> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Member.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Member>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMember(body: Member | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/members";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMember(_response);
        });
    }

    protected processUpdateMember(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteMembers(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/members?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteMembers(_response);
        });
    }

    protected processDeleteMembers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulkCreateMembers(body: Member[] | null | undefined): Promise<Member[]> {
        let url_ = this.baseUrl + "/api/members/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBulkCreateMembers(_response);
        });
    }

    protected processBulkCreateMembers(response: Response): Promise<Member[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Member.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Member[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulkUpdateMembers(body: Member[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/members/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBulkUpdateMembers(_response);
        });
    }

    protected processBulkUpdateMembers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulkDeleteMembersBySearchCriteria(body: MembersSearchCriteria | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/members/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBulkDeleteMembersBySearchCriteria(_response);
        });
    }

    protected processBulkDeleteMembersBySearchCriteria(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createContact(body: Contact | undefined): Promise<Contact> {
        let url_ = this.baseUrl + "/api/contacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateContact(_response);
        });
    }

    protected processCreateContact(response: Response): Promise<Contact> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contact.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateContact(body: Contact | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/contacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateContact(_response);
        });
    }

    protected processUpdateContact(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteContacts(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/contacts?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteContacts(_response);
        });
    }

    protected processDeleteContacts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    getContactsByIds(ids: string[] | null | undefined): Promise<Contact[]> {
        let url_ = this.baseUrl + "/api/contacts?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetContactsByIds(_response);
        });
    }

    protected processGetContactsByIds(response: Response): Promise<Contact[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Contact.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulkCreateContacts(body: Contact[] | null | undefined): Promise<Contact[]> {
        let url_ = this.baseUrl + "/api/contacts/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBulkCreateContacts(_response);
        });
    }

    protected processBulkCreateContacts(response: Response): Promise<Contact[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Contact.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulkUpdateContacts(body: Contact[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/contacts/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBulkUpdateContacts(_response);
        });
    }

    protected processBulkUpdateContacts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrganization(body: Organization | undefined): Promise<Organization> {
        let url_ = this.baseUrl + "/api/organizations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateOrganization(_response);
        });
    }

    protected processCreateOrganization(response: Response): Promise<Organization> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Organization.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrganization(body: Organization | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/organizations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateOrganization(_response);
        });
    }

    protected processUpdateOrganization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteOrganizations(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/organizations?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteOrganizations(_response);
        });
    }

    protected processDeleteOrganizations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    getOrganizationsByIds(ids: string[] | null | undefined): Promise<Organization[]> {
        let url_ = this.baseUrl + "/api/organizations?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetOrganizationsByIds(_response);
        });
    }

    protected processGetOrganizationsByIds(response: Response): Promise<Organization[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Organization.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulkCreateOrganizations(body: Organization[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/organizations/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBulkCreateOrganizations(_response);
        });
    }

    protected processBulkCreateOrganizations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulkUpdateOrganizations(body: Organization[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/organizations/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBulkUpdateOrganizations(_response);
        });
    }

    protected processBulkUpdateOrganizations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getOrganizationById(id: string | null): Promise<Organization> {
        let url_ = this.baseUrl + "/api/organizations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetOrganizationById(_response);
        });
    }

    protected processGetOrganizationById(response: Response): Promise<Organization> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Organization.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchOrganizations(body: MembersSearchCriteria | undefined): Promise<OrganizationSearchResult> {
        let url_ = this.baseUrl + "/api/organizations/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchOrganizations(_response);
        });
    }

    protected processSearchOrganizations(response: Response): Promise<OrganizationSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrganizationSearchResult>(null as any);
    }

    /**
     * @return Success
     */
    getContactById(id: string | null): Promise<Contact> {
        let url_ = this.baseUrl + "/api/contacts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetContactById(_response);
        });
    }

    protected processGetContactById(response: Response): Promise<Contact> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contact.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchContacts(body: MembersSearchCriteria | undefined): Promise<ContactSearchResult> {
        let url_ = this.baseUrl + "/api/contacts/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchContacts(_response);
        });
    }

    protected processSearchContacts(response: Response): Promise<ContactSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContactSearchResult>(null as any);
    }

    /**
     * @return Success
     */
    getVendorById(id: string | null): Promise<Vendor> {
        let url_ = this.baseUrl + "/api/vendors/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetVendorById(_response);
        });
    }

    protected processGetVendorById(response: Response): Promise<Vendor> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Vendor.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Vendor>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    getVendorsByIds(ids: string[] | null | undefined): Promise<Vendor[]> {
        let url_ = this.baseUrl + "/api/vendors?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetVendorsByIds(_response);
        });
    }

    protected processGetVendorsByIds(response: Response): Promise<Vendor[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Vendor.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Vendor[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchVendors(body: MembersSearchCriteria | undefined): Promise<VendorSearchResult> {
        let url_ = this.baseUrl + "/api/vendors/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchVendors(_response);
        });
    }

    protected processSearchVendors(response: Response): Promise<VendorSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VendorSearchResult>(null as any);
    }

    /**
     * @param memberId (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateAddesses(memberId: string | null | undefined, body: CustomerAddress[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/addresses?";
        if (memberId !== undefined && memberId !== null)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateAddesses(_response);
        });
    }

    protected processUpdateAddesses(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createEmployee(body: Employee | undefined): Promise<Employee> {
        let url_ = this.baseUrl + "/api/employees";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateEmployee(_response);
        });
    }

    protected processCreateEmployee(response: Response): Promise<Employee> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Employee.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Employee>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    getEmployeesByIds(ids: string[] | null | undefined): Promise<Employee[]> {
        let url_ = this.baseUrl + "/api/employees?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEmployeesByIds(_response);
        });
    }

    protected processGetEmployeesByIds(response: Response): Promise<Employee[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Employee.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Employee[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulkCreateEmployees(body: Employee[] | null | undefined): Promise<Employee[]> {
        let url_ = this.baseUrl + "/api/employees/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBulkCreateEmployees(_response);
        });
    }

    protected processBulkCreateEmployees(response: Response): Promise<Employee[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Employee.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Employee[]>(null as any);
    }

    /**
     * @param idQuery (optional) 
     * @return Success
     */
    getMemberOrganizations(idQuery: string | null | undefined, idPath: string): Promise<Organization[]> {
        let url_ = this.baseUrl + "/api/members/{id}/organizations?";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        if (idQuery !== undefined && idQuery !== null)
            url_ += "id=" + encodeURIComponent("" + idQuery) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMemberOrganizations(_response);
        });
    }

    protected processGetMemberOrganizations(response: Response): Promise<Organization[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Organization.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization[]>(null as any);
    }
}

export class CustomerReviewsModuleClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getCustomerReviewsList(body: CustomerReviewSearchCriteria | undefined): Promise<CustomerReviewListItemSearchResult> {
        let url_ = this.baseUrl + "/api/customerReviews/reviewList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCustomerReviewsList(_response);
        });
    }

    protected processGetCustomerReviewsList(response: Response): Promise<CustomerReviewListItemSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerReviewListItemSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerReviewListItemSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchCustomerReviews(body: CustomerReviewSearchCriteria | undefined): Promise<CustomerReviewSearchResult> {
        let url_ = this.baseUrl + "/api/customerReviews/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchCustomerReviews(_response);
        });
    }

    protected processSearchCustomerReviews(response: Response): Promise<CustomerReviewSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerReviewSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerReviewSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getProductIdsOfModifiedReviews(body: ChangedReviewsQuery | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/customerReviews/changes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProductIdsOfModifiedReviews(_response);
        });
    }

    protected processGetProductIdsOfModifiedReviews(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveReview(body: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/customerReviews/approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processApproveReview(_response);
        });
    }

    protected processApproveReview(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rejectReview(body: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/customerReviews/reject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRejectReview(_response);
        });
    }

    protected processRejectReview(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetReviewStatus(body: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/customerReviews/reset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processResetReviewStatus(_response);
        });
    }

    protected processResetReviewStatus(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CustomerReview[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/customerReviews";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    delete(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/customerReviews?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    viewedRequestReview(body: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/customerReviews/viewedRequestReview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processViewedRequestReview(_response);
        });
    }

    protected processViewedRequestReview(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CustomerReviewsModuleRatingClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getForCatalog(body: ProductCatalogRatingRequest | undefined): Promise<RatingStoreDto[]> {
        let url_ = this.baseUrl + "/api/rating/productRatingInCatalog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetForCatalog(_response);
        });
    }

    protected processGetForCatalog(response: Response): Promise<RatingStoreDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RatingStoreDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RatingStoreDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getProductRating(body: ProductStoreRatingRequest | undefined): Promise<RatingProductDto[]> {
        let url_ = this.baseUrl + "/api/rating/productRatingInStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProductRating(_response);
        });
    }

    protected processGetProductRating(response: Response): Promise<RatingProductDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RatingProductDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RatingProductDto[]>(null as any);
    }

    /**
     * @param storeId (optional) 
     * @return Success
     */
    calculateStore(storeId: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/rating/calculateStore?";
        if (storeId !== undefined && storeId !== null)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculateStore(_response);
        });
    }

    protected processCalculateStore(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ExportClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getExportedKnownTypes(): Promise<ExportedTypeDefinition[]> {
        let url_ = this.baseUrl + "/api/export/knowntypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetExportedKnownTypes(_response);
        });
    }

    protected processGetExportedKnownTypes(response: Response): Promise<ExportedTypeDefinition[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExportedTypeDefinition.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExportedTypeDefinition[]>(null as any);
    }

    /**
     * @return Success
     */
    getExportProviders(): Promise<IExportProvider[]> {
        let url_ = this.baseUrl + "/api/export/providers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetExportProviders(_response);
        });
    }

    protected processGetExportProviders(response: Response): Promise<IExportProvider[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IExportProvider.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IExportProvider[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getData(body: ExportDataRequest | undefined): Promise<ExportableSearchResult> {
        let url_ = this.baseUrl + "/api/export/data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetData(_response);
        });
    }

    protected processGetData(response: Response): Promise<ExportableSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportableSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExportableSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    runExport(body: ExportDataRequest | undefined): Promise<PlatformExportPushNotification> {
        let url_ = this.baseUrl + "/api/export/run";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRunExport(_response);
        });
    }

    protected processRunExport(response: Response): Promise<PlatformExportPushNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlatformExportPushNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlatformExportPushNotification>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelExport(body: ExportCancellationRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/export/task/cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCancelExport(_response);
        });
    }

    protected processCancelExport(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    downloadExportFile(fileName: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/export/download/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDownloadExportFile(_response);
        });
    }

    protected processDownloadExportFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ThumbnailsOptionsClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createThumbnailOption(body: ThumbnailOption | undefined): Promise<ThumbnailOption> {
        let url_ = this.baseUrl + "/api/image/thumbnails/options";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateThumbnailOption(_response);
        });
    }

    protected processCreateThumbnailOption(response: Response): Promise<ThumbnailOption> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThumbnailOption.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ThumbnailOption>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteThumbnailOption(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/image/thumbnails/options?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteThumbnailOption(_response);
        });
    }

    protected processDeleteThumbnailOption(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateThumbnailOption(body: ThumbnailOption | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/image/thumbnails/options";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateThumbnailOption(_response);
        });
    }

    protected processUpdateThumbnailOption(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getThumbnailOption(id: string | null): Promise<ThumbnailOption> {
        let url_ = this.baseUrl + "/api/image/thumbnails/options/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetThumbnailOption(_response);
        });
    }

    protected processGetThumbnailOption(response: Response): Promise<ThumbnailOption> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThumbnailOption.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ThumbnailOption>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchThumbnailOption(body: ThumbnailOptionSearchCriteria | undefined): Promise<ThumbnailOptionSearchResult> {
        let url_ = this.baseUrl + "/api/image/thumbnails/options/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchThumbnailOption(_response);
        });
    }

    protected processSearchThumbnailOption(response: Response): Promise<ThumbnailOptionSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThumbnailOptionSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ThumbnailOptionSearchResult>(null as any);
    }
}

export class ThumbnailsTasksClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createThumbnailTask(body: ThumbnailTask | undefined): Promise<ThumbnailTask> {
        let url_ = this.baseUrl + "/api/image/thumbnails/tasks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateThumbnailTask(_response);
        });
    }

    protected processCreateThumbnailTask(response: Response): Promise<ThumbnailTask> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThumbnailTask.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ThumbnailTask>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteThumbnailTask(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/image/thumbnails/tasks?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteThumbnailTask(_response);
        });
    }

    protected processDeleteThumbnailTask(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateThumbnailTask(body: ThumbnailTask | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/image/thumbnails/tasks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateThumbnailTask(_response);
        });
    }

    protected processUpdateThumbnailTask(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getThumbnailTask(id: string | null): Promise<ThumbnailTask> {
        let url_ = this.baseUrl + "/api/image/thumbnails/tasks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetThumbnailTask(_response);
        });
    }

    protected processGetThumbnailTask(response: Response): Promise<ThumbnailTask> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThumbnailTask.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ThumbnailTask>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchThumbnailTask(body: ThumbnailTaskSearchCriteria | undefined): Promise<ThumbnailTaskSearchResult> {
        let url_ = this.baseUrl + "/api/image/thumbnails/tasks/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchThumbnailTask(_response);
        });
    }

    protected processSearchThumbnailTask(response: Response): Promise<ThumbnailTaskSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThumbnailTaskSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ThumbnailTaskSearchResult>(null as any);
    }

    /**
     * @return Success
     */
    cancel(jobId: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/image/thumbnails/tasks/{jobId}/cancel";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCancel(_response);
        });
    }

    protected processCancel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    run(body: ThumbnailsTaskRunRequest | undefined): Promise<ThumbnailProcessNotification> {
        let url_ = this.baseUrl + "/api/image/thumbnails/tasks/run";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRun(_response);
        });
    }

    protected processRun(response: Response): Promise<ThumbnailProcessNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThumbnailProcessNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ThumbnailProcessNotification>(null as any);
    }
}

export class InventoryModuleClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchInventories(body: InventorySearchCriteria | undefined): Promise<InventoryInfoSearchResult> {
        let url_ = this.baseUrl + "/api/inventories/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchInventories(_response);
        });
    }

    protected processSearchInventories(response: Response): Promise<InventoryInfoSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryInfoSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InventoryInfoSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchInventory(body: InventorySearchCriteria | undefined): Promise<InventoryInfoSearchResult> {
        let url_ = this.baseUrl + "/api/inventory/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchInventory(_response);
        });
    }

    protected processSearchInventory(response: Response): Promise<InventoryInfoSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryInfoSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InventoryInfoSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchProductInventories(body: ProductInventorySearchCriteria | undefined): Promise<InventoryInfoSearchResult> {
        let url_ = this.baseUrl + "/api/inventory/product/inventories/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchProductInventories(_response);
        });
    }

    protected processSearchProductInventories(response: Response): Promise<InventoryInfoSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryInfoSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InventoryInfoSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchProductInventory(body: ProductInventorySearchCriteria | undefined): Promise<InventoryInfoSearchResult> {
        let url_ = this.baseUrl + "/api/inventory/product/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchProductInventory(_response);
        });
    }

    protected processSearchProductInventory(response: Response): Promise<InventoryInfoSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryInfoSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InventoryInfoSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchFulfillmentCenters(body: FulfillmentCenterSearchCriteria | undefined): Promise<FulfillmentCenterSearchResult> {
        let url_ = this.baseUrl + "/api/inventory/fulfillmentcenters/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchFulfillmentCenters(_response);
        });
    }

    protected processSearchFulfillmentCenters(response: Response): Promise<FulfillmentCenterSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FulfillmentCenterSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FulfillmentCenterSearchResult>(null as any);
    }

    /**
     * @return Success
     */
    getFulfillmentCenter(id: string | null): Promise<FulfillmentCenter> {
        let url_ = this.baseUrl + "/api/inventory/fulfillmentcenters/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetFulfillmentCenter(_response);
        });
    }

    protected processGetFulfillmentCenter(response: Response): Promise<FulfillmentCenter> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FulfillmentCenter.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FulfillmentCenter>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getFulfillmentCenters(body: string[] | null | undefined): Promise<FulfillmentCenter[]> {
        let url_ = this.baseUrl + "/api/inventory/fulfillmentcenters/plenty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetFulfillmentCenters(_response);
        });
    }

    protected processGetFulfillmentCenters(response: Response): Promise<FulfillmentCenter[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FulfillmentCenter.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FulfillmentCenter[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveFulfillmentCenter(body: FulfillmentCenter | undefined): Promise<FulfillmentCenter> {
        let url_ = this.baseUrl + "/api/inventory/fulfillmentcenters";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSaveFulfillmentCenter(_response);
        });
    }

    protected processSaveFulfillmentCenter(response: Response): Promise<FulfillmentCenter> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FulfillmentCenter.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FulfillmentCenter>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteInventoryFulfillmentCenters(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/inventory/fulfillmentcenters?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteInventoryFulfillmentCenters(_response);
        });
    }

    protected processDeleteInventoryFulfillmentCenters(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveFulfillmentCenters(body: FulfillmentCenter[] | null | undefined): Promise<FulfillmentCenter[]> {
        let url_ = this.baseUrl + "/api/inventory/fulfillmentcenters/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSaveFulfillmentCenters(_response);
        });
    }

    protected processSaveFulfillmentCenters(response: Response): Promise<FulfillmentCenter[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FulfillmentCenter.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FulfillmentCenter[]>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteFulfillmentCenters(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/fulfillment/centers?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteFulfillmentCenters(_response);
        });
    }

    protected processDeleteFulfillmentCenters(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @param fulfillmentCenterIds (optional) 
     * @return Success
     */
    getProductsInventories(ids: string[] | null | undefined, fulfillmentCenterIds: string[] | null | undefined): Promise<InventoryInfo[]> {
        let url_ = this.baseUrl + "/api/inventory/products?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (fulfillmentCenterIds !== undefined && fulfillmentCenterIds !== null)
            fulfillmentCenterIds && fulfillmentCenterIds.forEach(item => { url_ += "fulfillmentCenterIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProductsInventories(_response);
        });
    }

    protected processGetProductsInventories(response: Response): Promise<InventoryInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InventoryInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InventoryInfo[]>(null as any);
    }

    /**
     * @param fulfillmentCenterIds (optional) 
     * @param body (optional) 
     * @return Success
     */
    getProductsInventoriesByPlentyIds(fulfillmentCenterIds: string[] | null | undefined, body: string[] | null | undefined): Promise<InventoryInfo[]> {
        let url_ = this.baseUrl + "/api/inventory/products/plenty?";
        if (fulfillmentCenterIds !== undefined && fulfillmentCenterIds !== null)
            fulfillmentCenterIds && fulfillmentCenterIds.forEach(item => { url_ += "fulfillmentCenterIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProductsInventoriesByPlentyIds(_response);
        });
    }

    protected processGetProductsInventoriesByPlentyIds(response: Response): Promise<InventoryInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InventoryInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InventoryInfo[]>(null as any);
    }

    /**
     * @return Success
     */
    getProductInventories(productId: string | null): Promise<InventoryInfo[]> {
        let url_ = this.baseUrl + "/api/inventory/products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProductInventories(_response);
        });
    }

    protected processGetProductInventories(response: Response): Promise<InventoryInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InventoryInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InventoryInfo[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProductInventory(productId: string, body: InventoryInfo | undefined): Promise<InventoryInfo> {
        let url_ = this.baseUrl + "/api/inventory/products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateProductInventory(_response);
        });
    }

    protected processUpdateProductInventory(response: Response): Promise<InventoryInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InventoryInfo>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    upsertProductInventories(body: InventoryInfo[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/inventory/plenty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpsertProductInventories(_response);
        });
    }

    protected processUpsertProductInventories(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class MarketingModuleDynamicContentClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    dynamicContentPlaceListEntriesSearch(body: DynamicContentPlaceSearchCriteria | undefined): Promise<DynamicContentListEntrySearchResult> {
        let url_ = this.baseUrl + "/api/marketing/contentplaces/listentries/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDynamicContentPlaceListEntriesSearch(_response);
        });
    }

    protected processDynamicContentPlaceListEntriesSearch(response: Response): Promise<DynamicContentListEntrySearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentListEntrySearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentListEntrySearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    dynamicContentPlacesSearch(body: DynamicContentPlaceSearchCriteria | undefined): Promise<DynamicContentPlaceSearchResult> {
        let url_ = this.baseUrl + "/api/marketing/contentplaces/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDynamicContentPlacesSearch(_response);
        });
    }

    protected processDynamicContentPlacesSearch(response: Response): Promise<DynamicContentPlaceSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPlaceSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPlaceSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    dynamicContentItemsEntriesSearch(body: DynamicContentItemSearchCriteria | undefined): Promise<DynamicContentListEntrySearchResult> {
        let url_ = this.baseUrl + "/api/marketing/contentitems/listentries/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDynamicContentItemsEntriesSearch(_response);
        });
    }

    protected processDynamicContentItemsEntriesSearch(response: Response): Promise<DynamicContentListEntrySearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentListEntrySearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentListEntrySearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    dynamicContentItemsSearch(body: DynamicContentItemSearchCriteria | undefined): Promise<DynamicContentItemSearchResult> {
        let url_ = this.baseUrl + "/api/marketing/contentitems/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDynamicContentItemsSearch(_response);
        });
    }

    protected processDynamicContentItemsSearch(response: Response): Promise<DynamicContentItemSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentItemSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentItemSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    dynamicContentPublicationsSearch(body: DynamicContentPublicationSearchCriteria | undefined): Promise<DynamicContentPublicationSearchResult> {
        let url_ = this.baseUrl + "/api/marketing/contentpublications/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDynamicContentPublicationsSearch(_response);
        });
    }

    protected processDynamicContentPublicationsSearch(response: Response): Promise<DynamicContentPublicationSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPublicationSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPublicationSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    evaluateDynamicContent(body: DynamicContentEvaluationContext | undefined): Promise<DynamicContentItem[]> {
        let url_ = this.baseUrl + "/api/marketing/contentitems/evaluate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processEvaluateDynamicContent(_response);
        });
    }

    protected processEvaluateDynamicContent(response: Response): Promise<DynamicContentItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DynamicContentItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentItem[]>(null as any);
    }

    /**
     * @return Success
     */
    getDynamicContentById(id: string | null): Promise<DynamicContentItem> {
        let url_ = this.baseUrl + "/api/marketing/contentitems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDynamicContentById(_response);
        });
    }

    protected processGetDynamicContentById(response: Response): Promise<DynamicContentItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentItem>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDynamicContent(body: DynamicContentItem | undefined): Promise<DynamicContentItem> {
        let url_ = this.baseUrl + "/api/marketing/contentitems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateDynamicContent(_response);
        });
    }

    protected processCreateDynamicContent(response: Response): Promise<DynamicContentItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentItem>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDynamicContent(body: DynamicContentItem | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentitems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateDynamicContent(_response);
        });
    }

    protected processUpdateDynamicContent(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteDynamicContents(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentitems?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteDynamicContents(_response);
        });
    }

    protected processDeleteDynamicContents(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getDynamicContentPlaceById(id: string | null): Promise<DynamicContentPlace> {
        let url_ = this.baseUrl + "/api/marketing/contentplaces/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDynamicContentPlaceById(_response);
        });
    }

    protected processGetDynamicContentPlaceById(response: Response): Promise<DynamicContentPlace> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPlace.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPlace>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDynamicContentPlace(body: DynamicContentPlace | undefined): Promise<DynamicContentPlace> {
        let url_ = this.baseUrl + "/api/marketing/contentplaces";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateDynamicContentPlace(_response);
        });
    }

    protected processCreateDynamicContentPlace(response: Response): Promise<DynamicContentPlace> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPlace.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPlace>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDynamicContentPlace(body: DynamicContentPlace | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentplaces";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateDynamicContentPlace(_response);
        });
    }

    protected processUpdateDynamicContentPlace(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteDynamicContentPlaces(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentplaces?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteDynamicContentPlaces(_response);
        });
    }

    protected processDeleteDynamicContentPlaces(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getNewDynamicPublication(): Promise<DynamicContentPublication> {
        let url_ = this.baseUrl + "/api/marketing/contentpublications/new";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewDynamicPublication(_response);
        });
    }

    protected processGetNewDynamicPublication(response: Response): Promise<DynamicContentPublication> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPublication.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPublication>(null as any);
    }

    /**
     * @return Success
     */
    getDynamicContentPublicationById(id: string | null): Promise<DynamicContentPublication> {
        let url_ = this.baseUrl + "/api/marketing/contentpublications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDynamicContentPublicationById(_response);
        });
    }

    protected processGetDynamicContentPublicationById(response: Response): Promise<DynamicContentPublication> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPublication.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPublication>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDynamicContentPublication(body: DynamicContentPublication | undefined): Promise<DynamicContentPublication> {
        let url_ = this.baseUrl + "/api/marketing/contentpublications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateDynamicContentPublication(_response);
        });
    }

    protected processCreateDynamicContentPublication(response: Response): Promise<DynamicContentPublication> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPublication.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPublication>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDynamicContentPublication(body: DynamicContentPublication | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentpublications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateDynamicContentPublication(_response);
        });
    }

    protected processUpdateDynamicContentPublication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteDynamicContentPublications(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentpublications?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteDynamicContentPublications(_response);
        });
    }

    protected processDeleteDynamicContentPublications(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getDynamicContentFolderById(id: string | null): Promise<DynamicContentFolder> {
        let url_ = this.baseUrl + "/api/marketing/contentfolders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDynamicContentFolderById(_response);
        });
    }

    protected processGetDynamicContentFolderById(response: Response): Promise<DynamicContentFolder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentFolder.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentFolder>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDynamicContentFolder(body: DynamicContentFolder | undefined): Promise<DynamicContentFolder> {
        let url_ = this.baseUrl + "/api/marketing/contentfolders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateDynamicContentFolder(_response);
        });
    }

    protected processCreateDynamicContentFolder(response: Response): Promise<DynamicContentFolder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentFolder.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentFolder>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDynamicContentFolder(body: DynamicContentFolder | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentfolders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateDynamicContentFolder(_response);
        });
    }

    protected processUpdateDynamicContentFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteDynamicContentFolders(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentfolders?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteDynamicContentFolders(_response);
        });
    }

    protected processDeleteDynamicContentFolders(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class MarketingModulePromotionClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    promotionsSearch(body: PromotionSearchCriteria | undefined): Promise<PromotionSearchResult> {
        let url_ = this.baseUrl + "/api/marketing/promotions/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPromotionsSearch(_response);
        });
    }

    protected processPromotionsSearch(response: Response): Promise<PromotionSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PromotionSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PromotionSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    evaluatePromotions(body: PromotionEvaluationContext | undefined): Promise<PromotionReward[]> {
        let url_ = this.baseUrl + "/api/marketing/promotions/evaluate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processEvaluatePromotions(_response);
        });
    }

    protected processEvaluatePromotions(response: Response): Promise<PromotionReward[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PromotionReward.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PromotionReward[]>(null as any);
    }

    /**
     * @return Success
     */
    getPromotionById(id: string | null): Promise<Promotion> {
        let url_ = this.baseUrl + "/api/marketing/promotions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPromotionById(_response);
        });
    }

    protected processGetPromotionById(response: Response): Promise<Promotion> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Promotion.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Promotion>(null as any);
    }

    /**
     * @return Success
     */
    getNewDynamicPromotion(): Promise<Promotion> {
        let url_ = this.baseUrl + "/api/marketing/promotions/new";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewDynamicPromotion(_response);
        });
    }

    protected processGetNewDynamicPromotion(response: Response): Promise<Promotion> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Promotion.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Promotion>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPromotion(body: Promotion | undefined): Promise<Promotion> {
        let url_ = this.baseUrl + "/api/marketing/promotions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreatePromotion(_response);
        });
    }

    protected processCreatePromotion(response: Response): Promise<Promotion> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Promotion.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Promotion>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePromotions(body: Promotion | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/promotions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdatePromotions(_response);
        });
    }

    protected processUpdatePromotions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deletePromotions(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/promotions?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeletePromotions(_response);
        });
    }

    protected processDeletePromotions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchCoupons(body: CouponSearchCriteria | undefined): Promise<CouponSearchResult> {
        let url_ = this.baseUrl + "/api/marketing/promotions/coupons/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchCoupons(_response);
        });
    }

    protected processSearchCoupons(response: Response): Promise<CouponSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CouponSearchResult>(null as any);
    }

    /**
     * @return Success
     */
    getCoupon(id: string | null): Promise<Coupon> {
        let url_ = this.baseUrl + "/api/marketing/promotions/coupons/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCoupon(_response);
        });
    }

    protected processGetCoupon(response: Response): Promise<Coupon> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Coupon.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Coupon>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCoupons(body: Coupon[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/promotions/coupons/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddCoupons(_response);
        });
    }

    protected processAddCoupons(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteCoupons(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/promotions/coupons/delete?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteCoupons(_response);
        });
    }

    protected processDeleteCoupons(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    importCoupons(body: ImportRequest | undefined): Promise<ImportNotification> {
        let url_ = this.baseUrl + "/api/marketing/promotions/coupons/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processImportCoupons(_response);
        });
    }

    protected processImportCoupons(response: Response): Promise<ImportNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImportNotification>(null as any);
    }
}

export class VcmpCommonClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getVcmpSettings(): Promise<MarketplaceOptions> {
        let url_ = this.baseUrl + "/api/vcmp/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetVcmpSettings(_response);
        });
    }

    protected processGetVcmpSettings(response: Response): Promise<MarketplaceOptions> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MarketplaceOptions.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MarketplaceOptions>(null as any);
    }
}

export class VcmpSellerCatalogClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    massChangeProductsStatus(status: string | null, body: SearchProductsQuery | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/seller/products/status/{status}";
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined.");
        url_ = url_.replace("{status}", encodeURIComponent("" + status));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMassChangeProductsStatus(_response);
        });
    }

    protected processMassChangeProductsStatus(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeProductStatus(body: ChangeRequestStatusCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/seller/product/status/change";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processChangeProductStatus(_response);
        });
    }

    protected processChangeProductStatus(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchCategories(body: SearchCategoriesQuery | undefined): Promise<CategorySearchResult> {
        let url_ = this.baseUrl + "/api/vcmp/seller/categories/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchCategories(_response);
        });
    }

    protected processSearchCategories(response: Response): Promise<CategorySearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategorySearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategorySearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateProduct(body: ValidateProductQuery | undefined): Promise<ValidationFailure[]> {
        let url_ = this.baseUrl + "/api/vcmp/seller/products/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processValidateProduct(_response);
        });
    }

    protected processValidateProduct(response: Response): Promise<ValidationFailure[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ValidationFailure.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValidationFailure[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSellerCategories(body: CreateSellerCategoriesCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/seller/categories/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateSellerCategories(_response);
        });
    }

    protected processCreateSellerCategories(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteSellerCategories(body: DeleteSellerCategoriesCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/seller/seller/categories/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteSellerCategories(_response);
        });
    }

    protected processDeleteSellerCategories(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportSellerCategories(body: RunCategoriesExportCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/seller/categories/export";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processExportSellerCategories(_response);
        });
    }

    protected processExportSellerCategories(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchProducts(body: SearchProductsQuery | undefined): Promise<SearchProductsResult> {
        let url_ = this.baseUrl + "/api/vcmp/seller/products/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchProducts(_response);
        });
    }

    protected processSearchProducts(response: Response): Promise<SearchProductsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchProductsResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchProductsResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchPropertyDictionaryItems(body: PropertyDictionaryItemSearchCriteria | undefined): Promise<PropertyDictionaryItemSearchResult> {
        let url_ = this.baseUrl + "/api/vcmp/seller/dictionaryitems/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchPropertyDictionaryItems(_response);
        });
    }

    protected processSearchPropertyDictionaryItems(response: Response): Promise<PropertyDictionaryItemSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyDictionaryItemSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PropertyDictionaryItemSearchResult>(null as any);
    }

    /**
     * @return Success
     */
    getProductById(productId: string | null): Promise<SellerProduct> {
        let url_ = this.baseUrl + "/api/vcmp/seller/products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProductById(_response);
        });
    }

    protected processGetProductById(response: Response): Promise<SellerProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SellerProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SellerProduct>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createNewProduct(body: CreateNewProductCommand | undefined): Promise<SellerProduct> {
        let url_ = this.baseUrl + "/api/vcmp/seller/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateNewProduct(_response);
        });
    }

    protected processCreateNewProduct(response: Response): Promise<SellerProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SellerProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SellerProduct>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProductDetails(body: UpdateProductDetailsCommand | undefined): Promise<SellerProduct> {
        let url_ = this.baseUrl + "/api/vcmp/seller/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateProductDetails(_response);
        });
    }

    protected processUpdateProductDetails(response: Response): Promise<SellerProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SellerProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SellerProduct>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createNewPublicationRequest(body: CreateNewPublicationRequestCommand | undefined): Promise<ProductPublicationRequest> {
        let url_ = this.baseUrl + "/api/vcmp/seller/products/requests/new";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateNewPublicationRequest(_response);
        });
    }

    protected processCreateNewPublicationRequest(response: Response): Promise<ProductPublicationRequest> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductPublicationRequest.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductPublicationRequest>(null as any);
    }

    /**
     * @return Success
     */
    revertStagedChanges(productId: string | null): Promise<ProductPublicationRequest> {
        let url_ = this.baseUrl + "/api/vcmp/seller/product/{productId}/revert";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRevertStagedChanges(_response);
        });
    }

    protected processRevertStagedChanges(response: Response): Promise<ProductPublicationRequest> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductPublicationRequest.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductPublicationRequest>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchOffers(body: SearchOffersQuery | undefined): Promise<SearchOffersResult> {
        let url_ = this.baseUrl + "/api/vcmp/seller/offers/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchOffers(_response);
        });
    }

    protected processSearchOffers(response: Response): Promise<SearchOffersResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchOffersResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchOffersResult>(null as any);
    }

    /**
     * @return Success
     */
    getOfferById(offerId: string | null): Promise<Offer> {
        let url_ = this.baseUrl + "/api/vcmp/seller/offers/{offerId}";
        if (offerId === undefined || offerId === null)
            throw new Error("The parameter 'offerId' must be defined.");
        url_ = url_.replace("{offerId}", encodeURIComponent("" + offerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetOfferById(_response);
        });
    }

    protected processGetOfferById(response: Response): Promise<Offer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Offer.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Offer>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchOfferProducts(body: SearchProductsForNewOfferQuery | undefined): Promise<SearchOfferProductsResult> {
        let url_ = this.baseUrl + "/api/vcmp/seller/offers/products/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchOfferProducts(_response);
        });
    }

    protected processSearchOfferProducts(response: Response): Promise<SearchOfferProductsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchOfferProductsResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchOfferProductsResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createNewOffer(body: CreateNewOfferCommand | undefined): Promise<Offer> {
        let url_ = this.baseUrl + "/api/vcmp/seller/offers/new";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateNewOffer(_response);
        });
    }

    protected processCreateNewOffer(response: Response): Promise<Offer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Offer.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Offer>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteOffers(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/seller/offers?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteOffers(_response);
        });
    }

    protected processDeleteOffers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class VcmpSellerImportClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    runImport(body: RunImportCommand | undefined): Promise<ImportPushNotification> {
        let url_ = this.baseUrl + "/api/vcmp/import/run";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRunImport(_response);
        });
    }

    protected processRunImport(response: Response): Promise<ImportPushNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportPushNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImportPushNotification>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelJob(body: ImportCancellationRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/import/task/cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCancelJob(_response);
        });
    }

    protected processCancelJob(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    preview(body: PreviewDataQuery | undefined): Promise<ImportDataPreview> {
        let url_ = this.baseUrl + "/api/vcmp/import/preview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPreview(_response);
        });
    }

    protected processPreview(response: Response): Promise<ImportDataPreview> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportDataPreview.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImportDataPreview>(null as any);
    }

    /**
     * @return Success
     */
    getImporters(): Promise<IDataImporter[]> {
        let url_ = this.baseUrl + "/api/vcmp/import/importers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetImporters(_response);
        });
    }

    protected processGetImporters(response: Response): Promise<IDataImporter[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IDataImporter.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IDataImporter[]>(null as any);
    }

    /**
     * @return Success
     */
    getImportProfileById(profileId: string | null): Promise<ImportProfile> {
        let url_ = this.baseUrl + "/api/vcmp/import/profiles/{profileId}";
        if (profileId === undefined || profileId === null)
            throw new Error("The parameter 'profileId' must be defined.");
        url_ = url_.replace("{profileId}", encodeURIComponent("" + profileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetImportProfileById(_response);
        });
    }

    protected processGetImportProfileById(response: Response): Promise<ImportProfile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportProfile.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImportProfile>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createImportProfile(body: CreateProfileCommand | undefined): Promise<ImportProfile> {
        let url_ = this.baseUrl + "/api/vcmp/import/profiles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateImportProfile(_response);
        });
    }

    protected processCreateImportProfile(response: Response): Promise<ImportProfile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportProfile.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImportProfile>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateImportProfile(body: UpdateProfileCommand | undefined): Promise<ImportProfile> {
        let url_ = this.baseUrl + "/api/vcmp/import/profiles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateImportProfile(_response);
        });
    }

    protected processUpdateImportProfile(response: Response): Promise<ImportProfile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportProfile.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImportProfile>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteProfile(id: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/import/profiles?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteProfile(_response);
        });
    }

    protected processDeleteProfile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchImportProfiles(body: SearchImportProfilesQuery | undefined): Promise<SearchImportProfilesResult> {
        let url_ = this.baseUrl + "/api/vcmp/import/profiles/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchImportProfiles(_response);
        });
    }

    protected processSearchImportProfiles(response: Response): Promise<SearchImportProfilesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchImportProfilesResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchImportProfilesResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchImportProfilesHistory(body: SearchImportProfilesHistoryQuery | undefined): Promise<SearchImportProfilesHistoryResult> {
        let url_ = this.baseUrl + "/api/vcmp/import/profiles/execution/history/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchImportProfilesHistory(_response);
        });
    }

    protected processSearchImportProfilesHistory(response: Response): Promise<SearchImportProfilesHistoryResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchImportProfilesHistoryResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchImportProfilesHistoryResult>(null as any);
    }
}

export class VcmpSellerOrdersClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchOrders(body: SearchOrdersQuery | undefined): Promise<CustomerOrderSearchResult> {
        let url_ = this.baseUrl + "/api/vcmp/orders/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchOrders(_response);
        });
    }

    protected processSearchOrders(response: Response): Promise<CustomerOrderSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerOrderSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerOrderSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrderStatus(body: ChangeOrderStatusCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/orders/status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateOrderStatus(_response);
        });
    }

    protected processUpdateOrderStatus(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class VcmpSellerSecurityClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param memberId (optional) 
     * @return Success
     */
    sendInvitation(memberId: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/security/seller/send/invitation?";
        if (memberId !== undefined && memberId !== null)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendInvitation(_response);
        });
    }

    protected processSendInvitation(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendUserInvitation(body: SendSellerUserInvitationCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/security/seller/users/invitation/send";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendUserInvitation(_response);
        });
    }

    protected processSendUserInvitation(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateSeller(body: ValidateProductQuery | undefined): Promise<ValidationFailure[]> {
        let url_ = this.baseUrl + "/api/vcmp/security/seller/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processValidateSeller(_response);
        });
    }

    protected processValidateSeller(response: Response): Promise<ValidationFailure[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ValidationFailure.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValidationFailure[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSeller(body: CreateSellerCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/security/seller/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateSeller(_response);
        });
    }

    protected processCreateSeller(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSeller(body: UpdateSellerCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/security/seller/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateSeller(_response);
        });
    }

    protected processUpdateSeller(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteSellers(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/security/seller?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteSellers(_response);
        });
    }

    protected processDeleteSellers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchSellers(body: SearchSellersQuery | undefined): Promise<SearchSellersResult> {
        let url_ = this.baseUrl + "/api/vcmp/security/seller/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchSellers(_response);
        });
    }

    protected processSearchSellers(response: Response): Promise<SearchSellersResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchSellersResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchSellersResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSellerUser(body: CreateSellerUserCommand | undefined): Promise<SellerUser> {
        let url_ = this.baseUrl + "/api/vcmp/security/seller/users/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateSellerUser(_response);
        });
    }

    protected processCreateSellerUser(response: Response): Promise<SellerUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SellerUser.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SellerUser>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateUser(body: ValidateSellerUserQuery | undefined): Promise<ValidationFailure[]> {
        let url_ = this.baseUrl + "/api/vcmp/security/seller/users/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processValidateUser(_response);
        });
    }

    protected processValidateUser(response: Response): Promise<ValidationFailure[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ValidationFailure.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValidationFailure[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSellerUser(body: UpdateSellerUserCommand | undefined): Promise<SellerUser> {
        let url_ = this.baseUrl + "/api/vcmp/security/seller/users/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateSellerUser(_response);
        });
    }

    protected processUpdateSellerUser(response: Response): Promise<SellerUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SellerUser.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SellerUser>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteSellerUsers(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/security/seller/users?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteSellerUsers(_response);
        });
    }

    protected processDeleteSellerUsers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchSellerUsers(body: SearchSellerUsersQuery | undefined): Promise<SearchSellerUsersResult> {
        let url_ = this.baseUrl + "/api/vcmp/security/seller/users/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchSellerUsers(_response);
        });
    }

    protected processSearchSellerUsers(response: Response): Promise<SearchSellerUsersResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchSellerUsersResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchSellerUsersResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    forgotPassword(body: ForgotPasswordCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/vcmp/security/forgotpassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class NotificationsClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getNotifications(body: NotificationSearchCriteria | undefined): Promise<NotificationSearchResult> {
        let url_ = this.baseUrl + "/api/notifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNotifications(_response);
        });
    }

    protected processGetNotifications(response: Response): Promise<NotificationSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationSearchResult>(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @param tenantType (optional) 
     * @return Success
     */
    getNotificationByTypeId(type: string | null, tenantId: string | null | undefined, tenantType: string | null | undefined): Promise<Notification> {
        let url_ = this.baseUrl + "/api/notifications/{type}?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (tenantType !== undefined && tenantType !== null)
            url_ += "tenantType=" + encodeURIComponent("" + tenantType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNotificationByTypeId(_response);
        });
    }

    protected processGetNotificationByTypeId(response: Response): Promise<Notification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Notification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Notification>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateNotification(type: string, body: Notification | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/notifications/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateNotification(_response);
        });
    }

    protected processUpdateNotification(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    renderingTemplate(language: string | null, type: string, body: NotificationTemplateRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/notifications/{type}/templates/{language}/rendercontent";
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language));
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRenderingTemplate(_response);
        });
    }

    protected processRenderingTemplate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendNotification(body: Notification | undefined): Promise<NotificationSendResult> {
        let url_ = this.baseUrl + "/api/notifications/send";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendNotification(_response);
        });
    }

    protected processSendNotification(response: Response): Promise<NotificationSendResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationSendResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationSendResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    scheduleSendNotification(body: Notification | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/notifications/schedule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processScheduleSendNotification(_response);
        });
    }

    protected processScheduleSendNotification(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resendNotifications(body: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/notifications/scheduleresend";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processResendNotifications(_response);
        });
    }

    protected processResendNotifications(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendNotificationByRequest(body: NotificationRequest | undefined): Promise<NotificationSendResult> {
        let url_ = this.baseUrl + "/api/platform/notification/template/sendnotification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendNotificationByRequest(_response);
        });
    }

    protected processSendNotificationByRequest(response: Response): Promise<NotificationSendResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationSendResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationSendResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getNotificationJournal(body: NotificationMessageSearchCriteria | undefined): Promise<NotificationMessageSearchResult> {
        let url_ = this.baseUrl + "/api/notifications/journal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNotificationJournal(_response);
        });
    }

    protected processGetNotificationJournal(response: Response): Promise<NotificationMessageSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationMessageSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationMessageSearchResult>(null as any);
    }

    /**
     * @return Success
     */
    getObjectNotificationJournal(id: string | null): Promise<NotificationMessage> {
        let url_ = this.baseUrl + "/api/notifications/journal/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetObjectNotificationJournal(_response);
        });
    }

    protected processGetObjectNotificationJournal(response: Response): Promise<NotificationMessage> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationMessage.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationMessage>(null as any);
    }
}

export class OrderModuleClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchCustomerOrder(body: CustomerOrderSearchCriteria | undefined): Promise<CustomerOrderSearchResult> {
        let url_ = this.baseUrl + "/api/order/customerOrders/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchCustomerOrder(_response);
        });
    }

    protected processSearchCustomerOrder(response: Response): Promise<CustomerOrderSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerOrderSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerOrderSearchResult>(null as any);
    }

    /**
     * @param respGroup (optional) 
     * @return Success
     */
    getByNumber(number: string | null, respGroup: string | null | undefined): Promise<CustomerOrder> {
        let url_ = this.baseUrl + "/api/order/customerOrders/number/{number}?";
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number));
        if (respGroup !== undefined && respGroup !== null)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetByNumber(_response);
        });
    }

    protected processGetByNumber(response: Response): Promise<CustomerOrder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerOrder.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerOrder>(null as any);
    }

    /**
     * @param respGroup (optional) 
     * @return Success
     */
    getById(id: string | null, respGroup: string | null | undefined): Promise<CustomerOrder> {
        let url_ = this.baseUrl + "/api/order/customerOrders/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (respGroup !== undefined && respGroup !== null)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<CustomerOrder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerOrder.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerOrder>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    calculateTotals(body: CustomerOrder | undefined): Promise<CustomerOrder> {
        let url_ = this.baseUrl + "/api/order/customerOrders/recalculate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculateTotals(_response);
        });
    }

    protected processCalculateTotals(response: Response): Promise<CustomerOrder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerOrder.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerOrder>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    processOrderPayments(orderId: string | null, paymentId: string | null, body: BankCardInfo | undefined): Promise<ProcessPaymentRequestResult> {
        let url_ = this.baseUrl + "/api/order/customerOrders/{orderId}/processPayment/{paymentId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processProcessOrderPayments(_response);
        });
    }

    protected processProcessOrderPayments(response: Response): Promise<ProcessPaymentRequestResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessPaymentRequestResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProcessPaymentRequestResult>(null as any);
    }

    /**
     * @return Success
     */
    createOrderFromCart(cartId: string | null): Promise<CustomerOrder> {
        let url_ = this.baseUrl + "/api/order/customerOrders/{cartId}";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateOrderFromCart(_response);
        });
    }

    protected processCreateOrderFromCart(response: Response): Promise<CustomerOrder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerOrder.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerOrder>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrder(body: CustomerOrder | undefined): Promise<CustomerOrder> {
        let url_ = this.baseUrl + "/api/order/customerOrders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateOrder(_response);
        });
    }

    protected processCreateOrder(response: Response): Promise<CustomerOrder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerOrder.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerOrder>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrder(body: CustomerOrder | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/order/customerOrders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateOrder(_response);
        });
    }

    protected processUpdateOrder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteOrdersByIds(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/order/customerOrders?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteOrdersByIds(_response);
        });
    }

    protected processDeleteOrdersByIds(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getNewShipment(id: string | null): Promise<OrderShipment> {
        let url_ = this.baseUrl + "/api/order/customerOrders/{id}/shipments/new";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewShipment(_response);
        });
    }

    protected processGetNewShipment(response: Response): Promise<OrderShipment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderShipment.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderShipment>(null as any);
    }

    /**
     * @return Success
     */
    getNewPayment(id: string | null): Promise<PaymentIn> {
        let url_ = this.baseUrl + "/api/order/customerOrders/{id}/payments/new";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewPayment(_response);
        });
    }

    protected processGetNewPayment(response: Response): Promise<PaymentIn> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentIn.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentIn>(null as any);
    }

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    getDashboardStatistics(start: Date | null | undefined, end: Date | null | undefined): Promise<DashboardStatisticsResult> {
        let url_ = this.baseUrl + "/api/order/dashboardStatistics?";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent(start ? "" + start.toISOString() : "") + "&";
        if (end !== undefined && end !== null)
            url_ += "end=" + encodeURIComponent(end ? "" + end.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDashboardStatistics(_response);
        });
    }

    protected processGetDashboardStatistics(response: Response): Promise<DashboardStatisticsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardStatisticsResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardStatisticsResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    postProcessPayment(body: PaymentCallbackParameters | undefined): Promise<PostProcessPaymentRequestResult> {
        let url_ = this.baseUrl + "/api/paymentcallback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostProcessPayment(_response);
        });
    }

    protected processPostProcessPayment(response: Response): Promise<PostProcessPaymentRequestResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostProcessPaymentRequestResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PostProcessPaymentRequestResult>(null as any);
    }

    /**
     * @return OK
     */
    getInvoicePdf(orderNumber: string | null): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/order/customerOrders/invoice/{orderNumber}";
        if (orderNumber === undefined || orderNumber === null)
            throw new Error("The parameter 'orderNumber' must be defined.");
        url_ = url_.replace("{orderNumber}", encodeURIComponent("" + orderNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetInvoicePdf(_response);
        });
    }

    protected processGetInvoicePdf(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @return Success
     */
    getOrderChanges(id: string | null): Promise<OperationLog[]> {
        let url_ = this.baseUrl + "/api/order/customerOrders/{id}/changes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetOrderChanges(_response);
        });
    }

    protected processGetOrderChanges(response: Response): Promise<OperationLog[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OperationLog.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OperationLog[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchOrderChanges(body: CustomerOrderHistorySearchCriteria | undefined): Promise<ChangeLogSearchResult> {
        let url_ = this.baseUrl + "/api/order/customerOrders/searchChanges";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchOrderChanges(_response);
        });
    }

    protected processSearchOrderChanges(response: Response): Promise<ChangeLogSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChangeLogSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChangeLogSearchResult>(null as any);
    }

    /**
     * @return Success
     */
    getOrderFullTextSearchEnabled(): Promise<void> {
        let url_ = this.baseUrl + "/api/order/customerOrders/indexed/searchEnabled";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetOrderFullTextSearchEnabled(_response);
        });
    }

    protected processGetOrderFullTextSearchEnabled(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchCustomerOrderIndexed(body: CustomerOrderIndexedSearchCriteria | undefined): Promise<CustomerOrderSearchResult> {
        let url_ = this.baseUrl + "/api/order/customerOrders/indexed/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchCustomerOrderIndexed(_response);
        });
    }

    protected processSearchCustomerOrderIndexed(response: Response): Promise<CustomerOrderSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerOrderSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerOrderSearchResult>(null as any);
    }
}

export class OrderModulePaymentsClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchOrderPayments(body: PaymentSearchCriteria | undefined): Promise<PaymentSearchResult> {
        let url_ = this.baseUrl + "/api/order/payments/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchOrderPayments(_response);
        });
    }

    protected processSearchOrderPayments(response: Response): Promise<PaymentSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentSearchResult>(null as any);
    }

    /**
     * @param respGroup (optional) 
     * @return Success
     */
    getById(id: string | null, respGroup: string | null | undefined): Promise<PaymentIn> {
        let url_ = this.baseUrl + "/api/order/payments/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (respGroup !== undefined && respGroup !== null)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<PaymentIn> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentIn.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentIn>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPayment(body: PaymentIn | undefined): Promise<CustomerOrder> {
        let url_ = this.baseUrl + "/api/order/payments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreatePayment(_response);
        });
    }

    protected processCreatePayment(response: Response): Promise<CustomerOrder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerOrder.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerOrder>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePayment(body: PaymentIn | undefined): Promise<CustomerOrder> {
        let url_ = this.baseUrl + "/api/order/payments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdatePayment(_response);
        });
    }

    protected processUpdatePayment(response: Response): Promise<CustomerOrder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerOrder.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerOrder>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteOrderPaymentsByIds(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/order/payments?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteOrderPaymentsByIds(_response);
        });
    }

    protected processDeleteOrderPaymentsByIds(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class PaymentModuleClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRegisteredPaymentMethods(): Promise<PaymentMethod> {
        let url_ = this.baseUrl + "/api/payment";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRegisteredPaymentMethods(_response);
        });
    }

    protected processGetRegisteredPaymentMethods(response: Response): Promise<PaymentMethod> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentMethod.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentMethod>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePaymentMethod(body: PaymentMethod | undefined): Promise<PaymentMethod> {
        let url_ = this.baseUrl + "/api/payment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdatePaymentMethod(_response);
        });
    }

    protected processUpdatePaymentMethod(response: Response): Promise<PaymentMethod> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentMethod.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentMethod>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchPaymentMethods(body: PaymentMethodsSearchCriteria | undefined): Promise<PaymentMethodsSearchResult> {
        let url_ = this.baseUrl + "/api/payment/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchPaymentMethods(_response);
        });
    }

    protected processSearchPaymentMethods(response: Response): Promise<PaymentMethodsSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentMethodsSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentMethodsSearchResult>(null as any);
    }

    /**
     * @return Success
     */
    getPaymentMethodById(id: string | null): Promise<PaymentMethod> {
        let url_ = this.baseUrl + "/api/payment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPaymentMethodById(_response);
        });
    }

    protected processGetPaymentMethodById(response: Response): Promise<PaymentMethod> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentMethod.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentMethod>(null as any);
    }
}

export class PricingModuleClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    evaluatePrices(body: PriceEvaluationContext | undefined): Promise<Price[]> {
        let url_ = this.baseUrl + "/api/pricing/evaluate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processEvaluatePrices(_response);
        });
    }

    protected processEvaluatePrices(response: Response): Promise<Price[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Price.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Price[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    evaluatePriceLists(body: PriceEvaluationContext | undefined): Promise<Pricelist[]> {
        let url_ = this.baseUrl + "/api/pricing/pricelists/evaluate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processEvaluatePriceLists(_response);
        });
    }

    protected processEvaluatePriceLists(response: Response): Promise<Pricelist[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Pricelist.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Pricelist[]>(null as any);
    }

    /**
     * @return Success
     */
    getPricelistAssignmentById(id: string | null): Promise<PricelistAssignment> {
        let url_ = this.baseUrl + "/api/pricing/assignments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPricelistAssignmentById(_response);
        });
    }

    protected processGetPricelistAssignmentById(response: Response): Promise<PricelistAssignment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PricelistAssignment.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PricelistAssignment>(null as any);
    }

    /**
     * @return Success
     */
    getNewPricelistAssignments(): Promise<PricelistAssignment> {
        let url_ = this.baseUrl + "/api/pricing/assignments/new";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewPricelistAssignments(_response);
        });
    }

    protected processGetNewPricelistAssignments(response: Response): Promise<PricelistAssignment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PricelistAssignment.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PricelistAssignment>(null as any);
    }

    /**
     * @param currencies (optional) 
     * @param responseGroup (optional) 
     * @param objectType (optional) 
     * @param objectTypes (optional) 
     * @param objectIds (optional) 
     * @param keyword (optional) 
     * @param searchPhrase (optional) 
     * @param languageCode (optional) 
     * @param sort (optional) 
     * @param sortInfos (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @return Success
     */
    searchPricelists(currencies: string[] | null | undefined, responseGroup: string | null | undefined, objectType: string | null | undefined, objectTypes: string[] | null | undefined, objectIds: string[] | null | undefined, keyword: string | null | undefined, searchPhrase: string | null | undefined, languageCode: string | null | undefined, sort: string | null | undefined, sortInfos: SortInfo[] | null | undefined, skip: number | undefined, take: number | undefined): Promise<PricelistSearchResult> {
        let url_ = this.baseUrl + "/api/pricing/pricelists?";
        if (currencies !== undefined && currencies !== null)
            currencies && currencies.forEach(item => { url_ += "Currencies=" + encodeURIComponent("" + item) + "&"; });
        if (responseGroup !== undefined && responseGroup !== null)
            url_ += "ResponseGroup=" + encodeURIComponent("" + responseGroup) + "&";
        if (objectType !== undefined && objectType !== null)
            url_ += "ObjectType=" + encodeURIComponent("" + objectType) + "&";
        if (objectTypes !== undefined && objectTypes !== null)
            objectTypes && objectTypes.forEach(item => { url_ += "ObjectTypes=" + encodeURIComponent("" + item) + "&"; });
        if (objectIds !== undefined && objectIds !== null)
            objectIds && objectIds.forEach(item => { url_ += "ObjectIds=" + encodeURIComponent("" + item) + "&"; });
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (searchPhrase !== undefined && searchPhrase !== null)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (languageCode !== undefined && languageCode !== null)
            url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (sortInfos !== undefined && sortInfos !== null)
            sortInfos && sortInfos.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "SortInfos[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchPricelists(_response);
        });
    }

    protected processSearchPricelists(response: Response): Promise<PricelistSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PricelistSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PricelistSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPriceList(body: Pricelist | undefined): Promise<Pricelist> {
        let url_ = this.baseUrl + "/api/pricing/pricelists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreatePriceList(_response);
        });
    }

    protected processCreatePriceList(response: Response): Promise<Pricelist> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Pricelist.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Pricelist>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePriceList(body: Pricelist | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/pricing/pricelists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdatePriceList(_response);
        });
    }

    protected processUpdatePriceList(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deletePricelists(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/pricing/pricelists?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeletePricelists(_response);
        });
    }

    protected processDeletePricelists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param priceListId (optional) 
     * @param catalogIds (optional) 
     * @param storeIds (optional) 
     * @param priceListIds (optional) 
     * @param responseGroup (optional) 
     * @param objectType (optional) 
     * @param objectTypes (optional) 
     * @param objectIds (optional) 
     * @param keyword (optional) 
     * @param searchPhrase (optional) 
     * @param languageCode (optional) 
     * @param sort (optional) 
     * @param sortInfos (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @return Success
     */
    searchPricelistAssignments(priceListId: string | null | undefined, catalogIds: string[] | null | undefined, storeIds: string[] | null | undefined, priceListIds: string[] | null | undefined, responseGroup: string | null | undefined, objectType: string | null | undefined, objectTypes: string[] | null | undefined, objectIds: string[] | null | undefined, keyword: string | null | undefined, searchPhrase: string | null | undefined, languageCode: string | null | undefined, sort: string | null | undefined, sortInfos: SortInfo[] | null | undefined, skip: number | undefined, take: number | undefined): Promise<PricelistAssignmentSearchResult> {
        let url_ = this.baseUrl + "/api/pricing/assignments?";
        if (priceListId !== undefined && priceListId !== null)
            url_ += "PriceListId=" + encodeURIComponent("" + priceListId) + "&";
        if (catalogIds !== undefined && catalogIds !== null)
            catalogIds && catalogIds.forEach(item => { url_ += "CatalogIds=" + encodeURIComponent("" + item) + "&"; });
        if (storeIds !== undefined && storeIds !== null)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (priceListIds !== undefined && priceListIds !== null)
            priceListIds && priceListIds.forEach(item => { url_ += "PriceListIds=" + encodeURIComponent("" + item) + "&"; });
        if (responseGroup !== undefined && responseGroup !== null)
            url_ += "ResponseGroup=" + encodeURIComponent("" + responseGroup) + "&";
        if (objectType !== undefined && objectType !== null)
            url_ += "ObjectType=" + encodeURIComponent("" + objectType) + "&";
        if (objectTypes !== undefined && objectTypes !== null)
            objectTypes && objectTypes.forEach(item => { url_ += "ObjectTypes=" + encodeURIComponent("" + item) + "&"; });
        if (objectIds !== undefined && objectIds !== null)
            objectIds && objectIds.forEach(item => { url_ += "ObjectIds=" + encodeURIComponent("" + item) + "&"; });
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (searchPhrase !== undefined && searchPhrase !== null)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (languageCode !== undefined && languageCode !== null)
            url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (sortInfos !== undefined && sortInfos !== null)
            sortInfos && sortInfos.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "SortInfos[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchPricelistAssignments(_response);
        });
    }

    protected processSearchPricelistAssignments(response: Response): Promise<PricelistAssignmentSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PricelistAssignmentSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PricelistAssignmentSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPricelistAssignment(body: PricelistAssignment | undefined): Promise<PricelistAssignment> {
        let url_ = this.baseUrl + "/api/pricing/assignments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreatePricelistAssignment(_response);
        });
    }

    protected processCreatePricelistAssignment(response: Response): Promise<PricelistAssignment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PricelistAssignment.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PricelistAssignment>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePriceListAssignment(body: PricelistAssignment | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/pricing/assignments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdatePriceListAssignment(_response);
        });
    }

    protected processUpdatePriceListAssignment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteAssignments(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/pricing/assignments?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteAssignments(_response);
        });
    }

    protected processDeleteAssignments(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param groupByProducts (optional) 
     * @param priceListId (optional) 
     * @param priceListIds (optional) 
     * @param productId (optional) 
     * @param productIds (optional) 
     * @param modifiedSince (optional) 
     * @param responseGroup (optional) 
     * @param objectType (optional) 
     * @param objectTypes (optional) 
     * @param objectIds (optional) 
     * @param keyword (optional) 
     * @param searchPhrase (optional) 
     * @param languageCode (optional) 
     * @param sort (optional) 
     * @param sortInfos (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @return Success
     */
    searchProductPricesGet(groupByProducts: boolean | undefined, priceListId: string | null | undefined, priceListIds: string[] | null | undefined, productId: string | null | undefined, productIds: string[] | null | undefined, modifiedSince: Date | null | undefined, responseGroup: string | null | undefined, objectType: string | null | undefined, objectTypes: string[] | null | undefined, objectIds: string[] | null | undefined, keyword: string | null | undefined, searchPhrase: string | null | undefined, languageCode: string | null | undefined, sort: string | null | undefined, sortInfos: SortInfo[] | null | undefined, skip: number | undefined, take: number | undefined): Promise<ProductPriceSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/products/prices/search?";
        if (groupByProducts === null)
            throw new Error("The parameter 'groupByProducts' cannot be null.");
        else if (groupByProducts !== undefined)
            url_ += "GroupByProducts=" + encodeURIComponent("" + groupByProducts) + "&";
        if (priceListId !== undefined && priceListId !== null)
            url_ += "PriceListId=" + encodeURIComponent("" + priceListId) + "&";
        if (priceListIds !== undefined && priceListIds !== null)
            priceListIds && priceListIds.forEach(item => { url_ += "PriceListIds=" + encodeURIComponent("" + item) + "&"; });
        if (productId !== undefined && productId !== null)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (productIds !== undefined && productIds !== null)
            productIds && productIds.forEach(item => { url_ += "ProductIds=" + encodeURIComponent("" + item) + "&"; });
        if (modifiedSince !== undefined && modifiedSince !== null)
            url_ += "ModifiedSince=" + encodeURIComponent(modifiedSince ? "" + modifiedSince.toISOString() : "") + "&";
        if (responseGroup !== undefined && responseGroup !== null)
            url_ += "ResponseGroup=" + encodeURIComponent("" + responseGroup) + "&";
        if (objectType !== undefined && objectType !== null)
            url_ += "ObjectType=" + encodeURIComponent("" + objectType) + "&";
        if (objectTypes !== undefined && objectTypes !== null)
            objectTypes && objectTypes.forEach(item => { url_ += "ObjectTypes=" + encodeURIComponent("" + item) + "&"; });
        if (objectIds !== undefined && objectIds !== null)
            objectIds && objectIds.forEach(item => { url_ += "ObjectIds=" + encodeURIComponent("" + item) + "&"; });
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (searchPhrase !== undefined && searchPhrase !== null)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (languageCode !== undefined && languageCode !== null)
            url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (sortInfos !== undefined && sortInfos !== null)
            sortInfos && sortInfos.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "SortInfos[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchProductPricesGet(_response);
        });
    }

    protected processSearchProductPricesGet(response: Response): Promise<ProductPriceSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductPriceSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductPriceSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchProductPricesPost(body: PricesSearchCriteria | undefined): Promise<ProductPriceSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/products/prices/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchProductPricesPost(_response);
        });
    }

    protected processSearchProductPricesPost(response: Response): Promise<ProductPriceSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductPriceSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductPriceSearchResult>(null as any);
    }

    /**
     * @return Success
     */
    evaluateProductPrices(productId: string | null): Promise<Price[]> {
        let url_ = this.baseUrl + "/api/products/{productId}/prices";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processEvaluateProductPrices(_response);
        });
    }

    protected processEvaluateProductPrices(response: Response): Promise<Price[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Price.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Price[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProductPrices(productId: string, body: ProductPrice | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/products/{productId}/prices";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateProductPrices(_response);
        });
    }

    protected processUpdateProductPrices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    evaluateProductPricesForCatalog(productId: string | null, catalogId: string | null): Promise<Price[]> {
        let url_ = this.baseUrl + "/api/products/{productId}/{catalogId}/pricesWidget";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (catalogId === undefined || catalogId === null)
            throw new Error("The parameter 'catalogId' must be defined.");
        url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processEvaluateProductPricesForCatalog(_response);
        });
    }

    protected processEvaluateProductPricesForCatalog(response: Response): Promise<Price[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Price.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Price[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProductsPrices(body: ProductPrice[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/products/prices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateProductsPrices(_response);
        });
    }

    protected processUpdateProductsPrices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getProductPriceLists(productId: string | null): Promise<Pricelist[]> {
        let url_ = this.baseUrl + "/api/catalog/products/{productId}/pricelists";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProductPriceLists(_response);
        });
    }

    protected processGetProductPriceLists(response: Response): Promise<Pricelist[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Pricelist.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Pricelist[]>(null as any);
    }

    /**
     * @return Success
     */
    getPriceListById(id: string | null): Promise<Pricelist> {
        let url_ = this.baseUrl + "/api/pricing/pricelists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPriceListById(_response);
        });
    }

    protected processGetPriceListById(response: Response): Promise<Pricelist> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Pricelist.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Pricelist>(null as any);
    }

    /**
     * @return Success
     */
    getPriceListInShortById(id: string | null): Promise<Pricelist> {
        let url_ = this.baseUrl + "/api/pricing/pricelistsshort/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPriceListInShortById(_response);
        });
    }

    protected processGetPriceListInShortById(response: Response): Promise<Pricelist> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Pricelist.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Pricelist>(null as any);
    }

    /**
     * @param priceListId (optional) 
     * @param catalogIds (optional) 
     * @param storeIds (optional) 
     * @param priceListIds (optional) 
     * @param responseGroup (optional) 
     * @param objectType (optional) 
     * @param objectTypes (optional) 
     * @param objectIds (optional) 
     * @param keyword (optional) 
     * @param searchPhrase (optional) 
     * @param languageCode (optional) 
     * @param sort (optional) 
     * @param sortInfos (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @return Success
     */
    deleteFilteredAssignments(priceListId: string | null | undefined, catalogIds: string[] | null | undefined, storeIds: string[] | null | undefined, priceListIds: string[] | null | undefined, responseGroup: string | null | undefined, objectType: string | null | undefined, objectTypes: string[] | null | undefined, objectIds: string[] | null | undefined, keyword: string | null | undefined, searchPhrase: string | null | undefined, languageCode: string | null | undefined, sort: string | null | undefined, sortInfos: SortInfo[] | null | undefined, skip: number | undefined, take: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/pricing/filteredAssignments?";
        if (priceListId !== undefined && priceListId !== null)
            url_ += "PriceListId=" + encodeURIComponent("" + priceListId) + "&";
        if (catalogIds !== undefined && catalogIds !== null)
            catalogIds && catalogIds.forEach(item => { url_ += "CatalogIds=" + encodeURIComponent("" + item) + "&"; });
        if (storeIds !== undefined && storeIds !== null)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (priceListIds !== undefined && priceListIds !== null)
            priceListIds && priceListIds.forEach(item => { url_ += "PriceListIds=" + encodeURIComponent("" + item) + "&"; });
        if (responseGroup !== undefined && responseGroup !== null)
            url_ += "ResponseGroup=" + encodeURIComponent("" + responseGroup) + "&";
        if (objectType !== undefined && objectType !== null)
            url_ += "ObjectType=" + encodeURIComponent("" + objectType) + "&";
        if (objectTypes !== undefined && objectTypes !== null)
            objectTypes && objectTypes.forEach(item => { url_ += "ObjectTypes=" + encodeURIComponent("" + item) + "&"; });
        if (objectIds !== undefined && objectIds !== null)
            objectIds && objectIds.forEach(item => { url_ += "ObjectIds=" + encodeURIComponent("" + item) + "&"; });
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (searchPhrase !== undefined && searchPhrase !== null)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (languageCode !== undefined && languageCode !== null)
            url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (sortInfos !== undefined && sortInfos !== null)
            sortInfos && sortInfos.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "SortInfos[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteFilteredAssignments(_response);
        });
    }

    protected processDeleteFilteredAssignments(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param productIds (optional) 
     * @return Success
     */
    deleteProductPrices(pricelistId: string | null, productIds: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/pricing/pricelists/{pricelistId}/products/prices?";
        if (pricelistId === undefined || pricelistId === null)
            throw new Error("The parameter 'pricelistId' must be defined.");
        url_ = url_.replace("{pricelistId}", encodeURIComponent("" + pricelistId));
        if (productIds !== undefined && productIds !== null)
            productIds && productIds.forEach(item => { url_ += "productIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteProductPrices(_response);
        });
    }

    protected processDeleteProductPrices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param priceIds (optional) 
     * @return Success
     */
    deleteProductPrice(priceIds: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/pricing/products/prices?";
        if (priceIds !== undefined && priceIds !== null)
            priceIds && priceIds.forEach(item => { url_ += "priceIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteProductPrice(_response);
        });
    }

    protected processDeleteProductPrice(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class SearchIndexationModuleClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getIndices(): Promise<IndexState[]> {
        let url_ = this.baseUrl + "/api/search/indexes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetIndices(_response);
        });
    }

    protected processGetIndices(response: Response): Promise<IndexState[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IndexState.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IndexState[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllIndices(): Promise<IndexState[]> {
        let url_ = this.baseUrl + "/api/search/indexes/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAllIndices(_response);
        });
    }

    protected processGetAllIndices(response: Response): Promise<IndexState[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IndexState.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IndexState[]>(null as any);
    }

    /**
     * @return Success
     */
    getDocumentIndex(documentType: string | null, documentId: string | null): Promise<IndexDocument[]> {
        let url_ = this.baseUrl + "/api/search/indexes/index/{documentType}/{documentId}";
        if (documentType === undefined || documentType === null)
            throw new Error("The parameter 'documentType' must be defined.");
        url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType));
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDocumentIndex(_response);
        });
    }

    protected processGetDocumentIndex(response: Response): Promise<IndexDocument[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IndexDocument.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IndexDocument[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    indexDocuments(body: IndexingOptions[] | null | undefined): Promise<IndexProgressPushNotification> {
        let url_ = this.baseUrl + "/api/search/indexes/index";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processIndexDocuments(_response);
        });
    }

    protected processIndexDocuments(response: Response): Promise<IndexProgressPushNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IndexProgressPushNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IndexProgressPushNotification>(null as any);
    }

    /**
     * @return Success
     */
    cancelIndexationProcess(taskId: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/search/indexes/tasks/{taskId}/cancel";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCancelIndexationProcess(_response);
        });
    }

    protected processCancelIndexationProcess(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getSwapIndexSupported(): Promise<void> {
        let url_ = this.baseUrl + "/api/search/indexes/swapIndexSupported";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSwapIndexSupported(_response);
        });
    }

    protected processGetSwapIndexSupported(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    swapIndex(body: IndexingOptions | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/search/indexes/swapIndex";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSwapIndex(_response);
        });
    }

    protected processSwapIndex(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ShippingModuleClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRegisteredShippingMethods(): Promise<ShippingMethod> {
        let url_ = this.baseUrl + "/api/shipping";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRegisteredShippingMethods(_response);
        });
    }

    protected processGetRegisteredShippingMethods(response: Response): Promise<ShippingMethod> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShippingMethod.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShippingMethod>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateShippingMethod(body: ShippingMethod | undefined): Promise<ShippingMethod> {
        let url_ = this.baseUrl + "/api/shipping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateShippingMethod(_response);
        });
    }

    protected processUpdateShippingMethod(response: Response): Promise<ShippingMethod> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShippingMethod.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShippingMethod>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchShippingMethods(body: ShippingMethodsSearchCriteria | undefined): Promise<ShippingMethodsSearchResult> {
        let url_ = this.baseUrl + "/api/shipping/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchShippingMethods(_response);
        });
    }

    protected processSearchShippingMethods(response: Response): Promise<ShippingMethodsSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShippingMethodsSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShippingMethodsSearchResult>(null as any);
    }

    /**
     * @return Success
     */
    getShippingMethodById(id: string | null): Promise<ShippingMethod> {
        let url_ = this.baseUrl + "/api/shipping/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetShippingMethodById(_response);
        });
    }

    protected processGetShippingMethodById(response: Response): Promise<ShippingMethod> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShippingMethod.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShippingMethod>(null as any);
    }
}

export class SitemapsModuleApiClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchSitemaps(body: SitemapSearchCriteria | undefined): Promise<SitemapSearchResult> {
        let url_ = this.baseUrl + "/api/sitemaps/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchSitemaps(_response);
        });
    }

    protected processSearchSitemaps(response: Response): Promise<SitemapSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitemapSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SitemapSearchResult>(null as any);
    }

    /**
     * @return Success
     */
    getSitemapById(id: string | null): Promise<Sitemap> {
        let url_ = this.baseUrl + "/api/sitemaps/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSitemapById(_response);
        });
    }

    protected processGetSitemapById(response: Response): Promise<Sitemap> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Sitemap.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Sitemap>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addSitemap(body: Sitemap | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/sitemaps";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddSitemap(_response);
        });
    }

    protected processAddSitemap(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSitemap(body: Sitemap | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/sitemaps";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateSitemap(_response);
        });
    }

    protected processUpdateSitemap(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteSitemap(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/sitemaps?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteSitemap(_response);
        });
    }

    protected processDeleteSitemap(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchSitemapItems(body: SitemapItemSearchCriteria | undefined): Promise<SitemapItemsSearchResult> {
        let url_ = this.baseUrl + "/api/sitemaps/items/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchSitemapItems(_response);
        });
    }

    protected processSearchSitemapItems(response: Response): Promise<SitemapItemsSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitemapItemsSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SitemapItemsSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addSitemapItems(sitemapId: string | null, body: SitemapItem[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/sitemaps/{sitemapId}/items";
        if (sitemapId === undefined || sitemapId === null)
            throw new Error("The parameter 'sitemapId' must be defined.");
        url_ = url_.replace("{sitemapId}", encodeURIComponent("" + sitemapId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddSitemapItems(_response);
        });
    }

    protected processAddSitemapItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param itemIds (optional) 
     * @return Success
     */
    removeSitemapItems(itemIds: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/sitemaps/items?";
        if (itemIds !== undefined && itemIds !== null)
            itemIds && itemIds.forEach(item => { url_ += "itemIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRemoveSitemapItems(_response);
        });
    }

    protected processRemoveSitemapItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param storeId (optional) 
     * @return Success
     */
    getSitemapsSchema(storeId: string | null | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/sitemaps/schema?";
        if (storeId !== undefined && storeId !== null)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSitemapsSchema(_response);
        });
    }

    protected processGetSitemapsSchema(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param storeId (optional) 
     * @param baseUrl (optional) 
     * @param sitemapUrl (optional) 
     * @return OK
     */
    generateSitemap(storeId: string | null | undefined, baseUrl: string | null | undefined, sitemapUrl: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/sitemaps/generate?";
        if (storeId !== undefined && storeId !== null)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        if (baseUrl !== undefined && baseUrl !== null)
            url_ += "baseUrl=" + encodeURIComponent("" + baseUrl) + "&";
        if (sitemapUrl !== undefined && sitemapUrl !== null)
            url_ += "sitemapUrl=" + encodeURIComponent("" + sitemapUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGenerateSitemap(_response);
        });
    }

    protected processGenerateSitemap(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @param storeId (optional) 
     * @param baseUrl (optional) 
     * @return Success
     */
    downloadSitemap(storeId: string | null | undefined, baseUrl: string | null | undefined): Promise<SitemapDownloadNotification> {
        let url_ = this.baseUrl + "/api/sitemaps/download?";
        if (storeId !== undefined && storeId !== null)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        if (baseUrl !== undefined && baseUrl !== null)
            url_ += "baseUrl=" + encodeURIComponent("" + baseUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDownloadSitemap(_response);
        });
    }

    protected processDownloadSitemap(response: Response): Promise<SitemapDownloadNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitemapDownloadNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SitemapDownloadNotification>(null as any);
    }
}

export class StoreModuleClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchStores(body: StoreSearchCriteria | undefined): Promise<StoreSearchResult> {
        let url_ = this.baseUrl + "/api/stores/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchStores(_response);
        });
    }

    protected processSearchStores(response: Response): Promise<StoreSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoreSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StoreSearchResult>(null as any);
    }

    /**
     * @return Success
     */
    getStoreById(id: string | null): Promise<Store> {
        let url_ = this.baseUrl + "/api/stores/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetStoreById(_response);
        });
    }

    protected processGetStoreById(response: Response): Promise<Store> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Store.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Store>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createStore(body: Store | undefined): Promise<Store> {
        let url_ = this.baseUrl + "/api/stores";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateStore(_response);
        });
    }

    protected processCreateStore(response: Response): Promise<Store> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Store.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Store>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateStore(body: Store | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/stores";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateStore(_response);
        });
    }

    protected processUpdateStore(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteStore(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/stores?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteStore(_response);
        });
    }

    protected processDeleteStore(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendDynamicNotificationAnStoreEmail(body: SendDynamicNotificationRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/stores/send/dynamicnotification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendDynamicNotificationAnStoreEmail(_response);
        });
    }

    protected processSendDynamicNotificationAnStoreEmail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getLoginOnBehalfInfo(storeId: string | null, id: string | null): Promise<LoginOnBehalfInfo> {
        let url_ = this.baseUrl + "/api/stores/{storeId}/accounts/{id}/loginonbehalf";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetLoginOnBehalfInfo(_response);
        });
    }

    protected processGetLoginOnBehalfInfo(response: Response): Promise<LoginOnBehalfInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginOnBehalfInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginOnBehalfInfo>(null as any);
    }

    /**
     * @return Success
     */
    getUserAllowedStores(userId: string | null): Promise<Store[]> {
        let url_ = this.baseUrl + "/api/stores/allowed/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserAllowedStores(_response);
        });
    }

    protected processGetUserAllowedStores(response: Response): Promise<Store[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Store.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Store[]>(null as any);
    }
}

export class TaxModuleClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchTaxProviders(body: TaxProviderSearchCriteria | undefined): Promise<TaxProviderSearchResult> {
        let url_ = this.baseUrl + "/api/taxes/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchTaxProviders(_response);
        });
    }

    protected processSearchTaxProviders(response: Response): Promise<TaxProviderSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaxProviderSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaxProviderSearchResult>(null as any);
    }

    /**
     * @return Success
     */
    getTaxProviderById(id: string | null): Promise<TaxProviderSearchResult> {
        let url_ = this.baseUrl + "/api/taxes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTaxProviderById(_response);
        });
    }

    protected processGetTaxProviderById(response: Response): Promise<TaxProviderSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaxProviderSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaxProviderSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTaxProvider(body: TaxProvider | undefined): Promise<TaxProvider> {
        let url_ = this.baseUrl + "/api/taxes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateTaxProvider(_response);
        });
    }

    protected processUpdateTaxProvider(response: Response): Promise<TaxProvider> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaxProvider.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaxProvider>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    evaluateTaxes(storeId: string | null, body: TaxEvaluationContext | undefined): Promise<TaxRate[]> {
        let url_ = this.baseUrl + "/api/taxes/{storeId}/evaluate";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processEvaluateTaxes(_response);
        });
    }

    protected processEvaluateTaxes(response: Response): Promise<TaxRate[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaxRate.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaxRate[]>(null as any);
    }
}

export class WebHooksClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getWebhookById(id: string | null): Promise<Webhook> {
        let url_ = this.baseUrl + "/api/webhooks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetWebhookById(_response);
        });
    }

    protected processGetWebhookById(response: Response): Promise<Webhook> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Webhook.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Webhook>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    search(body: WebhookSearchCriteria | undefined): Promise<WebhookSearchResult> {
        let url_ = this.baseUrl + "/api/webhooks/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<WebhookSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebhookSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WebhookSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchWebhookFeed(body: WebhookFeedSearchCriteria | undefined): Promise<WebHookFeedSearchResult> {
        let url_ = this.baseUrl + "/api/webhooks/feed/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchWebhookFeed(_response);
        });
    }

    protected processSearchWebhookFeed(response: Response): Promise<WebHookFeedSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebHookFeedSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WebHookFeedSearchResult>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteWebHookFeeds(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/webhooks/feed?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteWebHookFeeds(_response);
        });
    }

    protected processDeleteWebHookFeeds(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveWebhooks(body: Webhook[] | null | undefined): Promise<Webhook[]> {
        let url_ = this.baseUrl + "/api/webhooks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSaveWebhooks(_response);
        });
    }

    protected processSaveWebhooks(response: Response): Promise<Webhook[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Webhook.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Webhook[]>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteWebHooks(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/webhooks?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteWebHooks(_response);
        });
    }

    protected processDeleteWebHooks(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    run(body: Webhook | undefined): Promise<WebhookSendResponse> {
        let url_ = this.baseUrl + "/api/webhooks/send";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRun(_response);
        });
    }

    protected processRun(response: Response): Promise<WebhookSendResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebhookSendResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WebhookSendResponse>(null as any);
    }

    /**
     * @return Success
     */
    getAllRegisteredEvents(): Promise<RegisteredEvent[]> {
        let url_ = this.baseUrl + "/api/webhooks/events";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAllRegisteredEvents(_response);
        });
    }

    protected processGetAllRegisteredEvents(response: Response): Promise<RegisteredEvent[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RegisteredEvent.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RegisteredEvent[]>(null as any);
    }

    /**
     * @param objectType (optional) 
     * @return Success
     */
    getEventObjectProperties(objectType: string | null | undefined): Promise<EventObjectProperties> {
        let url_ = this.baseUrl + "/api/webhooks/properties?";
        if (objectType !== undefined && objectType !== null)
            url_ += "objectType=" + encodeURIComponent("" + objectType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEventObjectProperties(_response);
        });
    }

    protected processGetEventObjectProperties(response: Response): Promise<EventObjectProperties> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventObjectProperties.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EventObjectProperties>(null as any);
    }
}

export class OpenIddictResponse implements IOpenIddictResponse {
    accessToken?: string | undefined;
    code?: string | undefined;
    deviceCode?: string | undefined;
    error?: string | undefined;
    errorDescription?: string | undefined;
    errorUri?: string | undefined;
    expiresIn?: number | undefined;
    idToken?: string | undefined;
    refreshToken?: string | undefined;
    scope?: string | undefined;
    state?: string | undefined;
    tokenType?: string | undefined;
    userCode?: string | undefined;
    readonly count?: number;

    constructor(data?: IOpenIddictResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.code = _data["code"];
            this.deviceCode = _data["deviceCode"];
            this.error = _data["error"];
            this.errorDescription = _data["errorDescription"];
            this.errorUri = _data["errorUri"];
            this.expiresIn = _data["expiresIn"];
            this.idToken = _data["idToken"];
            this.refreshToken = _data["refreshToken"];
            this.scope = _data["scope"];
            this.state = _data["state"];
            this.tokenType = _data["tokenType"];
            this.userCode = _data["userCode"];
            (<any>this).count = _data["count"];
        }
    }

    static fromJS(data: any): OpenIddictResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OpenIddictResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["code"] = this.code;
        data["deviceCode"] = this.deviceCode;
        data["error"] = this.error;
        data["errorDescription"] = this.errorDescription;
        data["errorUri"] = this.errorUri;
        data["expiresIn"] = this.expiresIn;
        data["idToken"] = this.idToken;
        data["refreshToken"] = this.refreshToken;
        data["scope"] = this.scope;
        data["state"] = this.state;
        data["tokenType"] = this.tokenType;
        data["userCode"] = this.userCode;
        data["count"] = this.count;
        return data;
    }
}

export interface IOpenIddictResponse {
    accessToken?: string | undefined;
    code?: string | undefined;
    deviceCode?: string | undefined;
    error?: string | undefined;
    errorDescription?: string | undefined;
    errorUri?: string | undefined;
    expiresIn?: number | undefined;
    idToken?: string | undefined;
    refreshToken?: string | undefined;
    scope?: string | undefined;
    state?: string | undefined;
    tokenType?: string | undefined;
    userCode?: string | undefined;
    count?: number;
}

export class LastModifiedResponse implements ILastModifiedResponse {
    scope?: string | undefined;
    lastModifiedDate?: Date;

    constructor(data?: ILastModifiedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scope = _data["scope"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LastModifiedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LastModifiedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scope"] = this.scope;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ILastModifiedResponse {
    scope?: string | undefined;
    lastModifiedDate?: Date;
}

export class ChangedEntitiesRequest implements IChangedEntitiesRequest {
    entityNames?: string[] | undefined;
    modifiedSince?: Date;

    constructor(data?: IChangedEntitiesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entityNames"])) {
                this.entityNames = [] as any;
                for (let item of _data["entityNames"])
                    this.entityNames!.push(item);
            }
            this.modifiedSince = _data["modifiedSince"] ? new Date(_data["modifiedSince"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ChangedEntitiesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangedEntitiesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entityNames)) {
            data["entityNames"] = [];
            for (let item of this.entityNames)
                data["entityNames"].push(item);
        }
        data["modifiedSince"] = this.modifiedSince ? this.modifiedSince.toISOString() : <any>undefined;
        return data;
    }
}

export interface IChangedEntitiesRequest {
    entityNames?: string[] | undefined;
    modifiedSince?: Date;
}

export class ChangedEntity implements IChangedEntity {
    name?: string | undefined;
    modifiedDate?: Date;

    constructor(data?: IChangedEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ChangedEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ChangedEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IChangedEntity {
    name?: string | undefined;
    modifiedDate?: Date;
}

export class ChangedEntitiesResponse implements IChangedEntitiesResponse {
    entities?: ChangedEntity[] | undefined;

    constructor(data?: IChangedEntitiesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entities"])) {
                this.entities = [] as any;
                for (let item of _data["entities"])
                    this.entities!.push(ChangedEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChangedEntitiesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChangedEntitiesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entities)) {
            data["entities"] = [];
            for (let item of this.entities)
                data["entities"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChangedEntitiesResponse {
    entities?: ChangedEntity[] | undefined;
}

export enum EntryState {
    Detached = "Detached",
    Unchanged = "Unchanged",
    Added = "Added",
    Deleted = "Deleted",
    Modified = "Modified",
}

export enum SortDirection {
    Ascending = "Ascending",
    Descending = "Descending",
}

export class SortInfo implements ISortInfo {
    sortColumn?: string | undefined;
    sortDirection?: SortDirection;

    constructor(data?: ISortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sortColumn = _data["sortColumn"];
            this.sortDirection = _data["sortDirection"];
        }
    }

    static fromJS(data: any): SortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sortColumn"] = this.sortColumn;
        data["sortDirection"] = this.sortDirection;
        return data;
    }
}

export interface ISortInfo {
    sortColumn?: string | undefined;
    sortDirection?: SortDirection;
}

export class ChangeLogSearchCriteria implements IChangeLogSearchCriteria {
    operationTypes?: EntryState[] | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IChangeLogSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["operationTypes"])) {
                this.operationTypes = [] as any;
                for (let item of _data["operationTypes"])
                    this.operationTypes!.push(item);
            }
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): ChangeLogSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeLogSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.operationTypes)) {
            data["operationTypes"] = [];
            for (let item of this.operationTypes)
                data["operationTypes"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IChangeLogSearchCriteria {
    operationTypes?: EntryState[] | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class OperationLog implements IOperationLog {
    objectType?: string | undefined;
    objectId?: string | undefined;
    operationType?: EntryState;
    detail?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IOperationLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectType = _data["objectType"];
            this.objectId = _data["objectId"];
            this.operationType = _data["operationType"];
            this.detail = _data["detail"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OperationLog {
        data = typeof data === 'object' ? data : {};
        let result = new OperationLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectType"] = this.objectType;
        data["objectId"] = this.objectId;
        data["operationType"] = this.operationType;
        data["detail"] = this.detail;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IOperationLog {
    objectType?: string | undefined;
    objectId?: string | undefined;
    operationType?: EntryState;
    detail?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ChangeLogSearchResult implements IChangeLogSearchResult {
    totalCount?: number;
    results?: OperationLog[] | undefined;

    constructor(data?: IChangeLogSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(OperationLog.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChangeLogSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeLogSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChangeLogSearchResult {
    totalCount?: number;
    results?: OperationLog[] | undefined;
}

export class License implements ILicense {
    type?: string | undefined;
    customerName?: string | undefined;
    customerEmail?: string | undefined;
    expirationDate?: Date;
    rawLicense?: string | undefined;

    constructor(data?: ILicense) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.customerName = _data["customerName"];
            this.customerEmail = _data["customerEmail"];
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.rawLicense = _data["rawLicense"];
        }
    }

    static fromJS(data: any): License {
        data = typeof data === 'object' ? data : {};
        let result = new License();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["customerName"] = this.customerName;
        data["customerEmail"] = this.customerEmail;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["rawLicense"] = this.rawLicense;
        return data;
    }
}

export interface ILicense {
    type?: string | undefined;
    customerName?: string | undefined;
    customerEmail?: string | undefined;
    expirationDate?: Date;
    rawLicense?: string | undefined;
}

export class SemanticVersion implements ISemanticVersion {
    readonly major?: number;
    readonly minor?: number;
    readonly patch?: number;
    readonly prerelease?: string | undefined;

    constructor(data?: ISemanticVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).major = _data["major"];
            (<any>this).minor = _data["minor"];
            (<any>this).patch = _data["patch"];
            (<any>this).prerelease = _data["prerelease"];
        }
    }

    static fromJS(data: any): SemanticVersion {
        data = typeof data === 'object' ? data : {};
        let result = new SemanticVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["major"] = this.major;
        data["minor"] = this.minor;
        data["patch"] = this.patch;
        data["prerelease"] = this.prerelease;
        return data;
    }
}

export interface ISemanticVersion {
    major?: number;
    minor?: number;
    patch?: number;
    prerelease?: string | undefined;
}

export class ModuleIdentity implements IModuleIdentity {
    id?: string | undefined;
    version?: SemanticVersion;

    constructor(data?: IModuleIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.version = _data["version"] ? SemanticVersion.fromJS(_data["version"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["version"] = this.version ? this.version.toJSON() : <any>undefined;
        return data;
    }
}

export interface IModuleIdentity {
    id?: string | undefined;
    version?: SemanticVersion;
}

export class ModuleDescriptor implements IModuleDescriptor {
    version?: string | undefined;
    platformVersion?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    authors?: string[] | undefined;
    owners?: string[] | undefined;
    licenseUrl?: string | undefined;
    projectUrl?: string | undefined;
    iconUrl?: string | undefined;
    requireLicenseAcceptance?: boolean;
    releaseNotes?: string | undefined;
    copyright?: string | undefined;
    tags?: string | undefined;
    groups?: string[] | undefined;
    dependencies?: ModuleIdentity[] | undefined;
    validationErrors?: string[] | undefined;
    isRemovable?: boolean;
    isInstalled?: boolean;
    installedVersion?: ModuleIdentity;
    id?: string | undefined;

    constructor(data?: IModuleDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.platformVersion = _data["platformVersion"];
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["authors"])) {
                this.authors = [] as any;
                for (let item of _data["authors"])
                    this.authors!.push(item);
            }
            if (Array.isArray(_data["owners"])) {
                this.owners = [] as any;
                for (let item of _data["owners"])
                    this.owners!.push(item);
            }
            this.licenseUrl = _data["licenseUrl"];
            this.projectUrl = _data["projectUrl"];
            this.iconUrl = _data["iconUrl"];
            this.requireLicenseAcceptance = _data["requireLicenseAcceptance"];
            this.releaseNotes = _data["releaseNotes"];
            this.copyright = _data["copyright"];
            this.tags = _data["tags"];
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            if (Array.isArray(_data["dependencies"])) {
                this.dependencies = [] as any;
                for (let item of _data["dependencies"])
                    this.dependencies!.push(ModuleIdentity.fromJS(item));
            }
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            this.isRemovable = _data["isRemovable"];
            this.isInstalled = _data["isInstalled"];
            this.installedVersion = _data["installedVersion"] ? ModuleIdentity.fromJS(_data["installedVersion"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ModuleDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["platformVersion"] = this.platformVersion;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.authors)) {
            data["authors"] = [];
            for (let item of this.authors)
                data["authors"].push(item);
        }
        if (Array.isArray(this.owners)) {
            data["owners"] = [];
            for (let item of this.owners)
                data["owners"].push(item);
        }
        data["licenseUrl"] = this.licenseUrl;
        data["projectUrl"] = this.projectUrl;
        data["iconUrl"] = this.iconUrl;
        data["requireLicenseAcceptance"] = this.requireLicenseAcceptance;
        data["releaseNotes"] = this.releaseNotes;
        data["copyright"] = this.copyright;
        data["tags"] = this.tags;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        if (Array.isArray(this.dependencies)) {
            data["dependencies"] = [];
            for (let item of this.dependencies)
                data["dependencies"].push(item.toJSON());
        }
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        data["isRemovable"] = this.isRemovable;
        data["isInstalled"] = this.isInstalled;
        data["installedVersion"] = this.installedVersion ? this.installedVersion.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IModuleDescriptor {
    version?: string | undefined;
    platformVersion?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    authors?: string[] | undefined;
    owners?: string[] | undefined;
    licenseUrl?: string | undefined;
    projectUrl?: string | undefined;
    iconUrl?: string | undefined;
    requireLicenseAcceptance?: boolean;
    releaseNotes?: string | undefined;
    copyright?: string | undefined;
    tags?: string | undefined;
    groups?: string[] | undefined;
    dependencies?: ModuleIdentity[] | undefined;
    validationErrors?: string[] | undefined;
    isRemovable?: boolean;
    isInstalled?: boolean;
    installedVersion?: ModuleIdentity;
    id?: string | undefined;
}

export class SystemInfo implements ISystemInfo {
    platformVersion?: string | undefined;
    license?: License;
    installedModules?: ModuleDescriptor[] | undefined;
    version?: string | undefined;
    is64BitOperatingSystem?: boolean;
    is64BitProcess?: boolean;

    constructor(data?: ISystemInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.platformVersion = _data["platformVersion"];
            this.license = _data["license"] ? License.fromJS(_data["license"]) : <any>undefined;
            if (Array.isArray(_data["installedModules"])) {
                this.installedModules = [] as any;
                for (let item of _data["installedModules"])
                    this.installedModules!.push(ModuleDescriptor.fromJS(item));
            }
            this.version = _data["version"];
            this.is64BitOperatingSystem = _data["is64BitOperatingSystem"];
            this.is64BitProcess = _data["is64BitProcess"];
        }
    }

    static fromJS(data: any): SystemInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SystemInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["platformVersion"] = this.platformVersion;
        data["license"] = this.license ? this.license.toJSON() : <any>undefined;
        if (Array.isArray(this.installedModules)) {
            data["installedModules"] = [];
            for (let item of this.installedModules)
                data["installedModules"].push(item.toJSON());
        }
        data["version"] = this.version;
        data["is64BitOperatingSystem"] = this.is64BitOperatingSystem;
        data["is64BitProcess"] = this.is64BitProcess;
        return data;
    }
}

export interface ISystemInfo {
    platformVersion?: string | undefined;
    license?: License;
    installedModules?: ModuleDescriptor[] | undefined;
    version?: string | undefined;
    is64BitOperatingSystem?: boolean;
    is64BitProcess?: boolean;
}

export class DynamicPropertySearchCriteria implements IDynamicPropertySearchCriteria {
    readonly typeName?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IDynamicPropertySearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).typeName = _data["typeName"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): DynamicPropertySearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertySearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IDynamicPropertySearchCriteria {
    typeName?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export enum DynamicPropertyValueType {
    Undefined = "Undefined",
    ShortText = "ShortText",
    LongText = "LongText",
    Integer = "Integer",
    Decimal = "Decimal",
    DateTime = "DateTime",
    Boolean = "Boolean",
    Html = "Html",
    Image = "Image",
}

export class DynamicPropertyName implements IDynamicPropertyName {
    locale?: string | undefined;
    name?: string | undefined;

    constructor(data?: IDynamicPropertyName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locale = _data["locale"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DynamicPropertyName {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locale"] = this.locale;
        data["name"] = this.name;
        return data;
    }
}

export interface IDynamicPropertyName {
    locale?: string | undefined;
    name?: string | undefined;
}

export class DynamicProperty implements IDynamicProperty {
    name?: string | undefined;
    description?: string | undefined;
    objectType?: string | undefined;
    isArray?: boolean;
    isDictionary?: boolean;
    isMultilingual?: boolean;
    isRequired?: boolean;
    displayOrder?: number | undefined;
    valueType?: DynamicPropertyValueType;
    displayNames?: DynamicPropertyName[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.objectType = _data["objectType"];
            this.isArray = _data["isArray"];
            this.isDictionary = _data["isDictionary"];
            this.isMultilingual = _data["isMultilingual"];
            this.isRequired = _data["isRequired"];
            this.displayOrder = _data["displayOrder"];
            this.valueType = _data["valueType"];
            if (Array.isArray(_data["displayNames"])) {
                this.displayNames = [] as any;
                for (let item of _data["displayNames"])
                    this.displayNames!.push(DynamicPropertyName.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicProperty {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["objectType"] = this.objectType;
        data["isArray"] = this.isArray;
        data["isDictionary"] = this.isDictionary;
        data["isMultilingual"] = this.isMultilingual;
        data["isRequired"] = this.isRequired;
        data["displayOrder"] = this.displayOrder;
        data["valueType"] = this.valueType;
        if (Array.isArray(this.displayNames)) {
            data["displayNames"] = [];
            for (let item of this.displayNames)
                data["displayNames"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicProperty {
    name?: string | undefined;
    description?: string | undefined;
    objectType?: string | undefined;
    isArray?: boolean;
    isDictionary?: boolean;
    isMultilingual?: boolean;
    isRequired?: boolean;
    displayOrder?: number | undefined;
    valueType?: DynamicPropertyValueType;
    displayNames?: DynamicPropertyName[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicPropertySearchResult implements IDynamicPropertySearchResult {
    totalCount?: number;
    results?: DynamicProperty[] | undefined;

    constructor(data?: IDynamicPropertySearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(DynamicProperty.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicPropertySearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertySearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDynamicPropertySearchResult {
    totalCount?: number;
    results?: DynamicProperty[] | undefined;
}

export class DynamicPropertyObjectValue implements IDynamicPropertyObjectValue {
    objectType?: string | undefined;
    objectId?: string | undefined;
    locale?: string | undefined;
    value?: any | undefined;
    valueId?: string | undefined;
    valueType?: DynamicPropertyValueType;
    propertyId?: string | undefined;
    propertyName?: string | undefined;

    constructor(data?: IDynamicPropertyObjectValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectType = _data["objectType"];
            this.objectId = _data["objectId"];
            this.locale = _data["locale"];
            this.value = _data["value"];
            this.valueId = _data["valueId"];
            this.valueType = _data["valueType"];
            this.propertyId = _data["propertyId"];
            this.propertyName = _data["propertyName"];
        }
    }

    static fromJS(data: any): DynamicPropertyObjectValue {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyObjectValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectType"] = this.objectType;
        data["objectId"] = this.objectId;
        data["locale"] = this.locale;
        data["value"] = this.value;
        data["valueId"] = this.valueId;
        data["valueType"] = this.valueType;
        data["propertyId"] = this.propertyId;
        data["propertyName"] = this.propertyName;
        return data;
    }
}

export interface IDynamicPropertyObjectValue {
    objectType?: string | undefined;
    objectId?: string | undefined;
    locale?: string | undefined;
    value?: any | undefined;
    valueId?: string | undefined;
    valueType?: DynamicPropertyValueType;
    propertyId?: string | undefined;
    propertyName?: string | undefined;
}

export class DynamicObjectProperty implements IDynamicObjectProperty {
    objectId?: string | undefined;
    values?: DynamicPropertyObjectValue[] | undefined;
    name?: string | undefined;
    description?: string | undefined;
    objectType?: string | undefined;
    isArray?: boolean;
    isDictionary?: boolean;
    isMultilingual?: boolean;
    isRequired?: boolean;
    displayOrder?: number | undefined;
    valueType?: DynamicPropertyValueType;
    displayNames?: DynamicPropertyName[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicObjectProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectId = _data["objectId"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(DynamicPropertyObjectValue.fromJS(item));
            }
            this.name = _data["name"];
            this.description = _data["description"];
            this.objectType = _data["objectType"];
            this.isArray = _data["isArray"];
            this.isDictionary = _data["isDictionary"];
            this.isMultilingual = _data["isMultilingual"];
            this.isRequired = _data["isRequired"];
            this.displayOrder = _data["displayOrder"];
            this.valueType = _data["valueType"];
            if (Array.isArray(_data["displayNames"])) {
                this.displayNames = [] as any;
                for (let item of _data["displayNames"])
                    this.displayNames!.push(DynamicPropertyName.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicObjectProperty {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicObjectProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectId"] = this.objectId;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["description"] = this.description;
        data["objectType"] = this.objectType;
        data["isArray"] = this.isArray;
        data["isDictionary"] = this.isDictionary;
        data["isMultilingual"] = this.isMultilingual;
        data["isRequired"] = this.isRequired;
        data["displayOrder"] = this.displayOrder;
        data["valueType"] = this.valueType;
        if (Array.isArray(this.displayNames)) {
            data["displayNames"] = [];
            for (let item of this.displayNames)
                data["displayNames"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicObjectProperty {
    objectId?: string | undefined;
    values?: DynamicPropertyObjectValue[] | undefined;
    name?: string | undefined;
    description?: string | undefined;
    objectType?: string | undefined;
    isArray?: boolean;
    isDictionary?: boolean;
    isMultilingual?: boolean;
    isRequired?: boolean;
    displayOrder?: number | undefined;
    valueType?: DynamicPropertyValueType;
    displayNames?: DynamicPropertyName[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicPropertyDictionaryItemSearchCriteria implements IDynamicPropertyDictionaryItemSearchCriteria {
    propertyId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IDynamicPropertyDictionaryItemSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): DynamicPropertyDictionaryItemSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyDictionaryItemSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IDynamicPropertyDictionaryItemSearchCriteria {
    propertyId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class DynamicPropertyDictionaryItemName implements IDynamicPropertyDictionaryItemName {
    locale?: string | undefined;
    name?: string | undefined;

    constructor(data?: IDynamicPropertyDictionaryItemName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locale = _data["locale"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DynamicPropertyDictionaryItemName {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyDictionaryItemName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locale"] = this.locale;
        data["name"] = this.name;
        return data;
    }
}

export interface IDynamicPropertyDictionaryItemName {
    locale?: string | undefined;
    name?: string | undefined;
}

export class DynamicPropertyDictionaryItem implements IDynamicPropertyDictionaryItem {
    propertyId?: string | undefined;
    name?: string | undefined;
    displayNames?: DynamicPropertyDictionaryItemName[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicPropertyDictionaryItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.name = _data["name"];
            if (Array.isArray(_data["displayNames"])) {
                this.displayNames = [] as any;
                for (let item of _data["displayNames"])
                    this.displayNames!.push(DynamicPropertyDictionaryItemName.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicPropertyDictionaryItem {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyDictionaryItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["name"] = this.name;
        if (Array.isArray(this.displayNames)) {
            data["displayNames"] = [];
            for (let item of this.displayNames)
                data["displayNames"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicPropertyDictionaryItem {
    propertyId?: string | undefined;
    name?: string | undefined;
    displayNames?: DynamicPropertyDictionaryItemName[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicPropertyDictionaryItemSearchResult implements IDynamicPropertyDictionaryItemSearchResult {
    totalCount?: number;
    results?: DynamicPropertyDictionaryItem[] | undefined;

    constructor(data?: IDynamicPropertyDictionaryItemSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(DynamicPropertyDictionaryItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicPropertyDictionaryItemSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyDictionaryItemSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDynamicPropertyDictionaryItemSearchResult {
    totalCount?: number;
    results?: DynamicPropertyDictionaryItem[] | undefined;
}

export class Job implements IJob {
    state?: string | undefined;
    completed?: boolean;
    id?: string | undefined;

    constructor(data?: IJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.completed = _data["completed"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Job {
        data = typeof data === 'object' ? data : {};
        let result = new Job();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["completed"] = this.completed;
        data["id"] = this.id;
        return data;
    }
}

export interface IJob {
    state?: string | undefined;
    completed?: boolean;
    id?: string | undefined;
}

export enum ProgressMessageLevel {
    Info = "Info",
    Warning = "Warning",
    Debug = "Debug",
    Error = "Error",
}

export class ProgressMessage implements IProgressMessage {
    message?: string | undefined;
    level?: ProgressMessageLevel;

    constructor(data?: IProgressMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.level = _data["level"];
        }
    }

    static fromJS(data: any): ProgressMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ProgressMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["level"] = this.level;
        return data;
    }
}

export interface IProgressMessage {
    message?: string | undefined;
    level?: ProgressMessageLevel;
}

export class ModulePushNotification implements IModulePushNotification {
    started?: Date | undefined;
    finished?: Date | undefined;
    progressLog?: ProgressMessage[] | undefined;
    readonly errorCount?: number;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IModulePushNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            if (Array.isArray(_data["progressLog"])) {
                this.progressLog = [] as any;
                for (let item of _data["progressLog"])
                    this.progressLog!.push(ProgressMessage.fromJS(item));
            }
            (<any>this).errorCount = _data["errorCount"];
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ModulePushNotification {
        data = typeof data === 'object' ? data : {};
        let result = new ModulePushNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        if (Array.isArray(this.progressLog)) {
            data["progressLog"] = [];
            for (let item of this.progressLog)
                data["progressLog"].push(item.toJSON());
        }
        data["errorCount"] = this.errorCount;
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data;
    }
}

export interface IModulePushNotification {
    started?: Date | undefined;
    finished?: Date | undefined;
    progressLog?: ProgressMessage[] | undefined;
    errorCount?: number;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export class ModuleAutoInstallPushNotification implements IModuleAutoInstallPushNotification {
    started?: Date | undefined;
    finished?: Date | undefined;
    progressLog?: ProgressMessage[] | undefined;
    readonly errorCount?: number;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IModuleAutoInstallPushNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            if (Array.isArray(_data["progressLog"])) {
                this.progressLog = [] as any;
                for (let item of _data["progressLog"])
                    this.progressLog!.push(ProgressMessage.fromJS(item));
            }
            (<any>this).errorCount = _data["errorCount"];
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ModuleAutoInstallPushNotification {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleAutoInstallPushNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        if (Array.isArray(this.progressLog)) {
            data["progressLog"] = [];
            for (let item of this.progressLog)
                data["progressLog"].push(item.toJSON());
        }
        data["errorCount"] = this.errorCount;
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data;
    }
}

export interface IModuleAutoInstallPushNotification {
    started?: Date | undefined;
    finished?: Date | undefined;
    progressLog?: ProgressMessage[] | undefined;
    errorCount?: number;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export enum JsonValueKind {
    Undefined = "Undefined",
    Object = "Object",
    Array = "Array",
    String = "String",
    Number = "Number",
    True = "True",
    False = "False",
    Null = "Null",
}

export class JsonElement implements IJsonElement {
    valueKind?: JsonValueKind;

    constructor(data?: IJsonElement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.valueKind = _data["valueKind"];
        }
    }

    static fromJS(data: any): JsonElement {
        data = typeof data === 'object' ? data : {};
        let result = new JsonElement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valueKind"] = this.valueKind;
        return data;
    }
}

export interface IJsonElement {
    valueKind?: JsonValueKind;
}

export class OpenIddictApplicationDescriptor implements IOpenIddictApplicationDescriptor {
    clientId?: string | undefined;
    clientSecret?: string | undefined;
    consentType?: string | undefined;
    displayName?: string | undefined;
    readonly displayNames?: { [key: string]: string; } | undefined;
    readonly permissions?: string[] | undefined;
    readonly postLogoutRedirectUris?: string[] | undefined;
    readonly properties?: { [key: string]: JsonElement; } | undefined;
    readonly redirectUris?: string[] | undefined;
    readonly requirements?: string[] | undefined;
    type?: string | undefined;

    constructor(data?: IOpenIddictApplicationDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
            this.consentType = _data["consentType"];
            this.displayName = _data["displayName"];
            if (_data["displayNames"]) {
                (<any>this).displayNames = {} as any;
                for (let key in _data["displayNames"]) {
                    if (_data["displayNames"].hasOwnProperty(key))
                        (<any>(<any>this).displayNames)![key] = _data["displayNames"][key];
                }
            }
            if (Array.isArray(_data["permissions"])) {
                (<any>this).permissions = [] as any;
                for (let item of _data["permissions"])
                    (<any>this).permissions!.push(item);
            }
            if (Array.isArray(_data["postLogoutRedirectUris"])) {
                (<any>this).postLogoutRedirectUris = [] as any;
                for (let item of _data["postLogoutRedirectUris"])
                    (<any>this).postLogoutRedirectUris!.push(item);
            }
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key] ? JsonElement.fromJS(_data["properties"][key]) : new JsonElement();
                }
            }
            if (Array.isArray(_data["redirectUris"])) {
                (<any>this).redirectUris = [] as any;
                for (let item of _data["redirectUris"])
                    (<any>this).redirectUris!.push(item);
            }
            if (Array.isArray(_data["requirements"])) {
                (<any>this).requirements = [] as any;
                for (let item of _data["requirements"])
                    (<any>this).requirements!.push(item);
            }
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): OpenIddictApplicationDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new OpenIddictApplicationDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["consentType"] = this.consentType;
        data["displayName"] = this.displayName;
        if (this.displayNames) {
            data["displayNames"] = {};
            for (let key in this.displayNames) {
                if (this.displayNames.hasOwnProperty(key))
                    (<any>data["displayNames"])[key] = (<any>this.displayNames)[key];
            }
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        if (Array.isArray(this.postLogoutRedirectUris)) {
            data["postLogoutRedirectUris"] = [];
            for (let item of this.postLogoutRedirectUris)
                data["postLogoutRedirectUris"].push(item);
        }
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        if (Array.isArray(this.redirectUris)) {
            data["redirectUris"] = [];
            for (let item of this.redirectUris)
                data["redirectUris"].push(item);
        }
        if (Array.isArray(this.requirements)) {
            data["requirements"] = [];
            for (let item of this.requirements)
                data["requirements"].push(item);
        }
        data["type"] = this.type;
        return data;
    }
}

export interface IOpenIddictApplicationDescriptor {
    clientId?: string | undefined;
    clientSecret?: string | undefined;
    consentType?: string | undefined;
    displayName?: string | undefined;
    displayNames?: { [key: string]: string; } | undefined;
    permissions?: string[] | undefined;
    postLogoutRedirectUris?: string[] | undefined;
    properties?: { [key: string]: JsonElement; } | undefined;
    redirectUris?: string[] | undefined;
    requirements?: string[] | undefined;
    type?: string | undefined;
}

export class OAuthAppSearchCriteria implements IOAuthAppSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IOAuthAppSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): OAuthAppSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new OAuthAppSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IOAuthAppSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class OAuthAppSearchResult implements IOAuthAppSearchResult {
    totalCount?: number;
    results?: OpenIddictApplicationDescriptor[] | undefined;

    constructor(data?: IOAuthAppSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(OpenIddictApplicationDescriptor.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OAuthAppSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new OAuthAppSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOAuthAppSearchResult {
    totalCount?: number;
    results?: OpenIddictApplicationDescriptor[] | undefined;
}

export class PushNotificationSearchCriteria implements IPushNotificationSearchCriteria {
    ids?: string[] | undefined;
    onlyNew?: boolean;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IPushNotificationSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.onlyNew = _data["onlyNew"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): PushNotificationSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new PushNotificationSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["onlyNew"] = this.onlyNew;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IPushNotificationSearchCriteria {
    ids?: string[] | undefined;
    onlyNew?: boolean;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class PushNotification implements IPushNotification {
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IPushNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PushNotification {
        data = typeof data === 'object' ? data : {};
        let result = new PushNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data;
    }
}

export interface IPushNotification {
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export class PushNotificationSearchResult implements IPushNotificationSearchResult {
    totalCount?: number;
    newCount?: number;
    notifyEvents?: PushNotification[] | undefined;

    constructor(data?: IPushNotificationSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.newCount = _data["newCount"];
            if (Array.isArray(_data["notifyEvents"])) {
                this.notifyEvents = [] as any;
                for (let item of _data["notifyEvents"])
                    this.notifyEvents!.push(PushNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PushNotificationSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new PushNotificationSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["newCount"] = this.newCount;
        if (Array.isArray(this.notifyEvents)) {
            data["notifyEvents"] = [];
            for (let item of this.notifyEvents)
                data["notifyEvents"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPushNotificationSearchResult {
    totalCount?: number;
    newCount?: number;
    notifyEvents?: PushNotification[] | undefined;
}

export class LoginRequest implements ILoginRequest {
    userName?: string | undefined;
    password?: string | undefined;
    rememberMe?: boolean;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data;
    }
}

export interface ILoginRequest {
    userName?: string | undefined;
    password?: string | undefined;
    rememberMe?: boolean;
}

export class SignInResult implements ISignInResult {
    readonly succeeded?: boolean;
    readonly isLockedOut?: boolean;
    readonly isNotAllowed?: boolean;
    readonly requiresTwoFactor?: boolean;

    constructor(data?: ISignInResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).succeeded = _data["succeeded"];
            (<any>this).isLockedOut = _data["isLockedOut"];
            (<any>this).isNotAllowed = _data["isNotAllowed"];
            (<any>this).requiresTwoFactor = _data["requiresTwoFactor"];
        }
    }

    static fromJS(data: any): SignInResult {
        data = typeof data === 'object' ? data : {};
        let result = new SignInResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["isLockedOut"] = this.isLockedOut;
        data["isNotAllowed"] = this.isNotAllowed;
        data["requiresTwoFactor"] = this.requiresTwoFactor;
        return data;
    }
}

export interface ISignInResult {
    succeeded?: boolean;
    isLockedOut?: boolean;
    isNotAllowed?: boolean;
    requiresTwoFactor?: boolean;
}

export class UserDetail implements IUserDetail {
    permissions?: string[] | undefined;
    userName?: string | undefined;
    isAdministrator?: boolean;
    passwordExpired?: boolean;
    daysTillPasswordExpiry?: number;
    id?: string | undefined;

    constructor(data?: IUserDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            this.userName = _data["userName"];
            this.isAdministrator = _data["isAdministrator"];
            this.passwordExpired = _data["passwordExpired"];
            this.daysTillPasswordExpiry = _data["daysTillPasswordExpiry"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDetail {
        data = typeof data === 'object' ? data : {};
        let result = new UserDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["userName"] = this.userName;
        data["isAdministrator"] = this.isAdministrator;
        data["passwordExpired"] = this.passwordExpired;
        data["daysTillPasswordExpiry"] = this.daysTillPasswordExpiry;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserDetail {
    permissions?: string[] | undefined;
    userName?: string | undefined;
    isAdministrator?: boolean;
    passwordExpired?: boolean;
    daysTillPasswordExpiry?: number;
    id?: string | undefined;
}

export class ClaimsIdentity implements IClaimsIdentity {
    authenticationType?: string | undefined;
    readonly isAuthenticated?: boolean;
    actor?: ClaimsIdentity;
    bootstrapContext?: any | undefined;
    claims?: Claim[] | undefined;
    label?: string | undefined;
    readonly name?: string | undefined;
    readonly nameClaimType?: string | undefined;
    readonly roleClaimType?: string | undefined;

    constructor(data?: IClaimsIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authenticationType = _data["authenticationType"];
            (<any>this).isAuthenticated = _data["isAuthenticated"];
            this.actor = _data["actor"] ? ClaimsIdentity.fromJS(_data["actor"]) : <any>undefined;
            this.bootstrapContext = _data["bootstrapContext"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(Claim.fromJS(item));
            }
            this.label = _data["label"];
            (<any>this).name = _data["name"];
            (<any>this).nameClaimType = _data["nameClaimType"];
            (<any>this).roleClaimType = _data["roleClaimType"];
        }
    }

    static fromJS(data: any): ClaimsIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationType"] = this.authenticationType;
        data["isAuthenticated"] = this.isAuthenticated;
        data["actor"] = this.actor ? this.actor.toJSON() : <any>undefined;
        data["bootstrapContext"] = this.bootstrapContext;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        data["label"] = this.label;
        data["name"] = this.name;
        data["nameClaimType"] = this.nameClaimType;
        data["roleClaimType"] = this.roleClaimType;
        return data;
    }
}

export interface IClaimsIdentity {
    authenticationType?: string | undefined;
    isAuthenticated?: boolean;
    actor?: ClaimsIdentity;
    bootstrapContext?: any | undefined;
    claims?: Claim[] | undefined;
    label?: string | undefined;
    name?: string | undefined;
    nameClaimType?: string | undefined;
    roleClaimType?: string | undefined;
}

export class Claim implements IClaim {
    issuer?: string | undefined;
    originalIssuer?: string | undefined;
    readonly properties?: { [key: string]: string; } | undefined;
    subject?: ClaimsIdentity;
    type?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;

    constructor(data?: IClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issuer = _data["issuer"];
            this.originalIssuer = _data["originalIssuer"];
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key];
                }
            }
            this.subject = _data["subject"] ? ClaimsIdentity.fromJS(_data["subject"]) : <any>undefined;
            this.type = _data["type"];
            this.value = _data["value"];
            this.valueType = _data["valueType"];
        }
    }

    static fromJS(data: any): Claim {
        data = typeof data === 'object' ? data : {};
        let result = new Claim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issuer"] = this.issuer;
        data["originalIssuer"] = this.originalIssuer;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["value"] = this.value;
        data["valueType"] = this.valueType;
        return data;
    }
}

export interface IClaim {
    issuer?: string | undefined;
    originalIssuer?: string | undefined;
    properties?: { [key: string]: string; } | undefined;
    subject?: ClaimsIdentity;
    type?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;
}

export class PermissionScope implements IPermissionScope {
    type?: string | undefined;
    label?: string | undefined;
    scope?: string | undefined;

    constructor(data?: IPermissionScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.label = _data["label"];
            this.scope = _data["scope"];
        }
    }

    static fromJS(data: any): PermissionScope {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["label"] = this.label;
        data["scope"] = this.scope;
        return data;
    }
}

export interface IPermissionScope {
    type?: string | undefined;
    label?: string | undefined;
    scope?: string | undefined;
}

export class Permission implements IPermission {
    id?: string | undefined;
    name?: string | undefined;
    moduleId?: string | undefined;
    groupName?: string | undefined;
    assignedScopes?: PermissionScope[] | undefined;
    readonly availableScopes?: PermissionScope[] | undefined;

    constructor(data?: IPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.moduleId = _data["moduleId"];
            this.groupName = _data["groupName"];
            if (Array.isArray(_data["assignedScopes"])) {
                this.assignedScopes = [] as any;
                for (let item of _data["assignedScopes"])
                    this.assignedScopes!.push(PermissionScope.fromJS(item));
            }
            if (Array.isArray(_data["availableScopes"])) {
                (<any>this).availableScopes = [] as any;
                for (let item of _data["availableScopes"])
                    (<any>this).availableScopes!.push(PermissionScope.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Permission {
        data = typeof data === 'object' ? data : {};
        let result = new Permission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["moduleId"] = this.moduleId;
        data["groupName"] = this.groupName;
        if (Array.isArray(this.assignedScopes)) {
            data["assignedScopes"] = [];
            for (let item of this.assignedScopes)
                data["assignedScopes"].push(item.toJSON());
        }
        if (Array.isArray(this.availableScopes)) {
            data["availableScopes"] = [];
            for (let item of this.availableScopes)
                data["availableScopes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermission {
    id?: string | undefined;
    name?: string | undefined;
    moduleId?: string | undefined;
    groupName?: string | undefined;
    assignedScopes?: PermissionScope[] | undefined;
    availableScopes?: PermissionScope[] | undefined;
}

export class RoleSearchCriteria implements IRoleSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IRoleSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): RoleSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new RoleSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IRoleSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class Role implements IRole {
    description?: string | undefined;
    permissions?: Permission[] | undefined;
    id?: string | undefined;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(Permission.fromJS(item));
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.normalizedName = _data["normalizedName"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["normalizedName"] = this.normalizedName;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IRole {
    description?: string | undefined;
    permissions?: Permission[] | undefined;
    id?: string | undefined;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class RoleSearchResult implements IRoleSearchResult {
    readonly roles?: Role[] | undefined;
    totalCount?: number;
    results?: Role[] | undefined;

    constructor(data?: IRoleSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roles"])) {
                (<any>this).roles = [] as any;
                for (let item of _data["roles"])
                    (<any>this).roles!.push(Role.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Role.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new RoleSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRoleSearchResult {
    roles?: Role[] | undefined;
    totalCount?: number;
    results?: Role[] | undefined;
}

export class SecurityResult implements ISecurityResult {
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: ISecurityResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): SecurityResult {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface ISecurityResult {
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class UserSearchCriteria implements IUserSearchCriteria {
    memberId?: string | undefined;
    memberIds?: string[] | undefined;
    modifiedSinceDate?: Date | undefined;
    roles?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IUserSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            if (Array.isArray(_data["memberIds"])) {
                this.memberIds = [] as any;
                for (let item of _data["memberIds"])
                    this.memberIds!.push(item);
            }
            this.modifiedSinceDate = _data["modifiedSinceDate"] ? new Date(_data["modifiedSinceDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): UserSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new UserSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        if (Array.isArray(this.memberIds)) {
            data["memberIds"] = [];
            for (let item of this.memberIds)
                data["memberIds"].push(item);
        }
        data["modifiedSinceDate"] = this.modifiedSinceDate ? this.modifiedSinceDate.toISOString() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IUserSearchCriteria {
    memberId?: string | undefined;
    memberIds?: string[] | undefined;
    modifiedSinceDate?: Date | undefined;
    roles?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export enum AccountState {
    PendingApproval = "PendingApproval",
    Approved = "Approved",
    Rejected = "Rejected",
}

export class ApplicationUserLogin implements IApplicationUserLogin {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;

    constructor(data?: IApplicationUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
        }
    }

    static fromJS(data: any): ApplicationUserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        return data;
    }
}

export interface IApplicationUserLogin {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;
}

export class ApplicationUser implements IApplicationUser {
    storeId?: string | undefined;
    memberId?: string | undefined;
    isAdministrator?: boolean;
    photoUrl?: string | undefined;
    userType?: string | undefined;
    status?: string | undefined;
    password?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    roles?: Role[] | undefined;
    lockoutEndDateUtc?: Date | undefined;
    userState?: AccountState;
    permissions?: string[] | undefined;
    logins?: ApplicationUserLogin[] | undefined;
    passwordExpired?: boolean;
    lastPasswordChangedDate?: Date | undefined;
    lastPasswordChangeRequestDate?: Date | undefined;
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;

    constructor(data?: IApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.memberId = _data["memberId"];
            this.isAdministrator = _data["isAdministrator"];
            this.photoUrl = _data["photoUrl"];
            this.userType = _data["userType"];
            this.status = _data["status"];
            this.password = _data["password"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(Role.fromJS(item));
            }
            this.lockoutEndDateUtc = _data["lockoutEndDateUtc"] ? new Date(_data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.userState = _data["userState"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            if (Array.isArray(_data["logins"])) {
                this.logins = [] as any;
                for (let item of _data["logins"])
                    this.logins!.push(ApplicationUserLogin.fromJS(item));
            }
            this.passwordExpired = _data["passwordExpired"];
            this.lastPasswordChangedDate = _data["lastPasswordChangedDate"] ? new Date(_data["lastPasswordChangedDate"].toString()) : <any>undefined;
            this.lastPasswordChangeRequestDate = _data["lastPasswordChangeRequestDate"] ? new Date(_data["lastPasswordChangeRequestDate"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any): ApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["memberId"] = this.memberId;
        data["isAdministrator"] = this.isAdministrator;
        data["photoUrl"] = this.photoUrl;
        data["userType"] = this.userType;
        data["status"] = this.status;
        data["password"] = this.password;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["userState"] = this.userState;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        data["passwordExpired"] = this.passwordExpired;
        data["lastPasswordChangedDate"] = this.lastPasswordChangedDate ? this.lastPasswordChangedDate.toISOString() : <any>undefined;
        data["lastPasswordChangeRequestDate"] = this.lastPasswordChangeRequestDate ? this.lastPasswordChangeRequestDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data;
    }
}

export interface IApplicationUser {
    storeId?: string | undefined;
    memberId?: string | undefined;
    isAdministrator?: boolean;
    photoUrl?: string | undefined;
    userType?: string | undefined;
    status?: string | undefined;
    password?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    roles?: Role[] | undefined;
    lockoutEndDateUtc?: Date | undefined;
    userState?: AccountState;
    permissions?: string[] | undefined;
    logins?: ApplicationUserLogin[] | undefined;
    passwordExpired?: boolean;
    lastPasswordChangedDate?: Date | undefined;
    lastPasswordChangeRequestDate?: Date | undefined;
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
}

export class UserSearchResult implements IUserSearchResult {
    readonly users?: ApplicationUser[] | undefined;
    totalCount?: number;
    results?: ApplicationUser[] | undefined;

    constructor(data?: IUserSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["users"])) {
                (<any>this).users = [] as any;
                for (let item of _data["users"])
                    (<any>this).users!.push(ApplicationUser.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ApplicationUser.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserSearchResult {
    users?: ApplicationUser[] | undefined;
    totalCount?: number;
    results?: ApplicationUser[] | undefined;
}

export class ChangePasswordRequest implements IChangePasswordRequest {
    userName?: string | undefined;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IChangePasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordRequest {
    userName?: string | undefined;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
}

export class ResetPasswordConfirmRequest implements IResetPasswordConfirmRequest {
    token?: string | undefined;
    newPassword?: string | undefined;
    forcePasswordChangeOnNextSignIn?: boolean;

    constructor(data?: IResetPasswordConfirmRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.newPassword = _data["newPassword"];
            this.forcePasswordChangeOnNextSignIn = _data["forcePasswordChangeOnNextSignIn"];
        }
    }

    static fromJS(data: any): ResetPasswordConfirmRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordConfirmRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["newPassword"] = this.newPassword;
        data["forcePasswordChangeOnNextSignIn"] = this.forcePasswordChangeOnNextSignIn;
        return data;
    }
}

export interface IResetPasswordConfirmRequest {
    token?: string | undefined;
    newPassword?: string | undefined;
    forcePasswordChangeOnNextSignIn?: boolean;
}

export class ValidatePasswordResetTokenRequest implements IValidatePasswordResetTokenRequest {
    token?: string | undefined;

    constructor(data?: IValidatePasswordResetTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ValidatePasswordResetTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ValidatePasswordResetTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

export interface IValidatePasswordResetTokenRequest {
    token?: string | undefined;
}

export class IdentityError implements IIdentityError {
    code?: string | undefined;
    description?: string | undefined;

    constructor(data?: IIdentityError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): IdentityError {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        return data;
    }
}

export interface IIdentityError {
    code?: string | undefined;
    description?: string | undefined;
}

export class IdentityResult implements IIdentityResult {
    readonly succeeded?: boolean;
    readonly errors?: IdentityError[] | undefined;

    constructor(data?: IIdentityResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(IdentityError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdentityResult {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIdentityResult {
    succeeded?: boolean;
    errors?: IdentityError[] | undefined;
}

export class UserLockedResult implements IUserLockedResult {
    locked?: boolean;

    constructor(data?: IUserLockedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locked = _data["locked"];
        }
    }

    static fromJS(data: any): UserLockedResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locked"] = this.locked;
        return data;
    }
}

export interface IUserLockedResult {
    locked?: boolean;
}

export class UserApiKey implements IUserApiKey {
    apiKey?: string | undefined;
    userName?: string | undefined;
    userId?: string | undefined;
    isActive?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IUserApiKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.apiKey = _data["apiKey"];
            this.userName = _data["userName"];
            this.userId = _data["userId"];
            this.isActive = _data["isActive"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserApiKey {
        data = typeof data === 'object' ? data : {};
        let result = new UserApiKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        data["userName"] = this.userName;
        data["userId"] = this.userId;
        data["isActive"] = this.isActive;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserApiKey {
    apiKey?: string | undefined;
    userName?: string | undefined;
    userId?: string | undefined;
    isActive?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export enum SettingValueType {
    ShortText = "ShortText",
    LongText = "LongText",
    Integer = "Integer",
    Decimal = "Decimal",
    DateTime = "DateTime",
    Boolean = "Boolean",
    SecureString = "SecureString",
    Json = "Json",
    PositiveInteger = "PositiveInteger",
}

export class ObjectSettingEntry implements IObjectSettingEntry {
    readonly itHasValues?: boolean;
    objectId?: string | undefined;
    objectType?: string | undefined;
    isReadOnly?: string | undefined;
    value?: any | undefined;
    restartRequired?: boolean;
    moduleId?: string | undefined;
    groupName?: string | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    isRequired?: boolean;
    isHidden?: boolean;
    valueType?: SettingValueType;
    allowedValues?: any[] | undefined;
    defaultValue?: any | undefined;
    isDictionary?: boolean;

    constructor(data?: IObjectSettingEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).itHasValues = _data["itHasValues"];
            this.objectId = _data["objectId"];
            this.objectType = _data["objectType"];
            this.isReadOnly = _data["isReadOnly"];
            this.value = _data["value"];
            this.restartRequired = _data["restartRequired"];
            this.moduleId = _data["moduleId"];
            this.groupName = _data["groupName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isRequired = _data["isRequired"];
            this.isHidden = _data["isHidden"];
            this.valueType = _data["valueType"];
            if (Array.isArray(_data["allowedValues"])) {
                this.allowedValues = [] as any;
                for (let item of _data["allowedValues"])
                    this.allowedValues!.push(item);
            }
            this.defaultValue = _data["defaultValue"];
            this.isDictionary = _data["isDictionary"];
        }
    }

    static fromJS(data: any): ObjectSettingEntry {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectSettingEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itHasValues"] = this.itHasValues;
        data["objectId"] = this.objectId;
        data["objectType"] = this.objectType;
        data["isReadOnly"] = this.isReadOnly;
        data["value"] = this.value;
        data["restartRequired"] = this.restartRequired;
        data["moduleId"] = this.moduleId;
        data["groupName"] = this.groupName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isRequired"] = this.isRequired;
        data["isHidden"] = this.isHidden;
        data["valueType"] = this.valueType;
        if (Array.isArray(this.allowedValues)) {
            data["allowedValues"] = [];
            for (let item of this.allowedValues)
                data["allowedValues"].push(item);
        }
        data["defaultValue"] = this.defaultValue;
        data["isDictionary"] = this.isDictionary;
        return data;
    }
}

export interface IObjectSettingEntry {
    itHasValues?: boolean;
    objectId?: string | undefined;
    objectType?: string | undefined;
    isReadOnly?: string | undefined;
    value?: any | undefined;
    restartRequired?: boolean;
    moduleId?: string | undefined;
    groupName?: string | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    isRequired?: boolean;
    isHidden?: boolean;
    valueType?: SettingValueType;
    allowedValues?: any[] | undefined;
    defaultValue?: any | undefined;
    isDictionary?: boolean;
}

export class TenantIdentity implements ITenantIdentity {
    id?: string | undefined;
    type?: string | undefined;
    readonly isEmpty?: boolean;
    readonly isValid?: boolean;

    constructor(data?: ITenantIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            (<any>this).isEmpty = _data["isEmpty"];
            (<any>this).isValid = _data["isValid"];
        }
    }

    static fromJS(data: any): TenantIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new TenantIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["isEmpty"] = this.isEmpty;
        data["isValid"] = this.isValid;
        return data;
    }
}

export interface ITenantIdentity {
    id?: string | undefined;
    type?: string | undefined;
    isEmpty?: boolean;
    isValid?: boolean;
}

export class AssetEntrySearchCriteria implements IAssetEntrySearchCriteria {
    tenants?: TenantIdentity[] | undefined;
    group?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IAssetEntrySearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tenants"])) {
                this.tenants = [] as any;
                for (let item of _data["tenants"])
                    this.tenants!.push(TenantIdentity.fromJS(item));
            }
            this.group = _data["group"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): AssetEntrySearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new AssetEntrySearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tenants)) {
            data["tenants"] = [];
            for (let item of this.tenants)
                data["tenants"].push(item.toJSON());
        }
        data["group"] = this.group;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IAssetEntrySearchCriteria {
    tenants?: TenantIdentity[] | undefined;
    group?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class BlobInfo implements IBlobInfo {
    key?: string | undefined;
    size?: number;
    contentType?: string | undefined;
    type?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
    relativeUrl?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IBlobInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.size = _data["size"];
            this.contentType = _data["contentType"];
            this.type = _data["type"];
            this.name = _data["name"];
            this.url = _data["url"];
            this.relativeUrl = _data["relativeUrl"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BlobInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BlobInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["size"] = this.size;
        data["contentType"] = this.contentType;
        data["type"] = this.type;
        data["name"] = this.name;
        data["url"] = this.url;
        data["relativeUrl"] = this.relativeUrl;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IBlobInfo {
    key?: string | undefined;
    size?: number;
    contentType?: string | undefined;
    type?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
    relativeUrl?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class AssetEntry implements IAssetEntry {
    languageCode?: string | undefined;
    tenant?: TenantIdentity;
    blobInfo?: BlobInfo;
    group?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IAssetEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageCode = _data["languageCode"];
            this.tenant = _data["tenant"] ? TenantIdentity.fromJS(_data["tenant"]) : <any>undefined;
            this.blobInfo = _data["blobInfo"] ? BlobInfo.fromJS(_data["blobInfo"]) : <any>undefined;
            this.group = _data["group"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AssetEntry {
        data = typeof data === 'object' ? data : {};
        let result = new AssetEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageCode"] = this.languageCode;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["blobInfo"] = this.blobInfo ? this.blobInfo.toJSON() : <any>undefined;
        data["group"] = this.group;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IAssetEntry {
    languageCode?: string | undefined;
    tenant?: TenantIdentity;
    blobInfo?: BlobInfo;
    group?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class AssetEntrySearchResult implements IAssetEntrySearchResult {
    totalCount?: number;
    results?: AssetEntry[] | undefined;

    constructor(data?: IAssetEntrySearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(AssetEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AssetEntrySearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetEntrySearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAssetEntrySearchResult {
    totalCount?: number;
    results?: AssetEntry[] | undefined;
}

export class BlobEntry implements IBlobEntry {
    type?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
    relativeUrl?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IBlobEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.name = _data["name"];
            this.url = _data["url"];
            this.relativeUrl = _data["relativeUrl"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BlobEntry {
        data = typeof data === 'object' ? data : {};
        let result = new BlobEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["name"] = this.name;
        data["url"] = this.url;
        data["relativeUrl"] = this.relativeUrl;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IBlobEntry {
    type?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
    relativeUrl?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class BlobEntrySearchResult implements IBlobEntrySearchResult {
    totalCount?: number;
    results?: BlobEntry[] | undefined;

    constructor(data?: IBlobEntrySearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(BlobEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BlobEntrySearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new BlobEntrySearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBlobEntrySearchResult {
    totalCount?: number;
    results?: BlobEntry[] | undefined;
}

export class BlobFolder implements IBlobFolder {
    parentUrl?: string | undefined;
    type?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
    relativeUrl?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IBlobFolder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentUrl = _data["parentUrl"];
            this.type = _data["type"];
            this.name = _data["name"];
            this.url = _data["url"];
            this.relativeUrl = _data["relativeUrl"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BlobFolder {
        data = typeof data === 'object' ? data : {};
        let result = new BlobFolder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentUrl"] = this.parentUrl;
        data["type"] = this.type;
        data["name"] = this.name;
        data["url"] = this.url;
        data["relativeUrl"] = this.relativeUrl;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IBlobFolder {
    parentUrl?: string | undefined;
    type?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
    relativeUrl?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class IBulkActionFactory implements IIBulkActionFactory {

    constructor(data?: IIBulkActionFactory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IBulkActionFactory {
        data = typeof data === 'object' ? data : {};
        let result = new IBulkActionFactory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIBulkActionFactory {
}

export class IDataSourceFactory implements IIDataSourceFactory {

    constructor(data?: IIDataSourceFactory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IDataSourceFactory {
        data = typeof data === 'object' ? data : {};
        let result = new IDataSourceFactory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIDataSourceFactory {
}

export class IBulkActionProvider implements IIBulkActionProvider {
    applicableTypes?: string[] | undefined;
    bulkActionFactory?: IBulkActionFactory;
    contextTypeName?: string | undefined;
    dataSourceFactory?: IDataSourceFactory;
    name?: string | undefined;
    permissions?: string[] | undefined;

    constructor(data?: IIBulkActionProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["applicableTypes"])) {
                this.applicableTypes = [] as any;
                for (let item of _data["applicableTypes"])
                    this.applicableTypes!.push(item);
            }
            this.bulkActionFactory = _data["bulkActionFactory"] ? IBulkActionFactory.fromJS(_data["bulkActionFactory"]) : <any>undefined;
            this.contextTypeName = _data["contextTypeName"];
            this.dataSourceFactory = _data["dataSourceFactory"] ? IDataSourceFactory.fromJS(_data["dataSourceFactory"]) : <any>undefined;
            this.name = _data["name"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any): IBulkActionProvider {
        data = typeof data === 'object' ? data : {};
        let result = new IBulkActionProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.applicableTypes)) {
            data["applicableTypes"] = [];
            for (let item of this.applicableTypes)
                data["applicableTypes"].push(item);
        }
        data["bulkActionFactory"] = this.bulkActionFactory ? this.bulkActionFactory.toJSON() : <any>undefined;
        data["contextTypeName"] = this.contextTypeName;
        data["dataSourceFactory"] = this.dataSourceFactory ? this.dataSourceFactory.toJSON() : <any>undefined;
        data["name"] = this.name;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data;
    }
}

export interface IIBulkActionProvider {
    applicableTypes?: string[] | undefined;
    bulkActionFactory?: IBulkActionFactory;
    contextTypeName?: string | undefined;
    dataSourceFactory?: IDataSourceFactory;
    name?: string | undefined;
    permissions?: string[] | undefined;
}

export class BulkActionContext implements IBulkActionContext {
    actionName?: string | undefined;
    readonly contextTypeName?: string | undefined;

    constructor(data?: IBulkActionContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionName = _data["actionName"];
            (<any>this).contextTypeName = _data["contextTypeName"];
        }
    }

    static fromJS(data: any): BulkActionContext {
        data = typeof data === 'object' ? data : {};
        let result = new BulkActionContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionName"] = this.actionName;
        data["contextTypeName"] = this.contextTypeName;
        return data;
    }
}

export interface IBulkActionContext {
    actionName?: string | undefined;
    contextTypeName?: string | undefined;
}

export class BulkActionPushNotification implements IBulkActionPushNotification {
    readonly errorCount?: number;
    errors?: string[] | undefined;
    finished?: Date | undefined;
    jobId?: string | undefined;
    processedCount?: number | undefined;
    totalCount?: number | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IBulkActionPushNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.jobId = _data["jobId"];
            this.processedCount = _data["processedCount"];
            this.totalCount = _data["totalCount"];
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BulkActionPushNotification {
        data = typeof data === 'object' ? data : {};
        let result = new BulkActionPushNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["jobId"] = this.jobId;
        data["processedCount"] = this.processedCount;
        data["totalCount"] = this.totalCount;
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data;
    }
}

export interface IBulkActionPushNotification {
    errorCount?: number;
    errors?: string[] | undefined;
    finished?: Date | undefined;
    jobId?: string | undefined;
    processedCount?: number | undefined;
    totalCount?: number | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export enum AddressType {
    Billing = "Billing",
    Shipping = "Shipping",
    BillingAndShipping = "BillingAndShipping",
    Pickup = "Pickup",
}

export class CartAddress implements ICartAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    outerId?: string | undefined;
    isDefault?: boolean;

    constructor(data?: ICartAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressType = _data["addressType"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.organization = _data["organization"];
            this.countryCode = _data["countryCode"];
            this.countryName = _data["countryName"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.zip = _data["zip"];
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.regionId = _data["regionId"];
            this.regionName = _data["regionName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.outerId = _data["outerId"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): CartAddress {
        data = typeof data === 'object' ? data : {};
        let result = new CartAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressType"] = this.addressType;
        data["key"] = this.key;
        data["name"] = this.name;
        data["organization"] = this.organization;
        data["countryCode"] = this.countryCode;
        data["countryName"] = this.countryName;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["zip"] = this.zip;
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["regionId"] = this.regionId;
        data["regionName"] = this.regionName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["outerId"] = this.outerId;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface ICartAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    outerId?: string | undefined;
    isDefault?: boolean;
}

export class Discount implements IDiscount {
    promotionId?: string | undefined;
    currency?: string | undefined;
    discountAmount?: number;
    discountAmountWithTax?: number;
    coupon?: string | undefined;
    description?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDiscount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.promotionId = _data["promotionId"];
            this.currency = _data["currency"];
            this.discountAmount = _data["discountAmount"];
            this.discountAmountWithTax = _data["discountAmountWithTax"];
            this.coupon = _data["coupon"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Discount {
        data = typeof data === 'object' ? data : {};
        let result = new Discount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["promotionId"] = this.promotionId;
        data["currency"] = this.currency;
        data["discountAmount"] = this.discountAmount;
        data["discountAmountWithTax"] = this.discountAmountWithTax;
        data["coupon"] = this.coupon;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }
}

export interface IDiscount {
    promotionId?: string | undefined;
    currency?: string | undefined;
    discountAmount?: number;
    discountAmountWithTax?: number;
    coupon?: string | undefined;
    description?: string | undefined;
    id?: string | undefined;
}

export class TaxDetail implements ITaxDetail {
    rate?: number;
    amount?: number;
    name?: string | undefined;

    constructor(data?: ITaxDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rate = _data["rate"];
            this.amount = _data["amount"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TaxDetail {
        data = typeof data === 'object' ? data : {};
        let result = new TaxDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rate"] = this.rate;
        data["amount"] = this.amount;
        data["name"] = this.name;
        return data;
    }
}

export interface ITaxDetail {
    rate?: number;
    amount?: number;
    name?: string | undefined;
}

export class CartLineItem implements ICartLineItem {
    productId?: string | undefined;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    sku?: string | undefined;
    productType?: string | undefined;
    name?: string | undefined;
    quantity?: number;
    fulfillmentCenterId?: string | undefined;
    fulfillmentCenterName?: string | undefined;
    fulfillmentLocationCode?: string | undefined;
    shipmentMethodCode?: string | undefined;
    requiredShipping?: boolean;
    thumbnailImageUrl?: string | undefined;
    imageUrl?: string | undefined;
    isGift?: boolean;
    isRejected?: boolean;
    currency?: string | undefined;
    languageCode?: string | undefined;
    note?: string | undefined;
    isReccuring?: boolean;
    taxIncluded?: boolean;
    volumetricWeight?: number | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    validationType?: string | undefined;
    isReadOnly?: boolean;
    priceId?: string | undefined;
    listPrice?: number;
    listPriceWithTax?: number;
    salePrice?: number;
    salePriceWithTax?: number;
    placedPrice?: number;
    placedPriceWithTax?: number;
    extendedPrice?: number;
    extendedPriceWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    discountTotal?: number;
    discountTotalWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    discounts?: Discount[] | undefined;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    taxDetails?: TaxDetail[] | undefined;
    readonly objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICartLineItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.catalogId = _data["catalogId"];
            this.categoryId = _data["categoryId"];
            this.sku = _data["sku"];
            this.productType = _data["productType"];
            this.name = _data["name"];
            this.quantity = _data["quantity"];
            this.fulfillmentCenterId = _data["fulfillmentCenterId"];
            this.fulfillmentCenterName = _data["fulfillmentCenterName"];
            this.fulfillmentLocationCode = _data["fulfillmentLocationCode"];
            this.shipmentMethodCode = _data["shipmentMethodCode"];
            this.requiredShipping = _data["requiredShipping"];
            this.thumbnailImageUrl = _data["thumbnailImageUrl"];
            this.imageUrl = _data["imageUrl"];
            this.isGift = _data["isGift"];
            this.isRejected = _data["isRejected"];
            this.currency = _data["currency"];
            this.languageCode = _data["languageCode"];
            this.note = _data["note"];
            this.isReccuring = _data["isReccuring"];
            this.taxIncluded = _data["taxIncluded"];
            this.volumetricWeight = _data["volumetricWeight"];
            this.weightUnit = _data["weightUnit"];
            this.weight = _data["weight"];
            this.measureUnit = _data["measureUnit"];
            this.height = _data["height"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.validationType = _data["validationType"];
            this.isReadOnly = _data["isReadOnly"];
            this.priceId = _data["priceId"];
            this.listPrice = _data["listPrice"];
            this.listPriceWithTax = _data["listPriceWithTax"];
            this.salePrice = _data["salePrice"];
            this.salePriceWithTax = _data["salePriceWithTax"];
            this.placedPrice = _data["placedPrice"];
            this.placedPriceWithTax = _data["placedPriceWithTax"];
            this.extendedPrice = _data["extendedPrice"];
            this.extendedPriceWithTax = _data["extendedPriceWithTax"];
            this.discountAmount = _data["discountAmount"];
            this.discountAmountWithTax = _data["discountAmountWithTax"];
            this.discountTotal = _data["discountTotal"];
            this.discountTotalWithTax = _data["discountTotalWithTax"];
            this.fee = _data["fee"];
            this.feeWithTax = _data["feeWithTax"];
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(Discount.fromJS(item));
            }
            this.taxType = _data["taxType"];
            this.taxTotal = _data["taxTotal"];
            this.taxPercentRate = _data["taxPercentRate"];
            if (Array.isArray(_data["taxDetails"])) {
                this.taxDetails = [] as any;
                for (let item of _data["taxDetails"])
                    this.taxDetails!.push(TaxDetail.fromJS(item));
            }
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CartLineItem {
        data = typeof data === 'object' ? data : {};
        let result = new CartLineItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["catalogId"] = this.catalogId;
        data["categoryId"] = this.categoryId;
        data["sku"] = this.sku;
        data["productType"] = this.productType;
        data["name"] = this.name;
        data["quantity"] = this.quantity;
        data["fulfillmentCenterId"] = this.fulfillmentCenterId;
        data["fulfillmentCenterName"] = this.fulfillmentCenterName;
        data["fulfillmentLocationCode"] = this.fulfillmentLocationCode;
        data["shipmentMethodCode"] = this.shipmentMethodCode;
        data["requiredShipping"] = this.requiredShipping;
        data["thumbnailImageUrl"] = this.thumbnailImageUrl;
        data["imageUrl"] = this.imageUrl;
        data["isGift"] = this.isGift;
        data["isRejected"] = this.isRejected;
        data["currency"] = this.currency;
        data["languageCode"] = this.languageCode;
        data["note"] = this.note;
        data["isReccuring"] = this.isReccuring;
        data["taxIncluded"] = this.taxIncluded;
        data["volumetricWeight"] = this.volumetricWeight;
        data["weightUnit"] = this.weightUnit;
        data["weight"] = this.weight;
        data["measureUnit"] = this.measureUnit;
        data["height"] = this.height;
        data["length"] = this.length;
        data["width"] = this.width;
        data["validationType"] = this.validationType;
        data["isReadOnly"] = this.isReadOnly;
        data["priceId"] = this.priceId;
        data["listPrice"] = this.listPrice;
        data["listPriceWithTax"] = this.listPriceWithTax;
        data["salePrice"] = this.salePrice;
        data["salePriceWithTax"] = this.salePriceWithTax;
        data["placedPrice"] = this.placedPrice;
        data["placedPriceWithTax"] = this.placedPriceWithTax;
        data["extendedPrice"] = this.extendedPrice;
        data["extendedPriceWithTax"] = this.extendedPriceWithTax;
        data["discountAmount"] = this.discountAmount;
        data["discountAmountWithTax"] = this.discountAmountWithTax;
        data["discountTotal"] = this.discountTotal;
        data["discountTotalWithTax"] = this.discountTotalWithTax;
        data["fee"] = this.fee;
        data["feeWithTax"] = this.feeWithTax;
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        data["taxType"] = this.taxType;
        data["taxTotal"] = this.taxTotal;
        data["taxPercentRate"] = this.taxPercentRate;
        if (Array.isArray(this.taxDetails)) {
            data["taxDetails"] = [];
            for (let item of this.taxDetails)
                data["taxDetails"].push(item.toJSON());
        }
        data["objectType"] = this.objectType;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ICartLineItem {
    productId?: string | undefined;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    sku?: string | undefined;
    productType?: string | undefined;
    name?: string | undefined;
    quantity?: number;
    fulfillmentCenterId?: string | undefined;
    fulfillmentCenterName?: string | undefined;
    fulfillmentLocationCode?: string | undefined;
    shipmentMethodCode?: string | undefined;
    requiredShipping?: boolean;
    thumbnailImageUrl?: string | undefined;
    imageUrl?: string | undefined;
    isGift?: boolean;
    isRejected?: boolean;
    currency?: string | undefined;
    languageCode?: string | undefined;
    note?: string | undefined;
    isReccuring?: boolean;
    taxIncluded?: boolean;
    volumetricWeight?: number | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    validationType?: string | undefined;
    isReadOnly?: boolean;
    priceId?: string | undefined;
    listPrice?: number;
    listPriceWithTax?: number;
    salePrice?: number;
    salePriceWithTax?: number;
    placedPrice?: number;
    placedPriceWithTax?: number;
    extendedPrice?: number;
    extendedPriceWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    discountTotal?: number;
    discountTotalWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    discounts?: Discount[] | undefined;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    taxDetails?: TaxDetail[] | undefined;
    objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Payment implements IPayment {
    currency?: string | undefined;
    paymentGatewayCode?: string | undefined;
    amount?: number;
    billingAddress?: CartAddress;
    price?: number;
    priceWithTax?: number;
    total?: number;
    totalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    discounts?: Discount[] | undefined;
    taxDetails?: TaxDetail[] | undefined;
    readonly objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currency = _data["currency"];
            this.paymentGatewayCode = _data["paymentGatewayCode"];
            this.amount = _data["amount"];
            this.billingAddress = _data["billingAddress"] ? CartAddress.fromJS(_data["billingAddress"]) : <any>undefined;
            this.price = _data["price"];
            this.priceWithTax = _data["priceWithTax"];
            this.total = _data["total"];
            this.totalWithTax = _data["totalWithTax"];
            this.discountAmount = _data["discountAmount"];
            this.discountAmountWithTax = _data["discountAmountWithTax"];
            this.taxType = _data["taxType"];
            this.taxTotal = _data["taxTotal"];
            this.taxPercentRate = _data["taxPercentRate"];
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(Discount.fromJS(item));
            }
            if (Array.isArray(_data["taxDetails"])) {
                this.taxDetails = [] as any;
                for (let item of _data["taxDetails"])
                    this.taxDetails!.push(TaxDetail.fromJS(item));
            }
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Payment {
        data = typeof data === 'object' ? data : {};
        let result = new Payment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currency"] = this.currency;
        data["paymentGatewayCode"] = this.paymentGatewayCode;
        data["amount"] = this.amount;
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        data["price"] = this.price;
        data["priceWithTax"] = this.priceWithTax;
        data["total"] = this.total;
        data["totalWithTax"] = this.totalWithTax;
        data["discountAmount"] = this.discountAmount;
        data["discountAmountWithTax"] = this.discountAmountWithTax;
        data["taxType"] = this.taxType;
        data["taxTotal"] = this.taxTotal;
        data["taxPercentRate"] = this.taxPercentRate;
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        if (Array.isArray(this.taxDetails)) {
            data["taxDetails"] = [];
            for (let item of this.taxDetails)
                data["taxDetails"].push(item.toJSON());
        }
        data["objectType"] = this.objectType;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IPayment {
    currency?: string | undefined;
    paymentGatewayCode?: string | undefined;
    amount?: number;
    billingAddress?: CartAddress;
    price?: number;
    priceWithTax?: number;
    total?: number;
    totalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    discounts?: Discount[] | undefined;
    taxDetails?: TaxDetail[] | undefined;
    objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CartShipmentItem implements ICartShipmentItem {
    lineItemId?: string | undefined;
    lineItem?: CartLineItem;
    barCode?: string | undefined;
    quantity?: number;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICartShipmentItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lineItemId = _data["lineItemId"];
            this.lineItem = _data["lineItem"] ? CartLineItem.fromJS(_data["lineItem"]) : <any>undefined;
            this.barCode = _data["barCode"];
            this.quantity = _data["quantity"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CartShipmentItem {
        data = typeof data === 'object' ? data : {};
        let result = new CartShipmentItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lineItemId"] = this.lineItemId;
        data["lineItem"] = this.lineItem ? this.lineItem.toJSON() : <any>undefined;
        data["barCode"] = this.barCode;
        data["quantity"] = this.quantity;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ICartShipmentItem {
    lineItemId?: string | undefined;
    lineItem?: CartLineItem;
    barCode?: string | undefined;
    quantity?: number;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CartShipment implements ICartShipment {
    shipmentMethodCode?: string | undefined;
    shipmentMethodOption?: string | undefined;
    fulfillmentCenterId?: string | undefined;
    fulfillmentCenterName?: string | undefined;
    warehouseLocation?: string | undefined;
    currency?: string | undefined;
    volumetricWeight?: number | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    price?: number;
    priceWithTax?: number;
    total?: number;
    totalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    deliveryAddress?: CartAddress;
    items?: CartShipmentItem[] | undefined;
    discounts?: Discount[] | undefined;
    taxDetails?: TaxDetail[] | undefined;
    readonly objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICartShipment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shipmentMethodCode = _data["shipmentMethodCode"];
            this.shipmentMethodOption = _data["shipmentMethodOption"];
            this.fulfillmentCenterId = _data["fulfillmentCenterId"];
            this.fulfillmentCenterName = _data["fulfillmentCenterName"];
            this.warehouseLocation = _data["warehouseLocation"];
            this.currency = _data["currency"];
            this.volumetricWeight = _data["volumetricWeight"];
            this.weightUnit = _data["weightUnit"];
            this.weight = _data["weight"];
            this.measureUnit = _data["measureUnit"];
            this.height = _data["height"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.price = _data["price"];
            this.priceWithTax = _data["priceWithTax"];
            this.total = _data["total"];
            this.totalWithTax = _data["totalWithTax"];
            this.discountAmount = _data["discountAmount"];
            this.discountAmountWithTax = _data["discountAmountWithTax"];
            this.fee = _data["fee"];
            this.feeWithTax = _data["feeWithTax"];
            this.taxType = _data["taxType"];
            this.taxTotal = _data["taxTotal"];
            this.taxPercentRate = _data["taxPercentRate"];
            this.deliveryAddress = _data["deliveryAddress"] ? CartAddress.fromJS(_data["deliveryAddress"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CartShipmentItem.fromJS(item));
            }
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(Discount.fromJS(item));
            }
            if (Array.isArray(_data["taxDetails"])) {
                this.taxDetails = [] as any;
                for (let item of _data["taxDetails"])
                    this.taxDetails!.push(TaxDetail.fromJS(item));
            }
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CartShipment {
        data = typeof data === 'object' ? data : {};
        let result = new CartShipment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shipmentMethodCode"] = this.shipmentMethodCode;
        data["shipmentMethodOption"] = this.shipmentMethodOption;
        data["fulfillmentCenterId"] = this.fulfillmentCenterId;
        data["fulfillmentCenterName"] = this.fulfillmentCenterName;
        data["warehouseLocation"] = this.warehouseLocation;
        data["currency"] = this.currency;
        data["volumetricWeight"] = this.volumetricWeight;
        data["weightUnit"] = this.weightUnit;
        data["weight"] = this.weight;
        data["measureUnit"] = this.measureUnit;
        data["height"] = this.height;
        data["length"] = this.length;
        data["width"] = this.width;
        data["price"] = this.price;
        data["priceWithTax"] = this.priceWithTax;
        data["total"] = this.total;
        data["totalWithTax"] = this.totalWithTax;
        data["discountAmount"] = this.discountAmount;
        data["discountAmountWithTax"] = this.discountAmountWithTax;
        data["fee"] = this.fee;
        data["feeWithTax"] = this.feeWithTax;
        data["taxType"] = this.taxType;
        data["taxTotal"] = this.taxTotal;
        data["taxPercentRate"] = this.taxPercentRate;
        data["deliveryAddress"] = this.deliveryAddress ? this.deliveryAddress.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        if (Array.isArray(this.taxDetails)) {
            data["taxDetails"] = [];
            for (let item of this.taxDetails)
                data["taxDetails"].push(item.toJSON());
        }
        data["objectType"] = this.objectType;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ICartShipment {
    shipmentMethodCode?: string | undefined;
    shipmentMethodOption?: string | undefined;
    fulfillmentCenterId?: string | undefined;
    fulfillmentCenterName?: string | undefined;
    warehouseLocation?: string | undefined;
    currency?: string | undefined;
    volumetricWeight?: number | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    price?: number;
    priceWithTax?: number;
    total?: number;
    totalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    deliveryAddress?: CartAddress;
    items?: CartShipmentItem[] | undefined;
    discounts?: Discount[] | undefined;
    taxDetails?: TaxDetail[] | undefined;
    objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ShoppingCart implements IShoppingCart {
    name?: string | undefined;
    storeId?: string | undefined;
    channelId?: string | undefined;
    isAnonymous?: boolean;
    customerId?: string | undefined;
    customerName?: string | undefined;
    organizationId?: string | undefined;
    currency?: string | undefined;
    languageCode?: string | undefined;
    taxIncluded?: boolean | undefined;
    isRecuring?: boolean | undefined;
    comment?: string | undefined;
    status?: string | undefined;
    purchaseOrderNumber?: string | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    validationType?: string | undefined;
    type?: string | undefined;
    volumetricWeight?: number | undefined;
    total?: number;
    subTotal?: number;
    subTotalWithTax?: number;
    subTotalDiscount?: number;
    subTotalDiscountWithTax?: number;
    shippingTotal?: number;
    shippingTotalWithTax?: number;
    shippingSubTotal?: number;
    shippingSubTotalWithTax?: number;
    shippingDiscountTotal?: number;
    shippingDiscountTotalWithTax?: number;
    paymentTotal?: number;
    paymentTotalWithTax?: number;
    paymentSubTotal?: number;
    paymentSubTotalWithTax?: number;
    paymentDiscountTotal?: number;
    paymentDiscountTotalWithTax?: number;
    handlingTotal?: number;
    handlingTotalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    discountTotal?: number;
    discountTotalWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    feeTotal?: number;
    feeTotalWithTax?: number;
    addresses?: CartAddress[] | undefined;
    items?: CartLineItem[] | undefined;
    payments?: Payment[] | undefined;
    shipments?: CartShipment[] | undefined;
    coupons?: string[] | undefined;
    coupon?: string | undefined;
    discounts?: Discount[] | undefined;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    taxDetails?: TaxDetail[] | undefined;
    readonly objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IShoppingCart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.storeId = _data["storeId"];
            this.channelId = _data["channelId"];
            this.isAnonymous = _data["isAnonymous"];
            this.customerId = _data["customerId"];
            this.customerName = _data["customerName"];
            this.organizationId = _data["organizationId"];
            this.currency = _data["currency"];
            this.languageCode = _data["languageCode"];
            this.taxIncluded = _data["taxIncluded"];
            this.isRecuring = _data["isRecuring"];
            this.comment = _data["comment"];
            this.status = _data["status"];
            this.purchaseOrderNumber = _data["purchaseOrderNumber"];
            this.weightUnit = _data["weightUnit"];
            this.weight = _data["weight"];
            this.validationType = _data["validationType"];
            this.type = _data["type"];
            this.volumetricWeight = _data["volumetricWeight"];
            this.total = _data["total"];
            this.subTotal = _data["subTotal"];
            this.subTotalWithTax = _data["subTotalWithTax"];
            this.subTotalDiscount = _data["subTotalDiscount"];
            this.subTotalDiscountWithTax = _data["subTotalDiscountWithTax"];
            this.shippingTotal = _data["shippingTotal"];
            this.shippingTotalWithTax = _data["shippingTotalWithTax"];
            this.shippingSubTotal = _data["shippingSubTotal"];
            this.shippingSubTotalWithTax = _data["shippingSubTotalWithTax"];
            this.shippingDiscountTotal = _data["shippingDiscountTotal"];
            this.shippingDiscountTotalWithTax = _data["shippingDiscountTotalWithTax"];
            this.paymentTotal = _data["paymentTotal"];
            this.paymentTotalWithTax = _data["paymentTotalWithTax"];
            this.paymentSubTotal = _data["paymentSubTotal"];
            this.paymentSubTotalWithTax = _data["paymentSubTotalWithTax"];
            this.paymentDiscountTotal = _data["paymentDiscountTotal"];
            this.paymentDiscountTotalWithTax = _data["paymentDiscountTotalWithTax"];
            this.handlingTotal = _data["handlingTotal"];
            this.handlingTotalWithTax = _data["handlingTotalWithTax"];
            this.discountAmount = _data["discountAmount"];
            this.discountAmountWithTax = _data["discountAmountWithTax"];
            this.discountTotal = _data["discountTotal"];
            this.discountTotalWithTax = _data["discountTotalWithTax"];
            this.fee = _data["fee"];
            this.feeWithTax = _data["feeWithTax"];
            this.feeTotal = _data["feeTotal"];
            this.feeTotalWithTax = _data["feeTotalWithTax"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CartAddress.fromJS(item));
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CartLineItem.fromJS(item));
            }
            if (Array.isArray(_data["payments"])) {
                this.payments = [] as any;
                for (let item of _data["payments"])
                    this.payments!.push(Payment.fromJS(item));
            }
            if (Array.isArray(_data["shipments"])) {
                this.shipments = [] as any;
                for (let item of _data["shipments"])
                    this.shipments!.push(CartShipment.fromJS(item));
            }
            if (Array.isArray(_data["coupons"])) {
                this.coupons = [] as any;
                for (let item of _data["coupons"])
                    this.coupons!.push(item);
            }
            this.coupon = _data["coupon"];
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(Discount.fromJS(item));
            }
            this.taxType = _data["taxType"];
            this.taxTotal = _data["taxTotal"];
            this.taxPercentRate = _data["taxPercentRate"];
            if (Array.isArray(_data["taxDetails"])) {
                this.taxDetails = [] as any;
                for (let item of _data["taxDetails"])
                    this.taxDetails!.push(TaxDetail.fromJS(item));
            }
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ShoppingCart {
        data = typeof data === 'object' ? data : {};
        let result = new ShoppingCart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["storeId"] = this.storeId;
        data["channelId"] = this.channelId;
        data["isAnonymous"] = this.isAnonymous;
        data["customerId"] = this.customerId;
        data["customerName"] = this.customerName;
        data["organizationId"] = this.organizationId;
        data["currency"] = this.currency;
        data["languageCode"] = this.languageCode;
        data["taxIncluded"] = this.taxIncluded;
        data["isRecuring"] = this.isRecuring;
        data["comment"] = this.comment;
        data["status"] = this.status;
        data["purchaseOrderNumber"] = this.purchaseOrderNumber;
        data["weightUnit"] = this.weightUnit;
        data["weight"] = this.weight;
        data["validationType"] = this.validationType;
        data["type"] = this.type;
        data["volumetricWeight"] = this.volumetricWeight;
        data["total"] = this.total;
        data["subTotal"] = this.subTotal;
        data["subTotalWithTax"] = this.subTotalWithTax;
        data["subTotalDiscount"] = this.subTotalDiscount;
        data["subTotalDiscountWithTax"] = this.subTotalDiscountWithTax;
        data["shippingTotal"] = this.shippingTotal;
        data["shippingTotalWithTax"] = this.shippingTotalWithTax;
        data["shippingSubTotal"] = this.shippingSubTotal;
        data["shippingSubTotalWithTax"] = this.shippingSubTotalWithTax;
        data["shippingDiscountTotal"] = this.shippingDiscountTotal;
        data["shippingDiscountTotalWithTax"] = this.shippingDiscountTotalWithTax;
        data["paymentTotal"] = this.paymentTotal;
        data["paymentTotalWithTax"] = this.paymentTotalWithTax;
        data["paymentSubTotal"] = this.paymentSubTotal;
        data["paymentSubTotalWithTax"] = this.paymentSubTotalWithTax;
        data["paymentDiscountTotal"] = this.paymentDiscountTotal;
        data["paymentDiscountTotalWithTax"] = this.paymentDiscountTotalWithTax;
        data["handlingTotal"] = this.handlingTotal;
        data["handlingTotalWithTax"] = this.handlingTotalWithTax;
        data["discountAmount"] = this.discountAmount;
        data["discountAmountWithTax"] = this.discountAmountWithTax;
        data["discountTotal"] = this.discountTotal;
        data["discountTotalWithTax"] = this.discountTotalWithTax;
        data["fee"] = this.fee;
        data["feeWithTax"] = this.feeWithTax;
        data["feeTotal"] = this.feeTotal;
        data["feeTotalWithTax"] = this.feeTotalWithTax;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.payments)) {
            data["payments"] = [];
            for (let item of this.payments)
                data["payments"].push(item.toJSON());
        }
        if (Array.isArray(this.shipments)) {
            data["shipments"] = [];
            for (let item of this.shipments)
                data["shipments"].push(item.toJSON());
        }
        if (Array.isArray(this.coupons)) {
            data["coupons"] = [];
            for (let item of this.coupons)
                data["coupons"].push(item);
        }
        data["coupon"] = this.coupon;
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        data["taxType"] = this.taxType;
        data["taxTotal"] = this.taxTotal;
        data["taxPercentRate"] = this.taxPercentRate;
        if (Array.isArray(this.taxDetails)) {
            data["taxDetails"] = [];
            for (let item of this.taxDetails)
                data["taxDetails"].push(item.toJSON());
        }
        data["objectType"] = this.objectType;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IShoppingCart {
    name?: string | undefined;
    storeId?: string | undefined;
    channelId?: string | undefined;
    isAnonymous?: boolean;
    customerId?: string | undefined;
    customerName?: string | undefined;
    organizationId?: string | undefined;
    currency?: string | undefined;
    languageCode?: string | undefined;
    taxIncluded?: boolean | undefined;
    isRecuring?: boolean | undefined;
    comment?: string | undefined;
    status?: string | undefined;
    purchaseOrderNumber?: string | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    validationType?: string | undefined;
    type?: string | undefined;
    volumetricWeight?: number | undefined;
    total?: number;
    subTotal?: number;
    subTotalWithTax?: number;
    subTotalDiscount?: number;
    subTotalDiscountWithTax?: number;
    shippingTotal?: number;
    shippingTotalWithTax?: number;
    shippingSubTotal?: number;
    shippingSubTotalWithTax?: number;
    shippingDiscountTotal?: number;
    shippingDiscountTotalWithTax?: number;
    paymentTotal?: number;
    paymentTotalWithTax?: number;
    paymentSubTotal?: number;
    paymentSubTotalWithTax?: number;
    paymentDiscountTotal?: number;
    paymentDiscountTotalWithTax?: number;
    handlingTotal?: number;
    handlingTotalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    discountTotal?: number;
    discountTotalWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    feeTotal?: number;
    feeTotalWithTax?: number;
    addresses?: CartAddress[] | undefined;
    items?: CartLineItem[] | undefined;
    payments?: Payment[] | undefined;
    shipments?: CartShipment[] | undefined;
    coupons?: string[] | undefined;
    coupon?: string | undefined;
    discounts?: Discount[] | undefined;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    taxDetails?: TaxDetail[] | undefined;
    objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ShippingMethod implements IShippingMethod {
    code?: string | undefined;
    readonly name?: string | undefined;
    logoUrl?: string | undefined;
    isActive?: boolean;
    priority?: number;
    taxType?: string | undefined;
    storeId?: string | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    readonly typeName?: string | undefined;
    id?: string | undefined;

    constructor(data?: IShippingMethod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            (<any>this).name = _data["name"];
            this.logoUrl = _data["logoUrl"];
            this.isActive = _data["isActive"];
            this.priority = _data["priority"];
            this.taxType = _data["taxType"];
            this.storeId = _data["storeId"];
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings!.push(ObjectSettingEntry.fromJS(item));
            }
            (<any>this).typeName = _data["typeName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ShippingMethod {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["logoUrl"] = this.logoUrl;
        data["isActive"] = this.isActive;
        data["priority"] = this.priority;
        data["taxType"] = this.taxType;
        data["storeId"] = this.storeId;
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["typeName"] = this.typeName;
        data["id"] = this.id;
        return data;
    }
}

export interface IShippingMethod {
    code?: string | undefined;
    name?: string | undefined;
    logoUrl?: string | undefined;
    isActive?: boolean;
    priority?: number;
    taxType?: string | undefined;
    storeId?: string | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    typeName?: string | undefined;
    id?: string | undefined;
}

export class ShippingRate implements IShippingRate {
    optionName?: string | undefined;
    optionDescription?: string | undefined;
    rate?: number;
    rateWithTax?: number;
    currency?: string | undefined;
    discountAmount?: number;
    discountAmountWithTax?: number;
    shippingMethod?: ShippingMethod;

    constructor(data?: IShippingRate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.optionName = _data["optionName"];
            this.optionDescription = _data["optionDescription"];
            this.rate = _data["rate"];
            this.rateWithTax = _data["rateWithTax"];
            this.currency = _data["currency"];
            this.discountAmount = _data["discountAmount"];
            this.discountAmountWithTax = _data["discountAmountWithTax"];
            this.shippingMethod = _data["shippingMethod"] ? ShippingMethod.fromJS(_data["shippingMethod"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ShippingRate {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingRate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["optionName"] = this.optionName;
        data["optionDescription"] = this.optionDescription;
        data["rate"] = this.rate;
        data["rateWithTax"] = this.rateWithTax;
        data["currency"] = this.currency;
        data["discountAmount"] = this.discountAmount;
        data["discountAmountWithTax"] = this.discountAmountWithTax;
        data["shippingMethod"] = this.shippingMethod ? this.shippingMethod.toJSON() : <any>undefined;
        return data;
    }
}

export interface IShippingRate {
    optionName?: string | undefined;
    optionDescription?: string | undefined;
    rate?: number;
    rateWithTax?: number;
    currency?: string | undefined;
    discountAmount?: number;
    discountAmountWithTax?: number;
    shippingMethod?: ShippingMethod;
}

export class ShippingEvaluationContext implements IShippingEvaluationContext {
    shoppingCart?: ShoppingCart;
    currency?: string | undefined;

    constructor(data?: IShippingEvaluationContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shoppingCart = _data["shoppingCart"] ? ShoppingCart.fromJS(_data["shoppingCart"]) : <any>undefined;
            this.currency = _data["currency"];
        }
    }

    static fromJS(data: any): ShippingEvaluationContext {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingEvaluationContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shoppingCart"] = this.shoppingCart ? this.shoppingCart.toJSON() : <any>undefined;
        data["currency"] = this.currency;
        return data;
    }
}

export interface IShippingEvaluationContext {
    shoppingCart?: ShoppingCart;
    currency?: string | undefined;
}

export enum PaymentMethodType {
    Unknown = "Unknown",
    Standard = "Standard",
    Redirection = "Redirection",
    PreparedForm = "PreparedForm",
}

export enum PaymentMethodGroupType {
    Paypal = "Paypal",
    BankCard = "BankCard",
    Alternative = "Alternative",
    Manual = "Manual",
}

export class PaymentMethod implements IPaymentMethod {
    code?: string | undefined;
    name?: string | undefined;
    logoUrl?: string | undefined;
    isActive?: boolean;
    priority?: number;
    isAvailableForPartial?: boolean;
    currency?: string | undefined;
    price?: number;
    readonly priceWithTax?: number;
    readonly total?: number;
    readonly totalWithTax?: number;
    discountAmount?: number;
    readonly discountAmountWithTax?: number;
    storeId?: string | undefined;
    description?: string | undefined;
    readonly typeName?: string | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    taxType?: string | undefined;
    readonly taxTotal?: number;
    taxPercentRate?: number;
    taxDetails?: TaxDetail[] | undefined;
    paymentMethodType?: PaymentMethodType;
    paymentMethodGroupType?: PaymentMethodGroupType;
    id?: string | undefined;

    constructor(data?: IPaymentMethod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.logoUrl = _data["logoUrl"];
            this.isActive = _data["isActive"];
            this.priority = _data["priority"];
            this.isAvailableForPartial = _data["isAvailableForPartial"];
            this.currency = _data["currency"];
            this.price = _data["price"];
            (<any>this).priceWithTax = _data["priceWithTax"];
            (<any>this).total = _data["total"];
            (<any>this).totalWithTax = _data["totalWithTax"];
            this.discountAmount = _data["discountAmount"];
            (<any>this).discountAmountWithTax = _data["discountAmountWithTax"];
            this.storeId = _data["storeId"];
            this.description = _data["description"];
            (<any>this).typeName = _data["typeName"];
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings!.push(ObjectSettingEntry.fromJS(item));
            }
            this.taxType = _data["taxType"];
            (<any>this).taxTotal = _data["taxTotal"];
            this.taxPercentRate = _data["taxPercentRate"];
            if (Array.isArray(_data["taxDetails"])) {
                this.taxDetails = [] as any;
                for (let item of _data["taxDetails"])
                    this.taxDetails!.push(TaxDetail.fromJS(item));
            }
            this.paymentMethodType = _data["paymentMethodType"];
            this.paymentMethodGroupType = _data["paymentMethodGroupType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PaymentMethod {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["logoUrl"] = this.logoUrl;
        data["isActive"] = this.isActive;
        data["priority"] = this.priority;
        data["isAvailableForPartial"] = this.isAvailableForPartial;
        data["currency"] = this.currency;
        data["price"] = this.price;
        data["priceWithTax"] = this.priceWithTax;
        data["total"] = this.total;
        data["totalWithTax"] = this.totalWithTax;
        data["discountAmount"] = this.discountAmount;
        data["discountAmountWithTax"] = this.discountAmountWithTax;
        data["storeId"] = this.storeId;
        data["description"] = this.description;
        data["typeName"] = this.typeName;
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["taxType"] = this.taxType;
        data["taxTotal"] = this.taxTotal;
        data["taxPercentRate"] = this.taxPercentRate;
        if (Array.isArray(this.taxDetails)) {
            data["taxDetails"] = [];
            for (let item of this.taxDetails)
                data["taxDetails"].push(item.toJSON());
        }
        data["paymentMethodType"] = this.paymentMethodType;
        data["paymentMethodGroupType"] = this.paymentMethodGroupType;
        data["id"] = this.id;
        return data;
    }
}

export interface IPaymentMethod {
    code?: string | undefined;
    name?: string | undefined;
    logoUrl?: string | undefined;
    isActive?: boolean;
    priority?: number;
    isAvailableForPartial?: boolean;
    currency?: string | undefined;
    price?: number;
    priceWithTax?: number;
    total?: number;
    totalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    storeId?: string | undefined;
    description?: string | undefined;
    typeName?: string | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    taxDetails?: TaxDetail[] | undefined;
    paymentMethodType?: PaymentMethodType;
    paymentMethodGroupType?: PaymentMethodGroupType;
    id?: string | undefined;
}

export class ShoppingCartSearchCriteria implements IShoppingCartSearchCriteria {
    name?: string | undefined;
    customerId?: string | undefined;
    storeId?: string | undefined;
    currency?: string | undefined;
    status?: string | undefined;
    type?: string | undefined;
    customerIds?: string[] | undefined;
    organizationId?: string | undefined;
    createdStartDate?: Date | undefined;
    createdEndDate?: Date | undefined;
    modifiedStartDate?: Date | undefined;
    modifiedEndDate?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IShoppingCartSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.customerId = _data["customerId"];
            this.storeId = _data["storeId"];
            this.currency = _data["currency"];
            this.status = _data["status"];
            this.type = _data["type"];
            if (Array.isArray(_data["customerIds"])) {
                this.customerIds = [] as any;
                for (let item of _data["customerIds"])
                    this.customerIds!.push(item);
            }
            this.organizationId = _data["organizationId"];
            this.createdStartDate = _data["createdStartDate"] ? new Date(_data["createdStartDate"].toString()) : <any>undefined;
            this.createdEndDate = _data["createdEndDate"] ? new Date(_data["createdEndDate"].toString()) : <any>undefined;
            this.modifiedStartDate = _data["modifiedStartDate"] ? new Date(_data["modifiedStartDate"].toString()) : <any>undefined;
            this.modifiedEndDate = _data["modifiedEndDate"] ? new Date(_data["modifiedEndDate"].toString()) : <any>undefined;
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): ShoppingCartSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new ShoppingCartSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["customerId"] = this.customerId;
        data["storeId"] = this.storeId;
        data["currency"] = this.currency;
        data["status"] = this.status;
        data["type"] = this.type;
        if (Array.isArray(this.customerIds)) {
            data["customerIds"] = [];
            for (let item of this.customerIds)
                data["customerIds"].push(item);
        }
        data["organizationId"] = this.organizationId;
        data["createdStartDate"] = this.createdStartDate ? this.createdStartDate.toISOString() : <any>undefined;
        data["createdEndDate"] = this.createdEndDate ? this.createdEndDate.toISOString() : <any>undefined;
        data["modifiedStartDate"] = this.modifiedStartDate ? this.modifiedStartDate.toISOString() : <any>undefined;
        data["modifiedEndDate"] = this.modifiedEndDate ? this.modifiedEndDate.toISOString() : <any>undefined;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IShoppingCartSearchCriteria {
    name?: string | undefined;
    customerId?: string | undefined;
    storeId?: string | undefined;
    currency?: string | undefined;
    status?: string | undefined;
    type?: string | undefined;
    customerIds?: string[] | undefined;
    organizationId?: string | undefined;
    createdStartDate?: Date | undefined;
    createdEndDate?: Date | undefined;
    modifiedStartDate?: Date | undefined;
    modifiedEndDate?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class ShoppingCartSearchResult implements IShoppingCartSearchResult {
    totalCount?: number;
    results?: ShoppingCart[] | undefined;

    constructor(data?: IShoppingCartSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ShoppingCart.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShoppingCartSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ShoppingCartSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IShoppingCartSearchResult {
    totalCount?: number;
    results?: ShoppingCart[] | undefined;
}

export class SeoInfo implements ISeoInfo {
    name?: string | undefined;
    semanticUrl?: string | undefined;
    pageTitle?: string | undefined;
    metaDescription?: string | undefined;
    imageAltDescription?: string | undefined;
    metaKeywords?: string | undefined;
    storeId?: string | undefined;
    objectId?: string | undefined;
    objectType?: string | undefined;
    isActive?: boolean;
    languageCode?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ISeoInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.semanticUrl = _data["semanticUrl"];
            this.pageTitle = _data["pageTitle"];
            this.metaDescription = _data["metaDescription"];
            this.imageAltDescription = _data["imageAltDescription"];
            this.metaKeywords = _data["metaKeywords"];
            this.storeId = _data["storeId"];
            this.objectId = _data["objectId"];
            this.objectType = _data["objectType"];
            this.isActive = _data["isActive"];
            this.languageCode = _data["languageCode"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SeoInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SeoInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["semanticUrl"] = this.semanticUrl;
        data["pageTitle"] = this.pageTitle;
        data["metaDescription"] = this.metaDescription;
        data["imageAltDescription"] = this.imageAltDescription;
        data["metaKeywords"] = this.metaKeywords;
        data["storeId"] = this.storeId;
        data["objectId"] = this.objectId;
        data["objectType"] = this.objectType;
        data["isActive"] = this.isActive;
        data["languageCode"] = this.languageCode;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ISeoInfo {
    name?: string | undefined;
    semanticUrl?: string | undefined;
    pageTitle?: string | undefined;
    metaDescription?: string | undefined;
    imageAltDescription?: string | undefined;
    metaKeywords?: string | undefined;
    storeId?: string | undefined;
    objectId?: string | undefined;
    objectType?: string | undefined;
    isActive?: boolean;
    languageCode?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Image implements IImage {
    binaryData?: string | undefined;
    altText?: string | undefined;
    relativeUrl?: string | undefined;
    url?: string | undefined;
    description?: string | undefined;
    sortOrder?: number;
    typeId?: string | undefined;
    group?: string | undefined;
    name?: string | undefined;
    outerId?: string | undefined;
    languageCode?: string | undefined;
    readonly isInherited?: boolean;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.binaryData = _data["binaryData"];
            this.altText = _data["altText"];
            this.relativeUrl = _data["relativeUrl"];
            this.url = _data["url"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.typeId = _data["typeId"];
            this.group = _data["group"];
            this.name = _data["name"];
            this.outerId = _data["outerId"];
            this.languageCode = _data["languageCode"];
            (<any>this).isInherited = _data["isInherited"];
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Image {
        data = typeof data === 'object' ? data : {};
        let result = new Image();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["binaryData"] = this.binaryData;
        data["altText"] = this.altText;
        data["relativeUrl"] = this.relativeUrl;
        data["url"] = this.url;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["typeId"] = this.typeId;
        data["group"] = this.group;
        data["name"] = this.name;
        data["outerId"] = this.outerId;
        data["languageCode"] = this.languageCode;
        data["isInherited"] = this.isInherited;
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IImage {
    binaryData?: string | undefined;
    altText?: string | undefined;
    relativeUrl?: string | undefined;
    url?: string | undefined;
    description?: string | undefined;
    sortOrder?: number;
    typeId?: string | undefined;
    group?: string | undefined;
    name?: string | undefined;
    outerId?: string | undefined;
    languageCode?: string | undefined;
    isInherited?: boolean;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ProductAssociation implements IProductAssociation {
    type?: string | undefined;
    priority?: number;
    quantity?: number | undefined;
    itemId?: string | undefined;
    associatedObjectId?: string | undefined;
    associatedObjectType?: string | undefined;
    outerId?: string | undefined;
    readonly associatedObjectName?: string | undefined;
    readonly associatedObjectImg?: string | undefined;
    tags?: string[] | undefined;
    readonly imgSrc?: string | undefined;
    images?: Image[] | undefined;
    id?: string | undefined;

    constructor(data?: IProductAssociation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.priority = _data["priority"];
            this.quantity = _data["quantity"];
            this.itemId = _data["itemId"];
            this.associatedObjectId = _data["associatedObjectId"];
            this.associatedObjectType = _data["associatedObjectType"];
            this.outerId = _data["outerId"];
            (<any>this).associatedObjectName = _data["associatedObjectName"];
            (<any>this).associatedObjectImg = _data["associatedObjectImg"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            (<any>this).imgSrc = _data["imgSrc"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(Image.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductAssociation {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAssociation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["priority"] = this.priority;
        data["quantity"] = this.quantity;
        data["itemId"] = this.itemId;
        data["associatedObjectId"] = this.associatedObjectId;
        data["associatedObjectType"] = this.associatedObjectType;
        data["outerId"] = this.outerId;
        data["associatedObjectName"] = this.associatedObjectName;
        data["associatedObjectImg"] = this.associatedObjectImg;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["imgSrc"] = this.imgSrc;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IProductAssociation {
    type?: string | undefined;
    priority?: number;
    quantity?: number | undefined;
    itemId?: string | undefined;
    associatedObjectId?: string | undefined;
    associatedObjectType?: string | undefined;
    outerId?: string | undefined;
    associatedObjectName?: string | undefined;
    associatedObjectImg?: string | undefined;
    tags?: string[] | undefined;
    imgSrc?: string | undefined;
    images?: Image[] | undefined;
    id?: string | undefined;
}

export class ProductAssociationSearchCriteria implements IProductAssociationSearchCriteria {
    group?: string | undefined;
    tags?: string[] | undefined;
    associatedObjectIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IProductAssociationSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data["group"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            if (Array.isArray(_data["associatedObjectIds"])) {
                this.associatedObjectIds = [] as any;
                for (let item of _data["associatedObjectIds"])
                    this.associatedObjectIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): ProductAssociationSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAssociationSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        if (Array.isArray(this.associatedObjectIds)) {
            data["associatedObjectIds"] = [];
            for (let item of this.associatedObjectIds)
                data["associatedObjectIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IProductAssociationSearchCriteria {
    group?: string | undefined;
    tags?: string[] | undefined;
    associatedObjectIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class ProductAssociationSearchResult implements IProductAssociationSearchResult {
    totalCount?: number;
    results?: ProductAssociation[] | undefined;

    constructor(data?: IProductAssociationSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ProductAssociation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductAssociationSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAssociationSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductAssociationSearchResult {
    totalCount?: number;
    results?: ProductAssociation[] | undefined;
}

export class CatalogSearchCriteria implements ICatalogSearchCriteria {
    catalogIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ICatalogSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["catalogIds"])) {
                this.catalogIds = [] as any;
                for (let item of _data["catalogIds"])
                    this.catalogIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): CatalogSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.catalogIds)) {
            data["catalogIds"] = [];
            for (let item of this.catalogIds)
                data["catalogIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ICatalogSearchCriteria {
    catalogIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class CatalogLanguage implements ICatalogLanguage {
    catalogId?: string | undefined;
    isDefault?: boolean;
    languageCode?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICatalogLanguage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalogId = _data["catalogId"];
            this.isDefault = _data["isDefault"];
            this.languageCode = _data["languageCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CatalogLanguage {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogLanguage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalogId"] = this.catalogId;
        data["isDefault"] = this.isDefault;
        data["languageCode"] = this.languageCode;
        data["id"] = this.id;
        return data;
    }
}

export interface ICatalogLanguage {
    catalogId?: string | undefined;
    isDefault?: boolean;
    languageCode?: string | undefined;
    id?: string | undefined;
}

export enum PropertyValueType {
    ShortText = "ShortText",
    LongText = "LongText",
    Number = "Number",
    DateTime = "DateTime",
    Boolean = "Boolean",
    Integer = "Integer",
    GeoPoint = "GeoPoint",
}

export enum PropertyType {
    Product = "Product",
    Variation = "Variation",
    Category = "Category",
    Catalog = "Catalog",
}

export class PropertyValue implements IPropertyValue {
    propertyName?: string | undefined;
    propertyId?: string | undefined;
    languageCode?: string | undefined;
    alias?: string | undefined;
    valueType?: PropertyValueType;
    valueId?: string | undefined;
    value?: any | undefined;
    readonly propertyMultivalue?: boolean;
    outerId?: string | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPropertyValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.propertyId = _data["propertyId"];
            this.languageCode = _data["languageCode"];
            this.alias = _data["alias"];
            this.valueType = _data["valueType"];
            this.valueId = _data["valueId"];
            this.value = _data["value"];
            (<any>this).propertyMultivalue = _data["propertyMultivalue"];
            this.outerId = _data["outerId"];
            this.isInherited = _data["isInherited"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PropertyValue {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["propertyId"] = this.propertyId;
        data["languageCode"] = this.languageCode;
        data["alias"] = this.alias;
        data["valueType"] = this.valueType;
        data["valueId"] = this.valueId;
        data["value"] = this.value;
        data["propertyMultivalue"] = this.propertyMultivalue;
        data["outerId"] = this.outerId;
        data["isInherited"] = this.isInherited;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IPropertyValue {
    propertyName?: string | undefined;
    propertyId?: string | undefined;
    languageCode?: string | undefined;
    alias?: string | undefined;
    valueType?: PropertyValueType;
    valueId?: string | undefined;
    value?: any | undefined;
    propertyMultivalue?: boolean;
    outerId?: string | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class PropertyAttribute implements IPropertyAttribute {
    propertyId?: string | undefined;
    value?: string | undefined;
    name?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPropertyAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.value = _data["value"];
            this.name = _data["name"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PropertyAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["value"] = this.value;
        data["name"] = this.name;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IPropertyAttribute {
    propertyId?: string | undefined;
    value?: string | undefined;
    name?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class PropertyDisplayName implements IPropertyDisplayName {
    name?: string | undefined;
    languageCode?: string | undefined;

    constructor(data?: IPropertyDisplayName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.languageCode = _data["languageCode"];
        }
    }

    static fromJS(data: any): PropertyDisplayName {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDisplayName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["languageCode"] = this.languageCode;
        return data;
    }
}

export interface IPropertyDisplayName {
    name?: string | undefined;
    languageCode?: string | undefined;
}

export class PropertyValidationRule implements IPropertyValidationRule {
    isUnique?: boolean;
    charCountMin?: number | undefined;
    charCountMax?: number | undefined;
    regExp?: string | undefined;
    propertyId?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPropertyValidationRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isUnique = _data["isUnique"];
            this.charCountMin = _data["charCountMin"];
            this.charCountMax = _data["charCountMax"];
            this.regExp = _data["regExp"];
            this.propertyId = _data["propertyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PropertyValidationRule {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyValidationRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isUnique"] = this.isUnique;
        data["charCountMin"] = this.charCountMin;
        data["charCountMax"] = this.charCountMax;
        data["regExp"] = this.regExp;
        data["propertyId"] = this.propertyId;
        data["id"] = this.id;
        return data;
    }
}

export interface IPropertyValidationRule {
    isUnique?: boolean;
    charCountMin?: number | undefined;
    charCountMax?: number | undefined;
    regExp?: string | undefined;
    propertyId?: string | undefined;
    id?: string | undefined;
}

export class Property implements IProperty {
    isReadOnly?: boolean;
    readonly isManageable?: boolean;
    isNew?: boolean;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    name?: string | undefined;
    required?: boolean;
    dictionary?: boolean;
    multivalue?: boolean;
    multilanguage?: boolean;
    hidden?: boolean;
    valueType?: PropertyValueType;
    type?: PropertyType;
    outerId?: string | undefined;
    ownerName?: string | undefined;
    values?: PropertyValue[] | undefined;
    attributes?: PropertyAttribute[] | undefined;
    displayNames?: PropertyDisplayName[] | undefined;
    validationRules?: PropertyValidationRule[] | undefined;
    validationRule?: PropertyValidationRule;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isReadOnly = _data["isReadOnly"];
            (<any>this).isManageable = _data["isManageable"];
            this.isNew = _data["isNew"];
            this.catalogId = _data["catalogId"];
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.required = _data["required"];
            this.dictionary = _data["dictionary"];
            this.multivalue = _data["multivalue"];
            this.multilanguage = _data["multilanguage"];
            this.hidden = _data["hidden"];
            this.valueType = _data["valueType"];
            this.type = _data["type"];
            this.outerId = _data["outerId"];
            this.ownerName = _data["ownerName"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(PropertyValue.fromJS(item));
            }
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(PropertyAttribute.fromJS(item));
            }
            if (Array.isArray(_data["displayNames"])) {
                this.displayNames = [] as any;
                for (let item of _data["displayNames"])
                    this.displayNames!.push(PropertyDisplayName.fromJS(item));
            }
            if (Array.isArray(_data["validationRules"])) {
                this.validationRules = [] as any;
                for (let item of _data["validationRules"])
                    this.validationRules!.push(PropertyValidationRule.fromJS(item));
            }
            this.validationRule = _data["validationRule"] ? PropertyValidationRule.fromJS(_data["validationRule"]) : <any>undefined;
            this.isInherited = _data["isInherited"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Property {
        data = typeof data === 'object' ? data : {};
        let result = new Property();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isReadOnly"] = this.isReadOnly;
        data["isManageable"] = this.isManageable;
        data["isNew"] = this.isNew;
        data["catalogId"] = this.catalogId;
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["required"] = this.required;
        data["dictionary"] = this.dictionary;
        data["multivalue"] = this.multivalue;
        data["multilanguage"] = this.multilanguage;
        data["hidden"] = this.hidden;
        data["valueType"] = this.valueType;
        data["type"] = this.type;
        data["outerId"] = this.outerId;
        data["ownerName"] = this.ownerName;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        if (Array.isArray(this.displayNames)) {
            data["displayNames"] = [];
            for (let item of this.displayNames)
                data["displayNames"].push(item.toJSON());
        }
        if (Array.isArray(this.validationRules)) {
            data["validationRules"] = [];
            for (let item of this.validationRules)
                data["validationRules"].push(item.toJSON());
        }
        data["validationRule"] = this.validationRule ? this.validationRule.toJSON() : <any>undefined;
        data["isInherited"] = this.isInherited;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IProperty {
    isReadOnly?: boolean;
    isManageable?: boolean;
    isNew?: boolean;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    name?: string | undefined;
    required?: boolean;
    dictionary?: boolean;
    multivalue?: boolean;
    multilanguage?: boolean;
    hidden?: boolean;
    valueType?: PropertyValueType;
    type?: PropertyType;
    outerId?: string | undefined;
    ownerName?: string | undefined;
    values?: PropertyValue[] | undefined;
    attributes?: PropertyAttribute[] | undefined;
    displayNames?: PropertyDisplayName[] | undefined;
    validationRules?: PropertyValidationRule[] | undefined;
    validationRule?: PropertyValidationRule;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Catalog implements ICatalog {
    name?: string | undefined;
    isVirtual?: boolean;
    outerId?: string | undefined;
    defaultLanguage?: CatalogLanguage;
    languages?: CatalogLanguage[] | undefined;
    properties?: Property[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICatalog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isVirtual = _data["isVirtual"];
            this.outerId = _data["outerId"];
            this.defaultLanguage = _data["defaultLanguage"] ? CatalogLanguage.fromJS(_data["defaultLanguage"]) : <any>undefined;
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(CatalogLanguage.fromJS(item));
            }
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(Property.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Catalog {
        data = typeof data === 'object' ? data : {};
        let result = new Catalog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isVirtual"] = this.isVirtual;
        data["outerId"] = this.outerId;
        data["defaultLanguage"] = this.defaultLanguage ? this.defaultLanguage.toJSON() : <any>undefined;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ICatalog {
    name?: string | undefined;
    isVirtual?: boolean;
    outerId?: string | undefined;
    defaultLanguage?: CatalogLanguage;
    languages?: CatalogLanguage[] | undefined;
    properties?: Property[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CatalogSearchResult implements ICatalogSearchResult {
    totalCount?: number;
    results?: Catalog[] | undefined;

    constructor(data?: ICatalogSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Catalog.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CatalogSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICatalogSearchResult {
    totalCount?: number;
    results?: Catalog[] | undefined;
}

export class ExcludedProperty implements IExcludedProperty {
    name?: string | undefined;
    isInherited?: boolean;

    constructor(data?: IExcludedProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isInherited = _data["isInherited"];
        }
    }

    static fromJS(data: any): ExcludedProperty {
        data = typeof data === 'object' ? data : {};
        let result = new ExcludedProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isInherited"] = this.isInherited;
        return data;
    }
}

export interface IExcludedProperty {
    name?: string | undefined;
    isInherited?: boolean;
}

export class CategoryLink implements ICategoryLink {
    readonly entryId?: string | undefined;
    listEntryId?: string | undefined;
    listEntryType?: string | undefined;
    priority?: number;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    category?: Category;
    readonly targetId?: string | undefined;
    readonly name?: string | undefined;

    constructor(data?: ICategoryLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).entryId = _data["entryId"];
            this.listEntryId = _data["listEntryId"];
            this.listEntryType = _data["listEntryType"];
            this.priority = _data["priority"];
            this.catalogId = _data["catalogId"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>undefined;
            (<any>this).targetId = _data["targetId"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): CategoryLink {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entryId"] = this.entryId;
        data["listEntryId"] = this.listEntryId;
        data["listEntryType"] = this.listEntryType;
        data["priority"] = this.priority;
        data["catalogId"] = this.catalogId;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["targetId"] = this.targetId;
        data["name"] = this.name;
        return data;
    }
}

export interface ICategoryLink {
    entryId?: string | undefined;
    listEntryId?: string | undefined;
    listEntryType?: string | undefined;
    priority?: number;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    category?: Category;
    targetId?: string | undefined;
    name?: string | undefined;
}

export class CategoryDescription implements ICategoryDescription {
    content?: string | undefined;
    descriptionType?: string | undefined;
    languageCode?: string | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICategoryDescription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.descriptionType = _data["descriptionType"];
            this.languageCode = _data["languageCode"];
            this.isInherited = _data["isInherited"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CategoryDescription {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDescription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["descriptionType"] = this.descriptionType;
        data["languageCode"] = this.languageCode;
        data["isInherited"] = this.isInherited;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ICategoryDescription {
    content?: string | undefined;
    descriptionType?: string | undefined;
    languageCode?: string | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class OutlineItem implements IOutlineItem {
    id?: string | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    name?: string | undefined;
    hasVirtualParent?: boolean;

    constructor(data?: IOutlineItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.name = _data["name"];
            this.hasVirtualParent = _data["hasVirtualParent"];
        }
    }

    static fromJS(data: any): OutlineItem {
        data = typeof data === 'object' ? data : {};
        let result = new OutlineItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["hasVirtualParent"] = this.hasVirtualParent;
        return data;
    }
}

export interface IOutlineItem {
    id?: string | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    name?: string | undefined;
    hasVirtualParent?: boolean;
}

export class Outline implements IOutline {
    items?: OutlineItem[] | undefined;

    constructor(data?: IOutline) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OutlineItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Outline {
        data = typeof data === 'object' ? data : {};
        let result = new Outline();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOutline {
    items?: OutlineItem[] | undefined;
}

export class Category implements ICategory {
    catalogId?: string | undefined;
    parentId?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    readonly outline?: string | undefined;
    path?: string | undefined;
    isVirtual?: boolean;
    level?: number;
    packageType?: string | undefined;
    priority?: number;
    isActive?: boolean | undefined;
    outerId?: string | undefined;
    properties?: Property[] | undefined;
    excludedProperties?: ExcludedProperty[] | undefined;
    links?: CategoryLink[] | undefined;
    taxType?: string | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    enableDescription?: boolean | undefined;
    descriptions?: CategoryDescription[] | undefined;
    readonly imgSrc?: string | undefined;
    images?: Image[] | undefined;
    outlines?: Outline[] | undefined;
    readonly isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalogId = _data["catalogId"];
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.name = _data["name"];
            (<any>this).outline = _data["outline"];
            this.path = _data["path"];
            this.isVirtual = _data["isVirtual"];
            this.level = _data["level"];
            this.packageType = _data["packageType"];
            this.priority = _data["priority"];
            this.isActive = _data["isActive"];
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(Property.fromJS(item));
            }
            if (Array.isArray(_data["excludedProperties"])) {
                this.excludedProperties = [] as any;
                for (let item of _data["excludedProperties"])
                    this.excludedProperties!.push(ExcludedProperty.fromJS(item));
            }
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(CategoryLink.fromJS(item));
            }
            this.taxType = _data["taxType"];
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.enableDescription = _data["enableDescription"];
            if (Array.isArray(_data["descriptions"])) {
                this.descriptions = [] as any;
                for (let item of _data["descriptions"])
                    this.descriptions!.push(CategoryDescription.fromJS(item));
            }
            (<any>this).imgSrc = _data["imgSrc"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(Image.fromJS(item));
            }
            if (Array.isArray(_data["outlines"])) {
                this.outlines = [] as any;
                for (let item of _data["outlines"])
                    this.outlines!.push(Outline.fromJS(item));
            }
            (<any>this).isInherited = _data["isInherited"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalogId"] = this.catalogId;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["outline"] = this.outline;
        data["path"] = this.path;
        data["isVirtual"] = this.isVirtual;
        data["level"] = this.level;
        data["packageType"] = this.packageType;
        data["priority"] = this.priority;
        data["isActive"] = this.isActive;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        if (Array.isArray(this.excludedProperties)) {
            data["excludedProperties"] = [];
            for (let item of this.excludedProperties)
                data["excludedProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["taxType"] = this.taxType;
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["enableDescription"] = this.enableDescription;
        if (Array.isArray(this.descriptions)) {
            data["descriptions"] = [];
            for (let item of this.descriptions)
                data["descriptions"].push(item.toJSON());
        }
        data["imgSrc"] = this.imgSrc;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        if (Array.isArray(this.outlines)) {
            data["outlines"] = [];
            for (let item of this.outlines)
                data["outlines"].push(item.toJSON());
        }
        data["isInherited"] = this.isInherited;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ICategory {
    catalogId?: string | undefined;
    parentId?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    outline?: string | undefined;
    path?: string | undefined;
    isVirtual?: boolean;
    level?: number;
    packageType?: string | undefined;
    priority?: number;
    isActive?: boolean | undefined;
    outerId?: string | undefined;
    properties?: Property[] | undefined;
    excludedProperties?: ExcludedProperty[] | undefined;
    links?: CategoryLink[] | undefined;
    taxType?: string | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    enableDescription?: boolean | undefined;
    descriptions?: CategoryDescription[] | undefined;
    imgSrc?: string | undefined;
    images?: Image[] | undefined;
    outlines?: Outline[] | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class NumericRange implements INumericRange {
    lower?: number | undefined;
    upper?: number | undefined;
    includeLower?: boolean;
    includeUpper?: boolean;

    constructor(data?: INumericRange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lower = _data["lower"];
            this.upper = _data["upper"];
            this.includeLower = _data["includeLower"];
            this.includeUpper = _data["includeUpper"];
        }
    }

    static fromJS(data: any): NumericRange {
        data = typeof data === 'object' ? data : {};
        let result = new NumericRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lower"] = this.lower;
        data["upper"] = this.upper;
        data["includeLower"] = this.includeLower;
        data["includeUpper"] = this.includeUpper;
        return data;
    }
}

export interface INumericRange {
    lower?: number | undefined;
    upper?: number | undefined;
    includeLower?: boolean;
    includeUpper?: boolean;
}

export class GeoPoint implements IGeoPoint {
    latitude?: number;
    longitude?: number;

    constructor(data?: IGeoPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): GeoPoint {
        data = typeof data === 'object' ? data : {};
        let result = new GeoPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }
}

export interface IGeoPoint {
    latitude?: number;
    longitude?: number;
}

export class GeoDistanceFilter implements IGeoDistanceFilter {
    fieldName?: string | undefined;
    location?: GeoPoint;
    distance?: number;

    constructor(data?: IGeoDistanceFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.location = _data["location"] ? GeoPoint.fromJS(_data["location"]) : <any>undefined;
            this.distance = _data["distance"];
        }
    }

    static fromJS(data: any): GeoDistanceFilter {
        data = typeof data === 'object' ? data : {};
        let result = new GeoDistanceFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["distance"] = this.distance;
        return data;
    }
}

export interface IGeoDistanceFilter {
    fieldName?: string | undefined;
    location?: GeoPoint;
    distance?: number;
}

export class ProductIndexedSearchCriteria implements IProductIndexedSearchCriteria {
    objectType?: string | undefined;
    productType?: string | undefined;
    currency?: string | undefined;
    pricelists?: string[] | undefined;
    priceRange?: NumericRange;
    classTypes?: string[] | undefined;
    withHidden?: boolean;
    searchInVariations?: boolean;
    startDate?: Date;
    startDateFrom?: Date | undefined;
    endDate?: Date | undefined;
    includeAggregations?: string[] | undefined;
    excludeAggregations?: string[] | undefined;
    geoDistanceFilter?: GeoDistanceFilter;
    readonly sortInfos?: SortInfo[] | undefined;
    storeId?: string | undefined;
    catalogId?: string | undefined;
    catalogIds?: string[] | undefined;
    outline?: string | undefined;
    outlines?: string[] | undefined;
    terms?: string[] | undefined;
    userGroups?: string[] | undefined;
    isFuzzySearch?: boolean;
    rawQuery?: string | undefined;
    includeFields?: string[] | undefined;
    searchPhrase?: string | undefined;
    keyword?: string | undefined;
    responseGroup?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IProductIndexedSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectType = _data["objectType"];
            this.productType = _data["productType"];
            this.currency = _data["currency"];
            if (Array.isArray(_data["pricelists"])) {
                this.pricelists = [] as any;
                for (let item of _data["pricelists"])
                    this.pricelists!.push(item);
            }
            this.priceRange = _data["priceRange"] ? NumericRange.fromJS(_data["priceRange"]) : <any>undefined;
            if (Array.isArray(_data["classTypes"])) {
                this.classTypes = [] as any;
                for (let item of _data["classTypes"])
                    this.classTypes!.push(item);
            }
            this.withHidden = _data["withHidden"];
            this.searchInVariations = _data["searchInVariations"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.startDateFrom = _data["startDateFrom"] ? new Date(_data["startDateFrom"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["includeAggregations"])) {
                this.includeAggregations = [] as any;
                for (let item of _data["includeAggregations"])
                    this.includeAggregations!.push(item);
            }
            if (Array.isArray(_data["excludeAggregations"])) {
                this.excludeAggregations = [] as any;
                for (let item of _data["excludeAggregations"])
                    this.excludeAggregations!.push(item);
            }
            this.geoDistanceFilter = _data["geoDistanceFilter"] ? GeoDistanceFilter.fromJS(_data["geoDistanceFilter"]) : <any>undefined;
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.storeId = _data["storeId"];
            this.catalogId = _data["catalogId"];
            if (Array.isArray(_data["catalogIds"])) {
                this.catalogIds = [] as any;
                for (let item of _data["catalogIds"])
                    this.catalogIds!.push(item);
            }
            this.outline = _data["outline"];
            if (Array.isArray(_data["outlines"])) {
                this.outlines = [] as any;
                for (let item of _data["outlines"])
                    this.outlines!.push(item);
            }
            if (Array.isArray(_data["terms"])) {
                this.terms = [] as any;
                for (let item of _data["terms"])
                    this.terms!.push(item);
            }
            if (Array.isArray(_data["userGroups"])) {
                this.userGroups = [] as any;
                for (let item of _data["userGroups"])
                    this.userGroups!.push(item);
            }
            this.isFuzzySearch = _data["isFuzzySearch"];
            this.rawQuery = _data["rawQuery"];
            if (Array.isArray(_data["includeFields"])) {
                this.includeFields = [] as any;
                for (let item of _data["includeFields"])
                    this.includeFields!.push(item);
            }
            this.searchPhrase = _data["searchPhrase"];
            this.keyword = _data["keyword"];
            this.responseGroup = _data["responseGroup"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): ProductIndexedSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new ProductIndexedSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectType"] = this.objectType;
        data["productType"] = this.productType;
        data["currency"] = this.currency;
        if (Array.isArray(this.pricelists)) {
            data["pricelists"] = [];
            for (let item of this.pricelists)
                data["pricelists"].push(item);
        }
        data["priceRange"] = this.priceRange ? this.priceRange.toJSON() : <any>undefined;
        if (Array.isArray(this.classTypes)) {
            data["classTypes"] = [];
            for (let item of this.classTypes)
                data["classTypes"].push(item);
        }
        data["withHidden"] = this.withHidden;
        data["searchInVariations"] = this.searchInVariations;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["startDateFrom"] = this.startDateFrom ? this.startDateFrom.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (Array.isArray(this.includeAggregations)) {
            data["includeAggregations"] = [];
            for (let item of this.includeAggregations)
                data["includeAggregations"].push(item);
        }
        if (Array.isArray(this.excludeAggregations)) {
            data["excludeAggregations"] = [];
            for (let item of this.excludeAggregations)
                data["excludeAggregations"].push(item);
        }
        data["geoDistanceFilter"] = this.geoDistanceFilter ? this.geoDistanceFilter.toJSON() : <any>undefined;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["storeId"] = this.storeId;
        data["catalogId"] = this.catalogId;
        if (Array.isArray(this.catalogIds)) {
            data["catalogIds"] = [];
            for (let item of this.catalogIds)
                data["catalogIds"].push(item);
        }
        data["outline"] = this.outline;
        if (Array.isArray(this.outlines)) {
            data["outlines"] = [];
            for (let item of this.outlines)
                data["outlines"].push(item);
        }
        if (Array.isArray(this.terms)) {
            data["terms"] = [];
            for (let item of this.terms)
                data["terms"].push(item);
        }
        if (Array.isArray(this.userGroups)) {
            data["userGroups"] = [];
            for (let item of this.userGroups)
                data["userGroups"].push(item);
        }
        data["isFuzzySearch"] = this.isFuzzySearch;
        data["rawQuery"] = this.rawQuery;
        if (Array.isArray(this.includeFields)) {
            data["includeFields"] = [];
            for (let item of this.includeFields)
                data["includeFields"].push(item);
        }
        data["searchPhrase"] = this.searchPhrase;
        data["keyword"] = this.keyword;
        data["responseGroup"] = this.responseGroup;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IProductIndexedSearchCriteria {
    objectType?: string | undefined;
    productType?: string | undefined;
    currency?: string | undefined;
    pricelists?: string[] | undefined;
    priceRange?: NumericRange;
    classTypes?: string[] | undefined;
    withHidden?: boolean;
    searchInVariations?: boolean;
    startDate?: Date;
    startDateFrom?: Date | undefined;
    endDate?: Date | undefined;
    includeAggregations?: string[] | undefined;
    excludeAggregations?: string[] | undefined;
    geoDistanceFilter?: GeoDistanceFilter;
    sortInfos?: SortInfo[] | undefined;
    storeId?: string | undefined;
    catalogId?: string | undefined;
    catalogIds?: string[] | undefined;
    outline?: string | undefined;
    outlines?: string[] | undefined;
    terms?: string[] | undefined;
    userGroups?: string[] | undefined;
    isFuzzySearch?: boolean;
    rawQuery?: string | undefined;
    includeFields?: string[] | undefined;
    searchPhrase?: string | undefined;
    keyword?: string | undefined;
    responseGroup?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    skip?: number;
    take?: number;
}

export class Asset implements IAsset {
    mimeType?: string | undefined;
    size?: number;
    readonly readableSize?: string | undefined;
    binaryData?: string | undefined;
    relativeUrl?: string | undefined;
    url?: string | undefined;
    description?: string | undefined;
    sortOrder?: number;
    typeId?: string | undefined;
    group?: string | undefined;
    name?: string | undefined;
    outerId?: string | undefined;
    languageCode?: string | undefined;
    readonly isInherited?: boolean;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IAsset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mimeType = _data["mimeType"];
            this.size = _data["size"];
            (<any>this).readableSize = _data["readableSize"];
            this.binaryData = _data["binaryData"];
            this.relativeUrl = _data["relativeUrl"];
            this.url = _data["url"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.typeId = _data["typeId"];
            this.group = _data["group"];
            this.name = _data["name"];
            this.outerId = _data["outerId"];
            this.languageCode = _data["languageCode"];
            (<any>this).isInherited = _data["isInherited"];
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Asset {
        data = typeof data === 'object' ? data : {};
        let result = new Asset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mimeType"] = this.mimeType;
        data["size"] = this.size;
        data["readableSize"] = this.readableSize;
        data["binaryData"] = this.binaryData;
        data["relativeUrl"] = this.relativeUrl;
        data["url"] = this.url;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["typeId"] = this.typeId;
        data["group"] = this.group;
        data["name"] = this.name;
        data["outerId"] = this.outerId;
        data["languageCode"] = this.languageCode;
        data["isInherited"] = this.isInherited;
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IAsset {
    mimeType?: string | undefined;
    size?: number;
    readableSize?: string | undefined;
    binaryData?: string | undefined;
    relativeUrl?: string | undefined;
    url?: string | undefined;
    description?: string | undefined;
    sortOrder?: number;
    typeId?: string | undefined;
    group?: string | undefined;
    name?: string | undefined;
    outerId?: string | undefined;
    languageCode?: string | undefined;
    isInherited?: boolean;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class EditorialReview implements IEditorialReview {
    content?: string | undefined;
    reviewType?: string | undefined;
    languageCode?: string | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IEditorialReview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.reviewType = _data["reviewType"];
            this.languageCode = _data["languageCode"];
            this.isInherited = _data["isInherited"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditorialReview {
        data = typeof data === 'object' ? data : {};
        let result = new EditorialReview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["reviewType"] = this.reviewType;
        data["languageCode"] = this.languageCode;
        data["isInherited"] = this.isInherited;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IEditorialReview {
    content?: string | undefined;
    reviewType?: string | undefined;
    languageCode?: string | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Variation implements IVariation {
    code?: string | undefined;
    manufacturerPartNumber?: string | undefined;
    gtin?: string | undefined;
    name?: string | undefined;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    readonly outline?: string | undefined;
    readonly path?: string | undefined;
    readonly titularItemId?: string | undefined;
    mainProductId?: string | undefined;
    isBuyable?: boolean | undefined;
    isActive?: boolean | undefined;
    trackInventory?: boolean | undefined;
    indexingDate?: Date | undefined;
    maxQuantity?: number | undefined;
    minQuantity?: number | undefined;
    productType?: string | undefined;
    packageType?: string | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    enableReview?: boolean | undefined;
    maxNumberOfDownload?: number | undefined;
    downloadExpiration?: Date | undefined;
    downloadType?: string | undefined;
    hasUserAgreement?: boolean | undefined;
    shippingType?: string | undefined;
    taxType?: string | undefined;
    vendor?: string | undefined;
    startDate?: Date;
    endDate?: Date | undefined;
    priority?: number;
    outerId?: string | undefined;
    properties?: Property[] | undefined;
    excludedProperties?: ExcludedProperty[] | undefined;
    propertyValues?: PropertyValue[] | undefined;
    readonly imgSrc?: string | undefined;
    images?: Image[] | undefined;
    assets?: Asset[] | undefined;
    links?: CategoryLink[] | undefined;
    variations?: Variation[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    reviews?: EditorialReview[] | undefined;
    associations?: ProductAssociation[] | undefined;
    referencedAssociations?: ProductAssociation[] | undefined;
    outlines?: Outline[] | undefined;
    readonly isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IVariation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.manufacturerPartNumber = _data["manufacturerPartNumber"];
            this.gtin = _data["gtin"];
            this.name = _data["name"];
            this.catalogId = _data["catalogId"];
            this.categoryId = _data["categoryId"];
            (<any>this).outline = _data["outline"];
            (<any>this).path = _data["path"];
            (<any>this).titularItemId = _data["titularItemId"];
            this.mainProductId = _data["mainProductId"];
            this.isBuyable = _data["isBuyable"];
            this.isActive = _data["isActive"];
            this.trackInventory = _data["trackInventory"];
            this.indexingDate = _data["indexingDate"] ? new Date(_data["indexingDate"].toString()) : <any>undefined;
            this.maxQuantity = _data["maxQuantity"];
            this.minQuantity = _data["minQuantity"];
            this.productType = _data["productType"];
            this.packageType = _data["packageType"];
            this.weightUnit = _data["weightUnit"];
            this.weight = _data["weight"];
            this.measureUnit = _data["measureUnit"];
            this.height = _data["height"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.enableReview = _data["enableReview"];
            this.maxNumberOfDownload = _data["maxNumberOfDownload"];
            this.downloadExpiration = _data["downloadExpiration"] ? new Date(_data["downloadExpiration"].toString()) : <any>undefined;
            this.downloadType = _data["downloadType"];
            this.hasUserAgreement = _data["hasUserAgreement"];
            this.shippingType = _data["shippingType"];
            this.taxType = _data["taxType"];
            this.vendor = _data["vendor"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.priority = _data["priority"];
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(Property.fromJS(item));
            }
            if (Array.isArray(_data["excludedProperties"])) {
                this.excludedProperties = [] as any;
                for (let item of _data["excludedProperties"])
                    this.excludedProperties!.push(ExcludedProperty.fromJS(item));
            }
            if (Array.isArray(_data["propertyValues"])) {
                this.propertyValues = [] as any;
                for (let item of _data["propertyValues"])
                    this.propertyValues!.push(PropertyValue.fromJS(item));
            }
            (<any>this).imgSrc = _data["imgSrc"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(Image.fromJS(item));
            }
            if (Array.isArray(_data["assets"])) {
                this.assets = [] as any;
                for (let item of _data["assets"])
                    this.assets!.push(Asset.fromJS(item));
            }
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(CategoryLink.fromJS(item));
            }
            if (Array.isArray(_data["variations"])) {
                this.variations = [] as any;
                for (let item of _data["variations"])
                    this.variations!.push(Variation.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(EditorialReview.fromJS(item));
            }
            if (Array.isArray(_data["associations"])) {
                this.associations = [] as any;
                for (let item of _data["associations"])
                    this.associations!.push(ProductAssociation.fromJS(item));
            }
            if (Array.isArray(_data["referencedAssociations"])) {
                this.referencedAssociations = [] as any;
                for (let item of _data["referencedAssociations"])
                    this.referencedAssociations!.push(ProductAssociation.fromJS(item));
            }
            if (Array.isArray(_data["outlines"])) {
                this.outlines = [] as any;
                for (let item of _data["outlines"])
                    this.outlines!.push(Outline.fromJS(item));
            }
            (<any>this).isInherited = _data["isInherited"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Variation {
        data = typeof data === 'object' ? data : {};
        let result = new Variation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["manufacturerPartNumber"] = this.manufacturerPartNumber;
        data["gtin"] = this.gtin;
        data["name"] = this.name;
        data["catalogId"] = this.catalogId;
        data["categoryId"] = this.categoryId;
        data["outline"] = this.outline;
        data["path"] = this.path;
        data["titularItemId"] = this.titularItemId;
        data["mainProductId"] = this.mainProductId;
        data["isBuyable"] = this.isBuyable;
        data["isActive"] = this.isActive;
        data["trackInventory"] = this.trackInventory;
        data["indexingDate"] = this.indexingDate ? this.indexingDate.toISOString() : <any>undefined;
        data["maxQuantity"] = this.maxQuantity;
        data["minQuantity"] = this.minQuantity;
        data["productType"] = this.productType;
        data["packageType"] = this.packageType;
        data["weightUnit"] = this.weightUnit;
        data["weight"] = this.weight;
        data["measureUnit"] = this.measureUnit;
        data["height"] = this.height;
        data["length"] = this.length;
        data["width"] = this.width;
        data["enableReview"] = this.enableReview;
        data["maxNumberOfDownload"] = this.maxNumberOfDownload;
        data["downloadExpiration"] = this.downloadExpiration ? this.downloadExpiration.toISOString() : <any>undefined;
        data["downloadType"] = this.downloadType;
        data["hasUserAgreement"] = this.hasUserAgreement;
        data["shippingType"] = this.shippingType;
        data["taxType"] = this.taxType;
        data["vendor"] = this.vendor;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["priority"] = this.priority;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        if (Array.isArray(this.excludedProperties)) {
            data["excludedProperties"] = [];
            for (let item of this.excludedProperties)
                data["excludedProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.propertyValues)) {
            data["propertyValues"] = [];
            for (let item of this.propertyValues)
                data["propertyValues"].push(item.toJSON());
        }
        data["imgSrc"] = this.imgSrc;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        if (Array.isArray(this.assets)) {
            data["assets"] = [];
            for (let item of this.assets)
                data["assets"].push(item.toJSON());
        }
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        if (Array.isArray(this.variations)) {
            data["variations"] = [];
            for (let item of this.variations)
                data["variations"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item.toJSON());
        }
        if (Array.isArray(this.associations)) {
            data["associations"] = [];
            for (let item of this.associations)
                data["associations"].push(item.toJSON());
        }
        if (Array.isArray(this.referencedAssociations)) {
            data["referencedAssociations"] = [];
            for (let item of this.referencedAssociations)
                data["referencedAssociations"].push(item.toJSON());
        }
        if (Array.isArray(this.outlines)) {
            data["outlines"] = [];
            for (let item of this.outlines)
                data["outlines"].push(item.toJSON());
        }
        data["isInherited"] = this.isInherited;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IVariation {
    code?: string | undefined;
    manufacturerPartNumber?: string | undefined;
    gtin?: string | undefined;
    name?: string | undefined;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    outline?: string | undefined;
    path?: string | undefined;
    titularItemId?: string | undefined;
    mainProductId?: string | undefined;
    isBuyable?: boolean | undefined;
    isActive?: boolean | undefined;
    trackInventory?: boolean | undefined;
    indexingDate?: Date | undefined;
    maxQuantity?: number | undefined;
    minQuantity?: number | undefined;
    productType?: string | undefined;
    packageType?: string | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    enableReview?: boolean | undefined;
    maxNumberOfDownload?: number | undefined;
    downloadExpiration?: Date | undefined;
    downloadType?: string | undefined;
    hasUserAgreement?: boolean | undefined;
    shippingType?: string | undefined;
    taxType?: string | undefined;
    vendor?: string | undefined;
    startDate?: Date;
    endDate?: Date | undefined;
    priority?: number;
    outerId?: string | undefined;
    properties?: Property[] | undefined;
    excludedProperties?: ExcludedProperty[] | undefined;
    propertyValues?: PropertyValue[] | undefined;
    imgSrc?: string | undefined;
    images?: Image[] | undefined;
    assets?: Asset[] | undefined;
    links?: CategoryLink[] | undefined;
    variations?: Variation[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    reviews?: EditorialReview[] | undefined;
    associations?: ProductAssociation[] | undefined;
    referencedAssociations?: ProductAssociation[] | undefined;
    outlines?: Outline[] | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CatalogProduct implements ICatalogProduct {
    code?: string | undefined;
    manufacturerPartNumber?: string | undefined;
    gtin?: string | undefined;
    name?: string | undefined;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    readonly outline?: string | undefined;
    readonly path?: string | undefined;
    readonly titularItemId?: string | undefined;
    mainProductId?: string | undefined;
    isBuyable?: boolean | undefined;
    isActive?: boolean | undefined;
    trackInventory?: boolean | undefined;
    indexingDate?: Date | undefined;
    maxQuantity?: number | undefined;
    minQuantity?: number | undefined;
    productType?: string | undefined;
    packageType?: string | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    enableReview?: boolean | undefined;
    maxNumberOfDownload?: number | undefined;
    downloadExpiration?: Date | undefined;
    downloadType?: string | undefined;
    hasUserAgreement?: boolean | undefined;
    shippingType?: string | undefined;
    taxType?: string | undefined;
    vendor?: string | undefined;
    startDate?: Date;
    endDate?: Date | undefined;
    priority?: number;
    outerId?: string | undefined;
    properties?: Property[] | undefined;
    excludedProperties?: ExcludedProperty[] | undefined;
    propertyValues?: PropertyValue[] | undefined;
    readonly imgSrc?: string | undefined;
    images?: Image[] | undefined;
    assets?: Asset[] | undefined;
    links?: CategoryLink[] | undefined;
    variations?: Variation[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    reviews?: EditorialReview[] | undefined;
    associations?: ProductAssociation[] | undefined;
    referencedAssociations?: ProductAssociation[] | undefined;
    outlines?: Outline[] | undefined;
    readonly isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICatalogProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.manufacturerPartNumber = _data["manufacturerPartNumber"];
            this.gtin = _data["gtin"];
            this.name = _data["name"];
            this.catalogId = _data["catalogId"];
            this.categoryId = _data["categoryId"];
            (<any>this).outline = _data["outline"];
            (<any>this).path = _data["path"];
            (<any>this).titularItemId = _data["titularItemId"];
            this.mainProductId = _data["mainProductId"];
            this.isBuyable = _data["isBuyable"];
            this.isActive = _data["isActive"];
            this.trackInventory = _data["trackInventory"];
            this.indexingDate = _data["indexingDate"] ? new Date(_data["indexingDate"].toString()) : <any>undefined;
            this.maxQuantity = _data["maxQuantity"];
            this.minQuantity = _data["minQuantity"];
            this.productType = _data["productType"];
            this.packageType = _data["packageType"];
            this.weightUnit = _data["weightUnit"];
            this.weight = _data["weight"];
            this.measureUnit = _data["measureUnit"];
            this.height = _data["height"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.enableReview = _data["enableReview"];
            this.maxNumberOfDownload = _data["maxNumberOfDownload"];
            this.downloadExpiration = _data["downloadExpiration"] ? new Date(_data["downloadExpiration"].toString()) : <any>undefined;
            this.downloadType = _data["downloadType"];
            this.hasUserAgreement = _data["hasUserAgreement"];
            this.shippingType = _data["shippingType"];
            this.taxType = _data["taxType"];
            this.vendor = _data["vendor"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.priority = _data["priority"];
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(Property.fromJS(item));
            }
            if (Array.isArray(_data["excludedProperties"])) {
                this.excludedProperties = [] as any;
                for (let item of _data["excludedProperties"])
                    this.excludedProperties!.push(ExcludedProperty.fromJS(item));
            }
            if (Array.isArray(_data["propertyValues"])) {
                this.propertyValues = [] as any;
                for (let item of _data["propertyValues"])
                    this.propertyValues!.push(PropertyValue.fromJS(item));
            }
            (<any>this).imgSrc = _data["imgSrc"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(Image.fromJS(item));
            }
            if (Array.isArray(_data["assets"])) {
                this.assets = [] as any;
                for (let item of _data["assets"])
                    this.assets!.push(Asset.fromJS(item));
            }
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(CategoryLink.fromJS(item));
            }
            if (Array.isArray(_data["variations"])) {
                this.variations = [] as any;
                for (let item of _data["variations"])
                    this.variations!.push(Variation.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(EditorialReview.fromJS(item));
            }
            if (Array.isArray(_data["associations"])) {
                this.associations = [] as any;
                for (let item of _data["associations"])
                    this.associations!.push(ProductAssociation.fromJS(item));
            }
            if (Array.isArray(_data["referencedAssociations"])) {
                this.referencedAssociations = [] as any;
                for (let item of _data["referencedAssociations"])
                    this.referencedAssociations!.push(ProductAssociation.fromJS(item));
            }
            if (Array.isArray(_data["outlines"])) {
                this.outlines = [] as any;
                for (let item of _data["outlines"])
                    this.outlines!.push(Outline.fromJS(item));
            }
            (<any>this).isInherited = _data["isInherited"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CatalogProduct {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["manufacturerPartNumber"] = this.manufacturerPartNumber;
        data["gtin"] = this.gtin;
        data["name"] = this.name;
        data["catalogId"] = this.catalogId;
        data["categoryId"] = this.categoryId;
        data["outline"] = this.outline;
        data["path"] = this.path;
        data["titularItemId"] = this.titularItemId;
        data["mainProductId"] = this.mainProductId;
        data["isBuyable"] = this.isBuyable;
        data["isActive"] = this.isActive;
        data["trackInventory"] = this.trackInventory;
        data["indexingDate"] = this.indexingDate ? this.indexingDate.toISOString() : <any>undefined;
        data["maxQuantity"] = this.maxQuantity;
        data["minQuantity"] = this.minQuantity;
        data["productType"] = this.productType;
        data["packageType"] = this.packageType;
        data["weightUnit"] = this.weightUnit;
        data["weight"] = this.weight;
        data["measureUnit"] = this.measureUnit;
        data["height"] = this.height;
        data["length"] = this.length;
        data["width"] = this.width;
        data["enableReview"] = this.enableReview;
        data["maxNumberOfDownload"] = this.maxNumberOfDownload;
        data["downloadExpiration"] = this.downloadExpiration ? this.downloadExpiration.toISOString() : <any>undefined;
        data["downloadType"] = this.downloadType;
        data["hasUserAgreement"] = this.hasUserAgreement;
        data["shippingType"] = this.shippingType;
        data["taxType"] = this.taxType;
        data["vendor"] = this.vendor;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["priority"] = this.priority;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        if (Array.isArray(this.excludedProperties)) {
            data["excludedProperties"] = [];
            for (let item of this.excludedProperties)
                data["excludedProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.propertyValues)) {
            data["propertyValues"] = [];
            for (let item of this.propertyValues)
                data["propertyValues"].push(item.toJSON());
        }
        data["imgSrc"] = this.imgSrc;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        if (Array.isArray(this.assets)) {
            data["assets"] = [];
            for (let item of this.assets)
                data["assets"].push(item.toJSON());
        }
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        if (Array.isArray(this.variations)) {
            data["variations"] = [];
            for (let item of this.variations)
                data["variations"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item.toJSON());
        }
        if (Array.isArray(this.associations)) {
            data["associations"] = [];
            for (let item of this.associations)
                data["associations"].push(item.toJSON());
        }
        if (Array.isArray(this.referencedAssociations)) {
            data["referencedAssociations"] = [];
            for (let item of this.referencedAssociations)
                data["referencedAssociations"].push(item.toJSON());
        }
        if (Array.isArray(this.outlines)) {
            data["outlines"] = [];
            for (let item of this.outlines)
                data["outlines"].push(item.toJSON());
        }
        data["isInherited"] = this.isInherited;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ICatalogProduct {
    code?: string | undefined;
    manufacturerPartNumber?: string | undefined;
    gtin?: string | undefined;
    name?: string | undefined;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    outline?: string | undefined;
    path?: string | undefined;
    titularItemId?: string | undefined;
    mainProductId?: string | undefined;
    isBuyable?: boolean | undefined;
    isActive?: boolean | undefined;
    trackInventory?: boolean | undefined;
    indexingDate?: Date | undefined;
    maxQuantity?: number | undefined;
    minQuantity?: number | undefined;
    productType?: string | undefined;
    packageType?: string | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    enableReview?: boolean | undefined;
    maxNumberOfDownload?: number | undefined;
    downloadExpiration?: Date | undefined;
    downloadType?: string | undefined;
    hasUserAgreement?: boolean | undefined;
    shippingType?: string | undefined;
    taxType?: string | undefined;
    vendor?: string | undefined;
    startDate?: Date;
    endDate?: Date | undefined;
    priority?: number;
    outerId?: string | undefined;
    properties?: Property[] | undefined;
    excludedProperties?: ExcludedProperty[] | undefined;
    propertyValues?: PropertyValue[] | undefined;
    imgSrc?: string | undefined;
    images?: Image[] | undefined;
    assets?: Asset[] | undefined;
    links?: CategoryLink[] | undefined;
    variations?: Variation[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    reviews?: EditorialReview[] | undefined;
    associations?: ProductAssociation[] | undefined;
    referencedAssociations?: ProductAssociation[] | undefined;
    outlines?: Outline[] | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class AggregationLabel implements IAggregationLabel {
    language?: string | undefined;
    label?: string | undefined;

    constructor(data?: IAggregationLabel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): AggregationLabel {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationLabel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language;
        data["label"] = this.label;
        return data;
    }
}

export interface IAggregationLabel {
    language?: string | undefined;
    label?: string | undefined;
}

export class AggregationItem implements IAggregationItem {
    value?: any | undefined;
    count?: number;
    isApplied?: boolean;
    labels?: AggregationLabel[] | undefined;
    requestedLowerBound?: string | undefined;
    requestedUpperBound?: string | undefined;

    constructor(data?: IAggregationItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.count = _data["count"];
            this.isApplied = _data["isApplied"];
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(AggregationLabel.fromJS(item));
            }
            this.requestedLowerBound = _data["requestedLowerBound"];
            this.requestedUpperBound = _data["requestedUpperBound"];
        }
    }

    static fromJS(data: any): AggregationItem {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["count"] = this.count;
        data["isApplied"] = this.isApplied;
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item.toJSON());
        }
        data["requestedLowerBound"] = this.requestedLowerBound;
        data["requestedUpperBound"] = this.requestedUpperBound;
        return data;
    }
}

export interface IAggregationItem {
    value?: any | undefined;
    count?: number;
    isApplied?: boolean;
    labels?: AggregationLabel[] | undefined;
    requestedLowerBound?: string | undefined;
    requestedUpperBound?: string | undefined;
}

export class Aggregation implements IAggregation {
    aggregationType?: string | undefined;
    field?: string | undefined;
    labels?: AggregationLabel[] | undefined;
    items?: AggregationItem[] | undefined;

    constructor(data?: IAggregation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.aggregationType = _data["aggregationType"];
            this.field = _data["field"];
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(AggregationLabel.fromJS(item));
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AggregationItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Aggregation {
        data = typeof data === 'object' ? data : {};
        let result = new Aggregation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregationType"] = this.aggregationType;
        data["field"] = this.field;
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item.toJSON());
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAggregation {
    aggregationType?: string | undefined;
    field?: string | undefined;
    labels?: AggregationLabel[] | undefined;
    items?: AggregationItem[] | undefined;
}

export class ProductIndexedSearchResult implements IProductIndexedSearchResult {
    totalCount?: number;
    items?: CatalogProduct[] | undefined;
    aggregations?: Aggregation[] | undefined;

    constructor(data?: IProductIndexedSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CatalogProduct.fromJS(item));
            }
            if (Array.isArray(_data["aggregations"])) {
                this.aggregations = [] as any;
                for (let item of _data["aggregations"])
                    this.aggregations!.push(Aggregation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductIndexedSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProductIndexedSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregations)) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductIndexedSearchResult {
    totalCount?: number;
    items?: CatalogProduct[] | undefined;
    aggregations?: Aggregation[] | undefined;
}

export class CategoryIndexedSearchCriteria implements ICategoryIndexedSearchCriteria {
    objectType?: string | undefined;
    storeId?: string | undefined;
    catalogId?: string | undefined;
    catalogIds?: string[] | undefined;
    outline?: string | undefined;
    outlines?: string[] | undefined;
    terms?: string[] | undefined;
    userGroups?: string[] | undefined;
    isFuzzySearch?: boolean;
    rawQuery?: string | undefined;
    includeFields?: string[] | undefined;
    searchPhrase?: string | undefined;
    keyword?: string | undefined;
    responseGroup?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ICategoryIndexedSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectType = _data["objectType"];
            this.storeId = _data["storeId"];
            this.catalogId = _data["catalogId"];
            if (Array.isArray(_data["catalogIds"])) {
                this.catalogIds = [] as any;
                for (let item of _data["catalogIds"])
                    this.catalogIds!.push(item);
            }
            this.outline = _data["outline"];
            if (Array.isArray(_data["outlines"])) {
                this.outlines = [] as any;
                for (let item of _data["outlines"])
                    this.outlines!.push(item);
            }
            if (Array.isArray(_data["terms"])) {
                this.terms = [] as any;
                for (let item of _data["terms"])
                    this.terms!.push(item);
            }
            if (Array.isArray(_data["userGroups"])) {
                this.userGroups = [] as any;
                for (let item of _data["userGroups"])
                    this.userGroups!.push(item);
            }
            this.isFuzzySearch = _data["isFuzzySearch"];
            this.rawQuery = _data["rawQuery"];
            if (Array.isArray(_data["includeFields"])) {
                this.includeFields = [] as any;
                for (let item of _data["includeFields"])
                    this.includeFields!.push(item);
            }
            this.searchPhrase = _data["searchPhrase"];
            this.keyword = _data["keyword"];
            this.responseGroup = _data["responseGroup"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): CategoryIndexedSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryIndexedSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectType"] = this.objectType;
        data["storeId"] = this.storeId;
        data["catalogId"] = this.catalogId;
        if (Array.isArray(this.catalogIds)) {
            data["catalogIds"] = [];
            for (let item of this.catalogIds)
                data["catalogIds"].push(item);
        }
        data["outline"] = this.outline;
        if (Array.isArray(this.outlines)) {
            data["outlines"] = [];
            for (let item of this.outlines)
                data["outlines"].push(item);
        }
        if (Array.isArray(this.terms)) {
            data["terms"] = [];
            for (let item of this.terms)
                data["terms"].push(item);
        }
        if (Array.isArray(this.userGroups)) {
            data["userGroups"] = [];
            for (let item of this.userGroups)
                data["userGroups"].push(item);
        }
        data["isFuzzySearch"] = this.isFuzzySearch;
        data["rawQuery"] = this.rawQuery;
        if (Array.isArray(this.includeFields)) {
            data["includeFields"] = [];
            for (let item of this.includeFields)
                data["includeFields"].push(item);
        }
        data["searchPhrase"] = this.searchPhrase;
        data["keyword"] = this.keyword;
        data["responseGroup"] = this.responseGroup;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ICategoryIndexedSearchCriteria {
    objectType?: string | undefined;
    storeId?: string | undefined;
    catalogId?: string | undefined;
    catalogIds?: string[] | undefined;
    outline?: string | undefined;
    outlines?: string[] | undefined;
    terms?: string[] | undefined;
    userGroups?: string[] | undefined;
    isFuzzySearch?: boolean;
    rawQuery?: string | undefined;
    includeFields?: string[] | undefined;
    searchPhrase?: string | undefined;
    keyword?: string | undefined;
    responseGroup?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class CategoryIndexedSearchResult implements ICategoryIndexedSearchResult {
    totalCount?: number;
    items?: Category[] | undefined;
    aggregations?: Aggregation[] | undefined;

    constructor(data?: ICategoryIndexedSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Category.fromJS(item));
            }
            if (Array.isArray(_data["aggregations"])) {
                this.aggregations = [] as any;
                for (let item of _data["aggregations"])
                    this.aggregations!.push(Aggregation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryIndexedSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryIndexedSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregations)) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategoryIndexedSearchResult {
    totalCount?: number;
    items?: Category[] | undefined;
    aggregations?: Aggregation[] | undefined;
}

export class CatalogListEntrySearchCriteria implements ICatalogListEntrySearchCriteria {
    code?: string | undefined;
    vendorId?: string | undefined;
    vendorIds?: string[] | undefined;
    productType?: string | undefined;
    productTypes?: string[] | undefined;
    excludeProductType?: string | undefined;
    excludeProductTypes?: string[] | undefined;
    withHidden?: boolean;
    hideDirectLinkedCategories?: boolean;
    mainProductId?: string | undefined;
    searchInChildren?: boolean;
    searchInVariations?: boolean;
    onlyBuyable?: boolean | undefined;
    onlyWithTrackingInventory?: boolean | undefined;
    catalogId?: string | undefined;
    catalogIds?: string[] | undefined;
    categoryId?: string | undefined;
    categoryIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ICatalogListEntrySearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.vendorId = _data["vendorId"];
            if (Array.isArray(_data["vendorIds"])) {
                this.vendorIds = [] as any;
                for (let item of _data["vendorIds"])
                    this.vendorIds!.push(item);
            }
            this.productType = _data["productType"];
            if (Array.isArray(_data["productTypes"])) {
                this.productTypes = [] as any;
                for (let item of _data["productTypes"])
                    this.productTypes!.push(item);
            }
            this.excludeProductType = _data["excludeProductType"];
            if (Array.isArray(_data["excludeProductTypes"])) {
                this.excludeProductTypes = [] as any;
                for (let item of _data["excludeProductTypes"])
                    this.excludeProductTypes!.push(item);
            }
            this.withHidden = _data["withHidden"];
            this.hideDirectLinkedCategories = _data["hideDirectLinkedCategories"];
            this.mainProductId = _data["mainProductId"];
            this.searchInChildren = _data["searchInChildren"];
            this.searchInVariations = _data["searchInVariations"];
            this.onlyBuyable = _data["onlyBuyable"];
            this.onlyWithTrackingInventory = _data["onlyWithTrackingInventory"];
            this.catalogId = _data["catalogId"];
            if (Array.isArray(_data["catalogIds"])) {
                this.catalogIds = [] as any;
                for (let item of _data["catalogIds"])
                    this.catalogIds!.push(item);
            }
            this.categoryId = _data["categoryId"];
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): CatalogListEntrySearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogListEntrySearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["vendorId"] = this.vendorId;
        if (Array.isArray(this.vendorIds)) {
            data["vendorIds"] = [];
            for (let item of this.vendorIds)
                data["vendorIds"].push(item);
        }
        data["productType"] = this.productType;
        if (Array.isArray(this.productTypes)) {
            data["productTypes"] = [];
            for (let item of this.productTypes)
                data["productTypes"].push(item);
        }
        data["excludeProductType"] = this.excludeProductType;
        if (Array.isArray(this.excludeProductTypes)) {
            data["excludeProductTypes"] = [];
            for (let item of this.excludeProductTypes)
                data["excludeProductTypes"].push(item);
        }
        data["withHidden"] = this.withHidden;
        data["hideDirectLinkedCategories"] = this.hideDirectLinkedCategories;
        data["mainProductId"] = this.mainProductId;
        data["searchInChildren"] = this.searchInChildren;
        data["searchInVariations"] = this.searchInVariations;
        data["onlyBuyable"] = this.onlyBuyable;
        data["onlyWithTrackingInventory"] = this.onlyWithTrackingInventory;
        data["catalogId"] = this.catalogId;
        if (Array.isArray(this.catalogIds)) {
            data["catalogIds"] = [];
            for (let item of this.catalogIds)
                data["catalogIds"].push(item);
        }
        data["categoryId"] = this.categoryId;
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ICatalogListEntrySearchCriteria {
    code?: string | undefined;
    vendorId?: string | undefined;
    vendorIds?: string[] | undefined;
    productType?: string | undefined;
    productTypes?: string[] | undefined;
    excludeProductType?: string | undefined;
    excludeProductTypes?: string[] | undefined;
    withHidden?: boolean;
    hideDirectLinkedCategories?: boolean;
    mainProductId?: string | undefined;
    searchInChildren?: boolean;
    searchInVariations?: boolean;
    onlyBuyable?: boolean | undefined;
    onlyWithTrackingInventory?: boolean | undefined;
    catalogId?: string | undefined;
    catalogIds?: string[] | undefined;
    categoryId?: string | undefined;
    categoryIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class ListEntryBase implements IListEntryBase {
    type?: string | undefined;
    isActive?: boolean | undefined;
    imageUrl?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    links?: CategoryLink[] | undefined;
    outline?: string[] | undefined;
    path?: string[] | undefined;
    catalogId?: string | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IListEntryBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.isActive = _data["isActive"];
            this.imageUrl = _data["imageUrl"];
            this.code = _data["code"];
            this.name = _data["name"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(CategoryLink.fromJS(item));
            }
            if (Array.isArray(_data["outline"])) {
                this.outline = [] as any;
                for (let item of _data["outline"])
                    this.outline!.push(item);
            }
            if (Array.isArray(_data["path"])) {
                this.path = [] as any;
                for (let item of _data["path"])
                    this.path!.push(item);
            }
            this.catalogId = _data["catalogId"];
            this.seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ListEntryBase {
        data = typeof data === 'object' ? data : {};
        let result = new ListEntryBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["isActive"] = this.isActive;
        data["imageUrl"] = this.imageUrl;
        data["code"] = this.code;
        data["name"] = this.name;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        if (Array.isArray(this.outline)) {
            data["outline"] = [];
            for (let item of this.outline)
                data["outline"].push(item);
        }
        if (Array.isArray(this.path)) {
            data["path"] = [];
            for (let item of this.path)
                data["path"].push(item);
        }
        data["catalogId"] = this.catalogId;
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IListEntryBase {
    type?: string | undefined;
    isActive?: boolean | undefined;
    imageUrl?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    links?: CategoryLink[] | undefined;
    outline?: string[] | undefined;
    path?: string[] | undefined;
    catalogId?: string | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ListEntrySearchResult implements IListEntrySearchResult {
    readonly listEntries?: ListEntryBase[] | undefined;
    totalCount?: number;
    results?: ListEntryBase[] | undefined;

    constructor(data?: IListEntrySearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listEntries"])) {
                (<any>this).listEntries = [] as any;
                for (let item of _data["listEntries"])
                    (<any>this).listEntries!.push(ListEntryBase.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ListEntryBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListEntrySearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListEntrySearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listEntries)) {
            data["listEntries"] = [];
            for (let item of this.listEntries)
                data["listEntries"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListEntrySearchResult {
    listEntries?: ListEntryBase[] | undefined;
    totalCount?: number;
    results?: ListEntryBase[] | undefined;
}

export class BulkLinkCreationRequest implements IBulkLinkCreationRequest {
    searchCriteria?: CatalogListEntrySearchCriteria;
    categoryId?: string | undefined;
    catalogId?: string | undefined;

    constructor(data?: IBulkLinkCreationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchCriteria = _data["searchCriteria"] ? CatalogListEntrySearchCriteria.fromJS(_data["searchCriteria"]) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.catalogId = _data["catalogId"];
        }
    }

    static fromJS(data: any): BulkLinkCreationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkLinkCreationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchCriteria"] = this.searchCriteria ? this.searchCriteria.toJSON() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["catalogId"] = this.catalogId;
        return data;
    }
}

export interface IBulkLinkCreationRequest {
    searchCriteria?: CatalogListEntrySearchCriteria;
    categoryId?: string | undefined;
    catalogId?: string | undefined;
}

export class LinkSearchCriteria implements ILinkSearchCriteria {
    categoryIds?: string[] | undefined;
    catalogIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ILinkSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            if (Array.isArray(_data["catalogIds"])) {
                this.catalogIds = [] as any;
                for (let item of _data["catalogIds"])
                    this.catalogIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): LinkSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new LinkSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        if (Array.isArray(this.catalogIds)) {
            data["catalogIds"] = [];
            for (let item of this.catalogIds)
                data["catalogIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ILinkSearchCriteria {
    categoryIds?: string[] | undefined;
    catalogIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class ListEntriesMoveRequest implements IListEntriesMoveRequest {
    catalog?: string | undefined;
    readonly catalogId?: string | undefined;
    category?: string | undefined;
    listEntries?: ListEntryBase[] | undefined;

    constructor(data?: IListEntriesMoveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalog = _data["catalog"];
            (<any>this).catalogId = _data["catalogId"];
            this.category = _data["category"];
            if (Array.isArray(_data["listEntries"])) {
                this.listEntries = [] as any;
                for (let item of _data["listEntries"])
                    this.listEntries!.push(ListEntryBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListEntriesMoveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListEntriesMoveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalog"] = this.catalog;
        data["catalogId"] = this.catalogId;
        data["category"] = this.category;
        if (Array.isArray(this.listEntries)) {
            data["listEntries"] = [];
            for (let item of this.listEntries)
                data["listEntries"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListEntriesMoveRequest {
    catalog?: string | undefined;
    catalogId?: string | undefined;
    category?: string | undefined;
    listEntries?: ListEntryBase[] | undefined;
}

export class PropertyValidationRequest implements IPropertyValidationRequest {
    originalName?: string | undefined;
    name?: string | undefined;
    productId?: string | undefined;

    constructor(data?: IPropertyValidationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.originalName = _data["originalName"];
            this.name = _data["name"];
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): PropertyValidationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyValidationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["originalName"] = this.originalName;
        data["name"] = this.name;
        data["productId"] = this.productId;
        return data;
    }
}

export interface IPropertyValidationRequest {
    originalName?: string | undefined;
    name?: string | undefined;
    productId?: string | undefined;
}

export enum Severity {
    Error = "Error",
    Warning = "Warning",
    Info = "Info",
}

export class ValidationFailure implements IValidationFailure {
    propertyName?: string | undefined;
    errorMessage?: string | undefined;
    attemptedValue?: any | undefined;
    customState?: any | undefined;
    severity?: Severity;
    errorCode?: string | undefined;
    formattedMessagePlaceholderValues?: { [key: string]: any; } | undefined;

    constructor(data?: IValidationFailure) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.errorMessage = _data["errorMessage"];
            this.attemptedValue = _data["attemptedValue"];
            this.customState = _data["customState"];
            this.severity = _data["severity"];
            this.errorCode = _data["errorCode"];
            if (_data["formattedMessagePlaceholderValues"]) {
                this.formattedMessagePlaceholderValues = {} as any;
                for (let key in _data["formattedMessagePlaceholderValues"]) {
                    if (_data["formattedMessagePlaceholderValues"].hasOwnProperty(key))
                        (<any>this.formattedMessagePlaceholderValues)![key] = _data["formattedMessagePlaceholderValues"][key];
                }
            }
        }
    }

    static fromJS(data: any): ValidationFailure {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationFailure();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["errorMessage"] = this.errorMessage;
        data["attemptedValue"] = this.attemptedValue;
        data["customState"] = this.customState;
        data["severity"] = this.severity;
        data["errorCode"] = this.errorCode;
        if (this.formattedMessagePlaceholderValues) {
            data["formattedMessagePlaceholderValues"] = {};
            for (let key in this.formattedMessagePlaceholderValues) {
                if (this.formattedMessagePlaceholderValues.hasOwnProperty(key))
                    (<any>data["formattedMessagePlaceholderValues"])[key] = (<any>this.formattedMessagePlaceholderValues)[key];
            }
        }
        return data;
    }
}

export interface IValidationFailure {
    propertyName?: string | undefined;
    errorMessage?: string | undefined;
    attemptedValue?: any | undefined;
    customState?: any | undefined;
    severity?: Severity;
    errorCode?: string | undefined;
    formattedMessagePlaceholderValues?: { [key: string]: any; } | undefined;
}

export class ValidationResult implements IValidationResult {
    readonly isValid?: boolean;
    readonly errors?: ValidationFailure[] | undefined;
    readonly ruleSetsExecuted?: string[] | undefined;

    constructor(data?: IValidationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isValid = _data["isValid"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(ValidationFailure.fromJS(item));
            }
            if (Array.isArray(_data["ruleSetsExecuted"])) {
                (<any>this).ruleSetsExecuted = [] as any;
                for (let item of _data["ruleSetsExecuted"])
                    (<any>this).ruleSetsExecuted!.push(item);
            }
        }
    }

    static fromJS(data: any): ValidationResult {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.ruleSetsExecuted)) {
            data["ruleSetsExecuted"] = [];
            for (let item of this.ruleSetsExecuted)
                data["ruleSetsExecuted"].push(item);
        }
        return data;
    }
}

export interface IValidationResult {
    isValid?: boolean;
    errors?: ValidationFailure[] | undefined;
    ruleSetsExecuted?: string[] | undefined;
}

export class CategoryPropertyValidationRequest implements ICategoryPropertyValidationRequest {
    propertyName?: string | undefined;
    propertyType?: string | undefined;
    categoryId?: string | undefined;
    catalogId?: string | undefined;

    constructor(data?: ICategoryPropertyValidationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.propertyType = _data["propertyType"];
            this.categoryId = _data["categoryId"];
            this.catalogId = _data["catalogId"];
        }
    }

    static fromJS(data: any): CategoryPropertyValidationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryPropertyValidationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["propertyType"] = this.propertyType;
        data["categoryId"] = this.categoryId;
        data["catalogId"] = this.catalogId;
        return data;
    }
}

export interface ICategoryPropertyValidationRequest {
    propertyName?: string | undefined;
    propertyType?: string | undefined;
    categoryId?: string | undefined;
    catalogId?: string | undefined;
}

export class PropertyDictionaryItemSearchCriteria implements IPropertyDictionaryItemSearchCriteria {
    propertyIds?: string[] | undefined;
    catalogIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IPropertyDictionaryItemSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["propertyIds"])) {
                this.propertyIds = [] as any;
                for (let item of _data["propertyIds"])
                    this.propertyIds!.push(item);
            }
            if (Array.isArray(_data["catalogIds"])) {
                this.catalogIds = [] as any;
                for (let item of _data["catalogIds"])
                    this.catalogIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): PropertyDictionaryItemSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDictionaryItemSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.propertyIds)) {
            data["propertyIds"] = [];
            for (let item of this.propertyIds)
                data["propertyIds"].push(item);
        }
        if (Array.isArray(this.catalogIds)) {
            data["catalogIds"] = [];
            for (let item of this.catalogIds)
                data["catalogIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IPropertyDictionaryItemSearchCriteria {
    propertyIds?: string[] | undefined;
    catalogIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class PropertyDictionaryItemLocalizedValue implements IPropertyDictionaryItemLocalizedValue {
    languageCode?: string | undefined;
    value?: string | undefined;

    constructor(data?: IPropertyDictionaryItemLocalizedValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageCode = _data["languageCode"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PropertyDictionaryItemLocalizedValue {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDictionaryItemLocalizedValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageCode"] = this.languageCode;
        data["value"] = this.value;
        return data;
    }
}

export interface IPropertyDictionaryItemLocalizedValue {
    languageCode?: string | undefined;
    value?: string | undefined;
}

export class PropertyDictionaryItem implements IPropertyDictionaryItem {
    propertyId?: string | undefined;
    alias?: string | undefined;
    sortOrder?: number;
    localizedValues?: PropertyDictionaryItemLocalizedValue[] | undefined;
    id?: string | undefined;

    constructor(data?: IPropertyDictionaryItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.alias = _data["alias"];
            this.sortOrder = _data["sortOrder"];
            if (Array.isArray(_data["localizedValues"])) {
                this.localizedValues = [] as any;
                for (let item of _data["localizedValues"])
                    this.localizedValues!.push(PropertyDictionaryItemLocalizedValue.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PropertyDictionaryItem {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDictionaryItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["alias"] = this.alias;
        data["sortOrder"] = this.sortOrder;
        if (Array.isArray(this.localizedValues)) {
            data["localizedValues"] = [];
            for (let item of this.localizedValues)
                data["localizedValues"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IPropertyDictionaryItem {
    propertyId?: string | undefined;
    alias?: string | undefined;
    sortOrder?: number;
    localizedValues?: PropertyDictionaryItemLocalizedValue[] | undefined;
    id?: string | undefined;
}

export class PropertyDictionaryItemSearchResult implements IPropertyDictionaryItemSearchResult {
    totalCount?: number;
    results?: PropertyDictionaryItem[] | undefined;

    constructor(data?: IPropertyDictionaryItemSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(PropertyDictionaryItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PropertyDictionaryItemSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDictionaryItemSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPropertyDictionaryItemSearchResult {
    totalCount?: number;
    results?: PropertyDictionaryItem[] | undefined;
}

export class VideoOptions implements IVideoOptions {
    googleApiKey?: string | undefined;

    constructor(data?: IVideoOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.googleApiKey = _data["googleApiKey"];
        }
    }

    static fromJS(data: any): VideoOptions {
        data = typeof data === 'object' ? data : {};
        let result = new VideoOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["googleApiKey"] = this.googleApiKey;
        return data;
    }
}

export interface IVideoOptions {
    googleApiKey?: string | undefined;
}

export class VideoCreateRequest implements IVideoCreateRequest {
    contentUrl?: string | undefined;
    sortOrder?: number | undefined;
    languageCode?: string | undefined;
    ownerId?: string | undefined;
    ownerType?: string | undefined;

    constructor(data?: IVideoCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentUrl = _data["contentUrl"];
            this.sortOrder = _data["sortOrder"];
            this.languageCode = _data["languageCode"];
            this.ownerId = _data["ownerId"];
            this.ownerType = _data["ownerType"];
        }
    }

    static fromJS(data: any): VideoCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VideoCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentUrl"] = this.contentUrl;
        data["sortOrder"] = this.sortOrder;
        data["languageCode"] = this.languageCode;
        data["ownerId"] = this.ownerId;
        data["ownerType"] = this.ownerType;
        return data;
    }
}

export interface IVideoCreateRequest {
    contentUrl?: string | undefined;
    sortOrder?: number | undefined;
    languageCode?: string | undefined;
    ownerId?: string | undefined;
    ownerType?: string | undefined;
}

export class Video implements IVideo {
    name?: string | undefined;
    description?: string | undefined;
    sortOrder?: number;
    uploadDate?: Date | undefined;
    thumbnailUrl?: string | undefined;
    contentUrl?: string | undefined;
    embedUrl?: string | undefined;
    duration?: string | undefined;
    languageCode?: string | undefined;
    ownerId?: string | undefined;
    ownerType?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IVideo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.uploadDate = _data["uploadDate"] ? new Date(_data["uploadDate"].toString()) : <any>undefined;
            this.thumbnailUrl = _data["thumbnailUrl"];
            this.contentUrl = _data["contentUrl"];
            this.embedUrl = _data["embedUrl"];
            this.duration = _data["duration"];
            this.languageCode = _data["languageCode"];
            this.ownerId = _data["ownerId"];
            this.ownerType = _data["ownerType"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Video {
        data = typeof data === 'object' ? data : {};
        let result = new Video();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["uploadDate"] = this.uploadDate ? this.uploadDate.toISOString() : <any>undefined;
        data["thumbnailUrl"] = this.thumbnailUrl;
        data["contentUrl"] = this.contentUrl;
        data["embedUrl"] = this.embedUrl;
        data["duration"] = this.duration;
        data["languageCode"] = this.languageCode;
        data["ownerId"] = this.ownerId;
        data["ownerType"] = this.ownerType;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IVideo {
    name?: string | undefined;
    description?: string | undefined;
    sortOrder?: number;
    uploadDate?: Date | undefined;
    thumbnailUrl?: string | undefined;
    contentUrl?: string | undefined;
    embedUrl?: string | undefined;
    duration?: string | undefined;
    languageCode?: string | undefined;
    ownerId?: string | undefined;
    ownerType?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class VideoSearchCriteria implements IVideoSearchCriteria {
    ownerIds?: string[] | undefined;
    ownerType?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IVideoSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ownerIds"])) {
                this.ownerIds = [] as any;
                for (let item of _data["ownerIds"])
                    this.ownerIds!.push(item);
            }
            this.ownerType = _data["ownerType"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): VideoSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new VideoSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ownerIds)) {
            data["ownerIds"] = [];
            for (let item of this.ownerIds)
                data["ownerIds"].push(item);
        }
        data["ownerType"] = this.ownerType;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IVideoSearchCriteria {
    ownerIds?: string[] | undefined;
    ownerType?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class VideoSearchResult implements IVideoSearchResult {
    totalCount?: number;
    results?: Video[] | undefined;

    constructor(data?: IVideoSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Video.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VideoSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new VideoSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVideoSearchResult {
    totalCount?: number;
    results?: Video[] | undefined;
}

export class CsvProductPropertyMap implements ICsvProductPropertyMap {
    entityColumnName?: string | undefined;
    csvColumnName?: string | undefined;
    isSystemProperty?: boolean;
    isRequired?: boolean;
    customValue?: string | undefined;
    stringFormat?: string | undefined;
    locale?: string | undefined;

    constructor(data?: ICsvProductPropertyMap) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityColumnName = _data["entityColumnName"];
            this.csvColumnName = _data["csvColumnName"];
            this.isSystemProperty = _data["isSystemProperty"];
            this.isRequired = _data["isRequired"];
            this.customValue = _data["customValue"];
            this.stringFormat = _data["stringFormat"];
            this.locale = _data["locale"];
        }
    }

    static fromJS(data: any): CsvProductPropertyMap {
        data = typeof data === 'object' ? data : {};
        let result = new CsvProductPropertyMap();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityColumnName"] = this.entityColumnName;
        data["csvColumnName"] = this.csvColumnName;
        data["isSystemProperty"] = this.isSystemProperty;
        data["isRequired"] = this.isRequired;
        data["customValue"] = this.customValue;
        data["stringFormat"] = this.stringFormat;
        data["locale"] = this.locale;
        return data;
    }
}

export interface ICsvProductPropertyMap {
    entityColumnName?: string | undefined;
    csvColumnName?: string | undefined;
    isSystemProperty?: boolean;
    isRequired?: boolean;
    customValue?: string | undefined;
    stringFormat?: string | undefined;
    locale?: string | undefined;
}

export class CsvProductMappingConfiguration implements ICsvProductMappingConfiguration {
    eTag?: string | undefined;
    delimiter?: string | undefined;
    csvColumns?: string[] | undefined;
    propertyMaps?: CsvProductPropertyMap[] | undefined;
    propertyCsvColumns?: string[] | undefined;

    constructor(data?: ICsvProductMappingConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eTag = _data["eTag"];
            this.delimiter = _data["delimiter"];
            if (Array.isArray(_data["csvColumns"])) {
                this.csvColumns = [] as any;
                for (let item of _data["csvColumns"])
                    this.csvColumns!.push(item);
            }
            if (Array.isArray(_data["propertyMaps"])) {
                this.propertyMaps = [] as any;
                for (let item of _data["propertyMaps"])
                    this.propertyMaps!.push(CsvProductPropertyMap.fromJS(item));
            }
            if (Array.isArray(_data["propertyCsvColumns"])) {
                this.propertyCsvColumns = [] as any;
                for (let item of _data["propertyCsvColumns"])
                    this.propertyCsvColumns!.push(item);
            }
        }
    }

    static fromJS(data: any): CsvProductMappingConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new CsvProductMappingConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eTag"] = this.eTag;
        data["delimiter"] = this.delimiter;
        if (Array.isArray(this.csvColumns)) {
            data["csvColumns"] = [];
            for (let item of this.csvColumns)
                data["csvColumns"].push(item);
        }
        if (Array.isArray(this.propertyMaps)) {
            data["propertyMaps"] = [];
            for (let item of this.propertyMaps)
                data["propertyMaps"].push(item.toJSON());
        }
        if (Array.isArray(this.propertyCsvColumns)) {
            data["propertyCsvColumns"] = [];
            for (let item of this.propertyCsvColumns)
                data["propertyCsvColumns"].push(item);
        }
        return data;
    }
}

export interface ICsvProductMappingConfiguration {
    eTag?: string | undefined;
    delimiter?: string | undefined;
    csvColumns?: string[] | undefined;
    propertyMaps?: CsvProductPropertyMap[] | undefined;
    propertyCsvColumns?: string[] | undefined;
}

export class CsvExportInfo implements ICsvExportInfo {
    catalogId?: string | undefined;
    productIds?: string[] | undefined;
    categoryIds?: string[] | undefined;
    priceListId?: string | undefined;
    fulfilmentCenterId?: string | undefined;
    currency?: string | undefined;
    configuration?: CsvProductMappingConfiguration;

    constructor(data?: ICsvExportInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalogId = _data["catalogId"];
            if (Array.isArray(_data["productIds"])) {
                this.productIds = [] as any;
                for (let item of _data["productIds"])
                    this.productIds!.push(item);
            }
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            this.priceListId = _data["priceListId"];
            this.fulfilmentCenterId = _data["fulfilmentCenterId"];
            this.currency = _data["currency"];
            this.configuration = _data["configuration"] ? CsvProductMappingConfiguration.fromJS(_data["configuration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CsvExportInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CsvExportInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalogId"] = this.catalogId;
        if (Array.isArray(this.productIds)) {
            data["productIds"] = [];
            for (let item of this.productIds)
                data["productIds"].push(item);
        }
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        data["priceListId"] = this.priceListId;
        data["fulfilmentCenterId"] = this.fulfilmentCenterId;
        data["currency"] = this.currency;
        data["configuration"] = this.configuration ? this.configuration.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICsvExportInfo {
    catalogId?: string | undefined;
    productIds?: string[] | undefined;
    categoryIds?: string[] | undefined;
    priceListId?: string | undefined;
    fulfilmentCenterId?: string | undefined;
    currency?: string | undefined;
    configuration?: CsvProductMappingConfiguration;
}

export class ExportNotification implements IExportNotification {
    downloadUrl?: string | undefined;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    readonly errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IExportNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.downloadUrl = _data["downloadUrl"];
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.processedCount = _data["processedCount"];
            (<any>this).errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ExportNotification {
        data = typeof data === 'object' ? data : {};
        let result = new ExportNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downloadUrl"] = this.downloadUrl;
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["processedCount"] = this.processedCount;
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data;
    }
}

export interface IExportNotification {
    downloadUrl?: string | undefined;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export class CsvImportInfo implements ICsvImportInfo {
    catalogId?: string | undefined;
    fileUrl?: string | undefined;
    configuration?: CsvProductMappingConfiguration;

    constructor(data?: ICsvImportInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalogId = _data["catalogId"];
            this.fileUrl = _data["fileUrl"];
            this.configuration = _data["configuration"] ? CsvProductMappingConfiguration.fromJS(_data["configuration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CsvImportInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CsvImportInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalogId"] = this.catalogId;
        data["fileUrl"] = this.fileUrl;
        data["configuration"] = this.configuration ? this.configuration.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICsvImportInfo {
    catalogId?: string | undefined;
    fileUrl?: string | undefined;
    configuration?: CsvProductMappingConfiguration;
}

export class CatalogCsvImportNotification implements ICatalogCsvImportNotification {
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    readonly errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: ICatalogCsvImportNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.processedCount = _data["processedCount"];
            (<any>this).errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CatalogCsvImportNotification {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCsvImportNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["processedCount"] = this.processedCount;
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data;
    }
}

export interface ICatalogCsvImportNotification {
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export class ContentStatistic implements IContentStatistic {
    activeThemeName?: string | undefined;
    themesCount?: number;
    pagesCount?: number;
    blogsCount?: number;

    constructor(data?: IContentStatistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activeThemeName = _data["activeThemeName"];
            this.themesCount = _data["themesCount"];
            this.pagesCount = _data["pagesCount"];
            this.blogsCount = _data["blogsCount"];
        }
    }

    static fromJS(data: any): ContentStatistic {
        data = typeof data === 'object' ? data : {};
        let result = new ContentStatistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activeThemeName"] = this.activeThemeName;
        data["themesCount"] = this.themesCount;
        data["pagesCount"] = this.pagesCount;
        data["blogsCount"] = this.blogsCount;
        return data;
    }
}

export interface IContentStatistic {
    activeThemeName?: string | undefined;
    themesCount?: number;
    pagesCount?: number;
    blogsCount?: number;
}

export class ContentItem implements IContentItem {
    name?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
    relativeUrl?: string | undefined;
    parentUrl?: string | undefined;
    modifiedDate?: Date | undefined;
    createdDate?: Date | undefined;

    constructor(data?: IContentItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
            this.url = _data["url"];
            this.relativeUrl = _data["relativeUrl"];
            this.parentUrl = _data["parentUrl"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContentItem {
        data = typeof data === 'object' ? data : {};
        let result = new ContentItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["url"] = this.url;
        data["relativeUrl"] = this.relativeUrl;
        data["parentUrl"] = this.parentUrl;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IContentItem {
    name?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
    relativeUrl?: string | undefined;
    parentUrl?: string | undefined;
    modifiedDate?: Date | undefined;
    createdDate?: Date | undefined;
}

export class ContentFolder implements IContentFolder {
    name?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
    relativeUrl?: string | undefined;
    parentUrl?: string | undefined;
    modifiedDate?: Date | undefined;
    createdDate?: Date | undefined;

    constructor(data?: IContentFolder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
            this.url = _data["url"];
            this.relativeUrl = _data["relativeUrl"];
            this.parentUrl = _data["parentUrl"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContentFolder {
        data = typeof data === 'object' ? data : {};
        let result = new ContentFolder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["url"] = this.url;
        data["relativeUrl"] = this.relativeUrl;
        data["parentUrl"] = this.parentUrl;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IContentFolder {
    name?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
    relativeUrl?: string | undefined;
    parentUrl?: string | undefined;
    modifiedDate?: Date | undefined;
    createdDate?: Date | undefined;
}

export class MenuLink implements IMenuLink {
    title?: string | undefined;
    url?: string | undefined;
    priority?: number;
    menuLinkListId?: string | undefined;
    associatedObjectId?: string | undefined;
    associatedObjectName?: string | undefined;
    associatedObjectType?: string | undefined;
    securityScopes?: string[] | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IMenuLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.url = _data["url"];
            this.priority = _data["priority"];
            this.menuLinkListId = _data["menuLinkListId"];
            this.associatedObjectId = _data["associatedObjectId"];
            this.associatedObjectName = _data["associatedObjectName"];
            this.associatedObjectType = _data["associatedObjectType"];
            if (Array.isArray(_data["securityScopes"])) {
                this.securityScopes = [] as any;
                for (let item of _data["securityScopes"])
                    this.securityScopes!.push(item);
            }
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MenuLink {
        data = typeof data === 'object' ? data : {};
        let result = new MenuLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["url"] = this.url;
        data["priority"] = this.priority;
        data["menuLinkListId"] = this.menuLinkListId;
        data["associatedObjectId"] = this.associatedObjectId;
        data["associatedObjectName"] = this.associatedObjectName;
        data["associatedObjectType"] = this.associatedObjectType;
        if (Array.isArray(this.securityScopes)) {
            data["securityScopes"] = [];
            for (let item of this.securityScopes)
                data["securityScopes"].push(item);
        }
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IMenuLink {
    title?: string | undefined;
    url?: string | undefined;
    priority?: number;
    menuLinkListId?: string | undefined;
    associatedObjectId?: string | undefined;
    associatedObjectName?: string | undefined;
    associatedObjectType?: string | undefined;
    securityScopes?: string[] | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class MenuLinkList implements IMenuLinkList {
    name?: string | undefined;
    storeId?: string | undefined;
    language?: string | undefined;
    menuLinks?: MenuLink[] | undefined;
    securityScopes?: string[] | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IMenuLinkList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.storeId = _data["storeId"];
            this.language = _data["language"];
            if (Array.isArray(_data["menuLinks"])) {
                this.menuLinks = [] as any;
                for (let item of _data["menuLinks"])
                    this.menuLinks!.push(MenuLink.fromJS(item));
            }
            if (Array.isArray(_data["securityScopes"])) {
                this.securityScopes = [] as any;
                for (let item of _data["securityScopes"])
                    this.securityScopes!.push(item);
            }
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MenuLinkList {
        data = typeof data === 'object' ? data : {};
        let result = new MenuLinkList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["storeId"] = this.storeId;
        data["language"] = this.language;
        if (Array.isArray(this.menuLinks)) {
            data["menuLinks"] = [];
            for (let item of this.menuLinks)
                data["menuLinks"].push(item.toJSON());
        }
        if (Array.isArray(this.securityScopes)) {
            data["securityScopes"] = [];
            for (let item of this.securityScopes)
                data["securityScopes"].push(item);
        }
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IMenuLinkList {
    name?: string | undefined;
    storeId?: string | undefined;
    language?: string | undefined;
    menuLinks?: MenuLink[] | undefined;
    securityScopes?: string[] | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Currency implements ICurrency {
    code?: string | undefined;
    cultureName?: string | undefined;
    englishName?: string | undefined;
    name?: string | undefined;
    isPrimary?: boolean;
    exchangeRate?: number;
    symbol?: string | undefined;
    customFormatting?: string | undefined;
    roundingType?: string | undefined;
    midpointRounding?: string | undefined;

    constructor(data?: ICurrency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.cultureName = _data["cultureName"];
            this.englishName = _data["englishName"];
            this.name = _data["name"];
            this.isPrimary = _data["isPrimary"];
            this.exchangeRate = _data["exchangeRate"];
            this.symbol = _data["symbol"];
            this.customFormatting = _data["customFormatting"];
            this.roundingType = _data["roundingType"];
            this.midpointRounding = _data["midpointRounding"];
        }
    }

    static fromJS(data: any): Currency {
        data = typeof data === 'object' ? data : {};
        let result = new Currency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["cultureName"] = this.cultureName;
        data["englishName"] = this.englishName;
        data["name"] = this.name;
        data["isPrimary"] = this.isPrimary;
        data["exchangeRate"] = this.exchangeRate;
        data["symbol"] = this.symbol;
        data["customFormatting"] = this.customFormatting;
        data["roundingType"] = this.roundingType;
        data["midpointRounding"] = this.midpointRounding;
        return data;
    }
}

export interface ICurrency {
    code?: string | undefined;
    cultureName?: string | undefined;
    englishName?: string | undefined;
    name?: string | undefined;
    isPrimary?: boolean;
    exchangeRate?: number;
    symbol?: string | undefined;
    customFormatting?: string | undefined;
    roundingType?: string | undefined;
    midpointRounding?: string | undefined;
}

export class PackageType implements IPackageType {
    name?: string | undefined;
    length?: number;
    width?: number;
    height?: number;
    measureUnit?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPackageType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.measureUnit = _data["measureUnit"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PackageType {
        data = typeof data === 'object' ? data : {};
        let result = new PackageType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["length"] = this.length;
        data["width"] = this.width;
        data["height"] = this.height;
        data["measureUnit"] = this.measureUnit;
        data["id"] = this.id;
        return data;
    }
}

export interface IPackageType {
    name?: string | undefined;
    length?: number;
    width?: number;
    height?: number;
    measureUnit?: string | undefined;
    id?: string | undefined;
}

export class Address implements IAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    outerId?: string | undefined;
    isDefault?: boolean;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressType = _data["addressType"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.organization = _data["organization"];
            this.countryCode = _data["countryCode"];
            this.countryName = _data["countryName"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.zip = _data["zip"];
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.regionId = _data["regionId"];
            this.regionName = _data["regionName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.outerId = _data["outerId"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressType"] = this.addressType;
        data["key"] = this.key;
        data["name"] = this.name;
        data["organization"] = this.organization;
        data["countryCode"] = this.countryCode;
        data["countryName"] = this.countryName;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["zip"] = this.zip;
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["regionId"] = this.regionId;
        data["regionName"] = this.regionName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["outerId"] = this.outerId;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    outerId?: string | undefined;
    isDefault?: boolean;
}

export class CustomerAddress implements ICustomerAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    outerId?: string | undefined;
    isDefault?: boolean;

    constructor(data?: ICustomerAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressType = _data["addressType"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.organization = _data["organization"];
            this.countryCode = _data["countryCode"];
            this.countryName = _data["countryName"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.zip = _data["zip"];
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.regionId = _data["regionId"];
            this.regionName = _data["regionName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.outerId = _data["outerId"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): CustomerAddress {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressType"] = this.addressType;
        data["key"] = this.key;
        data["name"] = this.name;
        data["organization"] = this.organization;
        data["countryCode"] = this.countryCode;
        data["countryName"] = this.countryName;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["zip"] = this.zip;
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["regionId"] = this.regionId;
        data["regionName"] = this.regionName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["outerId"] = this.outerId;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface ICustomerAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    outerId?: string | undefined;
    isDefault?: boolean;
}

export class Note implements INote {
    title?: string | undefined;
    body?: string | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: INote) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.body = _data["body"];
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Note {
        data = typeof data === 'object' ? data : {};
        let result = new Note();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["body"] = this.body;
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface INote {
    title?: string | undefined;
    body?: string | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Organization implements IOrganization {
    description?: string | undefined;
    businessCategory?: string | undefined;
    ownerId?: string | undefined;
    parentId?: string | undefined;
    readonly objectType?: string | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IOrganization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.businessCategory = _data["businessCategory"];
            this.ownerId = _data["ownerId"];
            this.parentId = _data["parentId"];
            (<any>this).objectType = _data["objectType"];
            this.name = _data["name"];
            this.memberType = _data["memberType"];
            this.outerId = _data["outerId"];
            this.status = _data["status"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CustomerAddress.fromJS(item));
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(item);
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
            if (Array.isArray(_data["notes"])) {
                this.notes = [] as any;
                for (let item of _data["notes"])
                    this.notes!.push(Note.fromJS(item));
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Organization {
        data = typeof data === 'object' ? data : {};
        let result = new Organization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["businessCategory"] = this.businessCategory;
        data["ownerId"] = this.ownerId;
        data["parentId"] = this.parentId;
        data["objectType"] = this.objectType;
        data["name"] = this.name;
        data["memberType"] = this.memberType;
        data["outerId"] = this.outerId;
        data["status"] = this.status;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item);
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (Array.isArray(this.notes)) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganization {
    description?: string | undefined;
    businessCategory?: string | undefined;
    ownerId?: string | undefined;
    parentId?: string | undefined;
    objectType?: string | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class MembersSearchCriteria implements IMembersSearchCriteria {
    memberType?: string | undefined;
    memberTypes?: string[] | undefined;
    group?: string | undefined;
    groups?: string[] | undefined;
    memberId?: string | undefined;
    deepSearch?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IMembersSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            if (Array.isArray(_data["memberTypes"])) {
                this.memberTypes = [] as any;
                for (let item of _data["memberTypes"])
                    this.memberTypes!.push(item);
            }
            this.group = _data["group"];
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            this.memberId = _data["memberId"];
            this.deepSearch = _data["deepSearch"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): MembersSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new MembersSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        if (Array.isArray(this.memberTypes)) {
            data["memberTypes"] = [];
            for (let item of this.memberTypes)
                data["memberTypes"].push(item);
        }
        data["group"] = this.group;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        data["memberId"] = this.memberId;
        data["deepSearch"] = this.deepSearch;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IMembersSearchCriteria {
    memberType?: string | undefined;
    memberTypes?: string[] | undefined;
    group?: string | undefined;
    groups?: string[] | undefined;
    memberId?: string | undefined;
    deepSearch?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class Member implements IMember {
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    readonly objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.memberType = _data["memberType"];
            this.outerId = _data["outerId"];
            this.status = _data["status"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CustomerAddress.fromJS(item));
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(item);
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
            if (Array.isArray(_data["notes"])) {
                this.notes = [] as any;
                for (let item of _data["notes"])
                    this.notes!.push(Note.fromJS(item));
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Member {
        data = typeof data === 'object' ? data : {};
        let result = new Member();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["memberType"] = this.memberType;
        data["outerId"] = this.outerId;
        data["status"] = this.status;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item);
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (Array.isArray(this.notes)) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        data["objectType"] = this.objectType;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IMember {
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class MemberSearchResult implements IMemberSearchResult {
    totalCount?: number;
    results?: Member[] | undefined;

    constructor(data?: IMemberSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Member.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MemberSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new MemberSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMemberSearchResult {
    totalCount?: number;
    results?: Member[] | undefined;
}

export class Contact implements IContact {
    salutation?: string | undefined;
    fullName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    birthDate?: Date | undefined;
    defaultLanguage?: string | undefined;
    timeZone?: string | undefined;
    organizations?: string[] | undefined;
    associatedOrganizations?: string[] | undefined;
    taxPayerId?: string | undefined;
    preferredDelivery?: string | undefined;
    preferredCommunication?: string | undefined;
    defaultShippingAddressId?: string | undefined;
    defaultBillingAddressId?: string | undefined;
    photoUrl?: string | undefined;
    isAnonymized?: boolean;
    readonly objectType?: string | undefined;
    securityAccounts?: ApplicationUser[] | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.salutation = _data["salutation"];
            this.fullName = _data["fullName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.defaultLanguage = _data["defaultLanguage"];
            this.timeZone = _data["timeZone"];
            if (Array.isArray(_data["organizations"])) {
                this.organizations = [] as any;
                for (let item of _data["organizations"])
                    this.organizations!.push(item);
            }
            if (Array.isArray(_data["associatedOrganizations"])) {
                this.associatedOrganizations = [] as any;
                for (let item of _data["associatedOrganizations"])
                    this.associatedOrganizations!.push(item);
            }
            this.taxPayerId = _data["taxPayerId"];
            this.preferredDelivery = _data["preferredDelivery"];
            this.preferredCommunication = _data["preferredCommunication"];
            this.defaultShippingAddressId = _data["defaultShippingAddressId"];
            this.defaultBillingAddressId = _data["defaultBillingAddressId"];
            this.photoUrl = _data["photoUrl"];
            this.isAnonymized = _data["isAnonymized"];
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["securityAccounts"])) {
                this.securityAccounts = [] as any;
                for (let item of _data["securityAccounts"])
                    this.securityAccounts!.push(ApplicationUser.fromJS(item));
            }
            this.name = _data["name"];
            this.memberType = _data["memberType"];
            this.outerId = _data["outerId"];
            this.status = _data["status"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CustomerAddress.fromJS(item));
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(item);
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
            if (Array.isArray(_data["notes"])) {
                this.notes = [] as any;
                for (let item of _data["notes"])
                    this.notes!.push(Note.fromJS(item));
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Contact {
        data = typeof data === 'object' ? data : {};
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["salutation"] = this.salutation;
        data["fullName"] = this.fullName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["defaultLanguage"] = this.defaultLanguage;
        data["timeZone"] = this.timeZone;
        if (Array.isArray(this.organizations)) {
            data["organizations"] = [];
            for (let item of this.organizations)
                data["organizations"].push(item);
        }
        if (Array.isArray(this.associatedOrganizations)) {
            data["associatedOrganizations"] = [];
            for (let item of this.associatedOrganizations)
                data["associatedOrganizations"].push(item);
        }
        data["taxPayerId"] = this.taxPayerId;
        data["preferredDelivery"] = this.preferredDelivery;
        data["preferredCommunication"] = this.preferredCommunication;
        data["defaultShippingAddressId"] = this.defaultShippingAddressId;
        data["defaultBillingAddressId"] = this.defaultBillingAddressId;
        data["photoUrl"] = this.photoUrl;
        data["isAnonymized"] = this.isAnonymized;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.securityAccounts)) {
            data["securityAccounts"] = [];
            for (let item of this.securityAccounts)
                data["securityAccounts"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["memberType"] = this.memberType;
        data["outerId"] = this.outerId;
        data["status"] = this.status;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item);
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (Array.isArray(this.notes)) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IContact {
    salutation?: string | undefined;
    fullName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    birthDate?: Date | undefined;
    defaultLanguage?: string | undefined;
    timeZone?: string | undefined;
    organizations?: string[] | undefined;
    associatedOrganizations?: string[] | undefined;
    taxPayerId?: string | undefined;
    preferredDelivery?: string | undefined;
    preferredCommunication?: string | undefined;
    defaultShippingAddressId?: string | undefined;
    defaultBillingAddressId?: string | undefined;
    photoUrl?: string | undefined;
    isAnonymized?: boolean;
    objectType?: string | undefined;
    securityAccounts?: ApplicationUser[] | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class OrganizationSearchResult implements IOrganizationSearchResult {
    totalCount?: number;
    results?: Organization[] | undefined;

    constructor(data?: IOrganizationSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Organization.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrganizationSearchResult {
    totalCount?: number;
    results?: Organization[] | undefined;
}

export class ContactSearchResult implements IContactSearchResult {
    totalCount?: number;
    results?: Contact[] | undefined;

    constructor(data?: IContactSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Contact.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContactSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ContactSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContactSearchResult {
    totalCount?: number;
    results?: Contact[] | undefined;
}

export class Vendor implements IVendor {
    description?: string | undefined;
    siteUrl?: string | undefined;
    logoUrl?: string | undefined;
    groupName?: string | undefined;
    securityAccounts?: ApplicationUser[] | undefined;
    readonly objectType?: string | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IVendor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.siteUrl = _data["siteUrl"];
            this.logoUrl = _data["logoUrl"];
            this.groupName = _data["groupName"];
            if (Array.isArray(_data["securityAccounts"])) {
                this.securityAccounts = [] as any;
                for (let item of _data["securityAccounts"])
                    this.securityAccounts!.push(ApplicationUser.fromJS(item));
            }
            (<any>this).objectType = _data["objectType"];
            this.name = _data["name"];
            this.memberType = _data["memberType"];
            this.outerId = _data["outerId"];
            this.status = _data["status"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CustomerAddress.fromJS(item));
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(item);
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
            if (Array.isArray(_data["notes"])) {
                this.notes = [] as any;
                for (let item of _data["notes"])
                    this.notes!.push(Note.fromJS(item));
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Vendor {
        data = typeof data === 'object' ? data : {};
        let result = new Vendor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["siteUrl"] = this.siteUrl;
        data["logoUrl"] = this.logoUrl;
        data["groupName"] = this.groupName;
        if (Array.isArray(this.securityAccounts)) {
            data["securityAccounts"] = [];
            for (let item of this.securityAccounts)
                data["securityAccounts"].push(item.toJSON());
        }
        data["objectType"] = this.objectType;
        data["name"] = this.name;
        data["memberType"] = this.memberType;
        data["outerId"] = this.outerId;
        data["status"] = this.status;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item);
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (Array.isArray(this.notes)) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IVendor {
    description?: string | undefined;
    siteUrl?: string | undefined;
    logoUrl?: string | undefined;
    groupName?: string | undefined;
    securityAccounts?: ApplicationUser[] | undefined;
    objectType?: string | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class VendorSearchResult implements IVendorSearchResult {
    readonly vendors?: Vendor[] | undefined;
    totalCount?: number;
    results?: Vendor[] | undefined;

    constructor(data?: IVendorSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["vendors"])) {
                (<any>this).vendors = [] as any;
                for (let item of _data["vendors"])
                    (<any>this).vendors!.push(Vendor.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Vendor.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VendorSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new VendorSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.vendors)) {
            data["vendors"] = [];
            for (let item of this.vendors)
                data["vendors"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVendorSearchResult {
    vendors?: Vendor[] | undefined;
    totalCount?: number;
    results?: Vendor[] | undefined;
}

export class Employee implements IEmployee {
    salutation?: string | undefined;
    fullName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    birthDate?: Date | undefined;
    defaultLanguage?: string | undefined;
    timeZone?: string | undefined;
    organizations?: string[] | undefined;
    employeeType?: string | undefined;
    isActive?: boolean;
    photoUrl?: string | undefined;
    readonly objectType?: string | undefined;
    securityAccounts?: ApplicationUser[] | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IEmployee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.salutation = _data["salutation"];
            this.fullName = _data["fullName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.defaultLanguage = _data["defaultLanguage"];
            this.timeZone = _data["timeZone"];
            if (Array.isArray(_data["organizations"])) {
                this.organizations = [] as any;
                for (let item of _data["organizations"])
                    this.organizations!.push(item);
            }
            this.employeeType = _data["employeeType"];
            this.isActive = _data["isActive"];
            this.photoUrl = _data["photoUrl"];
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["securityAccounts"])) {
                this.securityAccounts = [] as any;
                for (let item of _data["securityAccounts"])
                    this.securityAccounts!.push(ApplicationUser.fromJS(item));
            }
            this.name = _data["name"];
            this.memberType = _data["memberType"];
            this.outerId = _data["outerId"];
            this.status = _data["status"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CustomerAddress.fromJS(item));
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(item);
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
            if (Array.isArray(_data["notes"])) {
                this.notes = [] as any;
                for (let item of _data["notes"])
                    this.notes!.push(Note.fromJS(item));
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Employee {
        data = typeof data === 'object' ? data : {};
        let result = new Employee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["salutation"] = this.salutation;
        data["fullName"] = this.fullName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["defaultLanguage"] = this.defaultLanguage;
        data["timeZone"] = this.timeZone;
        if (Array.isArray(this.organizations)) {
            data["organizations"] = [];
            for (let item of this.organizations)
                data["organizations"].push(item);
        }
        data["employeeType"] = this.employeeType;
        data["isActive"] = this.isActive;
        data["photoUrl"] = this.photoUrl;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.securityAccounts)) {
            data["securityAccounts"] = [];
            for (let item of this.securityAccounts)
                data["securityAccounts"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["memberType"] = this.memberType;
        data["outerId"] = this.outerId;
        data["status"] = this.status;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item);
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (Array.isArray(this.notes)) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IEmployee {
    salutation?: string | undefined;
    fullName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    birthDate?: Date | undefined;
    defaultLanguage?: string | undefined;
    timeZone?: string | undefined;
    organizations?: string[] | undefined;
    employeeType?: string | undefined;
    isActive?: boolean;
    photoUrl?: string | undefined;
    objectType?: string | undefined;
    securityAccounts?: ApplicationUser[] | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CustomerReviewSearchCriteria implements ICustomerReviewSearchCriteria {
    productIds?: string[] | undefined;
    reviewStatus?: number[] | undefined;
    storeId?: string | undefined;
    modifiedDate?: Date | undefined;
    userId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ICustomerReviewSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["productIds"])) {
                this.productIds = [] as any;
                for (let item of _data["productIds"])
                    this.productIds!.push(item);
            }
            if (Array.isArray(_data["reviewStatus"])) {
                this.reviewStatus = [] as any;
                for (let item of _data["reviewStatus"])
                    this.reviewStatus!.push(item);
            }
            this.storeId = _data["storeId"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): CustomerReviewSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerReviewSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.productIds)) {
            data["productIds"] = [];
            for (let item of this.productIds)
                data["productIds"].push(item);
        }
        if (Array.isArray(this.reviewStatus)) {
            data["reviewStatus"] = [];
            for (let item of this.reviewStatus)
                data["reviewStatus"].push(item);
        }
        data["storeId"] = this.storeId;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ICustomerReviewSearchCriteria {
    productIds?: string[] | undefined;
    reviewStatus?: number[] | undefined;
    storeId?: string | undefined;
    modifiedDate?: Date | undefined;
    userId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class CustomerReviewListItem implements ICustomerReviewListItem {
    id?: string | undefined;
    productName?: string | undefined;
    reviewStatus?: string | undefined;
    reviewStatusId?: number;
    title?: string | undefined;
    review?: string | undefined;
    rating?: number;
    userName?: string | undefined;
    storeName?: string | undefined;
    createdDate?: Date;

    constructor(data?: ICustomerReviewListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productName = _data["productName"];
            this.reviewStatus = _data["reviewStatus"];
            this.reviewStatusId = _data["reviewStatusId"];
            this.title = _data["title"];
            this.review = _data["review"];
            this.rating = _data["rating"];
            this.userName = _data["userName"];
            this.storeName = _data["storeName"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerReviewListItem {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerReviewListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productName"] = this.productName;
        data["reviewStatus"] = this.reviewStatus;
        data["reviewStatusId"] = this.reviewStatusId;
        data["title"] = this.title;
        data["review"] = this.review;
        data["rating"] = this.rating;
        data["userName"] = this.userName;
        data["storeName"] = this.storeName;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICustomerReviewListItem {
    id?: string | undefined;
    productName?: string | undefined;
    reviewStatus?: string | undefined;
    reviewStatusId?: number;
    title?: string | undefined;
    review?: string | undefined;
    rating?: number;
    userName?: string | undefined;
    storeName?: string | undefined;
    createdDate?: Date;
}

export class CustomerReviewListItemSearchResult implements ICustomerReviewListItemSearchResult {
    totalCount?: number;
    results?: CustomerReviewListItem[] | undefined;

    constructor(data?: ICustomerReviewListItemSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CustomerReviewListItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerReviewListItemSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerReviewListItemSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomerReviewListItemSearchResult {
    totalCount?: number;
    results?: CustomerReviewListItem[] | undefined;
}

export enum CustomerReviewStatus {
    New = "New",
    Approved = "Approved",
    Rejected = "Rejected",
}

export class CustomerReview implements ICustomerReview {
    title?: string | undefined;
    review?: string | undefined;
    rating?: number;
    userId?: string | undefined;
    userName?: string | undefined;
    productId?: string | undefined;
    storeId?: string | undefined;
    reviewStatus?: CustomerReviewStatus;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICustomerReview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.review = _data["review"];
            this.rating = _data["rating"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.productId = _data["productId"];
            this.storeId = _data["storeId"];
            this.reviewStatus = _data["reviewStatus"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CustomerReview {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerReview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["review"] = this.review;
        data["rating"] = this.rating;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["productId"] = this.productId;
        data["storeId"] = this.storeId;
        data["reviewStatus"] = this.reviewStatus;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ICustomerReview {
    title?: string | undefined;
    review?: string | undefined;
    rating?: number;
    userId?: string | undefined;
    userName?: string | undefined;
    productId?: string | undefined;
    storeId?: string | undefined;
    reviewStatus?: CustomerReviewStatus;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CustomerReviewSearchResult implements ICustomerReviewSearchResult {
    totalCount?: number;
    results?: CustomerReview[] | undefined;

    constructor(data?: ICustomerReviewSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CustomerReview.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerReviewSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerReviewSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomerReviewSearchResult {
    totalCount?: number;
    results?: CustomerReview[] | undefined;
}

export class ChangedReviewsQuery implements IChangedReviewsQuery {
    modifiedDate?: Date;

    constructor(data?: IChangedReviewsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ChangedReviewsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ChangedReviewsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IChangedReviewsQuery {
    modifiedDate?: Date;
}

export class ProductCatalogRatingRequest implements IProductCatalogRatingRequest {
    catalogId?: string | undefined;
    productIds?: string[] | undefined;

    constructor(data?: IProductCatalogRatingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalogId = _data["catalogId"];
            if (Array.isArray(_data["productIds"])) {
                this.productIds = [] as any;
                for (let item of _data["productIds"])
                    this.productIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ProductCatalogRatingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCatalogRatingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalogId"] = this.catalogId;
        if (Array.isArray(this.productIds)) {
            data["productIds"] = [];
            for (let item of this.productIds)
                data["productIds"].push(item);
        }
        return data;
    }
}

export interface IProductCatalogRatingRequest {
    catalogId?: string | undefined;
    productIds?: string[] | undefined;
}

export class RatingStoreDto implements IRatingStoreDto {
    storeName?: string | undefined;
    storeId?: string | undefined;
    productId?: string | undefined;
    value?: number;
    reviewCount?: number;

    constructor(data?: IRatingStoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeName = _data["storeName"];
            this.storeId = _data["storeId"];
            this.productId = _data["productId"];
            this.value = _data["value"];
            this.reviewCount = _data["reviewCount"];
        }
    }

    static fromJS(data: any): RatingStoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new RatingStoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeName"] = this.storeName;
        data["storeId"] = this.storeId;
        data["productId"] = this.productId;
        data["value"] = this.value;
        data["reviewCount"] = this.reviewCount;
        return data;
    }
}

export interface IRatingStoreDto {
    storeName?: string | undefined;
    storeId?: string | undefined;
    productId?: string | undefined;
    value?: number;
    reviewCount?: number;
}

export class ProductStoreRatingRequest implements IProductStoreRatingRequest {
    storeId?: string | undefined;
    productIds?: string[] | undefined;

    constructor(data?: IProductStoreRatingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            if (Array.isArray(_data["productIds"])) {
                this.productIds = [] as any;
                for (let item of _data["productIds"])
                    this.productIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ProductStoreRatingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ProductStoreRatingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        if (Array.isArray(this.productIds)) {
            data["productIds"] = [];
            for (let item of this.productIds)
                data["productIds"].push(item);
        }
        return data;
    }
}

export interface IProductStoreRatingRequest {
    storeId?: string | undefined;
    productIds?: string[] | undefined;
}

export class RatingProductDto implements IRatingProductDto {
    productId?: string | undefined;
    value?: number;
    reviewCount?: number;

    constructor(data?: IRatingProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.value = _data["value"];
            this.reviewCount = _data["reviewCount"];
        }
    }

    static fromJS(data: any): RatingProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new RatingProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["value"] = this.value;
        data["reviewCount"] = this.reviewCount;
        return data;
    }
}

export interface IRatingProductDto {
    productId?: string | undefined;
    value?: number;
    reviewCount?: number;
}

export class ExportedTypePropertyInfo implements IExportedTypePropertyInfo {
    fullName?: string | undefined;
    group?: string | undefined;
    displayName?: string | undefined;
    isRequired?: boolean;

    constructor(data?: IExportedTypePropertyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.group = _data["group"];
            this.displayName = _data["displayName"];
            this.isRequired = _data["isRequired"];
        }
    }

    static fromJS(data: any): ExportedTypePropertyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ExportedTypePropertyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["group"] = this.group;
        data["displayName"] = this.displayName;
        data["isRequired"] = this.isRequired;
        return data;
    }
}

export interface IExportedTypePropertyInfo {
    fullName?: string | undefined;
    group?: string | undefined;
    displayName?: string | undefined;
    isRequired?: boolean;
}

export class ExportedTypeMetadata implements IExportedTypeMetadata {
    version?: string | undefined;
    propertyInfos?: ExportedTypePropertyInfo[] | undefined;

    constructor(data?: IExportedTypeMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            if (Array.isArray(_data["propertyInfos"])) {
                this.propertyInfos = [] as any;
                for (let item of _data["propertyInfos"])
                    this.propertyInfos!.push(ExportedTypePropertyInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExportedTypeMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new ExportedTypeMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        if (Array.isArray(this.propertyInfos)) {
            data["propertyInfos"] = [];
            for (let item of this.propertyInfos)
                data["propertyInfos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IExportedTypeMetadata {
    version?: string | undefined;
    propertyInfos?: ExportedTypePropertyInfo[] | undefined;
}

export class ExportedTypeDefinition implements IExportedTypeDefinition {
    typeName?: string | undefined;
    group?: string | undefined;
    metaData?: ExportedTypeMetadata;
    tabularMetaData?: ExportedTypeMetadata;
    exportDataQueryType?: string | undefined;
    readonly isTabularExportSupported?: boolean;
    restrictDataSelectivity?: boolean;

    constructor(data?: IExportedTypeDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeName = _data["typeName"];
            this.group = _data["group"];
            this.metaData = _data["metaData"] ? ExportedTypeMetadata.fromJS(_data["metaData"]) : <any>undefined;
            this.tabularMetaData = _data["tabularMetaData"] ? ExportedTypeMetadata.fromJS(_data["tabularMetaData"]) : <any>undefined;
            this.exportDataQueryType = _data["exportDataQueryType"];
            (<any>this).isTabularExportSupported = _data["isTabularExportSupported"];
            this.restrictDataSelectivity = _data["restrictDataSelectivity"];
        }
    }

    static fromJS(data: any): ExportedTypeDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new ExportedTypeDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName;
        data["group"] = this.group;
        data["metaData"] = this.metaData ? this.metaData.toJSON() : <any>undefined;
        data["tabularMetaData"] = this.tabularMetaData ? this.tabularMetaData.toJSON() : <any>undefined;
        data["exportDataQueryType"] = this.exportDataQueryType;
        data["isTabularExportSupported"] = this.isTabularExportSupported;
        data["restrictDataSelectivity"] = this.restrictDataSelectivity;
        return data;
    }
}

export interface IExportedTypeDefinition {
    typeName?: string | undefined;
    group?: string | undefined;
    metaData?: ExportedTypeMetadata;
    tabularMetaData?: ExportedTypeMetadata;
    exportDataQueryType?: string | undefined;
    isTabularExportSupported?: boolean;
    restrictDataSelectivity?: boolean;
}

export class IExportProviderConfiguration implements IIExportProviderConfiguration {
    type?: string | undefined;

    constructor(data?: IIExportProviderConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): IExportProviderConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new IExportProviderConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        return data;
    }
}

export interface IIExportProviderConfiguration {
    type?: string | undefined;
}

export class IExportProvider implements IIExportProvider {
    readonly typeName?: string | undefined;
    readonly exportedFileExtension?: string | undefined;
    readonly isTabular?: boolean;
    configuration?: IExportProviderConfiguration;

    constructor(data?: IIExportProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).typeName = _data["typeName"];
            (<any>this).exportedFileExtension = _data["exportedFileExtension"];
            (<any>this).isTabular = _data["isTabular"];
            this.configuration = _data["configuration"] ? IExportProviderConfiguration.fromJS(_data["configuration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IExportProvider {
        data = typeof data === 'object' ? data : {};
        let result = new IExportProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName;
        data["exportedFileExtension"] = this.exportedFileExtension;
        data["isTabular"] = this.isTabular;
        data["configuration"] = this.configuration ? this.configuration.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIExportProvider {
    typeName?: string | undefined;
    exportedFileExtension?: string | undefined;
    isTabular?: boolean;
    configuration?: IExportProviderConfiguration;
}

export class ExportDataQuery implements IExportDataQuery {
    readonly exportTypeName?: string | undefined;
    keyword?: string | undefined;
    objectIds?: string[] | undefined;
    sort?: string | undefined;
    includedProperties?: ExportedTypePropertyInfo[] | undefined;
    skip?: number | undefined;
    take?: number | undefined;
    isPreview?: boolean;

    constructor(data?: IExportDataQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).exportTypeName = _data["exportTypeName"];
            this.keyword = _data["keyword"];
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.sort = _data["sort"];
            if (Array.isArray(_data["includedProperties"])) {
                this.includedProperties = [] as any;
                for (let item of _data["includedProperties"])
                    this.includedProperties!.push(ExportedTypePropertyInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
            this.isPreview = _data["isPreview"];
        }
    }

    static fromJS(data: any): ExportDataQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ExportDataQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exportTypeName"] = this.exportTypeName;
        data["keyword"] = this.keyword;
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["sort"] = this.sort;
        if (Array.isArray(this.includedProperties)) {
            data["includedProperties"] = [];
            for (let item of this.includedProperties)
                data["includedProperties"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        data["isPreview"] = this.isPreview;
        return data;
    }
}

export interface IExportDataQuery {
    exportTypeName?: string | undefined;
    keyword?: string | undefined;
    objectIds?: string[] | undefined;
    sort?: string | undefined;
    includedProperties?: ExportedTypePropertyInfo[] | undefined;
    skip?: number | undefined;
    take?: number | undefined;
    isPreview?: boolean;
}

export class ExportDataRequest implements IExportDataRequest {
    exportTypeName?: string | undefined;
    dataQuery?: ExportDataQuery;
    providerConfig?: IExportProviderConfiguration;
    providerName?: string | undefined;

    constructor(data?: IExportDataRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exportTypeName = _data["exportTypeName"];
            this.dataQuery = _data["dataQuery"] ? ExportDataQuery.fromJS(_data["dataQuery"]) : <any>undefined;
            this.providerConfig = _data["providerConfig"] ? IExportProviderConfiguration.fromJS(_data["providerConfig"]) : <any>undefined;
            this.providerName = _data["providerName"];
        }
    }

    static fromJS(data: any): ExportDataRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ExportDataRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exportTypeName"] = this.exportTypeName;
        data["dataQuery"] = this.dataQuery ? this.dataQuery.toJSON() : <any>undefined;
        data["providerConfig"] = this.providerConfig ? this.providerConfig.toJSON() : <any>undefined;
        data["providerName"] = this.providerName;
        return data;
    }
}

export interface IExportDataRequest {
    exportTypeName?: string | undefined;
    dataQuery?: ExportDataQuery;
    providerConfig?: IExportProviderConfiguration;
    providerName?: string | undefined;
}

export class IExportable implements IIExportable {
    id?: string | undefined;

    constructor(data?: IIExportable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IExportable {
        data = typeof data === 'object' ? data : {};
        let result = new IExportable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IIExportable {
    id?: string | undefined;
}

export class ExportableSearchResult implements IExportableSearchResult {
    totalCount?: number;
    results?: IExportable[] | undefined;

    constructor(data?: IExportableSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(IExportable.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExportableSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ExportableSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IExportableSearchResult {
    totalCount?: number;
    results?: IExportable[] | undefined;
}

export class PlatformExportPushNotification implements IPlatformExportPushNotification {
    downloadUrl?: string | undefined;
    jobId?: string | undefined;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    readonly errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IPlatformExportPushNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.downloadUrl = _data["downloadUrl"];
            this.jobId = _data["jobId"];
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.processedCount = _data["processedCount"];
            (<any>this).errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PlatformExportPushNotification {
        data = typeof data === 'object' ? data : {};
        let result = new PlatformExportPushNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downloadUrl"] = this.downloadUrl;
        data["jobId"] = this.jobId;
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["processedCount"] = this.processedCount;
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data;
    }
}

export interface IPlatformExportPushNotification {
    downloadUrl?: string | undefined;
    jobId?: string | undefined;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export class ExportCancellationRequest implements IExportCancellationRequest {
    jobId?: string | undefined;

    constructor(data?: IExportCancellationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
        }
    }

    static fromJS(data: any): ExportCancellationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ExportCancellationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        return data;
    }
}

export interface IExportCancellationRequest {
    jobId?: string | undefined;
}

export enum ResizeMethod {
    FixedSize = "FixedSize",
    FixedWidth = "FixedWidth",
    FixedHeight = "FixedHeight",
    Crop = "Crop",
}

export enum AnchorPosition {
    TopLeft = "TopLeft",
    TopCenter = "TopCenter",
    TopRight = "TopRight",
    CenterLeft = "CenterLeft",
    Center = "Center",
    CenterRight = "CenterRight",
    BottomLeft = "BottomLeft",
    BottomCenter = "BottomCenter",
    BottomRight = "BottomRight",
}

export enum JpegQuality {
    Low = "Low",
    Medium = "Medium",
    High = "High",
    VeryHigh = "VeryHigh",
}

export class ThumbnailOption implements IThumbnailOption {
    name?: string | undefined;
    fileSuffix?: string | undefined;
    resizeMethod?: ResizeMethod;
    width?: number | undefined;
    height?: number | undefined;
    backgroundColor?: string | undefined;
    anchorPosition?: AnchorPosition;
    jpegQuality?: JpegQuality;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IThumbnailOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.fileSuffix = _data["fileSuffix"];
            this.resizeMethod = _data["resizeMethod"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.backgroundColor = _data["backgroundColor"];
            this.anchorPosition = _data["anchorPosition"];
            this.jpegQuality = _data["jpegQuality"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ThumbnailOption {
        data = typeof data === 'object' ? data : {};
        let result = new ThumbnailOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["fileSuffix"] = this.fileSuffix;
        data["resizeMethod"] = this.resizeMethod;
        data["width"] = this.width;
        data["height"] = this.height;
        data["backgroundColor"] = this.backgroundColor;
        data["anchorPosition"] = this.anchorPosition;
        data["jpegQuality"] = this.jpegQuality;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IThumbnailOption {
    name?: string | undefined;
    fileSuffix?: string | undefined;
    resizeMethod?: ResizeMethod;
    width?: number | undefined;
    height?: number | undefined;
    backgroundColor?: string | undefined;
    anchorPosition?: AnchorPosition;
    jpegQuality?: JpegQuality;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ThumbnailOptionSearchCriteria implements IThumbnailOptionSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IThumbnailOptionSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): ThumbnailOptionSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new ThumbnailOptionSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IThumbnailOptionSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class ThumbnailOptionSearchResult implements IThumbnailOptionSearchResult {
    totalCount?: number;
    results?: ThumbnailOption[] | undefined;

    constructor(data?: IThumbnailOptionSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ThumbnailOption.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ThumbnailOptionSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ThumbnailOptionSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IThumbnailOptionSearchResult {
    totalCount?: number;
    results?: ThumbnailOption[] | undefined;
}

export class ThumbnailTask implements IThumbnailTask {
    name?: string | undefined;
    lastRun?: Date | undefined;
    workPath?: string | undefined;
    thumbnailOptions?: ThumbnailOption[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IThumbnailTask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.lastRun = _data["lastRun"] ? new Date(_data["lastRun"].toString()) : <any>undefined;
            this.workPath = _data["workPath"];
            if (Array.isArray(_data["thumbnailOptions"])) {
                this.thumbnailOptions = [] as any;
                for (let item of _data["thumbnailOptions"])
                    this.thumbnailOptions!.push(ThumbnailOption.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ThumbnailTask {
        data = typeof data === 'object' ? data : {};
        let result = new ThumbnailTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["lastRun"] = this.lastRun ? this.lastRun.toISOString() : <any>undefined;
        data["workPath"] = this.workPath;
        if (Array.isArray(this.thumbnailOptions)) {
            data["thumbnailOptions"] = [];
            for (let item of this.thumbnailOptions)
                data["thumbnailOptions"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IThumbnailTask {
    name?: string | undefined;
    lastRun?: Date | undefined;
    workPath?: string | undefined;
    thumbnailOptions?: ThumbnailOption[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ThumbnailTaskSearchCriteria implements IThumbnailTaskSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IThumbnailTaskSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): ThumbnailTaskSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new ThumbnailTaskSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IThumbnailTaskSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class ThumbnailTaskSearchResult implements IThumbnailTaskSearchResult {
    totalCount?: number;
    results?: ThumbnailTask[] | undefined;

    constructor(data?: IThumbnailTaskSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ThumbnailTask.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ThumbnailTaskSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ThumbnailTaskSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IThumbnailTaskSearchResult {
    totalCount?: number;
    results?: ThumbnailTask[] | undefined;
}

export class ThumbnailsTaskRunRequest implements IThumbnailsTaskRunRequest {
    taskIds?: string[] | undefined;
    regenerate?: boolean;

    constructor(data?: IThumbnailsTaskRunRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["taskIds"])) {
                this.taskIds = [] as any;
                for (let item of _data["taskIds"])
                    this.taskIds!.push(item);
            }
            this.regenerate = _data["regenerate"];
        }
    }

    static fromJS(data: any): ThumbnailsTaskRunRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ThumbnailsTaskRunRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.taskIds)) {
            data["taskIds"] = [];
            for (let item of this.taskIds)
                data["taskIds"].push(item);
        }
        data["regenerate"] = this.regenerate;
        return data;
    }
}

export interface IThumbnailsTaskRunRequest {
    taskIds?: string[] | undefined;
    regenerate?: boolean;
}

export class ThumbnailProcessNotification implements IThumbnailProcessNotification {
    jobId?: string | undefined;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IThumbnailProcessNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.processedCount = _data["processedCount"];
            this.errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ThumbnailProcessNotification {
        data = typeof data === 'object' ? data : {};
        let result = new ThumbnailProcessNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["processedCount"] = this.processedCount;
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data;
    }
}

export interface IThumbnailProcessNotification {
    jobId?: string | undefined;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export class InventorySearchCriteria implements IInventorySearchCriteria {
    fulfillmentCenterIds?: string[] | undefined;
    productIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IInventorySearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fulfillmentCenterIds"])) {
                this.fulfillmentCenterIds = [] as any;
                for (let item of _data["fulfillmentCenterIds"])
                    this.fulfillmentCenterIds!.push(item);
            }
            if (Array.isArray(_data["productIds"])) {
                this.productIds = [] as any;
                for (let item of _data["productIds"])
                    this.productIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): InventorySearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new InventorySearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fulfillmentCenterIds)) {
            data["fulfillmentCenterIds"] = [];
            for (let item of this.fulfillmentCenterIds)
                data["fulfillmentCenterIds"].push(item);
        }
        if (Array.isArray(this.productIds)) {
            data["productIds"] = [];
            for (let item of this.productIds)
                data["productIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IInventorySearchCriteria {
    fulfillmentCenterIds?: string[] | undefined;
    productIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class InventoryAddress implements IInventoryAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    outerId?: string | undefined;
    isDefault?: boolean;

    constructor(data?: IInventoryAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressType = _data["addressType"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.organization = _data["organization"];
            this.countryCode = _data["countryCode"];
            this.countryName = _data["countryName"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.zip = _data["zip"];
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.regionId = _data["regionId"];
            this.regionName = _data["regionName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.outerId = _data["outerId"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): InventoryAddress {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressType"] = this.addressType;
        data["key"] = this.key;
        data["name"] = this.name;
        data["organization"] = this.organization;
        data["countryCode"] = this.countryCode;
        data["countryName"] = this.countryName;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["zip"] = this.zip;
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["regionId"] = this.regionId;
        data["regionName"] = this.regionName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["outerId"] = this.outerId;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IInventoryAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    outerId?: string | undefined;
    isDefault?: boolean;
}

export class FulfillmentCenter implements IFulfillmentCenter {
    name?: string | undefined;
    description?: string | undefined;
    geoLocation?: string | undefined;
    address?: InventoryAddress;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IFulfillmentCenter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.geoLocation = _data["geoLocation"];
            this.address = _data["address"] ? InventoryAddress.fromJS(_data["address"]) : <any>undefined;
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FulfillmentCenter {
        data = typeof data === 'object' ? data : {};
        let result = new FulfillmentCenter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["geoLocation"] = this.geoLocation;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IFulfillmentCenter {
    name?: string | undefined;
    description?: string | undefined;
    geoLocation?: string | undefined;
    address?: InventoryAddress;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export enum InventoryStatus {
    Disabled = "Disabled",
    Enabled = "Enabled",
    Ignored = "Ignored",
}

export class InventoryInfo implements IInventoryInfo {
    fulfillmentCenterId?: string | undefined;
    fulfillmentCenterName?: string | undefined;
    fulfillmentCenter?: FulfillmentCenter;
    productId?: string | undefined;
    inStockQuantity?: number;
    reservedQuantity?: number;
    reorderMinQuantity?: number;
    preorderQuantity?: number;
    backorderQuantity?: number;
    allowBackorder?: boolean;
    allowPreorder?: boolean;
    inTransit?: number;
    preorderAvailabilityDate?: Date | undefined;
    backorderAvailabilityDate?: Date | undefined;
    status?: InventoryStatus;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IInventoryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fulfillmentCenterId = _data["fulfillmentCenterId"];
            this.fulfillmentCenterName = _data["fulfillmentCenterName"];
            this.fulfillmentCenter = _data["fulfillmentCenter"] ? FulfillmentCenter.fromJS(_data["fulfillmentCenter"]) : <any>undefined;
            this.productId = _data["productId"];
            this.inStockQuantity = _data["inStockQuantity"];
            this.reservedQuantity = _data["reservedQuantity"];
            this.reorderMinQuantity = _data["reorderMinQuantity"];
            this.preorderQuantity = _data["preorderQuantity"];
            this.backorderQuantity = _data["backorderQuantity"];
            this.allowBackorder = _data["allowBackorder"];
            this.allowPreorder = _data["allowPreorder"];
            this.inTransit = _data["inTransit"];
            this.preorderAvailabilityDate = _data["preorderAvailabilityDate"] ? new Date(_data["preorderAvailabilityDate"].toString()) : <any>undefined;
            this.backorderAvailabilityDate = _data["backorderAvailabilityDate"] ? new Date(_data["backorderAvailabilityDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): InventoryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fulfillmentCenterId"] = this.fulfillmentCenterId;
        data["fulfillmentCenterName"] = this.fulfillmentCenterName;
        data["fulfillmentCenter"] = this.fulfillmentCenter ? this.fulfillmentCenter.toJSON() : <any>undefined;
        data["productId"] = this.productId;
        data["inStockQuantity"] = this.inStockQuantity;
        data["reservedQuantity"] = this.reservedQuantity;
        data["reorderMinQuantity"] = this.reorderMinQuantity;
        data["preorderQuantity"] = this.preorderQuantity;
        data["backorderQuantity"] = this.backorderQuantity;
        data["allowBackorder"] = this.allowBackorder;
        data["allowPreorder"] = this.allowPreorder;
        data["inTransit"] = this.inTransit;
        data["preorderAvailabilityDate"] = this.preorderAvailabilityDate ? this.preorderAvailabilityDate.toISOString() : <any>undefined;
        data["backorderAvailabilityDate"] = this.backorderAvailabilityDate ? this.backorderAvailabilityDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IInventoryInfo {
    fulfillmentCenterId?: string | undefined;
    fulfillmentCenterName?: string | undefined;
    fulfillmentCenter?: FulfillmentCenter;
    productId?: string | undefined;
    inStockQuantity?: number;
    reservedQuantity?: number;
    reorderMinQuantity?: number;
    preorderQuantity?: number;
    backorderQuantity?: number;
    allowBackorder?: boolean;
    allowPreorder?: boolean;
    inTransit?: number;
    preorderAvailabilityDate?: Date | undefined;
    backorderAvailabilityDate?: Date | undefined;
    status?: InventoryStatus;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class InventoryInfoSearchResult implements IInventoryInfoSearchResult {
    totalCount?: number;
    results?: InventoryInfo[] | undefined;

    constructor(data?: IInventoryInfoSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(InventoryInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InventoryInfoSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryInfoSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInventoryInfoSearchResult {
    totalCount?: number;
    results?: InventoryInfo[] | undefined;
}

export class ProductInventorySearchCriteria implements IProductInventorySearchCriteria {
    productId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IProductInventorySearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): ProductInventorySearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInventorySearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IProductInventorySearchCriteria {
    productId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class FulfillmentCenterSearchCriteria implements IFulfillmentCenterSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IFulfillmentCenterSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): FulfillmentCenterSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new FulfillmentCenterSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IFulfillmentCenterSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class FulfillmentCenterSearchResult implements IFulfillmentCenterSearchResult {
    totalCount?: number;
    results?: FulfillmentCenter[] | undefined;

    constructor(data?: IFulfillmentCenterSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(FulfillmentCenter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FulfillmentCenterSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new FulfillmentCenterSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFulfillmentCenterSearchResult {
    totalCount?: number;
    results?: FulfillmentCenter[] | undefined;
}

export class DynamicContentPlaceSearchCriteria implements IDynamicContentPlaceSearchCriteria {
    folderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IDynamicContentPlaceSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.folderId = _data["folderId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): DynamicContentPlaceSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentPlaceSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["folderId"] = this.folderId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IDynamicContentPlaceSearchCriteria {
    folderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class DynamicContentListEntry implements IDynamicContentListEntry {
    objectType?: string | undefined;
    imageUrl?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicContentListEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectType = _data["objectType"];
            this.imageUrl = _data["imageUrl"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicContentListEntry {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentListEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectType"] = this.objectType;
        data["imageUrl"] = this.imageUrl;
        data["name"] = this.name;
        data["description"] = this.description;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicContentListEntry {
    objectType?: string | undefined;
    imageUrl?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicContentListEntrySearchResult implements IDynamicContentListEntrySearchResult {
    totalCount?: number;
    results?: DynamicContentListEntry[] | undefined;

    constructor(data?: IDynamicContentListEntrySearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(DynamicContentListEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicContentListEntrySearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentListEntrySearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDynamicContentListEntrySearchResult {
    totalCount?: number;
    results?: DynamicContentListEntry[] | undefined;
}

export class DynamicContentFolder implements IDynamicContentFolder {
    readonly path?: string | undefined;
    readonly outline?: string | undefined;
    parentFolderId?: string | undefined;
    parentFolder?: DynamicContentFolder;
    readonly objectType?: string | undefined;
    imageUrl?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicContentFolder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).path = _data["path"];
            (<any>this).outline = _data["outline"];
            this.parentFolderId = _data["parentFolderId"];
            this.parentFolder = _data["parentFolder"] ? DynamicContentFolder.fromJS(_data["parentFolder"]) : <any>undefined;
            (<any>this).objectType = _data["objectType"];
            this.imageUrl = _data["imageUrl"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicContentFolder {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentFolder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["outline"] = this.outline;
        data["parentFolderId"] = this.parentFolderId;
        data["parentFolder"] = this.parentFolder ? this.parentFolder.toJSON() : <any>undefined;
        data["objectType"] = this.objectType;
        data["imageUrl"] = this.imageUrl;
        data["name"] = this.name;
        data["description"] = this.description;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicContentFolder {
    path?: string | undefined;
    outline?: string | undefined;
    parentFolderId?: string | undefined;
    parentFolder?: DynamicContentFolder;
    objectType?: string | undefined;
    imageUrl?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicContentPlace implements IDynamicContentPlace {
    readonly outline?: string | undefined;
    readonly path?: string | undefined;
    folderId?: string | undefined;
    folder?: DynamicContentFolder;
    objectType?: string | undefined;
    imageUrl?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicContentPlace) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).outline = _data["outline"];
            (<any>this).path = _data["path"];
            this.folderId = _data["folderId"];
            this.folder = _data["folder"] ? DynamicContentFolder.fromJS(_data["folder"]) : <any>undefined;
            this.objectType = _data["objectType"];
            this.imageUrl = _data["imageUrl"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicContentPlace {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentPlace();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outline"] = this.outline;
        data["path"] = this.path;
        data["folderId"] = this.folderId;
        data["folder"] = this.folder ? this.folder.toJSON() : <any>undefined;
        data["objectType"] = this.objectType;
        data["imageUrl"] = this.imageUrl;
        data["name"] = this.name;
        data["description"] = this.description;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicContentPlace {
    outline?: string | undefined;
    path?: string | undefined;
    folderId?: string | undefined;
    folder?: DynamicContentFolder;
    objectType?: string | undefined;
    imageUrl?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicContentPlaceSearchResult implements IDynamicContentPlaceSearchResult {
    totalCount?: number;
    results?: DynamicContentPlace[] | undefined;

    constructor(data?: IDynamicContentPlaceSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(DynamicContentPlace.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicContentPlaceSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentPlaceSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDynamicContentPlaceSearchResult {
    totalCount?: number;
    results?: DynamicContentPlace[] | undefined;
}

export class DynamicContentItemSearchCriteria implements IDynamicContentItemSearchCriteria {
    folderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IDynamicContentItemSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.folderId = _data["folderId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): DynamicContentItemSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentItemSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["folderId"] = this.folderId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IDynamicContentItemSearchCriteria {
    folderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class DynamicContentItem implements IDynamicContentItem {
    contentType?: string | undefined;
    priority?: number;
    readonly outline?: string | undefined;
    readonly path?: string | undefined;
    folderId?: string | undefined;
    folder?: DynamicContentFolder;
    readonly objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    imageUrl?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicContentItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentType = _data["contentType"];
            this.priority = _data["priority"];
            (<any>this).outline = _data["outline"];
            (<any>this).path = _data["path"];
            this.folderId = _data["folderId"];
            this.folder = _data["folder"] ? DynamicContentFolder.fromJS(_data["folder"]) : <any>undefined;
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            this.imageUrl = _data["imageUrl"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicContentItem {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentType"] = this.contentType;
        data["priority"] = this.priority;
        data["outline"] = this.outline;
        data["path"] = this.path;
        data["folderId"] = this.folderId;
        data["folder"] = this.folder ? this.folder.toJSON() : <any>undefined;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["imageUrl"] = this.imageUrl;
        data["name"] = this.name;
        data["description"] = this.description;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicContentItem {
    contentType?: string | undefined;
    priority?: number;
    outline?: string | undefined;
    path?: string | undefined;
    folderId?: string | undefined;
    folder?: DynamicContentFolder;
    objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    imageUrl?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicContentItemSearchResult implements IDynamicContentItemSearchResult {
    totalCount?: number;
    results?: DynamicContentItem[] | undefined;

    constructor(data?: IDynamicContentItemSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(DynamicContentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicContentItemSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentItemSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDynamicContentItemSearchResult {
    totalCount?: number;
    results?: DynamicContentItem[] | undefined;
}

export class DynamicContentPublicationSearchCriteria implements IDynamicContentPublicationSearchCriteria {
    onlyActive?: boolean;
    store?: string | undefined;
    placeName?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    folderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IDynamicContentPublicationSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onlyActive = _data["onlyActive"];
            this.store = _data["store"];
            this.placeName = _data["placeName"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.folderId = _data["folderId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): DynamicContentPublicationSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentPublicationSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onlyActive"] = this.onlyActive;
        data["store"] = this.store;
        data["placeName"] = this.placeName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["folderId"] = this.folderId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IDynamicContentPublicationSearchCriteria {
    onlyActive?: boolean;
    store?: string | undefined;
    placeName?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    folderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class IConditionTree implements IIConditionTree {
    readonly id?: string | undefined;
    readonly availableChildren?: IConditionTree[] | undefined;
    readonly children?: IConditionTree[] | undefined;

    constructor(data?: IIConditionTree) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["availableChildren"])) {
                (<any>this).availableChildren = [] as any;
                for (let item of _data["availableChildren"])
                    (<any>this).availableChildren!.push(IConditionTree.fromJS(item));
            }
            if (Array.isArray(_data["children"])) {
                (<any>this).children = [] as any;
                for (let item of _data["children"])
                    (<any>this).children!.push(IConditionTree.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IConditionTree {
        data = typeof data === 'object' ? data : {};
        let result = new IConditionTree();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.availableChildren)) {
            data["availableChildren"] = [];
            for (let item of this.availableChildren)
                data["availableChildren"].push(item.toJSON());
        }
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIConditionTree {
    id?: string | undefined;
    availableChildren?: IConditionTree[] | undefined;
    children?: IConditionTree[] | undefined;
}

export class DynamicContentConditionTree implements IDynamicContentConditionTree {
    all?: boolean;
    not?: boolean;
    readonly id?: string | undefined;
    availableChildren?: IConditionTree[] | undefined;
    children?: IConditionTree[] | undefined;

    constructor(data?: IDynamicContentConditionTree) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.all = _data["all"];
            this.not = _data["not"];
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["availableChildren"])) {
                this.availableChildren = [] as any;
                for (let item of _data["availableChildren"])
                    this.availableChildren!.push(IConditionTree.fromJS(item));
            }
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(IConditionTree.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicContentConditionTree {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentConditionTree();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["all"] = this.all;
        data["not"] = this.not;
        data["id"] = this.id;
        if (Array.isArray(this.availableChildren)) {
            data["availableChildren"] = [];
            for (let item of this.availableChildren)
                data["availableChildren"].push(item.toJSON());
        }
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDynamicContentConditionTree {
    all?: boolean;
    not?: boolean;
    id?: string | undefined;
    availableChildren?: IConditionTree[] | undefined;
    children?: IConditionTree[] | undefined;
}

export class DynamicContentPublication implements IDynamicContentPublication {
    name?: string | undefined;
    description?: string | undefined;
    priority?: number;
    isActive?: boolean;
    storeId?: string | undefined;
    dynamicExpression?: DynamicContentConditionTree;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    outerId?: string | undefined;
    contentItems?: DynamicContentItem[] | undefined;
    contentPlaces?: DynamicContentPlace[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicContentPublication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.priority = _data["priority"];
            this.isActive = _data["isActive"];
            this.storeId = _data["storeId"];
            this.dynamicExpression = _data["dynamicExpression"] ? DynamicContentConditionTree.fromJS(_data["dynamicExpression"]) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["contentItems"])) {
                this.contentItems = [] as any;
                for (let item of _data["contentItems"])
                    this.contentItems!.push(DynamicContentItem.fromJS(item));
            }
            if (Array.isArray(_data["contentPlaces"])) {
                this.contentPlaces = [] as any;
                for (let item of _data["contentPlaces"])
                    this.contentPlaces!.push(DynamicContentPlace.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicContentPublication {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentPublication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["priority"] = this.priority;
        data["isActive"] = this.isActive;
        data["storeId"] = this.storeId;
        data["dynamicExpression"] = this.dynamicExpression ? this.dynamicExpression.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.contentItems)) {
            data["contentItems"] = [];
            for (let item of this.contentItems)
                data["contentItems"].push(item.toJSON());
        }
        if (Array.isArray(this.contentPlaces)) {
            data["contentPlaces"] = [];
            for (let item of this.contentPlaces)
                data["contentPlaces"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicContentPublication {
    name?: string | undefined;
    description?: string | undefined;
    priority?: number;
    isActive?: boolean;
    storeId?: string | undefined;
    dynamicExpression?: DynamicContentConditionTree;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    outerId?: string | undefined;
    contentItems?: DynamicContentItem[] | undefined;
    contentPlaces?: DynamicContentPlace[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicContentPublicationSearchResult implements IDynamicContentPublicationSearchResult {
    totalCount?: number;
    results?: DynamicContentPublication[] | undefined;

    constructor(data?: IDynamicContentPublicationSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(DynamicContentPublication.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicContentPublicationSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentPublicationSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDynamicContentPublicationSearchResult {
    totalCount?: number;
    results?: DynamicContentPublication[] | undefined;
}

export class DynamicContentEvaluationContext implements IDynamicContentEvaluationContext {
    storeId?: string | undefined;
    placeName?: string | undefined;
    tags?: string[] | undefined;
    toDate?: Date;
    categoryId?: string | undefined;
    productId?: string | undefined;
    contextObject?: any | undefined;
    geoCity?: string | undefined;
    geoState?: string | undefined;
    geoCountry?: string | undefined;
    geoContinent?: string | undefined;
    geoZipCode?: string | undefined;
    geoConnectionType?: string | undefined;
    geoTimeZone?: string | undefined;
    geoIpRoutingType?: string | undefined;
    geoIspSecondLevel?: string | undefined;
    geoIspTopLevel?: string | undefined;
    shopperAge?: number;
    shopperGender?: string | undefined;
    language?: string | undefined;
    userGroups?: string[] | undefined;
    shopperSearchedPhraseInStore?: string | undefined;
    shopperSearchedPhraseOnInternet?: string | undefined;
    currentUrl?: string | undefined;
    referredUrl?: string | undefined;

    constructor(data?: IDynamicContentEvaluationContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.placeName = _data["placeName"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.productId = _data["productId"];
            this.contextObject = _data["contextObject"];
            this.geoCity = _data["geoCity"];
            this.geoState = _data["geoState"];
            this.geoCountry = _data["geoCountry"];
            this.geoContinent = _data["geoContinent"];
            this.geoZipCode = _data["geoZipCode"];
            this.geoConnectionType = _data["geoConnectionType"];
            this.geoTimeZone = _data["geoTimeZone"];
            this.geoIpRoutingType = _data["geoIpRoutingType"];
            this.geoIspSecondLevel = _data["geoIspSecondLevel"];
            this.geoIspTopLevel = _data["geoIspTopLevel"];
            this.shopperAge = _data["shopperAge"];
            this.shopperGender = _data["shopperGender"];
            this.language = _data["language"];
            if (Array.isArray(_data["userGroups"])) {
                this.userGroups = [] as any;
                for (let item of _data["userGroups"])
                    this.userGroups!.push(item);
            }
            this.shopperSearchedPhraseInStore = _data["shopperSearchedPhraseInStore"];
            this.shopperSearchedPhraseOnInternet = _data["shopperSearchedPhraseOnInternet"];
            this.currentUrl = _data["currentUrl"];
            this.referredUrl = _data["referredUrl"];
        }
    }

    static fromJS(data: any): DynamicContentEvaluationContext {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentEvaluationContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["placeName"] = this.placeName;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["productId"] = this.productId;
        data["contextObject"] = this.contextObject;
        data["geoCity"] = this.geoCity;
        data["geoState"] = this.geoState;
        data["geoCountry"] = this.geoCountry;
        data["geoContinent"] = this.geoContinent;
        data["geoZipCode"] = this.geoZipCode;
        data["geoConnectionType"] = this.geoConnectionType;
        data["geoTimeZone"] = this.geoTimeZone;
        data["geoIpRoutingType"] = this.geoIpRoutingType;
        data["geoIspSecondLevel"] = this.geoIspSecondLevel;
        data["geoIspTopLevel"] = this.geoIspTopLevel;
        data["shopperAge"] = this.shopperAge;
        data["shopperGender"] = this.shopperGender;
        data["language"] = this.language;
        if (Array.isArray(this.userGroups)) {
            data["userGroups"] = [];
            for (let item of this.userGroups)
                data["userGroups"].push(item);
        }
        data["shopperSearchedPhraseInStore"] = this.shopperSearchedPhraseInStore;
        data["shopperSearchedPhraseOnInternet"] = this.shopperSearchedPhraseOnInternet;
        data["currentUrl"] = this.currentUrl;
        data["referredUrl"] = this.referredUrl;
        return data;
    }
}

export interface IDynamicContentEvaluationContext {
    storeId?: string | undefined;
    placeName?: string | undefined;
    tags?: string[] | undefined;
    toDate?: Date;
    categoryId?: string | undefined;
    productId?: string | undefined;
    contextObject?: any | undefined;
    geoCity?: string | undefined;
    geoState?: string | undefined;
    geoCountry?: string | undefined;
    geoContinent?: string | undefined;
    geoZipCode?: string | undefined;
    geoConnectionType?: string | undefined;
    geoTimeZone?: string | undefined;
    geoIpRoutingType?: string | undefined;
    geoIspSecondLevel?: string | undefined;
    geoIspTopLevel?: string | undefined;
    shopperAge?: number;
    shopperGender?: string | undefined;
    language?: string | undefined;
    userGroups?: string[] | undefined;
    shopperSearchedPhraseInStore?: string | undefined;
    shopperSearchedPhraseOnInternet?: string | undefined;
    currentUrl?: string | undefined;
    referredUrl?: string | undefined;
}

export class PromotionSearchCriteria implements IPromotionSearchCriteria {
    onlyActive?: boolean;
    store?: string | undefined;
    storeIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IPromotionSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onlyActive = _data["onlyActive"];
            this.store = _data["store"];
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): PromotionSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onlyActive"] = this.onlyActive;
        data["store"] = this.store;
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IPromotionSearchCriteria {
    onlyActive?: boolean;
    store?: string | undefined;
    storeIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class PromotionConditionAndRewardTree implements IPromotionConditionAndRewardTree {
    all?: boolean;
    not?: boolean;
    readonly id?: string | undefined;
    availableChildren?: IConditionTree[] | undefined;
    children?: IConditionTree[] | undefined;

    constructor(data?: IPromotionConditionAndRewardTree) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.all = _data["all"];
            this.not = _data["not"];
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["availableChildren"])) {
                this.availableChildren = [] as any;
                for (let item of _data["availableChildren"])
                    this.availableChildren!.push(IConditionTree.fromJS(item));
            }
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(IConditionTree.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PromotionConditionAndRewardTree {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionConditionAndRewardTree();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["all"] = this.all;
        data["not"] = this.not;
        data["id"] = this.id;
        if (Array.isArray(this.availableChildren)) {
            data["availableChildren"] = [];
            for (let item of this.availableChildren)
                data["availableChildren"].push(item.toJSON());
        }
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPromotionConditionAndRewardTree {
    all?: boolean;
    not?: boolean;
    id?: string | undefined;
    availableChildren?: IConditionTree[] | undefined;
    children?: IConditionTree[] | undefined;
}

export class Promotion implements IPromotion {
    isAllowCombiningWithSelf?: boolean;
    dynamicExpression?: PromotionConditionAndRewardTree;
    store?: string | undefined;
    storeIds?: string[] | undefined;
    name?: string | undefined;
    type?: string | undefined;
    isActive?: boolean;
    priority?: number;
    isExclusive?: boolean;
    hasCoupons?: boolean;
    description?: string | undefined;
    maxUsageCount?: number;
    maxUsageOnOrder?: number;
    maxPersonalUsageCount?: number;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPromotion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAllowCombiningWithSelf = _data["isAllowCombiningWithSelf"];
            this.dynamicExpression = _data["dynamicExpression"] ? PromotionConditionAndRewardTree.fromJS(_data["dynamicExpression"]) : <any>undefined;
            this.store = _data["store"];
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.name = _data["name"];
            this.type = _data["type"];
            this.isActive = _data["isActive"];
            this.priority = _data["priority"];
            this.isExclusive = _data["isExclusive"];
            this.hasCoupons = _data["hasCoupons"];
            this.description = _data["description"];
            this.maxUsageCount = _data["maxUsageCount"];
            this.maxUsageOnOrder = _data["maxUsageOnOrder"];
            this.maxPersonalUsageCount = _data["maxPersonalUsageCount"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Promotion {
        data = typeof data === 'object' ? data : {};
        let result = new Promotion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAllowCombiningWithSelf"] = this.isAllowCombiningWithSelf;
        data["dynamicExpression"] = this.dynamicExpression ? this.dynamicExpression.toJSON() : <any>undefined;
        data["store"] = this.store;
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["name"] = this.name;
        data["type"] = this.type;
        data["isActive"] = this.isActive;
        data["priority"] = this.priority;
        data["isExclusive"] = this.isExclusive;
        data["hasCoupons"] = this.hasCoupons;
        data["description"] = this.description;
        data["maxUsageCount"] = this.maxUsageCount;
        data["maxUsageOnOrder"] = this.maxUsageOnOrder;
        data["maxPersonalUsageCount"] = this.maxPersonalUsageCount;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IPromotion {
    isAllowCombiningWithSelf?: boolean;
    dynamicExpression?: PromotionConditionAndRewardTree;
    store?: string | undefined;
    storeIds?: string[] | undefined;
    name?: string | undefined;
    type?: string | undefined;
    isActive?: boolean;
    priority?: number;
    isExclusive?: boolean;
    hasCoupons?: boolean;
    description?: string | undefined;
    maxUsageCount?: number;
    maxUsageOnOrder?: number;
    maxPersonalUsageCount?: number;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class PromotionSearchResult implements IPromotionSearchResult {
    totalCount?: number;
    results?: Promotion[] | undefined;

    constructor(data?: IPromotionSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Promotion.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PromotionSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPromotionSearchResult {
    totalCount?: number;
    results?: Promotion[] | undefined;
}

export class ProductPromoEntry implements IProductPromoEntry {
    code?: string | undefined;
    quantity?: number;
    inStockQuantity?: number;
    price?: number;
    listPrice?: number;
    discount?: number;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    productId?: string | undefined;
    owner?: any | undefined;
    outline?: string | undefined;
    variations?: ProductPromoEntry[] | undefined;
    attributes?: { [key: string]: string; } | undefined;

    constructor(data?: IProductPromoEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.quantity = _data["quantity"];
            this.inStockQuantity = _data["inStockQuantity"];
            this.price = _data["price"];
            this.listPrice = _data["listPrice"];
            this.discount = _data["discount"];
            this.catalogId = _data["catalogId"];
            this.categoryId = _data["categoryId"];
            this.productId = _data["productId"];
            this.owner = _data["owner"];
            this.outline = _data["outline"];
            if (Array.isArray(_data["variations"])) {
                this.variations = [] as any;
                for (let item of _data["variations"])
                    this.variations!.push(ProductPromoEntry.fromJS(item));
            }
            if (_data["attributes"]) {
                this.attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>this.attributes)![key] = _data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductPromoEntry {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPromoEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["quantity"] = this.quantity;
        data["inStockQuantity"] = this.inStockQuantity;
        data["price"] = this.price;
        data["listPrice"] = this.listPrice;
        data["discount"] = this.discount;
        data["catalogId"] = this.catalogId;
        data["categoryId"] = this.categoryId;
        data["productId"] = this.productId;
        data["owner"] = this.owner;
        data["outline"] = this.outline;
        if (Array.isArray(this.variations)) {
            data["variations"] = [];
            for (let item of this.variations)
                data["variations"].push(item.toJSON());
        }
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = (<any>this.attributes)[key];
            }
        }
        return data;
    }
}

export interface IProductPromoEntry {
    code?: string | undefined;
    quantity?: number;
    inStockQuantity?: number;
    price?: number;
    listPrice?: number;
    discount?: number;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    productId?: string | undefined;
    owner?: any | undefined;
    outline?: string | undefined;
    variations?: ProductPromoEntry[] | undefined;
    attributes?: { [key: string]: string; } | undefined;
}

export class PromotionEvaluationContext implements IPromotionEvaluationContext {
    refusedGiftIds?: string[] | undefined;
    storeId?: string | undefined;
    currency?: string | undefined;
    customerId?: string | undefined;
    isRegisteredUser?: boolean;
    isFirstTimeBuyer?: boolean;
    isEveryone?: boolean;
    cartTotal?: number;
    shipmentMethodCode?: string | undefined;
    shipmentMethodOption?: string | undefined;
    shipmentMethodPrice?: number;
    availableShipmentMethodCodes?: string[] | undefined;
    paymentMethodCode?: string | undefined;
    paymentMethodPrice?: number;
    availablePaymentMethodCodes?: string[] | undefined;
    coupon?: string | undefined;
    coupons?: string[] | undefined;
    cartPromoEntries?: ProductPromoEntry[] | undefined;
    promoEntries?: ProductPromoEntry[] | undefined;
    promoEntry?: ProductPromoEntry;
    contextObject?: any | undefined;
    geoCity?: string | undefined;
    geoState?: string | undefined;
    geoCountry?: string | undefined;
    geoContinent?: string | undefined;
    geoZipCode?: string | undefined;
    geoConnectionType?: string | undefined;
    geoTimeZone?: string | undefined;
    geoIpRoutingType?: string | undefined;
    geoIspSecondLevel?: string | undefined;
    geoIspTopLevel?: string | undefined;
    shopperAge?: number;
    shopperGender?: string | undefined;
    language?: string | undefined;
    userGroups?: string[] | undefined;
    shopperSearchedPhraseInStore?: string | undefined;
    shopperSearchedPhraseOnInternet?: string | undefined;
    currentUrl?: string | undefined;
    referredUrl?: string | undefined;

    constructor(data?: IPromotionEvaluationContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["refusedGiftIds"])) {
                this.refusedGiftIds = [] as any;
                for (let item of _data["refusedGiftIds"])
                    this.refusedGiftIds!.push(item);
            }
            this.storeId = _data["storeId"];
            this.currency = _data["currency"];
            this.customerId = _data["customerId"];
            this.isRegisteredUser = _data["isRegisteredUser"];
            this.isFirstTimeBuyer = _data["isFirstTimeBuyer"];
            this.isEveryone = _data["isEveryone"];
            this.cartTotal = _data["cartTotal"];
            this.shipmentMethodCode = _data["shipmentMethodCode"];
            this.shipmentMethodOption = _data["shipmentMethodOption"];
            this.shipmentMethodPrice = _data["shipmentMethodPrice"];
            if (Array.isArray(_data["availableShipmentMethodCodes"])) {
                this.availableShipmentMethodCodes = [] as any;
                for (let item of _data["availableShipmentMethodCodes"])
                    this.availableShipmentMethodCodes!.push(item);
            }
            this.paymentMethodCode = _data["paymentMethodCode"];
            this.paymentMethodPrice = _data["paymentMethodPrice"];
            if (Array.isArray(_data["availablePaymentMethodCodes"])) {
                this.availablePaymentMethodCodes = [] as any;
                for (let item of _data["availablePaymentMethodCodes"])
                    this.availablePaymentMethodCodes!.push(item);
            }
            this.coupon = _data["coupon"];
            if (Array.isArray(_data["coupons"])) {
                this.coupons = [] as any;
                for (let item of _data["coupons"])
                    this.coupons!.push(item);
            }
            if (Array.isArray(_data["cartPromoEntries"])) {
                this.cartPromoEntries = [] as any;
                for (let item of _data["cartPromoEntries"])
                    this.cartPromoEntries!.push(ProductPromoEntry.fromJS(item));
            }
            if (Array.isArray(_data["promoEntries"])) {
                this.promoEntries = [] as any;
                for (let item of _data["promoEntries"])
                    this.promoEntries!.push(ProductPromoEntry.fromJS(item));
            }
            this.promoEntry = _data["promoEntry"] ? ProductPromoEntry.fromJS(_data["promoEntry"]) : <any>undefined;
            this.contextObject = _data["contextObject"];
            this.geoCity = _data["geoCity"];
            this.geoState = _data["geoState"];
            this.geoCountry = _data["geoCountry"];
            this.geoContinent = _data["geoContinent"];
            this.geoZipCode = _data["geoZipCode"];
            this.geoConnectionType = _data["geoConnectionType"];
            this.geoTimeZone = _data["geoTimeZone"];
            this.geoIpRoutingType = _data["geoIpRoutingType"];
            this.geoIspSecondLevel = _data["geoIspSecondLevel"];
            this.geoIspTopLevel = _data["geoIspTopLevel"];
            this.shopperAge = _data["shopperAge"];
            this.shopperGender = _data["shopperGender"];
            this.language = _data["language"];
            if (Array.isArray(_data["userGroups"])) {
                this.userGroups = [] as any;
                for (let item of _data["userGroups"])
                    this.userGroups!.push(item);
            }
            this.shopperSearchedPhraseInStore = _data["shopperSearchedPhraseInStore"];
            this.shopperSearchedPhraseOnInternet = _data["shopperSearchedPhraseOnInternet"];
            this.currentUrl = _data["currentUrl"];
            this.referredUrl = _data["referredUrl"];
        }
    }

    static fromJS(data: any): PromotionEvaluationContext {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionEvaluationContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.refusedGiftIds)) {
            data["refusedGiftIds"] = [];
            for (let item of this.refusedGiftIds)
                data["refusedGiftIds"].push(item);
        }
        data["storeId"] = this.storeId;
        data["currency"] = this.currency;
        data["customerId"] = this.customerId;
        data["isRegisteredUser"] = this.isRegisteredUser;
        data["isFirstTimeBuyer"] = this.isFirstTimeBuyer;
        data["isEveryone"] = this.isEveryone;
        data["cartTotal"] = this.cartTotal;
        data["shipmentMethodCode"] = this.shipmentMethodCode;
        data["shipmentMethodOption"] = this.shipmentMethodOption;
        data["shipmentMethodPrice"] = this.shipmentMethodPrice;
        if (Array.isArray(this.availableShipmentMethodCodes)) {
            data["availableShipmentMethodCodes"] = [];
            for (let item of this.availableShipmentMethodCodes)
                data["availableShipmentMethodCodes"].push(item);
        }
        data["paymentMethodCode"] = this.paymentMethodCode;
        data["paymentMethodPrice"] = this.paymentMethodPrice;
        if (Array.isArray(this.availablePaymentMethodCodes)) {
            data["availablePaymentMethodCodes"] = [];
            for (let item of this.availablePaymentMethodCodes)
                data["availablePaymentMethodCodes"].push(item);
        }
        data["coupon"] = this.coupon;
        if (Array.isArray(this.coupons)) {
            data["coupons"] = [];
            for (let item of this.coupons)
                data["coupons"].push(item);
        }
        if (Array.isArray(this.cartPromoEntries)) {
            data["cartPromoEntries"] = [];
            for (let item of this.cartPromoEntries)
                data["cartPromoEntries"].push(item.toJSON());
        }
        if (Array.isArray(this.promoEntries)) {
            data["promoEntries"] = [];
            for (let item of this.promoEntries)
                data["promoEntries"].push(item.toJSON());
        }
        data["promoEntry"] = this.promoEntry ? this.promoEntry.toJSON() : <any>undefined;
        data["contextObject"] = this.contextObject;
        data["geoCity"] = this.geoCity;
        data["geoState"] = this.geoState;
        data["geoCountry"] = this.geoCountry;
        data["geoContinent"] = this.geoContinent;
        data["geoZipCode"] = this.geoZipCode;
        data["geoConnectionType"] = this.geoConnectionType;
        data["geoTimeZone"] = this.geoTimeZone;
        data["geoIpRoutingType"] = this.geoIpRoutingType;
        data["geoIspSecondLevel"] = this.geoIspSecondLevel;
        data["geoIspTopLevel"] = this.geoIspTopLevel;
        data["shopperAge"] = this.shopperAge;
        data["shopperGender"] = this.shopperGender;
        data["language"] = this.language;
        if (Array.isArray(this.userGroups)) {
            data["userGroups"] = [];
            for (let item of this.userGroups)
                data["userGroups"].push(item);
        }
        data["shopperSearchedPhraseInStore"] = this.shopperSearchedPhraseInStore;
        data["shopperSearchedPhraseOnInternet"] = this.shopperSearchedPhraseOnInternet;
        data["currentUrl"] = this.currentUrl;
        data["referredUrl"] = this.referredUrl;
        return data;
    }
}

export interface IPromotionEvaluationContext {
    refusedGiftIds?: string[] | undefined;
    storeId?: string | undefined;
    currency?: string | undefined;
    customerId?: string | undefined;
    isRegisteredUser?: boolean;
    isFirstTimeBuyer?: boolean;
    isEveryone?: boolean;
    cartTotal?: number;
    shipmentMethodCode?: string | undefined;
    shipmentMethodOption?: string | undefined;
    shipmentMethodPrice?: number;
    availableShipmentMethodCodes?: string[] | undefined;
    paymentMethodCode?: string | undefined;
    paymentMethodPrice?: number;
    availablePaymentMethodCodes?: string[] | undefined;
    coupon?: string | undefined;
    coupons?: string[] | undefined;
    cartPromoEntries?: ProductPromoEntry[] | undefined;
    promoEntries?: ProductPromoEntry[] | undefined;
    promoEntry?: ProductPromoEntry;
    contextObject?: any | undefined;
    geoCity?: string | undefined;
    geoState?: string | undefined;
    geoCountry?: string | undefined;
    geoContinent?: string | undefined;
    geoZipCode?: string | undefined;
    geoConnectionType?: string | undefined;
    geoTimeZone?: string | undefined;
    geoIpRoutingType?: string | undefined;
    geoIspSecondLevel?: string | undefined;
    geoIspTopLevel?: string | undefined;
    shopperAge?: number;
    shopperGender?: string | undefined;
    language?: string | undefined;
    userGroups?: string[] | undefined;
    shopperSearchedPhraseInStore?: string | undefined;
    shopperSearchedPhraseOnInternet?: string | undefined;
    currentUrl?: string | undefined;
    referredUrl?: string | undefined;
}

export enum RewardAmountType {
    Absolute = "Absolute",
    Relative = "Relative",
}

export class PromotionReward implements IPromotionReward {
    isValid?: boolean;
    description?: string | undefined;
    couponAmount?: number;
    coupon?: string | undefined;
    couponMinOrderAmount?: number | undefined;
    promotionId?: string | undefined;
    promotion?: Promotion;
    rewardType?: string | undefined;
    amountType?: RewardAmountType;
    amount?: number;
    quantity?: number;
    lineItemId?: string | undefined;
    productId?: string | undefined;
    conditionalProductId?: string | undefined;
    categoryId?: string | undefined;
    measureUnit?: string | undefined;
    imageUrl?: string | undefined;
    shippingMethod?: string | undefined;
    paymentMethod?: string | undefined;
    maxLimit?: number;
    forNthQuantity?: number;
    inEveryNthQuantity?: number;

    constructor(data?: IPromotionReward) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
            this.description = _data["description"];
            this.couponAmount = _data["couponAmount"];
            this.coupon = _data["coupon"];
            this.couponMinOrderAmount = _data["couponMinOrderAmount"];
            this.promotionId = _data["promotionId"];
            this.promotion = _data["promotion"] ? Promotion.fromJS(_data["promotion"]) : <any>undefined;
            this.rewardType = _data["rewardType"];
            this.amountType = _data["amountType"];
            this.amount = _data["amount"];
            this.quantity = _data["quantity"];
            this.lineItemId = _data["lineItemId"];
            this.productId = _data["productId"];
            this.conditionalProductId = _data["conditionalProductId"];
            this.categoryId = _data["categoryId"];
            this.measureUnit = _data["measureUnit"];
            this.imageUrl = _data["imageUrl"];
            this.shippingMethod = _data["shippingMethod"];
            this.paymentMethod = _data["paymentMethod"];
            this.maxLimit = _data["maxLimit"];
            this.forNthQuantity = _data["forNthQuantity"];
            this.inEveryNthQuantity = _data["inEveryNthQuantity"];
        }
    }

    static fromJS(data: any): PromotionReward {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionReward();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        data["description"] = this.description;
        data["couponAmount"] = this.couponAmount;
        data["coupon"] = this.coupon;
        data["couponMinOrderAmount"] = this.couponMinOrderAmount;
        data["promotionId"] = this.promotionId;
        data["promotion"] = this.promotion ? this.promotion.toJSON() : <any>undefined;
        data["rewardType"] = this.rewardType;
        data["amountType"] = this.amountType;
        data["amount"] = this.amount;
        data["quantity"] = this.quantity;
        data["lineItemId"] = this.lineItemId;
        data["productId"] = this.productId;
        data["conditionalProductId"] = this.conditionalProductId;
        data["categoryId"] = this.categoryId;
        data["measureUnit"] = this.measureUnit;
        data["imageUrl"] = this.imageUrl;
        data["shippingMethod"] = this.shippingMethod;
        data["paymentMethod"] = this.paymentMethod;
        data["maxLimit"] = this.maxLimit;
        data["forNthQuantity"] = this.forNthQuantity;
        data["inEveryNthQuantity"] = this.inEveryNthQuantity;
        return data;
    }
}

export interface IPromotionReward {
    isValid?: boolean;
    description?: string | undefined;
    couponAmount?: number;
    coupon?: string | undefined;
    couponMinOrderAmount?: number | undefined;
    promotionId?: string | undefined;
    promotion?: Promotion;
    rewardType?: string | undefined;
    amountType?: RewardAmountType;
    amount?: number;
    quantity?: number;
    lineItemId?: string | undefined;
    productId?: string | undefined;
    conditionalProductId?: string | undefined;
    categoryId?: string | undefined;
    measureUnit?: string | undefined;
    imageUrl?: string | undefined;
    shippingMethod?: string | undefined;
    paymentMethod?: string | undefined;
    maxLimit?: number;
    forNthQuantity?: number;
    inEveryNthQuantity?: number;
}

export class CouponSearchCriteria implements ICouponSearchCriteria {
    code?: string | undefined;
    codes?: string[] | undefined;
    promotionId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ICouponSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            if (Array.isArray(_data["codes"])) {
                this.codes = [] as any;
                for (let item of _data["codes"])
                    this.codes!.push(item);
            }
            this.promotionId = _data["promotionId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): CouponSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CouponSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        if (Array.isArray(this.codes)) {
            data["codes"] = [];
            for (let item of this.codes)
                data["codes"].push(item);
        }
        data["promotionId"] = this.promotionId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ICouponSearchCriteria {
    code?: string | undefined;
    codes?: string[] | undefined;
    promotionId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class Coupon implements ICoupon {
    maxUsesNumber?: number;
    maxUsesPerUser?: number;
    expirationDate?: Date | undefined;
    code?: string | undefined;
    promotionId?: string | undefined;
    totalUsesCount?: number;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICoupon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxUsesNumber = _data["maxUsesNumber"];
            this.maxUsesPerUser = _data["maxUsesPerUser"];
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.code = _data["code"];
            this.promotionId = _data["promotionId"];
            this.totalUsesCount = _data["totalUsesCount"];
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Coupon {
        data = typeof data === 'object' ? data : {};
        let result = new Coupon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxUsesNumber"] = this.maxUsesNumber;
        data["maxUsesPerUser"] = this.maxUsesPerUser;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["promotionId"] = this.promotionId;
        data["totalUsesCount"] = this.totalUsesCount;
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ICoupon {
    maxUsesNumber?: number;
    maxUsesPerUser?: number;
    expirationDate?: Date | undefined;
    code?: string | undefined;
    promotionId?: string | undefined;
    totalUsesCount?: number;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CouponSearchResult implements ICouponSearchResult {
    totalCount?: number;
    results?: Coupon[] | undefined;

    constructor(data?: ICouponSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Coupon.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CouponSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new CouponSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICouponSearchResult {
    totalCount?: number;
    results?: Coupon[] | undefined;
}

export class ImportRequest implements IImportRequest {
    fileUrl?: string | undefined;
    delimiter?: string | undefined;
    promotionId?: string | undefined;
    expirationDate?: Date | undefined;

    constructor(data?: IImportRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileUrl = _data["fileUrl"];
            this.delimiter = _data["delimiter"];
            this.promotionId = _data["promotionId"];
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ImportRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ImportRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileUrl"] = this.fileUrl;
        data["delimiter"] = this.delimiter;
        data["promotionId"] = this.promotionId;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IImportRequest {
    fileUrl?: string | undefined;
    delimiter?: string | undefined;
    promotionId?: string | undefined;
    expirationDate?: Date | undefined;
}

export class ImportNotification implements IImportNotification {
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IImportNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.processedCount = _data["processedCount"];
            this.errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ImportNotification {
        data = typeof data === 'object' ? data : {};
        let result = new ImportNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["processedCount"] = this.processedCount;
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data;
    }
}

export interface IImportNotification {
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export class MarketplaceOptions implements IMarketplaceOptions {
    masterCatalogId!: string;
    vendorPortalUrl?: string | undefined;
    availCurencies?: string[] | undefined;
    storeId!: string;

    constructor(data?: IMarketplaceOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.masterCatalogId = _data["masterCatalogId"];
            this.vendorPortalUrl = _data["vendorPortalUrl"];
            if (Array.isArray(_data["availCurencies"])) {
                this.availCurencies = [] as any;
                for (let item of _data["availCurencies"])
                    this.availCurencies!.push(item);
            }
            this.storeId = _data["storeId"];
        }
    }

    static fromJS(data: any): MarketplaceOptions {
        data = typeof data === 'object' ? data : {};
        let result = new MarketplaceOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["masterCatalogId"] = this.masterCatalogId;
        data["vendorPortalUrl"] = this.vendorPortalUrl;
        if (Array.isArray(this.availCurencies)) {
            data["availCurencies"] = [];
            for (let item of this.availCurencies)
                data["availCurencies"].push(item);
        }
        data["storeId"] = this.storeId;
        return data;
    }
}

export interface IMarketplaceOptions {
    masterCatalogId: string;
    vendorPortalUrl?: string | undefined;
    availCurencies?: string[] | undefined;
    storeId: string;
}

export class SearchProductsQuery implements ISearchProductsQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    publishedProductsIds?: string[] | undefined;
    searchFromAllSellers?: boolean;
    gtin?: string | undefined;
    categoryId?: string | undefined;
    storesIds?: string[] | undefined;
    status?: string | undefined;
    isPublished?: boolean | undefined;
    outerIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ISearchProductsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            if (Array.isArray(_data["publishedProductsIds"])) {
                this.publishedProductsIds = [] as any;
                for (let item of _data["publishedProductsIds"])
                    this.publishedProductsIds!.push(item);
            }
            this.searchFromAllSellers = _data["searchFromAllSellers"];
            this.gtin = _data["gtin"];
            this.categoryId = _data["categoryId"];
            if (Array.isArray(_data["storesIds"])) {
                this.storesIds = [] as any;
                for (let item of _data["storesIds"])
                    this.storesIds!.push(item);
            }
            this.status = _data["status"];
            this.isPublished = _data["isPublished"];
            if (Array.isArray(_data["outerIds"])) {
                this.outerIds = [] as any;
                for (let item of _data["outerIds"])
                    this.outerIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): SearchProductsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchProductsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        if (Array.isArray(this.publishedProductsIds)) {
            data["publishedProductsIds"] = [];
            for (let item of this.publishedProductsIds)
                data["publishedProductsIds"].push(item);
        }
        data["searchFromAllSellers"] = this.searchFromAllSellers;
        data["gtin"] = this.gtin;
        data["categoryId"] = this.categoryId;
        if (Array.isArray(this.storesIds)) {
            data["storesIds"] = [];
            for (let item of this.storesIds)
                data["storesIds"].push(item);
        }
        data["status"] = this.status;
        data["isPublished"] = this.isPublished;
        if (Array.isArray(this.outerIds)) {
            data["outerIds"] = [];
            for (let item of this.outerIds)
                data["outerIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ISearchProductsQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    publishedProductsIds?: string[] | undefined;
    searchFromAllSellers?: boolean;
    gtin?: string | undefined;
    categoryId?: string | undefined;
    storesIds?: string[] | undefined;
    status?: string | undefined;
    isPublished?: boolean | undefined;
    outerIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export enum PublicationRequestStatus {
    None = "None",
    WaitForApproval = "WaitForApproval",
    RequestChanges = "RequestChanges",
    Rejected = "Rejected",
    Approved = "Approved",
}

export class ChangeRequestStatusCommand implements IChangeRequestStatusCommand {
    operatorId!: string;
    operatorName!: string;
    requestId?: string | undefined;
    sellerProductId?: string | undefined;
    comment?: string | undefined;
    newStatus!: PublicationRequestStatus;

    constructor(data?: IChangeRequestStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operatorId = _data["operatorId"];
            this.operatorName = _data["operatorName"];
            this.requestId = _data["requestId"];
            this.sellerProductId = _data["sellerProductId"];
            this.comment = _data["comment"];
            this.newStatus = _data["newStatus"];
        }
    }

    static fromJS(data: any): ChangeRequestStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeRequestStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operatorId"] = this.operatorId;
        data["operatorName"] = this.operatorName;
        data["requestId"] = this.requestId;
        data["sellerProductId"] = this.sellerProductId;
        data["comment"] = this.comment;
        data["newStatus"] = this.newStatus;
        return data;
    }
}

export interface IChangeRequestStatusCommand {
    operatorId: string;
    operatorName: string;
    requestId?: string | undefined;
    sellerProductId?: string | undefined;
    comment?: string | undefined;
    newStatus: PublicationRequestStatus;
}

export class SearchCategoriesQuery implements ISearchCategoriesQuery {
    storeId?: string | undefined;
    sellerName?: string | undefined;
    sellerId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ISearchCategoriesQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.sellerName = _data["sellerName"];
            this.sellerId = _data["sellerId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): SearchCategoriesQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchCategoriesQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["sellerName"] = this.sellerName;
        data["sellerId"] = this.sellerId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ISearchCategoriesQuery {
    storeId?: string | undefined;
    sellerName?: string | undefined;
    sellerId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class CategorySearchResult implements ICategorySearchResult {
    totalCount?: number;
    results?: Category[] | undefined;

    constructor(data?: ICategorySearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Category.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategorySearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategorySearchResult {
    totalCount?: number;
    results?: Category[] | undefined;
}

export enum SellerProductStatus {
    None = "None",
    Published = "Published",
    HasStagedChanges = "HasStagedChanges",
    WaitForApproval = "WaitForApproval",
    RequiresChanges = "RequiresChanges",
    Rejected = "Rejected",
    Approved = "Approved",
}

export class ProductPublicationRequest implements IProductPublicationRequest {
    storeId?: string | undefined;
    storeName?: string | undefined;
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    operatorId?: string | undefined;
    operatorName?: string | undefined;
    sellerProductId?: string | undefined;
    sellerProduct?: SellerProduct;
    comment?: string | undefined;
    prevStatus?: PublicationRequestStatus;
    status?: PublicationRequestStatus;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IProductPublicationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.operatorId = _data["operatorId"];
            this.operatorName = _data["operatorName"];
            this.sellerProductId = _data["sellerProductId"];
            this.sellerProduct = _data["sellerProduct"] ? SellerProduct.fromJS(_data["sellerProduct"]) : <any>undefined;
            this.comment = _data["comment"];
            this.prevStatus = _data["prevStatus"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductPublicationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPublicationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["operatorId"] = this.operatorId;
        data["operatorName"] = this.operatorName;
        data["sellerProductId"] = this.sellerProductId;
        data["sellerProduct"] = this.sellerProduct ? this.sellerProduct.toJSON() : <any>undefined;
        data["comment"] = this.comment;
        data["prevStatus"] = this.prevStatus;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IProductPublicationRequest {
    storeId?: string | undefined;
    storeName?: string | undefined;
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    operatorId?: string | undefined;
    operatorName?: string | undefined;
    sellerProductId?: string | undefined;
    sellerProduct?: SellerProduct;
    comment?: string | undefined;
    prevStatus?: PublicationRequestStatus;
    status?: PublicationRequestStatus;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class SellerProduct implements ISellerProduct {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    name?: string | undefined;
    imgSrc?: string | undefined;
    gtin?: string | undefined;
    categoryId?: string | undefined;
    path?: string | undefined;
    readonly outline?: string | undefined;
    readonly description?: string | undefined;
    hasStagedChanges?: boolean;
    isPublished?: boolean;
    status?: SellerProductStatus;
    canBeModified?: boolean;
    publicationRequests?: ProductPublicationRequest[] | undefined;
    outerId?: string | undefined;
    productData?: CatalogProduct;
    publishedProductDataId?: string | undefined;
    stagedProductDataId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ISellerProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.name = _data["name"];
            this.imgSrc = _data["imgSrc"];
            this.gtin = _data["gtin"];
            this.categoryId = _data["categoryId"];
            this.path = _data["path"];
            (<any>this).outline = _data["outline"];
            (<any>this).description = _data["description"];
            this.hasStagedChanges = _data["hasStagedChanges"];
            this.isPublished = _data["isPublished"];
            this.status = _data["status"];
            this.canBeModified = _data["canBeModified"];
            if (Array.isArray(_data["publicationRequests"])) {
                this.publicationRequests = [] as any;
                for (let item of _data["publicationRequests"])
                    this.publicationRequests!.push(ProductPublicationRequest.fromJS(item));
            }
            this.outerId = _data["outerId"];
            this.productData = _data["productData"] ? CatalogProduct.fromJS(_data["productData"]) : <any>undefined;
            this.publishedProductDataId = _data["publishedProductDataId"];
            this.stagedProductDataId = _data["stagedProductDataId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SellerProduct {
        data = typeof data === 'object' ? data : {};
        let result = new SellerProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["name"] = this.name;
        data["imgSrc"] = this.imgSrc;
        data["gtin"] = this.gtin;
        data["categoryId"] = this.categoryId;
        data["path"] = this.path;
        data["outline"] = this.outline;
        data["description"] = this.description;
        data["hasStagedChanges"] = this.hasStagedChanges;
        data["isPublished"] = this.isPublished;
        data["status"] = this.status;
        data["canBeModified"] = this.canBeModified;
        if (Array.isArray(this.publicationRequests)) {
            data["publicationRequests"] = [];
            for (let item of this.publicationRequests)
                data["publicationRequests"].push(item.toJSON());
        }
        data["outerId"] = this.outerId;
        data["productData"] = this.productData ? this.productData.toJSON() : <any>undefined;
        data["publishedProductDataId"] = this.publishedProductDataId;
        data["stagedProductDataId"] = this.stagedProductDataId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ISellerProduct {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    name?: string | undefined;
    imgSrc?: string | undefined;
    gtin?: string | undefined;
    categoryId?: string | undefined;
    path?: string | undefined;
    outline?: string | undefined;
    description?: string | undefined;
    hasStagedChanges?: boolean;
    isPublished?: boolean;
    status?: SellerProductStatus;
    canBeModified?: boolean;
    publicationRequests?: ProductPublicationRequest[] | undefined;
    outerId?: string | undefined;
    productData?: CatalogProduct;
    publishedProductDataId?: string | undefined;
    stagedProductDataId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ValidateProductQuery implements IValidateProductQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    sellerProduct?: SellerProduct;

    constructor(data?: IValidateProductQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.sellerProduct = _data["sellerProduct"] ? SellerProduct.fromJS(_data["sellerProduct"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ValidateProductQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateProductQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["sellerProduct"] = this.sellerProduct ? this.sellerProduct.toJSON() : <any>undefined;
        return data;
    }
}

export interface IValidateProductQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    sellerProduct?: SellerProduct;
}

export class CategorySearchCriteria implements ICategorySearchCriteria {
    code?: string | undefined;
    catalogId?: string | undefined;
    catalogIds?: string[] | undefined;
    categoryId?: string | undefined;
    searchOnlyInRoot?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ICategorySearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.catalogId = _data["catalogId"];
            if (Array.isArray(_data["catalogIds"])) {
                this.catalogIds = [] as any;
                for (let item of _data["catalogIds"])
                    this.catalogIds!.push(item);
            }
            this.categoryId = _data["categoryId"];
            this.searchOnlyInRoot = _data["searchOnlyInRoot"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): CategorySearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["catalogId"] = this.catalogId;
        if (Array.isArray(this.catalogIds)) {
            data["catalogIds"] = [];
            for (let item of this.catalogIds)
                data["catalogIds"].push(item);
        }
        data["categoryId"] = this.categoryId;
        data["searchOnlyInRoot"] = this.searchOnlyInRoot;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ICategorySearchCriteria {
    code?: string | undefined;
    catalogId?: string | undefined;
    catalogIds?: string[] | undefined;
    categoryId?: string | undefined;
    searchOnlyInRoot?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class CreateSellerCategoriesCommand implements ICreateSellerCategoriesCommand {
    sellerId?: string | undefined;
    categoryIds?: string[] | undefined;
    searchCriteria?: CategorySearchCriteria;

    constructor(data?: ICreateSellerCategoriesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            this.searchCriteria = _data["searchCriteria"] ? CategorySearchCriteria.fromJS(_data["searchCriteria"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateSellerCategoriesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSellerCategoriesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        data["searchCriteria"] = this.searchCriteria ? this.searchCriteria.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateSellerCategoriesCommand {
    sellerId?: string | undefined;
    categoryIds?: string[] | undefined;
    searchCriteria?: CategorySearchCriteria;
}

export class DeleteSellerCategoriesCommand implements IDeleteSellerCategoriesCommand {
    sellerId?: string | undefined;
    categoryIds?: string[] | undefined;

    constructor(data?: IDeleteSellerCategoriesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
        }
    }

    static fromJS(data: any): DeleteSellerCategoriesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteSellerCategoriesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        return data;
    }
}

export interface IDeleteSellerCategoriesCommand {
    sellerId?: string | undefined;
    categoryIds?: string[] | undefined;
}

export class RunCategoriesExportCommand implements IRunCategoriesExportCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    exportTypeName?: string | undefined;
    dataQuery?: ExportDataQuery;
    providerConfig?: IExportProviderConfiguration;
    providerName?: string | undefined;

    constructor(data?: IRunCategoriesExportCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.exportTypeName = _data["exportTypeName"];
            this.dataQuery = _data["dataQuery"] ? ExportDataQuery.fromJS(_data["dataQuery"]) : <any>undefined;
            this.providerConfig = _data["providerConfig"] ? IExportProviderConfiguration.fromJS(_data["providerConfig"]) : <any>undefined;
            this.providerName = _data["providerName"];
        }
    }

    static fromJS(data: any): RunCategoriesExportCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RunCategoriesExportCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["exportTypeName"] = this.exportTypeName;
        data["dataQuery"] = this.dataQuery ? this.dataQuery.toJSON() : <any>undefined;
        data["providerConfig"] = this.providerConfig ? this.providerConfig.toJSON() : <any>undefined;
        data["providerName"] = this.providerName;
        return data;
    }
}

export interface IRunCategoriesExportCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    exportTypeName?: string | undefined;
    dataQuery?: ExportDataQuery;
    providerConfig?: IExportProviderConfiguration;
    providerName?: string | undefined;
}

export class SearchProductsResult implements ISearchProductsResult {
    totalCount?: number;
    results?: SellerProduct[] | undefined;

    constructor(data?: ISearchProductsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(SellerProduct.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchProductsResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchProductsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISearchProductsResult {
    totalCount?: number;
    results?: SellerProduct[] | undefined;
}

export class ProductDetails implements IProductDetails {
    name?: string | undefined;
    description?: string | undefined;
    gtin?: string | undefined;
    categoryId?: string | undefined;
    outerId?: string | undefined;
    properties?: Property[] | undefined;
    images?: Image[] | undefined;

    constructor(data?: IProductDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.gtin = _data["gtin"];
            this.categoryId = _data["categoryId"];
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(Property.fromJS(item));
            }
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(Image.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["gtin"] = this.gtin;
        data["categoryId"] = this.categoryId;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductDetails {
    name?: string | undefined;
    description?: string | undefined;
    gtin?: string | undefined;
    categoryId?: string | undefined;
    outerId?: string | undefined;
    properties?: Property[] | undefined;
    images?: Image[] | undefined;
}

export class CreateNewProductCommand implements ICreateNewProductCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    productDetails?: ProductDetails;

    constructor(data?: ICreateNewProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.productDetails = _data["productDetails"] ? ProductDetails.fromJS(_data["productDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateNewProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNewProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["productDetails"] = this.productDetails ? this.productDetails.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateNewProductCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    productDetails?: ProductDetails;
}

export class UpdateProductDetailsCommand implements IUpdateProductDetailsCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    sellerProductId?: string | undefined;
    productDetails?: ProductDetails;

    constructor(data?: IUpdateProductDetailsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.sellerProductId = _data["sellerProductId"];
            this.productDetails = _data["productDetails"] ? ProductDetails.fromJS(_data["productDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateProductDetailsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductDetailsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["sellerProductId"] = this.sellerProductId;
        data["productDetails"] = this.productDetails ? this.productDetails.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateProductDetailsCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    sellerProductId?: string | undefined;
    productDetails?: ProductDetails;
}

export class CreateNewPublicationRequestCommand implements ICreateNewPublicationRequestCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    storeId?: string | undefined;
    productId!: string;
    comment?: string | undefined;

    constructor(data?: ICreateNewPublicationRequestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.storeId = _data["storeId"];
            this.productId = _data["productId"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): CreateNewPublicationRequestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNewPublicationRequestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["storeId"] = this.storeId;
        data["productId"] = this.productId;
        data["comment"] = this.comment;
        return data;
    }
}

export interface ICreateNewPublicationRequestCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    storeId?: string | undefined;
    productId: string;
    comment?: string | undefined;
}

export class SearchOffersQuery implements ISearchOffersQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    sellerProductId?: string | undefined;
    outerIds?: string[] | undefined;
    productId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ISearchOffersQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.sellerProductId = _data["sellerProductId"];
            if (Array.isArray(_data["outerIds"])) {
                this.outerIds = [] as any;
                for (let item of _data["outerIds"])
                    this.outerIds!.push(item);
            }
            this.productId = _data["productId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): SearchOffersQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchOffersQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["sellerProductId"] = this.sellerProductId;
        if (Array.isArray(this.outerIds)) {
            data["outerIds"] = [];
            for (let item of this.outerIds)
                data["outerIds"].push(item);
        }
        data["productId"] = this.productId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ISearchOffersQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    sellerProductId?: string | undefined;
    outerIds?: string[] | undefined;
    productId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class OfferPrice implements IOfferPrice {
    listPrice!: number;
    salePrice?: number | undefined;
    minQuantity?: number;
    id?: string | undefined;

    constructor(data?: IOfferPrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.listPrice = _data["listPrice"];
            this.salePrice = _data["salePrice"];
            this.minQuantity = _data["minQuantity"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OfferPrice {
        data = typeof data === 'object' ? data : {};
        let result = new OfferPrice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listPrice"] = this.listPrice;
        data["salePrice"] = this.salePrice;
        data["minQuantity"] = this.minQuantity;
        data["id"] = this.id;
        return data;
    }
}

export interface IOfferPrice {
    listPrice: number;
    salePrice?: number | undefined;
    minQuantity?: number;
    id?: string | undefined;
}

export class Offer implements IOffer {
    isActive?: boolean;
    outerId?: string | undefined;
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    storeId?: string | undefined;
    storeName?: string | undefined;
    name?: string | undefined;
    sku?: string | undefined;
    imgSrc?: string | undefined;
    categoryId?: string | undefined;
    path?: string | undefined;
    currency?: string | undefined;
    readonly listPrice?: number | undefined;
    readonly salePrice?: number | undefined;
    readonly minQuantity?: number | undefined;
    prices?: OfferPrice[] | undefined;
    inStockQuantity?: number;
    trackInventory?: boolean;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    estimatedDeliveryDate?: string | undefined;
    productId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IOffer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isActive = _data["isActive"];
            this.outerId = _data["outerId"];
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.name = _data["name"];
            this.sku = _data["sku"];
            this.imgSrc = _data["imgSrc"];
            this.categoryId = _data["categoryId"];
            this.path = _data["path"];
            this.currency = _data["currency"];
            (<any>this).listPrice = _data["listPrice"];
            (<any>this).salePrice = _data["salePrice"];
            (<any>this).minQuantity = _data["minQuantity"];
            if (Array.isArray(_data["prices"])) {
                this.prices = [] as any;
                for (let item of _data["prices"])
                    this.prices!.push(OfferPrice.fromJS(item));
            }
            this.inStockQuantity = _data["inStockQuantity"];
            this.trackInventory = _data["trackInventory"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.estimatedDeliveryDate = _data["estimatedDeliveryDate"];
            this.productId = _data["productId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Offer {
        data = typeof data === 'object' ? data : {};
        let result = new Offer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isActive"] = this.isActive;
        data["outerId"] = this.outerId;
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["name"] = this.name;
        data["sku"] = this.sku;
        data["imgSrc"] = this.imgSrc;
        data["categoryId"] = this.categoryId;
        data["path"] = this.path;
        data["currency"] = this.currency;
        data["listPrice"] = this.listPrice;
        data["salePrice"] = this.salePrice;
        data["minQuantity"] = this.minQuantity;
        if (Array.isArray(this.prices)) {
            data["prices"] = [];
            for (let item of this.prices)
                data["prices"].push(item.toJSON());
        }
        data["inStockQuantity"] = this.inStockQuantity;
        data["trackInventory"] = this.trackInventory;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["estimatedDeliveryDate"] = this.estimatedDeliveryDate;
        data["productId"] = this.productId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IOffer {
    isActive?: boolean;
    outerId?: string | undefined;
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    storeId?: string | undefined;
    storeName?: string | undefined;
    name?: string | undefined;
    sku?: string | undefined;
    imgSrc?: string | undefined;
    categoryId?: string | undefined;
    path?: string | undefined;
    currency?: string | undefined;
    listPrice?: number | undefined;
    salePrice?: number | undefined;
    minQuantity?: number | undefined;
    prices?: OfferPrice[] | undefined;
    inStockQuantity?: number;
    trackInventory?: boolean;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    estimatedDeliveryDate?: string | undefined;
    productId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class SearchOffersResult implements ISearchOffersResult {
    totalCount?: number;
    results?: Offer[] | undefined;

    constructor(data?: ISearchOffersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Offer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchOffersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchOffersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISearchOffersResult {
    totalCount?: number;
    results?: Offer[] | undefined;
}

export class SearchProductsForNewOfferQuery implements ISearchProductsForNewOfferQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ISearchProductsForNewOfferQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): SearchProductsForNewOfferQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchProductsForNewOfferQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ISearchProductsForNewOfferQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class OfferProduct implements IOfferProduct {
    name?: string | undefined;
    sellerProductId?: string | undefined;
    sku?: string | undefined;
    imgSrc?: string | undefined;
    categoryId?: string | undefined;
    path?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IOfferProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.sellerProductId = _data["sellerProductId"];
            this.sku = _data["sku"];
            this.imgSrc = _data["imgSrc"];
            this.categoryId = _data["categoryId"];
            this.path = _data["path"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OfferProduct {
        data = typeof data === 'object' ? data : {};
        let result = new OfferProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["sellerProductId"] = this.sellerProductId;
        data["sku"] = this.sku;
        data["imgSrc"] = this.imgSrc;
        data["categoryId"] = this.categoryId;
        data["path"] = this.path;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IOfferProduct {
    name?: string | undefined;
    sellerProductId?: string | undefined;
    sku?: string | undefined;
    imgSrc?: string | undefined;
    categoryId?: string | undefined;
    path?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class SearchOfferProductsResult implements ISearchOfferProductsResult {
    totalCount?: number;
    results?: OfferProduct[] | undefined;

    constructor(data?: ISearchOfferProductsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(OfferProduct.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchOfferProductsResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchOfferProductsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISearchOfferProductsResult {
    totalCount?: number;
    results?: OfferProduct[] | undefined;
}

export class OfferDetails implements IOfferDetails {
    productId?: string | undefined;
    isActive?: boolean;
    outerId?: string | undefined;
    name?: string | undefined;
    sku!: string;
    currency!: string;
    prices?: OfferPrice[] | undefined;
    inStockQuantity?: number;
    trackInventory?: boolean;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    estimatedDeliveryDate?: string | undefined;

    constructor(data?: IOfferDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.isActive = _data["isActive"];
            this.outerId = _data["outerId"];
            this.name = _data["name"];
            this.sku = _data["sku"];
            this.currency = _data["currency"];
            if (Array.isArray(_data["prices"])) {
                this.prices = [] as any;
                for (let item of _data["prices"])
                    this.prices!.push(OfferPrice.fromJS(item));
            }
            this.inStockQuantity = _data["inStockQuantity"];
            this.trackInventory = _data["trackInventory"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.estimatedDeliveryDate = _data["estimatedDeliveryDate"];
        }
    }

    static fromJS(data: any): OfferDetails {
        data = typeof data === 'object' ? data : {};
        let result = new OfferDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["isActive"] = this.isActive;
        data["outerId"] = this.outerId;
        data["name"] = this.name;
        data["sku"] = this.sku;
        data["currency"] = this.currency;
        if (Array.isArray(this.prices)) {
            data["prices"] = [];
            for (let item of this.prices)
                data["prices"].push(item.toJSON());
        }
        data["inStockQuantity"] = this.inStockQuantity;
        data["trackInventory"] = this.trackInventory;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["estimatedDeliveryDate"] = this.estimatedDeliveryDate;
        return data;
    }
}

export interface IOfferDetails {
    productId?: string | undefined;
    isActive?: boolean;
    outerId?: string | undefined;
    name?: string | undefined;
    sku: string;
    currency: string;
    prices?: OfferPrice[] | undefined;
    inStockQuantity?: number;
    trackInventory?: boolean;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    estimatedDeliveryDate?: string | undefined;
}

export class CreateNewOfferCommand implements ICreateNewOfferCommand {
    outerId?: string | undefined;
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    storeId?: string | undefined;
    storeName?: string | undefined;
    details!: OfferDetails;
    productId!: string;

    constructor(data?: ICreateNewOfferCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.details = new OfferDetails();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.outerId = _data["outerId"];
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.details = _data["details"] ? OfferDetails.fromJS(_data["details"]) : new OfferDetails();
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): CreateNewOfferCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNewOfferCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outerId"] = this.outerId;
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["productId"] = this.productId;
        return data;
    }
}

export interface ICreateNewOfferCommand {
    outerId?: string | undefined;
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    storeId?: string | undefined;
    storeName?: string | undefined;
    details: OfferDetails;
    productId: string;
}

export class ImportProfile implements IImportProfile {
    name?: string | undefined;
    dataImporterType?: string | undefined;
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    readonly typeName?: string | undefined;
    importFileUrl?: string | undefined;
    previewObjectCount?: number;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IImportProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.dataImporterType = _data["dataImporterType"];
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings!.push(ObjectSettingEntry.fromJS(item));
            }
            (<any>this).typeName = _data["typeName"];
            this.importFileUrl = _data["importFileUrl"];
            this.previewObjectCount = _data["previewObjectCount"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ImportProfile {
        data = typeof data === 'object' ? data : {};
        let result = new ImportProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["dataImporterType"] = this.dataImporterType;
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["typeName"] = this.typeName;
        data["importFileUrl"] = this.importFileUrl;
        data["previewObjectCount"] = this.previewObjectCount;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IImportProfile {
    name?: string | undefined;
    dataImporterType?: string | undefined;
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    typeName?: string | undefined;
    importFileUrl?: string | undefined;
    previewObjectCount?: number;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class RunImportCommand implements IRunImportCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    importProfile?: ImportProfile;

    constructor(data?: IRunImportCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.importProfile = _data["importProfile"] ? ImportProfile.fromJS(_data["importProfile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RunImportCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RunImportCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["importProfile"] = this.importProfile ? this.importProfile.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRunImportCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    importProfile?: ImportProfile;
}

export class ImportPushNotification implements IImportPushNotification {
    profileId?: string | undefined;
    profileName?: string | undefined;
    jobId?: string | undefined;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    readonly errorCount?: number;
    errors?: string[] | undefined;
    reportUrl?: string | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IImportPushNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profileId = _data["profileId"];
            this.profileName = _data["profileName"];
            this.jobId = _data["jobId"];
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.processedCount = _data["processedCount"];
            (<any>this).errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.reportUrl = _data["reportUrl"];
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ImportPushNotification {
        data = typeof data === 'object' ? data : {};
        let result = new ImportPushNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profileId"] = this.profileId;
        data["profileName"] = this.profileName;
        data["jobId"] = this.jobId;
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["processedCount"] = this.processedCount;
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["reportUrl"] = this.reportUrl;
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data;
    }
}

export interface IImportPushNotification {
    profileId?: string | undefined;
    profileName?: string | undefined;
    jobId?: string | undefined;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    reportUrl?: string | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export class ImportCancellationRequest implements IImportCancellationRequest {
    jobId?: string | undefined;

    constructor(data?: IImportCancellationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
        }
    }

    static fromJS(data: any): ImportCancellationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ImportCancellationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        return data;
    }
}

export interface IImportCancellationRequest {
    jobId?: string | undefined;
}

export class PreviewDataQuery implements IPreviewDataQuery {
    importProfile?: ImportProfile;

    constructor(data?: IPreviewDataQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.importProfile = _data["importProfile"] ? ImportProfile.fromJS(_data["importProfile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PreviewDataQuery {
        data = typeof data === 'object' ? data : {};
        let result = new PreviewDataQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["importProfile"] = this.importProfile ? this.importProfile.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPreviewDataQuery {
    importProfile?: ImportProfile;
}

export class ImportDataPreview implements IImportDataPreview {
    totalCount?: number;
    fileName?: string | undefined;
    records?: any[] | undefined;

    constructor(data?: IImportDataPreview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.fileName = _data["fileName"];
            if (Array.isArray(_data["records"])) {
                this.records = [] as any;
                for (let item of _data["records"])
                    this.records!.push(item);
            }
        }
    }

    static fromJS(data: any): ImportDataPreview {
        data = typeof data === 'object' ? data : {};
        let result = new ImportDataPreview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["fileName"] = this.fileName;
        if (Array.isArray(this.records)) {
            data["records"] = [];
            for (let item of this.records)
                data["records"].push(item);
        }
        return data;
    }
}

export interface IImportDataPreview {
    totalCount?: number;
    fileName?: string | undefined;
    records?: any[] | undefined;
}

export class SettingDescriptor implements ISettingDescriptor {
    restartRequired?: boolean;
    moduleId?: string | undefined;
    groupName?: string | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    isRequired?: boolean;
    isHidden?: boolean;
    valueType?: SettingValueType;
    allowedValues?: any[] | undefined;
    defaultValue?: any | undefined;
    isDictionary?: boolean;

    constructor(data?: ISettingDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.restartRequired = _data["restartRequired"];
            this.moduleId = _data["moduleId"];
            this.groupName = _data["groupName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isRequired = _data["isRequired"];
            this.isHidden = _data["isHidden"];
            this.valueType = _data["valueType"];
            if (Array.isArray(_data["allowedValues"])) {
                this.allowedValues = [] as any;
                for (let item of _data["allowedValues"])
                    this.allowedValues!.push(item);
            }
            this.defaultValue = _data["defaultValue"];
            this.isDictionary = _data["isDictionary"];
        }
    }

    static fromJS(data: any): SettingDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new SettingDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["restartRequired"] = this.restartRequired;
        data["moduleId"] = this.moduleId;
        data["groupName"] = this.groupName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isRequired"] = this.isRequired;
        data["isHidden"] = this.isHidden;
        data["valueType"] = this.valueType;
        if (Array.isArray(this.allowedValues)) {
            data["allowedValues"] = [];
            for (let item of this.allowedValues)
                data["allowedValues"].push(item);
        }
        data["defaultValue"] = this.defaultValue;
        data["isDictionary"] = this.isDictionary;
        return data;
    }
}

export interface ISettingDescriptor {
    restartRequired?: boolean;
    moduleId?: string | undefined;
    groupName?: string | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    isRequired?: boolean;
    isHidden?: boolean;
    valueType?: SettingValueType;
    allowedValues?: any[] | undefined;
    defaultValue?: any | undefined;
    isDictionary?: boolean;
}

export class IDataImporter implements IIDataImporter {
    readonly typeName?: string | undefined;
    readonly metadata?: { [key: string]: string; } | undefined;
    availSettings?: SettingDescriptor[] | undefined;

    constructor(data?: IIDataImporter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).typeName = _data["typeName"];
            if (_data["metadata"]) {
                (<any>this).metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>(<any>this).metadata)![key] = _data["metadata"][key];
                }
            }
            if (Array.isArray(_data["availSettings"])) {
                this.availSettings = [] as any;
                for (let item of _data["availSettings"])
                    this.availSettings!.push(SettingDescriptor.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IDataImporter {
        data = typeof data === 'object' ? data : {};
        let result = new IDataImporter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        if (Array.isArray(this.availSettings)) {
            data["availSettings"] = [];
            for (let item of this.availSettings)
                data["availSettings"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIDataImporter {
    typeName?: string | undefined;
    metadata?: { [key: string]: string; } | undefined;
    availSettings?: SettingDescriptor[] | undefined;
}

export class CreateProfileCommand implements ICreateProfileCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    importProfile?: ImportProfile;

    constructor(data?: ICreateProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.importProfile = _data["importProfile"] ? ImportProfile.fromJS(_data["importProfile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["importProfile"] = this.importProfile ? this.importProfile.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateProfileCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    importProfile?: ImportProfile;
}

export class UpdateProfileCommand implements IUpdateProfileCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    importProfileId!: string;
    importProfile?: ImportProfile;

    constructor(data?: IUpdateProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.importProfileId = _data["importProfileId"];
            this.importProfile = _data["importProfile"] ? ImportProfile.fromJS(_data["importProfile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["importProfileId"] = this.importProfileId;
        data["importProfile"] = this.importProfile ? this.importProfile.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateProfileCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    importProfileId: string;
    importProfile?: ImportProfile;
}

export class SearchImportProfilesQuery implements ISearchImportProfilesQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    name?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ISearchImportProfilesQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.name = _data["name"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): SearchImportProfilesQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchImportProfilesQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["name"] = this.name;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ISearchImportProfilesQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    name?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class SearchImportProfilesResult implements ISearchImportProfilesResult {
    totalCount?: number;
    results?: ImportProfile[] | undefined;

    constructor(data?: ISearchImportProfilesResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ImportProfile.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchImportProfilesResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchImportProfilesResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISearchImportProfilesResult {
    totalCount?: number;
    results?: ImportProfile[] | undefined;
}

export class SearchImportProfilesHistoryQuery implements ISearchImportProfilesHistoryQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    profileId?: string | undefined;
    jobId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ISearchImportProfilesHistoryQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.profileId = _data["profileId"];
            this.jobId = _data["jobId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): SearchImportProfilesHistoryQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchImportProfilesHistoryQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["profileId"] = this.profileId;
        data["jobId"] = this.jobId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ISearchImportProfilesHistoryQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    profileId?: string | undefined;
    jobId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class ImportRunHistory implements IImportRunHistory {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    jobId?: string | undefined;
    profileId?: string | undefined;
    profileName?: string | undefined;
    executed?: Date;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorsCount?: number;
    errors?: string[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IImportRunHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.jobId = _data["jobId"];
            this.profileId = _data["profileId"];
            this.profileName = _data["profileName"];
            this.executed = _data["executed"] ? new Date(_data["executed"].toString()) : <any>undefined;
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.processedCount = _data["processedCount"];
            this.errorsCount = _data["errorsCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ImportRunHistory {
        data = typeof data === 'object' ? data : {};
        let result = new ImportRunHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["jobId"] = this.jobId;
        data["profileId"] = this.profileId;
        data["profileName"] = this.profileName;
        data["executed"] = this.executed ? this.executed.toISOString() : <any>undefined;
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["processedCount"] = this.processedCount;
        data["errorsCount"] = this.errorsCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IImportRunHistory {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    jobId?: string | undefined;
    profileId?: string | undefined;
    profileName?: string | undefined;
    executed?: Date;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorsCount?: number;
    errors?: string[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class SearchImportProfilesHistoryResult implements ISearchImportProfilesHistoryResult {
    totalCount?: number;
    results?: ImportRunHistory[] | undefined;

    constructor(data?: ISearchImportProfilesHistoryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ImportRunHistory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchImportProfilesHistoryResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchImportProfilesHistoryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISearchImportProfilesHistoryResult {
    totalCount?: number;
    results?: ImportRunHistory[] | undefined;
}

export class SearchOrdersQuery implements ISearchOrdersQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    withPrototypes?: boolean;
    onlyRecurring?: boolean;
    subscriptionId?: string | undefined;
    subscriptionIds?: string[] | undefined;
    operationId?: string | undefined;
    customerId?: string | undefined;
    customerIds?: string[] | undefined;
    ids?: string[] | undefined;
    hasParentOperation?: boolean | undefined;
    parentOperationId?: string | undefined;
    employeeId?: string | undefined;
    storeIds?: string[] | undefined;
    status?: string | undefined;
    statuses?: string[] | undefined;
    number?: string | undefined;
    numbers?: string[] | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ISearchOrdersQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.withPrototypes = _data["withPrototypes"];
            this.onlyRecurring = _data["onlyRecurring"];
            this.subscriptionId = _data["subscriptionId"];
            if (Array.isArray(_data["subscriptionIds"])) {
                this.subscriptionIds = [] as any;
                for (let item of _data["subscriptionIds"])
                    this.subscriptionIds!.push(item);
            }
            this.operationId = _data["operationId"];
            this.customerId = _data["customerId"];
            if (Array.isArray(_data["customerIds"])) {
                this.customerIds = [] as any;
                for (let item of _data["customerIds"])
                    this.customerIds!.push(item);
            }
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.hasParentOperation = _data["hasParentOperation"];
            this.parentOperationId = _data["parentOperationId"];
            this.employeeId = _data["employeeId"];
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.status = _data["status"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(item);
            }
            this.number = _data["number"];
            if (Array.isArray(_data["numbers"])) {
                this.numbers = [] as any;
                for (let item of _data["numbers"])
                    this.numbers!.push(item);
            }
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): SearchOrdersQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchOrdersQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["withPrototypes"] = this.withPrototypes;
        data["onlyRecurring"] = this.onlyRecurring;
        data["subscriptionId"] = this.subscriptionId;
        if (Array.isArray(this.subscriptionIds)) {
            data["subscriptionIds"] = [];
            for (let item of this.subscriptionIds)
                data["subscriptionIds"].push(item);
        }
        data["operationId"] = this.operationId;
        data["customerId"] = this.customerId;
        if (Array.isArray(this.customerIds)) {
            data["customerIds"] = [];
            for (let item of this.customerIds)
                data["customerIds"].push(item);
        }
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["hasParentOperation"] = this.hasParentOperation;
        data["parentOperationId"] = this.parentOperationId;
        data["employeeId"] = this.employeeId;
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["status"] = this.status;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item);
        }
        data["number"] = this.number;
        if (Array.isArray(this.numbers)) {
            data["numbers"] = [];
            for (let item of this.numbers)
                data["numbers"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ISearchOrdersQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    withPrototypes?: boolean;
    onlyRecurring?: boolean;
    subscriptionId?: string | undefined;
    subscriptionIds?: string[] | undefined;
    operationId?: string | undefined;
    customerId?: string | undefined;
    customerIds?: string[] | undefined;
    ids?: string[] | undefined;
    hasParentOperation?: boolean | undefined;
    parentOperationId?: string | undefined;
    employeeId?: string | undefined;
    storeIds?: string[] | undefined;
    status?: string | undefined;
    statuses?: string[] | undefined;
    number?: string | undefined;
    numbers?: string[] | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class OrderAddress implements IOrderAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    outerId?: string | undefined;
    isDefault?: boolean;

    constructor(data?: IOrderAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressType = _data["addressType"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.organization = _data["organization"];
            this.countryCode = _data["countryCode"];
            this.countryName = _data["countryName"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.zip = _data["zip"];
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.regionId = _data["regionId"];
            this.regionName = _data["regionName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.outerId = _data["outerId"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): OrderAddress {
        data = typeof data === 'object' ? data : {};
        let result = new OrderAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressType"] = this.addressType;
        data["key"] = this.key;
        data["name"] = this.name;
        data["organization"] = this.organization;
        data["countryCode"] = this.countryCode;
        data["countryName"] = this.countryName;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["zip"] = this.zip;
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["regionId"] = this.regionId;
        data["regionName"] = this.regionName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["outerId"] = this.outerId;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IOrderAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    outerId?: string | undefined;
    isDefault?: boolean;
}

export enum PaymentStatus {
    New = "New",
    Pending = "Pending",
    Authorized = "Authorized",
    Paid = "Paid",
    PartiallyRefunded = "PartiallyRefunded",
    Refunded = "Refunded",
    Voided = "Voided",
    Custom = "Custom",
    Cancelled = "Cancelled",
    Declined = "Declined",
    Error = "Error",
}

export class ProcessPaymentRequestResult implements IProcessPaymentRequestResult {
    redirectUrl?: string | undefined;
    htmlForm?: string | undefined;
    outerId?: string | undefined;
    paymentMethod?: PaymentMethod;
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    newPaymentStatus?: PaymentStatus;

    constructor(data?: IProcessPaymentRequestResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.redirectUrl = _data["redirectUrl"];
            this.htmlForm = _data["htmlForm"];
            this.outerId = _data["outerId"];
            this.paymentMethod = _data["paymentMethod"] ? PaymentMethod.fromJS(_data["paymentMethod"]) : <any>undefined;
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.newPaymentStatus = _data["newPaymentStatus"];
        }
    }

    static fromJS(data: any): ProcessPaymentRequestResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessPaymentRequestResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["redirectUrl"] = this.redirectUrl;
        data["htmlForm"] = this.htmlForm;
        data["outerId"] = this.outerId;
        data["paymentMethod"] = this.paymentMethod ? this.paymentMethod.toJSON() : <any>undefined;
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["newPaymentStatus"] = this.newPaymentStatus;
        return data;
    }
}

export interface IProcessPaymentRequestResult {
    redirectUrl?: string | undefined;
    htmlForm?: string | undefined;
    outerId?: string | undefined;
    paymentMethod?: PaymentMethod;
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    newPaymentStatus?: PaymentStatus;
}

export class PaymentGatewayTransaction implements IPaymentGatewayTransaction {
    amount?: number;
    currencyCode?: string | undefined;
    isProcessed?: boolean;
    processedDate?: Date | undefined;
    processError?: string | undefined;
    processAttemptCount?: number;
    requestData?: string | undefined;
    responseData?: string | undefined;
    responseCode?: string | undefined;
    gatewayIpAddress?: string | undefined;
    type?: string | undefined;
    status?: string | undefined;
    note?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPaymentGatewayTransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.currencyCode = _data["currencyCode"];
            this.isProcessed = _data["isProcessed"];
            this.processedDate = _data["processedDate"] ? new Date(_data["processedDate"].toString()) : <any>undefined;
            this.processError = _data["processError"];
            this.processAttemptCount = _data["processAttemptCount"];
            this.requestData = _data["requestData"];
            this.responseData = _data["responseData"];
            this.responseCode = _data["responseCode"];
            this.gatewayIpAddress = _data["gatewayIpAddress"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.note = _data["note"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PaymentGatewayTransaction {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGatewayTransaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["currencyCode"] = this.currencyCode;
        data["isProcessed"] = this.isProcessed;
        data["processedDate"] = this.processedDate ? this.processedDate.toISOString() : <any>undefined;
        data["processError"] = this.processError;
        data["processAttemptCount"] = this.processAttemptCount;
        data["requestData"] = this.requestData;
        data["responseData"] = this.responseData;
        data["responseCode"] = this.responseCode;
        data["gatewayIpAddress"] = this.gatewayIpAddress;
        data["type"] = this.type;
        data["status"] = this.status;
        data["note"] = this.note;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IPaymentGatewayTransaction {
    amount?: number;
    currencyCode?: string | undefined;
    isProcessed?: boolean;
    processedDate?: Date | undefined;
    processError?: string | undefined;
    processAttemptCount?: number;
    requestData?: string | undefined;
    responseData?: string | undefined;
    responseCode?: string | undefined;
    gatewayIpAddress?: string | undefined;
    type?: string | undefined;
    status?: string | undefined;
    note?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class IOperation implements IIOperation {
    operationType?: string | undefined;
    parentOperationId?: string | undefined;
    number?: string | undefined;
    isApproved?: boolean;
    status?: string | undefined;
    comment?: string | undefined;
    currency?: string | undefined;
    childrenOperations?: IOperation[] | undefined;
    id?: string | undefined;

    constructor(data?: IIOperation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationType = _data["operationType"];
            this.parentOperationId = _data["parentOperationId"];
            this.number = _data["number"];
            this.isApproved = _data["isApproved"];
            this.status = _data["status"];
            this.comment = _data["comment"];
            this.currency = _data["currency"];
            if (Array.isArray(_data["childrenOperations"])) {
                this.childrenOperations = [] as any;
                for (let item of _data["childrenOperations"])
                    this.childrenOperations!.push(IOperation.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IOperation {
        data = typeof data === 'object' ? data : {};
        let result = new IOperation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationType"] = this.operationType;
        data["parentOperationId"] = this.parentOperationId;
        data["number"] = this.number;
        data["isApproved"] = this.isApproved;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["currency"] = this.currency;
        if (Array.isArray(this.childrenOperations)) {
            data["childrenOperations"] = [];
            for (let item of this.childrenOperations)
                data["childrenOperations"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IIOperation {
    operationType?: string | undefined;
    parentOperationId?: string | undefined;
    number?: string | undefined;
    isApproved?: boolean;
    status?: string | undefined;
    comment?: string | undefined;
    currency?: string | undefined;
    childrenOperations?: IOperation[] | undefined;
    id?: string | undefined;
}

export enum CancelledState {
    Undefined = "Undefined",
    Requested = "Requested",
    Completed = "Completed",
}

export class PaymentIn implements IPaymentIn {
    orderId?: string | undefined;
    purpose?: string | undefined;
    gatewayCode?: string | undefined;
    paymentMethod?: PaymentMethod;
    organizationId?: string | undefined;
    organizationName?: string | undefined;
    customerId?: string | undefined;
    customerName?: string | undefined;
    incomingDate?: Date | undefined;
    billingAddress?: OrderAddress;
    paymentStatus?: PaymentStatus;
    authorizedDate?: Date | undefined;
    capturedDate?: Date | undefined;
    voidedDate?: Date | undefined;
    processPaymentResult?: ProcessPaymentRequestResult;
    price?: number;
    priceWithTax?: number;
    total?: number;
    totalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    objectType?: string | undefined;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    taxDetails?: TaxDetail[] | undefined;
    discounts?: Discount[] | undefined;
    transactions?: PaymentGatewayTransaction[] | undefined;
    operationType?: string | undefined;
    parentOperationId?: string | undefined;
    number?: string | undefined;
    isApproved?: boolean;
    status?: string | undefined;
    comment?: string | undefined;
    currency?: string | undefined;
    sum?: number;
    outerId?: string | undefined;
    cancelledState?: CancelledState;
    isCancelled?: boolean;
    cancelledDate?: Date | undefined;
    cancelReason?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    operationsLog?: OperationLog[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPaymentIn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.purpose = _data["purpose"];
            this.gatewayCode = _data["gatewayCode"];
            this.paymentMethod = _data["paymentMethod"] ? PaymentMethod.fromJS(_data["paymentMethod"]) : <any>undefined;
            this.organizationId = _data["organizationId"];
            this.organizationName = _data["organizationName"];
            this.customerId = _data["customerId"];
            this.customerName = _data["customerName"];
            this.incomingDate = _data["incomingDate"] ? new Date(_data["incomingDate"].toString()) : <any>undefined;
            this.billingAddress = _data["billingAddress"] ? OrderAddress.fromJS(_data["billingAddress"]) : <any>undefined;
            this.paymentStatus = _data["paymentStatus"];
            this.authorizedDate = _data["authorizedDate"] ? new Date(_data["authorizedDate"].toString()) : <any>undefined;
            this.capturedDate = _data["capturedDate"] ? new Date(_data["capturedDate"].toString()) : <any>undefined;
            this.voidedDate = _data["voidedDate"] ? new Date(_data["voidedDate"].toString()) : <any>undefined;
            this.processPaymentResult = _data["processPaymentResult"] ? ProcessPaymentRequestResult.fromJS(_data["processPaymentResult"]) : <any>undefined;
            this.price = _data["price"];
            this.priceWithTax = _data["priceWithTax"];
            this.total = _data["total"];
            this.totalWithTax = _data["totalWithTax"];
            this.discountAmount = _data["discountAmount"];
            this.discountAmountWithTax = _data["discountAmountWithTax"];
            this.objectType = _data["objectType"];
            this.taxType = _data["taxType"];
            this.taxTotal = _data["taxTotal"];
            this.taxPercentRate = _data["taxPercentRate"];
            if (Array.isArray(_data["taxDetails"])) {
                this.taxDetails = [] as any;
                for (let item of _data["taxDetails"])
                    this.taxDetails!.push(TaxDetail.fromJS(item));
            }
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(Discount.fromJS(item));
            }
            if (Array.isArray(_data["transactions"])) {
                this.transactions = [] as any;
                for (let item of _data["transactions"])
                    this.transactions!.push(PaymentGatewayTransaction.fromJS(item));
            }
            this.operationType = _data["operationType"];
            this.parentOperationId = _data["parentOperationId"];
            this.number = _data["number"];
            this.isApproved = _data["isApproved"];
            this.status = _data["status"];
            this.comment = _data["comment"];
            this.currency = _data["currency"];
            this.sum = _data["sum"];
            this.outerId = _data["outerId"];
            this.cancelledState = _data["cancelledState"];
            this.isCancelled = _data["isCancelled"];
            this.cancelledDate = _data["cancelledDate"] ? new Date(_data["cancelledDate"].toString()) : <any>undefined;
            this.cancelReason = _data["cancelReason"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            if (Array.isArray(_data["operationsLog"])) {
                this.operationsLog = [] as any;
                for (let item of _data["operationsLog"])
                    this.operationsLog!.push(OperationLog.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PaymentIn {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["purpose"] = this.purpose;
        data["gatewayCode"] = this.gatewayCode;
        data["paymentMethod"] = this.paymentMethod ? this.paymentMethod.toJSON() : <any>undefined;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["customerId"] = this.customerId;
        data["customerName"] = this.customerName;
        data["incomingDate"] = this.incomingDate ? this.incomingDate.toISOString() : <any>undefined;
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        data["paymentStatus"] = this.paymentStatus;
        data["authorizedDate"] = this.authorizedDate ? this.authorizedDate.toISOString() : <any>undefined;
        data["capturedDate"] = this.capturedDate ? this.capturedDate.toISOString() : <any>undefined;
        data["voidedDate"] = this.voidedDate ? this.voidedDate.toISOString() : <any>undefined;
        data["processPaymentResult"] = this.processPaymentResult ? this.processPaymentResult.toJSON() : <any>undefined;
        data["price"] = this.price;
        data["priceWithTax"] = this.priceWithTax;
        data["total"] = this.total;
        data["totalWithTax"] = this.totalWithTax;
        data["discountAmount"] = this.discountAmount;
        data["discountAmountWithTax"] = this.discountAmountWithTax;
        data["objectType"] = this.objectType;
        data["taxType"] = this.taxType;
        data["taxTotal"] = this.taxTotal;
        data["taxPercentRate"] = this.taxPercentRate;
        if (Array.isArray(this.taxDetails)) {
            data["taxDetails"] = [];
            for (let item of this.taxDetails)
                data["taxDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        if (Array.isArray(this.transactions)) {
            data["transactions"] = [];
            for (let item of this.transactions)
                data["transactions"].push(item.toJSON());
        }
        data["operationType"] = this.operationType;
        data["parentOperationId"] = this.parentOperationId;
        data["number"] = this.number;
        data["isApproved"] = this.isApproved;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["currency"] = this.currency;
        data["sum"] = this.sum;
        data["outerId"] = this.outerId;
        data["cancelledState"] = this.cancelledState;
        data["isCancelled"] = this.isCancelled;
        data["cancelledDate"] = this.cancelledDate ? this.cancelledDate.toISOString() : <any>undefined;
        data["cancelReason"] = this.cancelReason;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.operationsLog)) {
            data["operationsLog"] = [];
            for (let item of this.operationsLog)
                data["operationsLog"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IPaymentIn {
    orderId?: string | undefined;
    purpose?: string | undefined;
    gatewayCode?: string | undefined;
    paymentMethod?: PaymentMethod;
    organizationId?: string | undefined;
    organizationName?: string | undefined;
    customerId?: string | undefined;
    customerName?: string | undefined;
    incomingDate?: Date | undefined;
    billingAddress?: OrderAddress;
    paymentStatus?: PaymentStatus;
    authorizedDate?: Date | undefined;
    capturedDate?: Date | undefined;
    voidedDate?: Date | undefined;
    processPaymentResult?: ProcessPaymentRequestResult;
    price?: number;
    priceWithTax?: number;
    total?: number;
    totalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    objectType?: string | undefined;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    taxDetails?: TaxDetail[] | undefined;
    discounts?: Discount[] | undefined;
    transactions?: PaymentGatewayTransaction[] | undefined;
    operationType?: string | undefined;
    parentOperationId?: string | undefined;
    number?: string | undefined;
    isApproved?: boolean;
    status?: string | undefined;
    comment?: string | undefined;
    currency?: string | undefined;
    sum?: number;
    outerId?: string | undefined;
    cancelledState?: CancelledState;
    isCancelled?: boolean;
    cancelledDate?: Date | undefined;
    cancelReason?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    operationsLog?: OperationLog[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class OrderLineItem implements IOrderLineItem {
    priceId?: string | undefined;
    currency?: string | undefined;
    price?: number;
    priceWithTax?: number;
    placedPrice?: number;
    placedPriceWithTax?: number;
    extendedPrice?: number;
    extendedPriceWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    discountTotal?: number;
    discountTotalWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    reserveQuantity?: number;
    quantity?: number;
    productId?: string | undefined;
    sku?: string | undefined;
    productType?: string | undefined;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    name?: string | undefined;
    comment?: string | undefined;
    imageUrl?: string | undefined;
    isGift?: boolean | undefined;
    shippingMethodCode?: string | undefined;
    fulfillmentLocationCode?: string | undefined;
    fulfillmentCenterId?: string | undefined;
    fulfillmentCenterName?: string | undefined;
    outerId?: string | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    isCancelled?: boolean;
    cancelledDate?: Date | undefined;
    cancelReason?: string | undefined;
    readonly objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    discounts?: Discount[] | undefined;
    taxDetails?: TaxDetail[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IOrderLineItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.priceId = _data["priceId"];
            this.currency = _data["currency"];
            this.price = _data["price"];
            this.priceWithTax = _data["priceWithTax"];
            this.placedPrice = _data["placedPrice"];
            this.placedPriceWithTax = _data["placedPriceWithTax"];
            this.extendedPrice = _data["extendedPrice"];
            this.extendedPriceWithTax = _data["extendedPriceWithTax"];
            this.discountAmount = _data["discountAmount"];
            this.discountAmountWithTax = _data["discountAmountWithTax"];
            this.discountTotal = _data["discountTotal"];
            this.discountTotalWithTax = _data["discountTotalWithTax"];
            this.fee = _data["fee"];
            this.feeWithTax = _data["feeWithTax"];
            this.taxType = _data["taxType"];
            this.taxTotal = _data["taxTotal"];
            this.taxPercentRate = _data["taxPercentRate"];
            this.reserveQuantity = _data["reserveQuantity"];
            this.quantity = _data["quantity"];
            this.productId = _data["productId"];
            this.sku = _data["sku"];
            this.productType = _data["productType"];
            this.catalogId = _data["catalogId"];
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.comment = _data["comment"];
            this.imageUrl = _data["imageUrl"];
            this.isGift = _data["isGift"];
            this.shippingMethodCode = _data["shippingMethodCode"];
            this.fulfillmentLocationCode = _data["fulfillmentLocationCode"];
            this.fulfillmentCenterId = _data["fulfillmentCenterId"];
            this.fulfillmentCenterName = _data["fulfillmentCenterName"];
            this.outerId = _data["outerId"];
            this.weightUnit = _data["weightUnit"];
            this.weight = _data["weight"];
            this.measureUnit = _data["measureUnit"];
            this.height = _data["height"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.isCancelled = _data["isCancelled"];
            this.cancelledDate = _data["cancelledDate"] ? new Date(_data["cancelledDate"].toString()) : <any>undefined;
            this.cancelReason = _data["cancelReason"];
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(Discount.fromJS(item));
            }
            if (Array.isArray(_data["taxDetails"])) {
                this.taxDetails = [] as any;
                for (let item of _data["taxDetails"])
                    this.taxDetails!.push(TaxDetail.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrderLineItem {
        data = typeof data === 'object' ? data : {};
        let result = new OrderLineItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priceId"] = this.priceId;
        data["currency"] = this.currency;
        data["price"] = this.price;
        data["priceWithTax"] = this.priceWithTax;
        data["placedPrice"] = this.placedPrice;
        data["placedPriceWithTax"] = this.placedPriceWithTax;
        data["extendedPrice"] = this.extendedPrice;
        data["extendedPriceWithTax"] = this.extendedPriceWithTax;
        data["discountAmount"] = this.discountAmount;
        data["discountAmountWithTax"] = this.discountAmountWithTax;
        data["discountTotal"] = this.discountTotal;
        data["discountTotalWithTax"] = this.discountTotalWithTax;
        data["fee"] = this.fee;
        data["feeWithTax"] = this.feeWithTax;
        data["taxType"] = this.taxType;
        data["taxTotal"] = this.taxTotal;
        data["taxPercentRate"] = this.taxPercentRate;
        data["reserveQuantity"] = this.reserveQuantity;
        data["quantity"] = this.quantity;
        data["productId"] = this.productId;
        data["sku"] = this.sku;
        data["productType"] = this.productType;
        data["catalogId"] = this.catalogId;
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["comment"] = this.comment;
        data["imageUrl"] = this.imageUrl;
        data["isGift"] = this.isGift;
        data["shippingMethodCode"] = this.shippingMethodCode;
        data["fulfillmentLocationCode"] = this.fulfillmentLocationCode;
        data["fulfillmentCenterId"] = this.fulfillmentCenterId;
        data["fulfillmentCenterName"] = this.fulfillmentCenterName;
        data["outerId"] = this.outerId;
        data["weightUnit"] = this.weightUnit;
        data["weight"] = this.weight;
        data["measureUnit"] = this.measureUnit;
        data["height"] = this.height;
        data["length"] = this.length;
        data["width"] = this.width;
        data["isCancelled"] = this.isCancelled;
        data["cancelledDate"] = this.cancelledDate ? this.cancelledDate.toISOString() : <any>undefined;
        data["cancelReason"] = this.cancelReason;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        if (Array.isArray(this.taxDetails)) {
            data["taxDetails"] = [];
            for (let item of this.taxDetails)
                data["taxDetails"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrderLineItem {
    priceId?: string | undefined;
    currency?: string | undefined;
    price?: number;
    priceWithTax?: number;
    placedPrice?: number;
    placedPriceWithTax?: number;
    extendedPrice?: number;
    extendedPriceWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    discountTotal?: number;
    discountTotalWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    reserveQuantity?: number;
    quantity?: number;
    productId?: string | undefined;
    sku?: string | undefined;
    productType?: string | undefined;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    name?: string | undefined;
    comment?: string | undefined;
    imageUrl?: string | undefined;
    isGift?: boolean | undefined;
    shippingMethodCode?: string | undefined;
    fulfillmentLocationCode?: string | undefined;
    fulfillmentCenterId?: string | undefined;
    fulfillmentCenterName?: string | undefined;
    outerId?: string | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    isCancelled?: boolean;
    cancelledDate?: Date | undefined;
    cancelReason?: string | undefined;
    objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    discounts?: Discount[] | undefined;
    taxDetails?: TaxDetail[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class OrderShipmentItem implements IOrderShipmentItem {
    lineItemId?: string | undefined;
    lineItem?: OrderLineItem;
    barCode?: string | undefined;
    quantity?: number;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IOrderShipmentItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lineItemId = _data["lineItemId"];
            this.lineItem = _data["lineItem"] ? OrderLineItem.fromJS(_data["lineItem"]) : <any>undefined;
            this.barCode = _data["barCode"];
            this.quantity = _data["quantity"];
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrderShipmentItem {
        data = typeof data === 'object' ? data : {};
        let result = new OrderShipmentItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lineItemId"] = this.lineItemId;
        data["lineItem"] = this.lineItem ? this.lineItem.toJSON() : <any>undefined;
        data["barCode"] = this.barCode;
        data["quantity"] = this.quantity;
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrderShipmentItem {
    lineItemId?: string | undefined;
    lineItem?: OrderLineItem;
    barCode?: string | undefined;
    quantity?: number;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ShipmentPackage implements IShipmentPackage {
    barCode?: string | undefined;
    packageType?: string | undefined;
    items?: OrderShipmentItem[] | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IShipmentPackage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.barCode = _data["barCode"];
            this.packageType = _data["packageType"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderShipmentItem.fromJS(item));
            }
            this.weightUnit = _data["weightUnit"];
            this.weight = _data["weight"];
            this.measureUnit = _data["measureUnit"];
            this.height = _data["height"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ShipmentPackage {
        data = typeof data === 'object' ? data : {};
        let result = new ShipmentPackage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["barCode"] = this.barCode;
        data["packageType"] = this.packageType;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["weightUnit"] = this.weightUnit;
        data["weight"] = this.weight;
        data["measureUnit"] = this.measureUnit;
        data["height"] = this.height;
        data["length"] = this.length;
        data["width"] = this.width;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IShipmentPackage {
    barCode?: string | undefined;
    packageType?: string | undefined;
    items?: OrderShipmentItem[] | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class OrderShipment implements IOrderShipment {
    organizationId?: string | undefined;
    organizationName?: string | undefined;
    fulfillmentCenterId?: string | undefined;
    fulfillmentCenterName?: string | undefined;
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    shipmentMethodCode?: string | undefined;
    shipmentMethodOption?: string | undefined;
    shippingMethod?: ShippingMethod;
    customerOrderId?: string | undefined;
    customerOrder?: CustomerOrder;
    items?: OrderShipmentItem[] | undefined;
    packages?: ShipmentPackage[] | undefined;
    inPayments?: PaymentIn[] | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    discounts?: Discount[] | undefined;
    deliveryAddress?: OrderAddress;
    price?: number;
    priceWithTax?: number;
    total?: number;
    totalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    objectType?: string | undefined;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    taxDetails?: TaxDetail[] | undefined;
    operationType?: string | undefined;
    parentOperationId?: string | undefined;
    number?: string | undefined;
    isApproved?: boolean;
    status?: string | undefined;
    comment?: string | undefined;
    currency?: string | undefined;
    sum?: number;
    outerId?: string | undefined;
    cancelledState?: CancelledState;
    isCancelled?: boolean;
    cancelledDate?: Date | undefined;
    cancelReason?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    operationsLog?: OperationLog[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IOrderShipment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationId = _data["organizationId"];
            this.organizationName = _data["organizationName"];
            this.fulfillmentCenterId = _data["fulfillmentCenterId"];
            this.fulfillmentCenterName = _data["fulfillmentCenterName"];
            this.employeeId = _data["employeeId"];
            this.employeeName = _data["employeeName"];
            this.shipmentMethodCode = _data["shipmentMethodCode"];
            this.shipmentMethodOption = _data["shipmentMethodOption"];
            this.shippingMethod = _data["shippingMethod"] ? ShippingMethod.fromJS(_data["shippingMethod"]) : <any>undefined;
            this.customerOrderId = _data["customerOrderId"];
            this.customerOrder = _data["customerOrder"] ? CustomerOrder.fromJS(_data["customerOrder"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderShipmentItem.fromJS(item));
            }
            if (Array.isArray(_data["packages"])) {
                this.packages = [] as any;
                for (let item of _data["packages"])
                    this.packages!.push(ShipmentPackage.fromJS(item));
            }
            if (Array.isArray(_data["inPayments"])) {
                this.inPayments = [] as any;
                for (let item of _data["inPayments"])
                    this.inPayments!.push(PaymentIn.fromJS(item));
            }
            this.weightUnit = _data["weightUnit"];
            this.weight = _data["weight"];
            this.measureUnit = _data["measureUnit"];
            this.height = _data["height"];
            this.length = _data["length"];
            this.width = _data["width"];
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(Discount.fromJS(item));
            }
            this.deliveryAddress = _data["deliveryAddress"] ? OrderAddress.fromJS(_data["deliveryAddress"]) : <any>undefined;
            this.price = _data["price"];
            this.priceWithTax = _data["priceWithTax"];
            this.total = _data["total"];
            this.totalWithTax = _data["totalWithTax"];
            this.discountAmount = _data["discountAmount"];
            this.discountAmountWithTax = _data["discountAmountWithTax"];
            this.fee = _data["fee"];
            this.feeWithTax = _data["feeWithTax"];
            this.objectType = _data["objectType"];
            this.taxType = _data["taxType"];
            this.taxTotal = _data["taxTotal"];
            this.taxPercentRate = _data["taxPercentRate"];
            if (Array.isArray(_data["taxDetails"])) {
                this.taxDetails = [] as any;
                for (let item of _data["taxDetails"])
                    this.taxDetails!.push(TaxDetail.fromJS(item));
            }
            this.operationType = _data["operationType"];
            this.parentOperationId = _data["parentOperationId"];
            this.number = _data["number"];
            this.isApproved = _data["isApproved"];
            this.status = _data["status"];
            this.comment = _data["comment"];
            this.currency = _data["currency"];
            this.sum = _data["sum"];
            this.outerId = _data["outerId"];
            this.cancelledState = _data["cancelledState"];
            this.isCancelled = _data["isCancelled"];
            this.cancelledDate = _data["cancelledDate"] ? new Date(_data["cancelledDate"].toString()) : <any>undefined;
            this.cancelReason = _data["cancelReason"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            if (Array.isArray(_data["operationsLog"])) {
                this.operationsLog = [] as any;
                for (let item of _data["operationsLog"])
                    this.operationsLog!.push(OperationLog.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrderShipment {
        data = typeof data === 'object' ? data : {};
        let result = new OrderShipment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["fulfillmentCenterId"] = this.fulfillmentCenterId;
        data["fulfillmentCenterName"] = this.fulfillmentCenterName;
        data["employeeId"] = this.employeeId;
        data["employeeName"] = this.employeeName;
        data["shipmentMethodCode"] = this.shipmentMethodCode;
        data["shipmentMethodOption"] = this.shipmentMethodOption;
        data["shippingMethod"] = this.shippingMethod ? this.shippingMethod.toJSON() : <any>undefined;
        data["customerOrderId"] = this.customerOrderId;
        data["customerOrder"] = this.customerOrder ? this.customerOrder.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.packages)) {
            data["packages"] = [];
            for (let item of this.packages)
                data["packages"].push(item.toJSON());
        }
        if (Array.isArray(this.inPayments)) {
            data["inPayments"] = [];
            for (let item of this.inPayments)
                data["inPayments"].push(item.toJSON());
        }
        data["weightUnit"] = this.weightUnit;
        data["weight"] = this.weight;
        data["measureUnit"] = this.measureUnit;
        data["height"] = this.height;
        data["length"] = this.length;
        data["width"] = this.width;
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        data["deliveryAddress"] = this.deliveryAddress ? this.deliveryAddress.toJSON() : <any>undefined;
        data["price"] = this.price;
        data["priceWithTax"] = this.priceWithTax;
        data["total"] = this.total;
        data["totalWithTax"] = this.totalWithTax;
        data["discountAmount"] = this.discountAmount;
        data["discountAmountWithTax"] = this.discountAmountWithTax;
        data["fee"] = this.fee;
        data["feeWithTax"] = this.feeWithTax;
        data["objectType"] = this.objectType;
        data["taxType"] = this.taxType;
        data["taxTotal"] = this.taxTotal;
        data["taxPercentRate"] = this.taxPercentRate;
        if (Array.isArray(this.taxDetails)) {
            data["taxDetails"] = [];
            for (let item of this.taxDetails)
                data["taxDetails"].push(item.toJSON());
        }
        data["operationType"] = this.operationType;
        data["parentOperationId"] = this.parentOperationId;
        data["number"] = this.number;
        data["isApproved"] = this.isApproved;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["currency"] = this.currency;
        data["sum"] = this.sum;
        data["outerId"] = this.outerId;
        data["cancelledState"] = this.cancelledState;
        data["isCancelled"] = this.isCancelled;
        data["cancelledDate"] = this.cancelledDate ? this.cancelledDate.toISOString() : <any>undefined;
        data["cancelReason"] = this.cancelReason;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.operationsLog)) {
            data["operationsLog"] = [];
            for (let item of this.operationsLog)
                data["operationsLog"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrderShipment {
    organizationId?: string | undefined;
    organizationName?: string | undefined;
    fulfillmentCenterId?: string | undefined;
    fulfillmentCenterName?: string | undefined;
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    shipmentMethodCode?: string | undefined;
    shipmentMethodOption?: string | undefined;
    shippingMethod?: ShippingMethod;
    customerOrderId?: string | undefined;
    customerOrder?: CustomerOrder;
    items?: OrderShipmentItem[] | undefined;
    packages?: ShipmentPackage[] | undefined;
    inPayments?: PaymentIn[] | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    discounts?: Discount[] | undefined;
    deliveryAddress?: OrderAddress;
    price?: number;
    priceWithTax?: number;
    total?: number;
    totalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    objectType?: string | undefined;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    taxDetails?: TaxDetail[] | undefined;
    operationType?: string | undefined;
    parentOperationId?: string | undefined;
    number?: string | undefined;
    isApproved?: boolean;
    status?: string | undefined;
    comment?: string | undefined;
    currency?: string | undefined;
    sum?: number;
    outerId?: string | undefined;
    cancelledState?: CancelledState;
    isCancelled?: boolean;
    cancelledDate?: Date | undefined;
    cancelReason?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    operationsLog?: OperationLog[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CustomerOrder implements ICustomerOrder {
    customerId?: string | undefined;
    customerName?: string | undefined;
    channelId?: string | undefined;
    storeId?: string | undefined;
    storeName?: string | undefined;
    organizationId?: string | undefined;
    organizationName?: string | undefined;
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    shoppingCartId?: string | undefined;
    isPrototype?: boolean;
    purchaseOrderNumber?: string | undefined;
    subscriptionNumber?: string | undefined;
    subscriptionId?: string | undefined;
    objectType?: string | undefined;
    addresses?: OrderAddress[] | undefined;
    inPayments?: PaymentIn[] | undefined;
    items?: OrderLineItem[] | undefined;
    shipments?: OrderShipment[] | undefined;
    discounts?: Discount[] | undefined;
    discountAmount?: number;
    taxDetails?: TaxDetail[] | undefined;
    scopes?: string[] | undefined;
    total?: number;
    subTotal?: number;
    subTotalWithTax?: number;
    subTotalDiscount?: number;
    subTotalDiscountWithTax?: number;
    subTotalTaxTotal?: number;
    shippingTotal?: number;
    shippingTotalWithTax?: number;
    shippingSubTotal?: number;
    shippingSubTotalWithTax?: number;
    shippingDiscountTotal?: number;
    shippingDiscountTotalWithTax?: number;
    shippingTaxTotal?: number;
    paymentTotal?: number;
    paymentTotalWithTax?: number;
    paymentSubTotal?: number;
    paymentSubTotalWithTax?: number;
    paymentDiscountTotal?: number;
    paymentDiscountTotalWithTax?: number;
    paymentTaxTotal?: number;
    discountTotal?: number;
    discountTotalWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    feeTotal?: number;
    feeTotalWithTax?: number;
    handlingTotal?: number;
    handlingTotalWithTax?: number;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    languageCode?: string | undefined;
    operationType?: string | undefined;
    parentOperationId?: string | undefined;
    number?: string | undefined;
    isApproved?: boolean;
    status?: string | undefined;
    comment?: string | undefined;
    currency?: string | undefined;
    sum?: number;
    outerId?: string | undefined;
    cancelledState?: CancelledState;
    isCancelled?: boolean;
    cancelledDate?: Date | undefined;
    cancelReason?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    operationsLog?: OperationLog[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICustomerOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"];
            this.customerName = _data["customerName"];
            this.channelId = _data["channelId"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.organizationId = _data["organizationId"];
            this.organizationName = _data["organizationName"];
            this.employeeId = _data["employeeId"];
            this.employeeName = _data["employeeName"];
            this.shoppingCartId = _data["shoppingCartId"];
            this.isPrototype = _data["isPrototype"];
            this.purchaseOrderNumber = _data["purchaseOrderNumber"];
            this.subscriptionNumber = _data["subscriptionNumber"];
            this.subscriptionId = _data["subscriptionId"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(OrderAddress.fromJS(item));
            }
            if (Array.isArray(_data["inPayments"])) {
                this.inPayments = [] as any;
                for (let item of _data["inPayments"])
                    this.inPayments!.push(PaymentIn.fromJS(item));
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderLineItem.fromJS(item));
            }
            if (Array.isArray(_data["shipments"])) {
                this.shipments = [] as any;
                for (let item of _data["shipments"])
                    this.shipments!.push(OrderShipment.fromJS(item));
            }
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(Discount.fromJS(item));
            }
            this.discountAmount = _data["discountAmount"];
            if (Array.isArray(_data["taxDetails"])) {
                this.taxDetails = [] as any;
                for (let item of _data["taxDetails"])
                    this.taxDetails!.push(TaxDetail.fromJS(item));
            }
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            this.total = _data["total"];
            this.subTotal = _data["subTotal"];
            this.subTotalWithTax = _data["subTotalWithTax"];
            this.subTotalDiscount = _data["subTotalDiscount"];
            this.subTotalDiscountWithTax = _data["subTotalDiscountWithTax"];
            this.subTotalTaxTotal = _data["subTotalTaxTotal"];
            this.shippingTotal = _data["shippingTotal"];
            this.shippingTotalWithTax = _data["shippingTotalWithTax"];
            this.shippingSubTotal = _data["shippingSubTotal"];
            this.shippingSubTotalWithTax = _data["shippingSubTotalWithTax"];
            this.shippingDiscountTotal = _data["shippingDiscountTotal"];
            this.shippingDiscountTotalWithTax = _data["shippingDiscountTotalWithTax"];
            this.shippingTaxTotal = _data["shippingTaxTotal"];
            this.paymentTotal = _data["paymentTotal"];
            this.paymentTotalWithTax = _data["paymentTotalWithTax"];
            this.paymentSubTotal = _data["paymentSubTotal"];
            this.paymentSubTotalWithTax = _data["paymentSubTotalWithTax"];
            this.paymentDiscountTotal = _data["paymentDiscountTotal"];
            this.paymentDiscountTotalWithTax = _data["paymentDiscountTotalWithTax"];
            this.paymentTaxTotal = _data["paymentTaxTotal"];
            this.discountTotal = _data["discountTotal"];
            this.discountTotalWithTax = _data["discountTotalWithTax"];
            this.fee = _data["fee"];
            this.feeWithTax = _data["feeWithTax"];
            this.feeTotal = _data["feeTotal"];
            this.feeTotalWithTax = _data["feeTotalWithTax"];
            this.handlingTotal = _data["handlingTotal"];
            this.handlingTotalWithTax = _data["handlingTotalWithTax"];
            this.taxType = _data["taxType"];
            this.taxTotal = _data["taxTotal"];
            this.taxPercentRate = _data["taxPercentRate"];
            this.languageCode = _data["languageCode"];
            this.operationType = _data["operationType"];
            this.parentOperationId = _data["parentOperationId"];
            this.number = _data["number"];
            this.isApproved = _data["isApproved"];
            this.status = _data["status"];
            this.comment = _data["comment"];
            this.currency = _data["currency"];
            this.sum = _data["sum"];
            this.outerId = _data["outerId"];
            this.cancelledState = _data["cancelledState"];
            this.isCancelled = _data["isCancelled"];
            this.cancelledDate = _data["cancelledDate"] ? new Date(_data["cancelledDate"].toString()) : <any>undefined;
            this.cancelReason = _data["cancelReason"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            if (Array.isArray(_data["operationsLog"])) {
                this.operationsLog = [] as any;
                for (let item of _data["operationsLog"])
                    this.operationsLog!.push(OperationLog.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CustomerOrder {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["customerName"] = this.customerName;
        data["channelId"] = this.channelId;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["employeeId"] = this.employeeId;
        data["employeeName"] = this.employeeName;
        data["shoppingCartId"] = this.shoppingCartId;
        data["isPrototype"] = this.isPrototype;
        data["purchaseOrderNumber"] = this.purchaseOrderNumber;
        data["subscriptionNumber"] = this.subscriptionNumber;
        data["subscriptionId"] = this.subscriptionId;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.inPayments)) {
            data["inPayments"] = [];
            for (let item of this.inPayments)
                data["inPayments"].push(item.toJSON());
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.shipments)) {
            data["shipments"] = [];
            for (let item of this.shipments)
                data["shipments"].push(item.toJSON());
        }
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        data["discountAmount"] = this.discountAmount;
        if (Array.isArray(this.taxDetails)) {
            data["taxDetails"] = [];
            for (let item of this.taxDetails)
                data["taxDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        data["total"] = this.total;
        data["subTotal"] = this.subTotal;
        data["subTotalWithTax"] = this.subTotalWithTax;
        data["subTotalDiscount"] = this.subTotalDiscount;
        data["subTotalDiscountWithTax"] = this.subTotalDiscountWithTax;
        data["subTotalTaxTotal"] = this.subTotalTaxTotal;
        data["shippingTotal"] = this.shippingTotal;
        data["shippingTotalWithTax"] = this.shippingTotalWithTax;
        data["shippingSubTotal"] = this.shippingSubTotal;
        data["shippingSubTotalWithTax"] = this.shippingSubTotalWithTax;
        data["shippingDiscountTotal"] = this.shippingDiscountTotal;
        data["shippingDiscountTotalWithTax"] = this.shippingDiscountTotalWithTax;
        data["shippingTaxTotal"] = this.shippingTaxTotal;
        data["paymentTotal"] = this.paymentTotal;
        data["paymentTotalWithTax"] = this.paymentTotalWithTax;
        data["paymentSubTotal"] = this.paymentSubTotal;
        data["paymentSubTotalWithTax"] = this.paymentSubTotalWithTax;
        data["paymentDiscountTotal"] = this.paymentDiscountTotal;
        data["paymentDiscountTotalWithTax"] = this.paymentDiscountTotalWithTax;
        data["paymentTaxTotal"] = this.paymentTaxTotal;
        data["discountTotal"] = this.discountTotal;
        data["discountTotalWithTax"] = this.discountTotalWithTax;
        data["fee"] = this.fee;
        data["feeWithTax"] = this.feeWithTax;
        data["feeTotal"] = this.feeTotal;
        data["feeTotalWithTax"] = this.feeTotalWithTax;
        data["handlingTotal"] = this.handlingTotal;
        data["handlingTotalWithTax"] = this.handlingTotalWithTax;
        data["taxType"] = this.taxType;
        data["taxTotal"] = this.taxTotal;
        data["taxPercentRate"] = this.taxPercentRate;
        data["languageCode"] = this.languageCode;
        data["operationType"] = this.operationType;
        data["parentOperationId"] = this.parentOperationId;
        data["number"] = this.number;
        data["isApproved"] = this.isApproved;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["currency"] = this.currency;
        data["sum"] = this.sum;
        data["outerId"] = this.outerId;
        data["cancelledState"] = this.cancelledState;
        data["isCancelled"] = this.isCancelled;
        data["cancelledDate"] = this.cancelledDate ? this.cancelledDate.toISOString() : <any>undefined;
        data["cancelReason"] = this.cancelReason;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.operationsLog)) {
            data["operationsLog"] = [];
            for (let item of this.operationsLog)
                data["operationsLog"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ICustomerOrder {
    customerId?: string | undefined;
    customerName?: string | undefined;
    channelId?: string | undefined;
    storeId?: string | undefined;
    storeName?: string | undefined;
    organizationId?: string | undefined;
    organizationName?: string | undefined;
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    shoppingCartId?: string | undefined;
    isPrototype?: boolean;
    purchaseOrderNumber?: string | undefined;
    subscriptionNumber?: string | undefined;
    subscriptionId?: string | undefined;
    objectType?: string | undefined;
    addresses?: OrderAddress[] | undefined;
    inPayments?: PaymentIn[] | undefined;
    items?: OrderLineItem[] | undefined;
    shipments?: OrderShipment[] | undefined;
    discounts?: Discount[] | undefined;
    discountAmount?: number;
    taxDetails?: TaxDetail[] | undefined;
    scopes?: string[] | undefined;
    total?: number;
    subTotal?: number;
    subTotalWithTax?: number;
    subTotalDiscount?: number;
    subTotalDiscountWithTax?: number;
    subTotalTaxTotal?: number;
    shippingTotal?: number;
    shippingTotalWithTax?: number;
    shippingSubTotal?: number;
    shippingSubTotalWithTax?: number;
    shippingDiscountTotal?: number;
    shippingDiscountTotalWithTax?: number;
    shippingTaxTotal?: number;
    paymentTotal?: number;
    paymentTotalWithTax?: number;
    paymentSubTotal?: number;
    paymentSubTotalWithTax?: number;
    paymentDiscountTotal?: number;
    paymentDiscountTotalWithTax?: number;
    paymentTaxTotal?: number;
    discountTotal?: number;
    discountTotalWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    feeTotal?: number;
    feeTotalWithTax?: number;
    handlingTotal?: number;
    handlingTotalWithTax?: number;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    languageCode?: string | undefined;
    operationType?: string | undefined;
    parentOperationId?: string | undefined;
    number?: string | undefined;
    isApproved?: boolean;
    status?: string | undefined;
    comment?: string | undefined;
    currency?: string | undefined;
    sum?: number;
    outerId?: string | undefined;
    cancelledState?: CancelledState;
    isCancelled?: boolean;
    cancelledDate?: Date | undefined;
    cancelReason?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    operationsLog?: OperationLog[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CustomerOrderSearchResult implements ICustomerOrderSearchResult {
    totalCount?: number;
    results?: CustomerOrder[] | undefined;

    constructor(data?: ICustomerOrderSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CustomerOrder.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerOrderSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerOrderSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomerOrderSearchResult {
    totalCount?: number;
    results?: CustomerOrder[] | undefined;
}

export class ChangeOrderStatusCommand implements IChangeOrderStatusCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    orderId?: string | undefined;
    newStatus?: string | undefined;

    constructor(data?: IChangeOrderStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.orderId = _data["orderId"];
            this.newStatus = _data["newStatus"];
        }
    }

    static fromJS(data: any): ChangeOrderStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeOrderStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["orderId"] = this.orderId;
        data["newStatus"] = this.newStatus;
        return data;
    }
}

export interface IChangeOrderStatusCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    orderId?: string | undefined;
    newStatus?: string | undefined;
}

export class Seller implements ISeller {
    name?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ISeller) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Seller {
        data = typeof data === 'object' ? data : {};
        let result = new Seller();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ISeller {
    name?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class SendSellerUserInvitationCommand implements ISendSellerUserInvitationCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    seller?: Seller;
    sellerUserId!: string;
    message?: string | undefined;

    constructor(data?: ISendSellerUserInvitationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.seller = _data["seller"] ? Seller.fromJS(_data["seller"]) : <any>undefined;
            this.sellerUserId = _data["sellerUserId"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): SendSellerUserInvitationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendSellerUserInvitationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["seller"] = this.seller ? this.seller.toJSON() : <any>undefined;
        data["sellerUserId"] = this.sellerUserId;
        data["message"] = this.message;
        return data;
    }
}

export interface ISendSellerUserInvitationCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    seller?: Seller;
    sellerUserId: string;
    message?: string | undefined;
}

export class SellerOwnerDetails implements ISellerOwnerDetails {
    firstName?: string | undefined;
    lastName?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;

    constructor(data?: ISellerOwnerDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): SellerOwnerDetails {
        data = typeof data === 'object' ? data : {};
        let result = new SellerOwnerDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        data["email"] = this.email;
        return data;
    }
}

export interface ISellerOwnerDetails {
    firstName?: string | undefined;
    lastName?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
}

export class CreateSellerCommand implements ICreateSellerCommand {
    sellerName?: string | undefined;
    ownerDetails?: SellerOwnerDetails;
    categoryIds?: string[] | undefined;

    constructor(data?: ICreateSellerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerName = _data["sellerName"];
            this.ownerDetails = _data["ownerDetails"] ? SellerOwnerDetails.fromJS(_data["ownerDetails"]) : <any>undefined;
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateSellerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSellerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerName"] = this.sellerName;
        data["ownerDetails"] = this.ownerDetails ? this.ownerDetails.toJSON() : <any>undefined;
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        return data;
    }
}

export interface ICreateSellerCommand {
    sellerName?: string | undefined;
    ownerDetails?: SellerOwnerDetails;
    categoryIds?: string[] | undefined;
}

export class UpdateSellerCommand implements IUpdateSellerCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;

    constructor(data?: IUpdateSellerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
        }
    }

    static fromJS(data: any): UpdateSellerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSellerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        return data;
    }
}

export interface IUpdateSellerCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
}

export class SearchSellersQuery implements ISearchSellersQuery {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ISearchSellersQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): SearchSellersQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchSellersQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ISearchSellersQuery {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class SearchSellersResult implements ISearchSellersResult {
    totalCount?: number;
    results?: Seller[] | undefined;

    constructor(data?: ISearchSellersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Seller.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchSellersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchSellersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISearchSellersResult {
    totalCount?: number;
    results?: Seller[] | undefined;
}

export class SellerUserDetails implements ISellerUserDetails {
    firstName?: string | undefined;
    lastName?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    role?: string | undefined;
    isLockedOut?: boolean;

    constructor(data?: ISellerUserDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.role = _data["role"];
            this.isLockedOut = _data["isLockedOut"];
        }
    }

    static fromJS(data: any): SellerUserDetails {
        data = typeof data === 'object' ? data : {};
        let result = new SellerUserDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["role"] = this.role;
        data["isLockedOut"] = this.isLockedOut;
        return data;
    }
}

export interface ISellerUserDetails {
    firstName?: string | undefined;
    lastName?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    role?: string | undefined;
    isLockedOut?: boolean;
}

export class CreateSellerUserCommand implements ICreateSellerUserCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    seller?: Seller;
    userDetails?: SellerUserDetails;
    sendInvitation?: boolean;

    constructor(data?: ICreateSellerUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.seller = _data["seller"] ? Seller.fromJS(_data["seller"]) : <any>undefined;
            this.userDetails = _data["userDetails"] ? SellerUserDetails.fromJS(_data["userDetails"]) : <any>undefined;
            this.sendInvitation = _data["sendInvitation"];
        }
    }

    static fromJS(data: any): CreateSellerUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSellerUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["seller"] = this.seller ? this.seller.toJSON() : <any>undefined;
        data["userDetails"] = this.userDetails ? this.userDetails.toJSON() : <any>undefined;
        data["sendInvitation"] = this.sendInvitation;
        return data;
    }
}

export interface ICreateSellerUserCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    seller?: Seller;
    userDetails?: SellerUserDetails;
    sendInvitation?: boolean;
}

export class SellerUser implements ISellerUser {
    readonly sellerId?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    readonly fullName?: string | undefined;
    readonly userName?: string | undefined;
    email?: string | undefined;
    role?: string | undefined;
    readonly isLockedOut?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ISellerUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).sellerId = _data["sellerId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            (<any>this).fullName = _data["fullName"];
            (<any>this).userName = _data["userName"];
            this.email = _data["email"];
            this.role = _data["role"];
            (<any>this).isLockedOut = _data["isLockedOut"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SellerUser {
        data = typeof data === 'object' ? data : {};
        let result = new SellerUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["role"] = this.role;
        data["isLockedOut"] = this.isLockedOut;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ISellerUser {
    sellerId?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    role?: string | undefined;
    isLockedOut?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ValidateSellerUserQuery implements IValidateSellerUserQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    sellerUser?: SellerUser;

    constructor(data?: IValidateSellerUserQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.sellerUser = _data["sellerUser"] ? SellerUser.fromJS(_data["sellerUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ValidateSellerUserQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateSellerUserQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["sellerUser"] = this.sellerUser ? this.sellerUser.toJSON() : <any>undefined;
        return data;
    }
}

export interface IValidateSellerUserQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    sellerUser?: SellerUser;
}

export class UpdateSellerUserCommand implements IUpdateSellerUserCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    seller?: Seller;
    sellerUserId!: string;
    userDetails?: SellerUserDetails;

    constructor(data?: IUpdateSellerUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.seller = _data["seller"] ? Seller.fromJS(_data["seller"]) : <any>undefined;
            this.sellerUserId = _data["sellerUserId"];
            this.userDetails = _data["userDetails"] ? SellerUserDetails.fromJS(_data["userDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateSellerUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSellerUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["seller"] = this.seller ? this.seller.toJSON() : <any>undefined;
        data["sellerUserId"] = this.sellerUserId;
        data["userDetails"] = this.userDetails ? this.userDetails.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateSellerUserCommand {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    seller?: Seller;
    sellerUserId: string;
    userDetails?: SellerUserDetails;
}

export class SearchSellerUsersQuery implements ISearchSellerUsersQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ISearchSellerUsersQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.sellerName = _data["sellerName"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): SearchSellerUsersQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchSellerUsersQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["sellerName"] = this.sellerName;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ISearchSellerUsersQuery {
    sellerId?: string | undefined;
    sellerName?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class SearchSellerUsersResult implements ISearchSellerUsersResult {
    totalCount?: number;
    results?: SellerUser[] | undefined;

    constructor(data?: ISearchSellerUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(SellerUser.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchSellerUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchSellerUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISearchSellerUsersResult {
    totalCount?: number;
    results?: SellerUser[] | undefined;
}

export class ForgotPasswordCommand implements IForgotPasswordCommand {
    loginOrEmail!: string;

    constructor(data?: IForgotPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loginOrEmail = _data["loginOrEmail"];
        }
    }

    static fromJS(data: any): ForgotPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loginOrEmail"] = this.loginOrEmail;
        return data;
    }
}

export interface IForgotPasswordCommand {
    loginOrEmail: string;
}

export class NotificationSearchCriteria implements INotificationSearchCriteria {
    notificationType?: string | undefined;
    tenantId?: string | undefined;
    tenantType?: string | undefined;
    isActive?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: INotificationSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationType = _data["notificationType"];
            this.tenantId = _data["tenantId"];
            this.tenantType = _data["tenantType"];
            this.isActive = _data["isActive"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): NotificationSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationType"] = this.notificationType;
        data["tenantId"] = this.tenantId;
        data["tenantType"] = this.tenantType;
        data["isActive"] = this.isActive;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface INotificationSearchCriteria {
    notificationType?: string | undefined;
    tenantId?: string | undefined;
    tenantType?: string | undefined;
    isActive?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class NotificationTemplate implements INotificationTemplate {
    languageCode?: string | undefined;
    readonly kind?: string | undefined;
    readonly type?: string | undefined;
    isReadonly?: boolean;
    outerId?: string | undefined;
    isPredefined?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: INotificationTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageCode = _data["languageCode"];
            (<any>this).kind = _data["kind"];
            (<any>this).type = _data["type"];
            this.isReadonly = _data["isReadonly"];
            this.outerId = _data["outerId"];
            this.isPredefined = _data["isPredefined"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NotificationTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageCode"] = this.languageCode;
        data["kind"] = this.kind;
        data["type"] = this.type;
        data["isReadonly"] = this.isReadonly;
        data["outerId"] = this.outerId;
        data["isPredefined"] = this.isPredefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface INotificationTemplate {
    languageCode?: string | undefined;
    kind?: string | undefined;
    type?: string | undefined;
    isReadonly?: boolean;
    outerId?: string | undefined;
    isPredefined?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Notification implements INotification {
    tenantIdentity?: TenantIdentity;
    isActive?: boolean | undefined;
    languageCode?: string | undefined;
    alias?: string | undefined;
    type?: string | undefined;
    readonly kind?: string | undefined;
    outerId?: string | undefined;
    templates?: NotificationTemplate[] | undefined;
    readonly customValidationError?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: INotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantIdentity = _data["tenantIdentity"] ? TenantIdentity.fromJS(_data["tenantIdentity"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.languageCode = _data["languageCode"];
            this.alias = _data["alias"];
            this.type = _data["type"];
            (<any>this).kind = _data["kind"];
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["templates"])) {
                this.templates = [] as any;
                for (let item of _data["templates"])
                    this.templates!.push(NotificationTemplate.fromJS(item));
            }
            (<any>this).customValidationError = _data["customValidationError"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Notification {
        data = typeof data === 'object' ? data : {};
        let result = new Notification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantIdentity"] = this.tenantIdentity ? this.tenantIdentity.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["languageCode"] = this.languageCode;
        data["alias"] = this.alias;
        data["type"] = this.type;
        data["kind"] = this.kind;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.templates)) {
            data["templates"] = [];
            for (let item of this.templates)
                data["templates"].push(item.toJSON());
        }
        data["customValidationError"] = this.customValidationError;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface INotification {
    tenantIdentity?: TenantIdentity;
    isActive?: boolean | undefined;
    languageCode?: string | undefined;
    alias?: string | undefined;
    type?: string | undefined;
    kind?: string | undefined;
    outerId?: string | undefined;
    templates?: NotificationTemplate[] | undefined;
    customValidationError?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class NotificationSearchResult implements INotificationSearchResult {
    totalCount?: number;
    results?: Notification[] | undefined;

    constructor(data?: INotificationSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Notification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface INotificationSearchResult {
    totalCount?: number;
    results?: Notification[] | undefined;
}

export class NotificationTemplateRequest implements INotificationTemplateRequest {
    text?: string | undefined;
    data?: Notification;

    constructor(data?: INotificationTemplateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.data = _data["data"] ? Notification.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationTemplateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationTemplateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface INotificationTemplateRequest {
    text?: string | undefined;
    data?: Notification;
}

export class NotificationSendResult implements INotificationSendResult {
    errorMessage?: string | undefined;
    isSuccess?: boolean;

    constructor(data?: INotificationSendResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.isSuccess = _data["isSuccess"];
        }
    }

    static fromJS(data: any): NotificationSendResult {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSendResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["isSuccess"] = this.isSuccess;
        return data;
    }
}

export interface INotificationSendResult {
    errorMessage?: string | undefined;
    isSuccess?: boolean;
}

export enum NotificationParameterValueType {
    String = "String",
    Integer = "Integer",
    Decimal = "Decimal",
    DateTime = "DateTime",
    Boolean = "Boolean",
}

export class NotificationParameter implements INotificationParameter {
    parameterName?: string | undefined;
    parameterDescription?: string | undefined;
    parameterCodeInView?: string | undefined;
    isDictionary?: boolean;
    isArray?: boolean;
    type?: NotificationParameterValueType;
    value?: any | undefined;

    constructor(data?: INotificationParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parameterName = _data["parameterName"];
            this.parameterDescription = _data["parameterDescription"];
            this.parameterCodeInView = _data["parameterCodeInView"];
            this.isDictionary = _data["isDictionary"];
            this.isArray = _data["isArray"];
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NotificationParameter {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationParameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parameterName"] = this.parameterName;
        data["parameterDescription"] = this.parameterDescription;
        data["parameterCodeInView"] = this.parameterCodeInView;
        data["isDictionary"] = this.isDictionary;
        data["isArray"] = this.isArray;
        data["type"] = this.type;
        data["value"] = this.value;
        return data;
    }
}

export interface INotificationParameter {
    parameterName?: string | undefined;
    parameterDescription?: string | undefined;
    parameterCodeInView?: string | undefined;
    isDictionary?: boolean;
    isArray?: boolean;
    type?: NotificationParameterValueType;
    value?: any | undefined;
}

export class NotificationRequest implements INotificationRequest {
    type?: string | undefined;
    objectId?: string | undefined;
    objectTypeId?: string | undefined;
    language?: string | undefined;
    notificationParameters?: NotificationParameter[] | undefined;

    constructor(data?: INotificationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.objectId = _data["objectId"];
            this.objectTypeId = _data["objectTypeId"];
            this.language = _data["language"];
            if (Array.isArray(_data["notificationParameters"])) {
                this.notificationParameters = [] as any;
                for (let item of _data["notificationParameters"])
                    this.notificationParameters!.push(NotificationParameter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["objectId"] = this.objectId;
        data["objectTypeId"] = this.objectTypeId;
        data["language"] = this.language;
        if (Array.isArray(this.notificationParameters)) {
            data["notificationParameters"] = [];
            for (let item of this.notificationParameters)
                data["notificationParameters"].push(item.toJSON());
        }
        return data;
    }
}

export interface INotificationRequest {
    type?: string | undefined;
    objectId?: string | undefined;
    objectTypeId?: string | undefined;
    language?: string | undefined;
    notificationParameters?: NotificationParameter[] | undefined;
}

export class NotificationMessageSearchCriteria implements INotificationMessageSearchCriteria {
    notificationType?: string | undefined;
    status?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: INotificationMessageSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationType = _data["notificationType"];
            this.status = _data["status"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): NotificationMessageSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationMessageSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationType"] = this.notificationType;
        data["status"] = this.status;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface INotificationMessageSearchCriteria {
    notificationType?: string | undefined;
    status?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export enum NotificationMessageStatus {
    Pending = "Pending",
    Sent = "Sent",
    Error = "Error",
}

export class NotificationMessage implements INotificationMessage {
    readonly kind?: string | undefined;
    readonly type?: string | undefined;
    tenantIdentity?: TenantIdentity;
    notificationId?: string | undefined;
    notificationType?: string | undefined;
    sendAttemptCount?: number;
    maxSendAttemptCount?: number;
    lastSendError?: string | undefined;
    lastSendAttemptDate?: Date | undefined;
    sendDate?: Date | undefined;
    languageCode?: string | undefined;
    status?: NotificationMessageStatus;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: INotificationMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).kind = _data["kind"];
            (<any>this).type = _data["type"];
            this.tenantIdentity = _data["tenantIdentity"] ? TenantIdentity.fromJS(_data["tenantIdentity"]) : <any>undefined;
            this.notificationId = _data["notificationId"];
            this.notificationType = _data["notificationType"];
            this.sendAttemptCount = _data["sendAttemptCount"];
            this.maxSendAttemptCount = _data["maxSendAttemptCount"];
            this.lastSendError = _data["lastSendError"];
            this.lastSendAttemptDate = _data["lastSendAttemptDate"] ? new Date(_data["lastSendAttemptDate"].toString()) : <any>undefined;
            this.sendDate = _data["sendDate"] ? new Date(_data["sendDate"].toString()) : <any>undefined;
            this.languageCode = _data["languageCode"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NotificationMessage {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this.kind;
        data["type"] = this.type;
        data["tenantIdentity"] = this.tenantIdentity ? this.tenantIdentity.toJSON() : <any>undefined;
        data["notificationId"] = this.notificationId;
        data["notificationType"] = this.notificationType;
        data["sendAttemptCount"] = this.sendAttemptCount;
        data["maxSendAttemptCount"] = this.maxSendAttemptCount;
        data["lastSendError"] = this.lastSendError;
        data["lastSendAttemptDate"] = this.lastSendAttemptDate ? this.lastSendAttemptDate.toISOString() : <any>undefined;
        data["sendDate"] = this.sendDate ? this.sendDate.toISOString() : <any>undefined;
        data["languageCode"] = this.languageCode;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface INotificationMessage {
    kind?: string | undefined;
    type?: string | undefined;
    tenantIdentity?: TenantIdentity;
    notificationId?: string | undefined;
    notificationType?: string | undefined;
    sendAttemptCount?: number;
    maxSendAttemptCount?: number;
    lastSendError?: string | undefined;
    lastSendAttemptDate?: Date | undefined;
    sendDate?: Date | undefined;
    languageCode?: string | undefined;
    status?: NotificationMessageStatus;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class NotificationMessageSearchResult implements INotificationMessageSearchResult {
    totalCount?: number;
    results?: NotificationMessage[] | undefined;

    constructor(data?: INotificationMessageSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(NotificationMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationMessageSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationMessageSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface INotificationMessageSearchResult {
    totalCount?: number;
    results?: NotificationMessage[] | undefined;
}

export class CustomerOrderSearchCriteria implements ICustomerOrderSearchCriteria {
    withPrototypes?: boolean;
    onlyRecurring?: boolean;
    subscriptionId?: string | undefined;
    subscriptionIds?: string[] | undefined;
    operationId?: string | undefined;
    customerId?: string | undefined;
    customerIds?: string[] | undefined;
    ids?: string[] | undefined;
    hasParentOperation?: boolean | undefined;
    parentOperationId?: string | undefined;
    employeeId?: string | undefined;
    storeIds?: string[] | undefined;
    status?: string | undefined;
    statuses?: string[] | undefined;
    number?: string | undefined;
    numbers?: string[] | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ICustomerOrderSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.withPrototypes = _data["withPrototypes"];
            this.onlyRecurring = _data["onlyRecurring"];
            this.subscriptionId = _data["subscriptionId"];
            if (Array.isArray(_data["subscriptionIds"])) {
                this.subscriptionIds = [] as any;
                for (let item of _data["subscriptionIds"])
                    this.subscriptionIds!.push(item);
            }
            this.operationId = _data["operationId"];
            this.customerId = _data["customerId"];
            if (Array.isArray(_data["customerIds"])) {
                this.customerIds = [] as any;
                for (let item of _data["customerIds"])
                    this.customerIds!.push(item);
            }
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.hasParentOperation = _data["hasParentOperation"];
            this.parentOperationId = _data["parentOperationId"];
            this.employeeId = _data["employeeId"];
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.status = _data["status"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(item);
            }
            this.number = _data["number"];
            if (Array.isArray(_data["numbers"])) {
                this.numbers = [] as any;
                for (let item of _data["numbers"])
                    this.numbers!.push(item);
            }
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): CustomerOrderSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerOrderSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["withPrototypes"] = this.withPrototypes;
        data["onlyRecurring"] = this.onlyRecurring;
        data["subscriptionId"] = this.subscriptionId;
        if (Array.isArray(this.subscriptionIds)) {
            data["subscriptionIds"] = [];
            for (let item of this.subscriptionIds)
                data["subscriptionIds"].push(item);
        }
        data["operationId"] = this.operationId;
        data["customerId"] = this.customerId;
        if (Array.isArray(this.customerIds)) {
            data["customerIds"] = [];
            for (let item of this.customerIds)
                data["customerIds"].push(item);
        }
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["hasParentOperation"] = this.hasParentOperation;
        data["parentOperationId"] = this.parentOperationId;
        data["employeeId"] = this.employeeId;
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["status"] = this.status;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item);
        }
        data["number"] = this.number;
        if (Array.isArray(this.numbers)) {
            data["numbers"] = [];
            for (let item of this.numbers)
                data["numbers"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ICustomerOrderSearchCriteria {
    withPrototypes?: boolean;
    onlyRecurring?: boolean;
    subscriptionId?: string | undefined;
    subscriptionIds?: string[] | undefined;
    operationId?: string | undefined;
    customerId?: string | undefined;
    customerIds?: string[] | undefined;
    ids?: string[] | undefined;
    hasParentOperation?: boolean | undefined;
    parentOperationId?: string | undefined;
    employeeId?: string | undefined;
    storeIds?: string[] | undefined;
    status?: string | undefined;
    statuses?: string[] | undefined;
    number?: string | undefined;
    numbers?: string[] | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class BankCardInfo implements IBankCardInfo {
    bankCardNumber?: string | undefined;
    bankCardType?: string | undefined;
    bankCardMonth?: number;
    bankCardYear?: number;
    bankCardCVV2?: string | undefined;
    cardholderName?: string | undefined;

    constructor(data?: IBankCardInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankCardNumber = _data["bankCardNumber"];
            this.bankCardType = _data["bankCardType"];
            this.bankCardMonth = _data["bankCardMonth"];
            this.bankCardYear = _data["bankCardYear"];
            this.bankCardCVV2 = _data["bankCardCVV2"];
            this.cardholderName = _data["cardholderName"];
        }
    }

    static fromJS(data: any): BankCardInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BankCardInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankCardNumber"] = this.bankCardNumber;
        data["bankCardType"] = this.bankCardType;
        data["bankCardMonth"] = this.bankCardMonth;
        data["bankCardYear"] = this.bankCardYear;
        data["bankCardCVV2"] = this.bankCardCVV2;
        data["cardholderName"] = this.cardholderName;
        return data;
    }
}

export interface IBankCardInfo {
    bankCardNumber?: string | undefined;
    bankCardType?: string | undefined;
    bankCardMonth?: number;
    bankCardYear?: number;
    bankCardCVV2?: string | undefined;
    cardholderName?: string | undefined;
}

export class Money implements IMoney {
    currency?: string | undefined;
    amount?: number;

    constructor(data?: IMoney) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currency = _data["currency"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): Money {
        data = typeof data === 'object' ? data : {};
        let result = new Money();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currency"] = this.currency;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IMoney {
    currency?: string | undefined;
    amount?: number;
}

export class QuarterPeriodMoney implements IQuarterPeriodMoney {
    year?: number;
    quarter?: number;
    currency?: string | undefined;
    amount?: number;

    constructor(data?: IQuarterPeriodMoney) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
            this.quarter = _data["quarter"];
            this.currency = _data["currency"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): QuarterPeriodMoney {
        data = typeof data === 'object' ? data : {};
        let result = new QuarterPeriodMoney();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["quarter"] = this.quarter;
        data["currency"] = this.currency;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IQuarterPeriodMoney {
    year?: number;
    quarter?: number;
    currency?: string | undefined;
    amount?: number;
}

export class DashboardStatisticsResult implements IDashboardStatisticsResult {
    startDate?: Date;
    endDate?: Date;
    revenue?: Money[] | undefined;
    revenuePeriodDetails?: QuarterPeriodMoney[] | undefined;
    orderCount?: number;
    customersCount?: number;
    revenuePerCustomer?: Money[] | undefined;
    avgOrderValue?: Money[] | undefined;
    avgOrderValuePeriodDetails?: QuarterPeriodMoney[] | undefined;
    itemsPurchased?: number;
    lineitemsPerOrder?: number;

    constructor(data?: IDashboardStatisticsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["revenue"])) {
                this.revenue = [] as any;
                for (let item of _data["revenue"])
                    this.revenue!.push(Money.fromJS(item));
            }
            if (Array.isArray(_data["revenuePeriodDetails"])) {
                this.revenuePeriodDetails = [] as any;
                for (let item of _data["revenuePeriodDetails"])
                    this.revenuePeriodDetails!.push(QuarterPeriodMoney.fromJS(item));
            }
            this.orderCount = _data["orderCount"];
            this.customersCount = _data["customersCount"];
            if (Array.isArray(_data["revenuePerCustomer"])) {
                this.revenuePerCustomer = [] as any;
                for (let item of _data["revenuePerCustomer"])
                    this.revenuePerCustomer!.push(Money.fromJS(item));
            }
            if (Array.isArray(_data["avgOrderValue"])) {
                this.avgOrderValue = [] as any;
                for (let item of _data["avgOrderValue"])
                    this.avgOrderValue!.push(Money.fromJS(item));
            }
            if (Array.isArray(_data["avgOrderValuePeriodDetails"])) {
                this.avgOrderValuePeriodDetails = [] as any;
                for (let item of _data["avgOrderValuePeriodDetails"])
                    this.avgOrderValuePeriodDetails!.push(QuarterPeriodMoney.fromJS(item));
            }
            this.itemsPurchased = _data["itemsPurchased"];
            this.lineitemsPerOrder = _data["lineitemsPerOrder"];
        }
    }

    static fromJS(data: any): DashboardStatisticsResult {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardStatisticsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (Array.isArray(this.revenue)) {
            data["revenue"] = [];
            for (let item of this.revenue)
                data["revenue"].push(item.toJSON());
        }
        if (Array.isArray(this.revenuePeriodDetails)) {
            data["revenuePeriodDetails"] = [];
            for (let item of this.revenuePeriodDetails)
                data["revenuePeriodDetails"].push(item.toJSON());
        }
        data["orderCount"] = this.orderCount;
        data["customersCount"] = this.customersCount;
        if (Array.isArray(this.revenuePerCustomer)) {
            data["revenuePerCustomer"] = [];
            for (let item of this.revenuePerCustomer)
                data["revenuePerCustomer"].push(item.toJSON());
        }
        if (Array.isArray(this.avgOrderValue)) {
            data["avgOrderValue"] = [];
            for (let item of this.avgOrderValue)
                data["avgOrderValue"].push(item.toJSON());
        }
        if (Array.isArray(this.avgOrderValuePeriodDetails)) {
            data["avgOrderValuePeriodDetails"] = [];
            for (let item of this.avgOrderValuePeriodDetails)
                data["avgOrderValuePeriodDetails"].push(item.toJSON());
        }
        data["itemsPurchased"] = this.itemsPurchased;
        data["lineitemsPerOrder"] = this.lineitemsPerOrder;
        return data;
    }
}

export interface IDashboardStatisticsResult {
    startDate?: Date;
    endDate?: Date;
    revenue?: Money[] | undefined;
    revenuePeriodDetails?: QuarterPeriodMoney[] | undefined;
    orderCount?: number;
    customersCount?: number;
    revenuePerCustomer?: Money[] | undefined;
    avgOrderValue?: Money[] | undefined;
    avgOrderValuePeriodDetails?: QuarterPeriodMoney[] | undefined;
    itemsPurchased?: number;
    lineitemsPerOrder?: number;
}

export class KeyValuePair implements IKeyValuePair {
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: IKeyValuePair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): KeyValuePair {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValuePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IKeyValuePair {
    key?: string | undefined;
    value?: string | undefined;
}

export class PaymentCallbackParameters implements IPaymentCallbackParameters {
    parameters?: KeyValuePair[] | undefined;

    constructor(data?: IPaymentCallbackParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["parameters"])
                    this.parameters!.push(KeyValuePair.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentCallbackParameters {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentCallbackParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPaymentCallbackParameters {
    parameters?: KeyValuePair[] | undefined;
}

export class PostProcessPaymentRequestResult implements IPostProcessPaymentRequestResult {
    returnUrl?: string | undefined;
    orderId?: string | undefined;
    outerId?: string | undefined;
    paymentMethod?: PaymentMethod;
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    newPaymentStatus?: PaymentStatus;

    constructor(data?: IPostProcessPaymentRequestResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.returnUrl = _data["returnUrl"];
            this.orderId = _data["orderId"];
            this.outerId = _data["outerId"];
            this.paymentMethod = _data["paymentMethod"] ? PaymentMethod.fromJS(_data["paymentMethod"]) : <any>undefined;
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.newPaymentStatus = _data["newPaymentStatus"];
        }
    }

    static fromJS(data: any): PostProcessPaymentRequestResult {
        data = typeof data === 'object' ? data : {};
        let result = new PostProcessPaymentRequestResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["returnUrl"] = this.returnUrl;
        data["orderId"] = this.orderId;
        data["outerId"] = this.outerId;
        data["paymentMethod"] = this.paymentMethod ? this.paymentMethod.toJSON() : <any>undefined;
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["newPaymentStatus"] = this.newPaymentStatus;
        return data;
    }
}

export interface IPostProcessPaymentRequestResult {
    returnUrl?: string | undefined;
    orderId?: string | undefined;
    outerId?: string | undefined;
    paymentMethod?: PaymentMethod;
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    newPaymentStatus?: PaymentStatus;
}

export class CustomerOrderHistorySearchCriteria implements ICustomerOrderHistorySearchCriteria {
    orderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ICustomerOrderHistorySearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): CustomerOrderHistorySearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerOrderHistorySearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ICustomerOrderHistorySearchCriteria {
    orderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class CustomerOrderIndexedSearchCriteria implements ICustomerOrderIndexedSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ICustomerOrderIndexedSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): CustomerOrderIndexedSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerOrderIndexedSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ICustomerOrderIndexedSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class PaymentSearchCriteria implements IPaymentSearchCriteria {
    orderId?: string | undefined;
    orderNumber?: string | undefined;
    customerId?: string | undefined;
    capturedStartDate?: Date | undefined;
    capturedEndDate?: Date | undefined;
    authorizedStartDate?: Date | undefined;
    authorizedEndDate?: Date | undefined;
    ids?: string[] | undefined;
    hasParentOperation?: boolean | undefined;
    parentOperationId?: string | undefined;
    employeeId?: string | undefined;
    storeIds?: string[] | undefined;
    status?: string | undefined;
    statuses?: string[] | undefined;
    number?: string | undefined;
    numbers?: string[] | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IPaymentSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.orderNumber = _data["orderNumber"];
            this.customerId = _data["customerId"];
            this.capturedStartDate = _data["capturedStartDate"] ? new Date(_data["capturedStartDate"].toString()) : <any>undefined;
            this.capturedEndDate = _data["capturedEndDate"] ? new Date(_data["capturedEndDate"].toString()) : <any>undefined;
            this.authorizedStartDate = _data["authorizedStartDate"] ? new Date(_data["authorizedStartDate"].toString()) : <any>undefined;
            this.authorizedEndDate = _data["authorizedEndDate"] ? new Date(_data["authorizedEndDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.hasParentOperation = _data["hasParentOperation"];
            this.parentOperationId = _data["parentOperationId"];
            this.employeeId = _data["employeeId"];
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.status = _data["status"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(item);
            }
            this.number = _data["number"];
            if (Array.isArray(_data["numbers"])) {
                this.numbers = [] as any;
                for (let item of _data["numbers"])
                    this.numbers!.push(item);
            }
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): PaymentSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["orderNumber"] = this.orderNumber;
        data["customerId"] = this.customerId;
        data["capturedStartDate"] = this.capturedStartDate ? this.capturedStartDate.toISOString() : <any>undefined;
        data["capturedEndDate"] = this.capturedEndDate ? this.capturedEndDate.toISOString() : <any>undefined;
        data["authorizedStartDate"] = this.authorizedStartDate ? this.authorizedStartDate.toISOString() : <any>undefined;
        data["authorizedEndDate"] = this.authorizedEndDate ? this.authorizedEndDate.toISOString() : <any>undefined;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["hasParentOperation"] = this.hasParentOperation;
        data["parentOperationId"] = this.parentOperationId;
        data["employeeId"] = this.employeeId;
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["status"] = this.status;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item);
        }
        data["number"] = this.number;
        if (Array.isArray(this.numbers)) {
            data["numbers"] = [];
            for (let item of this.numbers)
                data["numbers"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IPaymentSearchCriteria {
    orderId?: string | undefined;
    orderNumber?: string | undefined;
    customerId?: string | undefined;
    capturedStartDate?: Date | undefined;
    capturedEndDate?: Date | undefined;
    authorizedStartDate?: Date | undefined;
    authorizedEndDate?: Date | undefined;
    ids?: string[] | undefined;
    hasParentOperation?: boolean | undefined;
    parentOperationId?: string | undefined;
    employeeId?: string | undefined;
    storeIds?: string[] | undefined;
    status?: string | undefined;
    statuses?: string[] | undefined;
    number?: string | undefined;
    numbers?: string[] | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class PaymentSearchResult implements IPaymentSearchResult {
    totalCount?: number;
    results?: PaymentIn[] | undefined;

    constructor(data?: IPaymentSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(PaymentIn.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPaymentSearchResult {
    totalCount?: number;
    results?: PaymentIn[] | undefined;
}

export class PaymentMethodsSearchCriteria implements IPaymentMethodsSearchCriteria {
    storeId?: string | undefined;
    codes?: string[] | undefined;
    isActive?: boolean | undefined;
    withoutTransient?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IPaymentMethodsSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            if (Array.isArray(_data["codes"])) {
                this.codes = [] as any;
                for (let item of _data["codes"])
                    this.codes!.push(item);
            }
            this.isActive = _data["isActive"];
            this.withoutTransient = _data["withoutTransient"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): PaymentMethodsSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodsSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        if (Array.isArray(this.codes)) {
            data["codes"] = [];
            for (let item of this.codes)
                data["codes"].push(item);
        }
        data["isActive"] = this.isActive;
        data["withoutTransient"] = this.withoutTransient;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IPaymentMethodsSearchCriteria {
    storeId?: string | undefined;
    codes?: string[] | undefined;
    isActive?: boolean | undefined;
    withoutTransient?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class PaymentMethodsSearchResult implements IPaymentMethodsSearchResult {
    totalCount?: number;
    results?: PaymentMethod[] | undefined;

    constructor(data?: IPaymentMethodsSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(PaymentMethod.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentMethodsSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodsSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPaymentMethodsSearchResult {
    totalCount?: number;
    results?: PaymentMethod[] | undefined;
}

export class PriceEvaluationContext implements IPriceEvaluationContext {
    storeId?: string | undefined;
    catalogId?: string | undefined;
    productIds?: string[] | undefined;
    pricelistIds?: string[] | undefined;
    returnAllMatchedPrices?: boolean;
    quantity?: number;
    customerId?: string | undefined;
    organizationId?: string | undefined;
    certainDate?: Date | undefined;
    currency?: string | undefined;
    skipAssignmentValidation?: boolean;
    contextObject?: any | undefined;
    geoCity?: string | undefined;
    geoState?: string | undefined;
    geoCountry?: string | undefined;
    geoContinent?: string | undefined;
    geoZipCode?: string | undefined;
    geoConnectionType?: string | undefined;
    geoTimeZone?: string | undefined;
    geoIpRoutingType?: string | undefined;
    geoIspSecondLevel?: string | undefined;
    geoIspTopLevel?: string | undefined;
    shopperAge?: number;
    shopperGender?: string | undefined;
    language?: string | undefined;
    userGroups?: string[] | undefined;
    shopperSearchedPhraseInStore?: string | undefined;
    shopperSearchedPhraseOnInternet?: string | undefined;
    currentUrl?: string | undefined;
    referredUrl?: string | undefined;

    constructor(data?: IPriceEvaluationContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.catalogId = _data["catalogId"];
            if (Array.isArray(_data["productIds"])) {
                this.productIds = [] as any;
                for (let item of _data["productIds"])
                    this.productIds!.push(item);
            }
            if (Array.isArray(_data["pricelistIds"])) {
                this.pricelistIds = [] as any;
                for (let item of _data["pricelistIds"])
                    this.pricelistIds!.push(item);
            }
            this.returnAllMatchedPrices = _data["returnAllMatchedPrices"];
            this.quantity = _data["quantity"];
            this.customerId = _data["customerId"];
            this.organizationId = _data["organizationId"];
            this.certainDate = _data["certainDate"] ? new Date(_data["certainDate"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.skipAssignmentValidation = _data["skipAssignmentValidation"];
            this.contextObject = _data["contextObject"];
            this.geoCity = _data["geoCity"];
            this.geoState = _data["geoState"];
            this.geoCountry = _data["geoCountry"];
            this.geoContinent = _data["geoContinent"];
            this.geoZipCode = _data["geoZipCode"];
            this.geoConnectionType = _data["geoConnectionType"];
            this.geoTimeZone = _data["geoTimeZone"];
            this.geoIpRoutingType = _data["geoIpRoutingType"];
            this.geoIspSecondLevel = _data["geoIspSecondLevel"];
            this.geoIspTopLevel = _data["geoIspTopLevel"];
            this.shopperAge = _data["shopperAge"];
            this.shopperGender = _data["shopperGender"];
            this.language = _data["language"];
            if (Array.isArray(_data["userGroups"])) {
                this.userGroups = [] as any;
                for (let item of _data["userGroups"])
                    this.userGroups!.push(item);
            }
            this.shopperSearchedPhraseInStore = _data["shopperSearchedPhraseInStore"];
            this.shopperSearchedPhraseOnInternet = _data["shopperSearchedPhraseOnInternet"];
            this.currentUrl = _data["currentUrl"];
            this.referredUrl = _data["referredUrl"];
        }
    }

    static fromJS(data: any): PriceEvaluationContext {
        data = typeof data === 'object' ? data : {};
        let result = new PriceEvaluationContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["catalogId"] = this.catalogId;
        if (Array.isArray(this.productIds)) {
            data["productIds"] = [];
            for (let item of this.productIds)
                data["productIds"].push(item);
        }
        if (Array.isArray(this.pricelistIds)) {
            data["pricelistIds"] = [];
            for (let item of this.pricelistIds)
                data["pricelistIds"].push(item);
        }
        data["returnAllMatchedPrices"] = this.returnAllMatchedPrices;
        data["quantity"] = this.quantity;
        data["customerId"] = this.customerId;
        data["organizationId"] = this.organizationId;
        data["certainDate"] = this.certainDate ? this.certainDate.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["skipAssignmentValidation"] = this.skipAssignmentValidation;
        data["contextObject"] = this.contextObject;
        data["geoCity"] = this.geoCity;
        data["geoState"] = this.geoState;
        data["geoCountry"] = this.geoCountry;
        data["geoContinent"] = this.geoContinent;
        data["geoZipCode"] = this.geoZipCode;
        data["geoConnectionType"] = this.geoConnectionType;
        data["geoTimeZone"] = this.geoTimeZone;
        data["geoIpRoutingType"] = this.geoIpRoutingType;
        data["geoIspSecondLevel"] = this.geoIspSecondLevel;
        data["geoIspTopLevel"] = this.geoIspTopLevel;
        data["shopperAge"] = this.shopperAge;
        data["shopperGender"] = this.shopperGender;
        data["language"] = this.language;
        if (Array.isArray(this.userGroups)) {
            data["userGroups"] = [];
            for (let item of this.userGroups)
                data["userGroups"].push(item);
        }
        data["shopperSearchedPhraseInStore"] = this.shopperSearchedPhraseInStore;
        data["shopperSearchedPhraseOnInternet"] = this.shopperSearchedPhraseOnInternet;
        data["currentUrl"] = this.currentUrl;
        data["referredUrl"] = this.referredUrl;
        return data;
    }
}

export interface IPriceEvaluationContext {
    storeId?: string | undefined;
    catalogId?: string | undefined;
    productIds?: string[] | undefined;
    pricelistIds?: string[] | undefined;
    returnAllMatchedPrices?: boolean;
    quantity?: number;
    customerId?: string | undefined;
    organizationId?: string | undefined;
    certainDate?: Date | undefined;
    currency?: string | undefined;
    skipAssignmentValidation?: boolean;
    contextObject?: any | undefined;
    geoCity?: string | undefined;
    geoState?: string | undefined;
    geoCountry?: string | undefined;
    geoContinent?: string | undefined;
    geoZipCode?: string | undefined;
    geoConnectionType?: string | undefined;
    geoTimeZone?: string | undefined;
    geoIpRoutingType?: string | undefined;
    geoIspSecondLevel?: string | undefined;
    geoIspTopLevel?: string | undefined;
    shopperAge?: number;
    shopperGender?: string | undefined;
    language?: string | undefined;
    userGroups?: string[] | undefined;
    shopperSearchedPhraseInStore?: string | undefined;
    shopperSearchedPhraseOnInternet?: string | undefined;
    currentUrl?: string | undefined;
    referredUrl?: string | undefined;
}

export class PriceConditionTree implements IPriceConditionTree {
    all?: boolean;
    not?: boolean;
    readonly id?: string | undefined;
    availableChildren?: IConditionTree[] | undefined;
    children?: IConditionTree[] | undefined;

    constructor(data?: IPriceConditionTree) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.all = _data["all"];
            this.not = _data["not"];
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["availableChildren"])) {
                this.availableChildren = [] as any;
                for (let item of _data["availableChildren"])
                    this.availableChildren!.push(IConditionTree.fromJS(item));
            }
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(IConditionTree.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PriceConditionTree {
        data = typeof data === 'object' ? data : {};
        let result = new PriceConditionTree();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["all"] = this.all;
        data["not"] = this.not;
        data["id"] = this.id;
        if (Array.isArray(this.availableChildren)) {
            data["availableChildren"] = [];
            for (let item of this.availableChildren)
                data["availableChildren"].push(item.toJSON());
        }
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPriceConditionTree {
    all?: boolean;
    not?: boolean;
    id?: string | undefined;
    availableChildren?: IConditionTree[] | undefined;
    children?: IConditionTree[] | undefined;
}

export class PricelistAssignment implements IPricelistAssignment {
    catalogId?: string | undefined;
    storeId?: string | undefined;
    pricelistId?: string | undefined;
    pricelist?: Pricelist;
    name?: string | undefined;
    description?: string | undefined;
    priority?: number;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    dynamicExpression?: PriceConditionTree;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPricelistAssignment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalogId = _data["catalogId"];
            this.storeId = _data["storeId"];
            this.pricelistId = _data["pricelistId"];
            this.pricelist = _data["pricelist"] ? Pricelist.fromJS(_data["pricelist"]) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
            this.priority = _data["priority"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.dynamicExpression = _data["dynamicExpression"] ? PriceConditionTree.fromJS(_data["dynamicExpression"]) : <any>undefined;
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PricelistAssignment {
        data = typeof data === 'object' ? data : {};
        let result = new PricelistAssignment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalogId"] = this.catalogId;
        data["storeId"] = this.storeId;
        data["pricelistId"] = this.pricelistId;
        data["pricelist"] = this.pricelist ? this.pricelist.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        data["priority"] = this.priority;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["dynamicExpression"] = this.dynamicExpression ? this.dynamicExpression.toJSON() : <any>undefined;
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IPricelistAssignment {
    catalogId?: string | undefined;
    storeId?: string | undefined;
    pricelistId?: string | undefined;
    pricelist?: Pricelist;
    name?: string | undefined;
    description?: string | undefined;
    priority?: number;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    dynamicExpression?: PriceConditionTree;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Pricelist implements IPricelist {
    name?: string | undefined;
    description?: string | undefined;
    currency?: string | undefined;
    outerId?: string | undefined;
    prices?: Price[] | undefined;
    assignments?: PricelistAssignment[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPricelist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.currency = _data["currency"];
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["prices"])) {
                this.prices = [] as any;
                for (let item of _data["prices"])
                    this.prices!.push(Price.fromJS(item));
            }
            if (Array.isArray(_data["assignments"])) {
                this.assignments = [] as any;
                for (let item of _data["assignments"])
                    this.assignments!.push(PricelistAssignment.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Pricelist {
        data = typeof data === 'object' ? data : {};
        let result = new Pricelist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["currency"] = this.currency;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.prices)) {
            data["prices"] = [];
            for (let item of this.prices)
                data["prices"].push(item.toJSON());
        }
        if (Array.isArray(this.assignments)) {
            data["assignments"] = [];
            for (let item of this.assignments)
                data["assignments"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IPricelist {
    name?: string | undefined;
    description?: string | undefined;
    currency?: string | undefined;
    outerId?: string | undefined;
    prices?: Price[] | undefined;
    assignments?: PricelistAssignment[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Price implements IPrice {
    pricelistId?: string | undefined;
    pricelist?: Pricelist;
    currency?: string | undefined;
    productId?: string | undefined;
    sale?: number | undefined;
    list?: number;
    minQuantity?: number;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    readonly effectiveValue?: number;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pricelistId = _data["pricelistId"];
            this.pricelist = _data["pricelist"] ? Pricelist.fromJS(_data["pricelist"]) : <any>undefined;
            this.currency = _data["currency"];
            this.productId = _data["productId"];
            this.sale = _data["sale"];
            this.list = _data["list"];
            this.minQuantity = _data["minQuantity"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            (<any>this).effectiveValue = _data["effectiveValue"];
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Price {
        data = typeof data === 'object' ? data : {};
        let result = new Price();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pricelistId"] = this.pricelistId;
        data["pricelist"] = this.pricelist ? this.pricelist.toJSON() : <any>undefined;
        data["currency"] = this.currency;
        data["productId"] = this.productId;
        data["sale"] = this.sale;
        data["list"] = this.list;
        data["minQuantity"] = this.minQuantity;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["effectiveValue"] = this.effectiveValue;
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IPrice {
    pricelistId?: string | undefined;
    pricelist?: Pricelist;
    currency?: string | undefined;
    productId?: string | undefined;
    sale?: number | undefined;
    list?: number;
    minQuantity?: number;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    effectiveValue?: number;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class PricelistSearchResult implements IPricelistSearchResult {
    totalCount?: number;
    results?: Pricelist[] | undefined;

    constructor(data?: IPricelistSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Pricelist.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PricelistSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new PricelistSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPricelistSearchResult {
    totalCount?: number;
    results?: Pricelist[] | undefined;
}

export class PricelistAssignmentSearchResult implements IPricelistAssignmentSearchResult {
    totalCount?: number;
    results?: PricelistAssignment[] | undefined;

    constructor(data?: IPricelistAssignmentSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(PricelistAssignment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PricelistAssignmentSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new PricelistAssignmentSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPricelistAssignmentSearchResult {
    totalCount?: number;
    results?: PricelistAssignment[] | undefined;
}

export class ProductPrice implements IProductPrice {
    productId?: string | undefined;
    product?: CatalogProduct;
    prices?: Price[] | undefined;

    constructor(data?: IProductPrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.product = _data["product"] ? CatalogProduct.fromJS(_data["product"]) : <any>undefined;
            if (Array.isArray(_data["prices"])) {
                this.prices = [] as any;
                for (let item of _data["prices"])
                    this.prices!.push(Price.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductPrice {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPrice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        if (Array.isArray(this.prices)) {
            data["prices"] = [];
            for (let item of this.prices)
                data["prices"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductPrice {
    productId?: string | undefined;
    product?: CatalogProduct;
    prices?: Price[] | undefined;
}

export class ProductPriceSearchResult implements IProductPriceSearchResult {
    totalCount?: number;
    results?: ProductPrice[] | undefined;

    constructor(data?: IProductPriceSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ProductPrice.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductPriceSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPriceSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductPriceSearchResult {
    totalCount?: number;
    results?: ProductPrice[] | undefined;
}

export class PricesSearchCriteria implements IPricesSearchCriteria {
    groupByProducts?: boolean;
    priceListId?: string | undefined;
    priceListIds?: string[] | undefined;
    productId?: string | undefined;
    productIds?: string[] | undefined;
    modifiedSince?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IPricesSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupByProducts = _data["groupByProducts"];
            this.priceListId = _data["priceListId"];
            if (Array.isArray(_data["priceListIds"])) {
                this.priceListIds = [] as any;
                for (let item of _data["priceListIds"])
                    this.priceListIds!.push(item);
            }
            this.productId = _data["productId"];
            if (Array.isArray(_data["productIds"])) {
                this.productIds = [] as any;
                for (let item of _data["productIds"])
                    this.productIds!.push(item);
            }
            this.modifiedSince = _data["modifiedSince"] ? new Date(_data["modifiedSince"].toString()) : <any>undefined;
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): PricesSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new PricesSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupByProducts"] = this.groupByProducts;
        data["priceListId"] = this.priceListId;
        if (Array.isArray(this.priceListIds)) {
            data["priceListIds"] = [];
            for (let item of this.priceListIds)
                data["priceListIds"].push(item);
        }
        data["productId"] = this.productId;
        if (Array.isArray(this.productIds)) {
            data["productIds"] = [];
            for (let item of this.productIds)
                data["productIds"].push(item);
        }
        data["modifiedSince"] = this.modifiedSince ? this.modifiedSince.toISOString() : <any>undefined;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IPricesSearchCriteria {
    groupByProducts?: boolean;
    priceListId?: string | undefined;
    priceListIds?: string[] | undefined;
    productId?: string | undefined;
    productIds?: string[] | undefined;
    modifiedSince?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class IndexState implements IIndexState {
    provider?: string | undefined;
    scope?: string | undefined;
    documentType?: string | undefined;
    indexedDocumentsCount?: number | undefined;
    lastIndexationDate?: Date | undefined;
    isActive?: boolean;

    constructor(data?: IIndexState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.provider = _data["provider"];
            this.scope = _data["scope"];
            this.documentType = _data["documentType"];
            this.indexedDocumentsCount = _data["indexedDocumentsCount"];
            this.lastIndexationDate = _data["lastIndexationDate"] ? new Date(_data["lastIndexationDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): IndexState {
        data = typeof data === 'object' ? data : {};
        let result = new IndexState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provider"] = this.provider;
        data["scope"] = this.scope;
        data["documentType"] = this.documentType;
        data["indexedDocumentsCount"] = this.indexedDocumentsCount;
        data["lastIndexationDate"] = this.lastIndexationDate ? this.lastIndexationDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IIndexState {
    provider?: string | undefined;
    scope?: string | undefined;
    documentType?: string | undefined;
    indexedDocumentsCount?: number | undefined;
    lastIndexationDate?: Date | undefined;
    isActive?: boolean;
}

export enum IndexDocumentFieldValueType {
    Undefined = "Undefined",
    String = "String",
    Char = "Char",
    Guid = "Guid",
    Integer = "Integer",
    Double = "Double",
    Short = "Short",
    Byte = "Byte",
    Long = "Long",
    Float = "Float",
    Decimal = "Decimal",
    DateTime = "DateTime",
    Boolean = "Boolean",
    GeoPoint = "GeoPoint",
    Complex = "Complex",
}

export class IndexDocumentField implements IIndexDocumentField {
    name?: string | undefined;
    values?: any[] | undefined;
    value?: any | undefined;
    isRetrievable?: boolean;
    isFilterable?: boolean;
    isSearchable?: boolean;
    isCollection?: boolean;
    valueType?: IndexDocumentFieldValueType;

    constructor(data?: IIndexDocumentField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
            this.value = _data["value"];
            this.isRetrievable = _data["isRetrievable"];
            this.isFilterable = _data["isFilterable"];
            this.isSearchable = _data["isSearchable"];
            this.isCollection = _data["isCollection"];
            this.valueType = _data["valueType"];
        }
    }

    static fromJS(data: any): IndexDocumentField {
        data = typeof data === 'object' ? data : {};
        let result = new IndexDocumentField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        data["value"] = this.value;
        data["isRetrievable"] = this.isRetrievable;
        data["isFilterable"] = this.isFilterable;
        data["isSearchable"] = this.isSearchable;
        data["isCollection"] = this.isCollection;
        data["valueType"] = this.valueType;
        return data;
    }
}

export interface IIndexDocumentField {
    name?: string | undefined;
    values?: any[] | undefined;
    value?: any | undefined;
    isRetrievable?: boolean;
    isFilterable?: boolean;
    isSearchable?: boolean;
    isCollection?: boolean;
    valueType?: IndexDocumentFieldValueType;
}

export class IndexDocument implements IIndexDocument {
    fields?: IndexDocumentField[] | undefined;
    id?: string | undefined;

    constructor(data?: IIndexDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(IndexDocumentField.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IndexDocument {
        data = typeof data === 'object' ? data : {};
        let result = new IndexDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IIndexDocument {
    fields?: IndexDocumentField[] | undefined;
    id?: string | undefined;
}

export class IndexingOptions implements IIndexingOptions {
    documentType?: string | undefined;
    documentIds?: string[] | undefined;
    deleteExistingIndex?: boolean;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    batchSize?: number | undefined;

    constructor(data?: IIndexingOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentType = _data["documentType"];
            if (Array.isArray(_data["documentIds"])) {
                this.documentIds = [] as any;
                for (let item of _data["documentIds"])
                    this.documentIds!.push(item);
            }
            this.deleteExistingIndex = _data["deleteExistingIndex"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.batchSize = _data["batchSize"];
        }
    }

    static fromJS(data: any): IndexingOptions {
        data = typeof data === 'object' ? data : {};
        let result = new IndexingOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType;
        if (Array.isArray(this.documentIds)) {
            data["documentIds"] = [];
            for (let item of this.documentIds)
                data["documentIds"].push(item);
        }
        data["deleteExistingIndex"] = this.deleteExistingIndex;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["batchSize"] = this.batchSize;
        return data;
    }
}

export interface IIndexingOptions {
    documentType?: string | undefined;
    documentIds?: string[] | undefined;
    deleteExistingIndex?: boolean;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    batchSize?: number | undefined;
}

export class IndexProgressPushNotification implements IIndexProgressPushNotification {
    documentType?: string | undefined;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IIndexProgressPushNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentType = _data["documentType"];
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.processedCount = _data["processedCount"];
            this.errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IndexProgressPushNotification {
        data = typeof data === 'object' ? data : {};
        let result = new IndexProgressPushNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType;
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["processedCount"] = this.processedCount;
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data;
    }
}

export interface IIndexProgressPushNotification {
    documentType?: string | undefined;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export class ShippingMethodsSearchCriteria implements IShippingMethodsSearchCriteria {
    storeId?: string | undefined;
    codes?: string[] | undefined;
    isActive?: boolean | undefined;
    taxType?: string | undefined;
    withoutTransient?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IShippingMethodsSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            if (Array.isArray(_data["codes"])) {
                this.codes = [] as any;
                for (let item of _data["codes"])
                    this.codes!.push(item);
            }
            this.isActive = _data["isActive"];
            this.taxType = _data["taxType"];
            this.withoutTransient = _data["withoutTransient"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): ShippingMethodsSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingMethodsSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        if (Array.isArray(this.codes)) {
            data["codes"] = [];
            for (let item of this.codes)
                data["codes"].push(item);
        }
        data["isActive"] = this.isActive;
        data["taxType"] = this.taxType;
        data["withoutTransient"] = this.withoutTransient;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IShippingMethodsSearchCriteria {
    storeId?: string | undefined;
    codes?: string[] | undefined;
    isActive?: boolean | undefined;
    taxType?: string | undefined;
    withoutTransient?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class ShippingMethodsSearchResult implements IShippingMethodsSearchResult {
    totalCount?: number;
    results?: ShippingMethod[] | undefined;

    constructor(data?: IShippingMethodsSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ShippingMethod.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShippingMethodsSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingMethodsSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IShippingMethodsSearchResult {
    totalCount?: number;
    results?: ShippingMethod[] | undefined;
}

export class SitemapSearchCriteria implements ISitemapSearchCriteria {
    storeId?: string | undefined;
    location?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ISitemapSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.location = _data["location"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): SitemapSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new SitemapSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["location"] = this.location;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ISitemapSearchCriteria {
    storeId?: string | undefined;
    location?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class SitemapItemAlternateLinkRecord implements ISitemapItemAlternateLinkRecord {
    url?: string | undefined;
    language?: string | undefined;
    type?: string | undefined;

    constructor(data?: ISitemapItemAlternateLinkRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.language = _data["language"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): SitemapItemAlternateLinkRecord {
        data = typeof data === 'object' ? data : {};
        let result = new SitemapItemAlternateLinkRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["language"] = this.language;
        data["type"] = this.type;
        return data;
    }
}

export interface ISitemapItemAlternateLinkRecord {
    url?: string | undefined;
    language?: string | undefined;
    type?: string | undefined;
}

export class SitemapItemRecord implements ISitemapItemRecord {
    url?: string | undefined;
    modifiedDate?: Date;
    updateFrequency?: string | undefined;
    priority?: number;
    alternates?: SitemapItemAlternateLinkRecord[] | undefined;

    constructor(data?: ISitemapItemRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.updateFrequency = _data["updateFrequency"];
            this.priority = _data["priority"];
            if (Array.isArray(_data["alternates"])) {
                this.alternates = [] as any;
                for (let item of _data["alternates"])
                    this.alternates!.push(SitemapItemAlternateLinkRecord.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SitemapItemRecord {
        data = typeof data === 'object' ? data : {};
        let result = new SitemapItemRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["updateFrequency"] = this.updateFrequency;
        data["priority"] = this.priority;
        if (Array.isArray(this.alternates)) {
            data["alternates"] = [];
            for (let item of this.alternates)
                data["alternates"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISitemapItemRecord {
    url?: string | undefined;
    modifiedDate?: Date;
    updateFrequency?: string | undefined;
    priority?: number;
    alternates?: SitemapItemAlternateLinkRecord[] | undefined;
}

export class SitemapItem implements ISitemapItem {
    sitemapId?: string | undefined;
    title?: string | undefined;
    imageUrl?: string | undefined;
    objectId?: string | undefined;
    objectType?: string | undefined;
    urlTemplate?: string | undefined;
    itemsRecords?: SitemapItemRecord[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ISitemapItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sitemapId = _data["sitemapId"];
            this.title = _data["title"];
            this.imageUrl = _data["imageUrl"];
            this.objectId = _data["objectId"];
            this.objectType = _data["objectType"];
            this.urlTemplate = _data["urlTemplate"];
            if (Array.isArray(_data["itemsRecords"])) {
                this.itemsRecords = [] as any;
                for (let item of _data["itemsRecords"])
                    this.itemsRecords!.push(SitemapItemRecord.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SitemapItem {
        data = typeof data === 'object' ? data : {};
        let result = new SitemapItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sitemapId"] = this.sitemapId;
        data["title"] = this.title;
        data["imageUrl"] = this.imageUrl;
        data["objectId"] = this.objectId;
        data["objectType"] = this.objectType;
        data["urlTemplate"] = this.urlTemplate;
        if (Array.isArray(this.itemsRecords)) {
            data["itemsRecords"] = [];
            for (let item of this.itemsRecords)
                data["itemsRecords"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ISitemapItem {
    sitemapId?: string | undefined;
    title?: string | undefined;
    imageUrl?: string | undefined;
    objectId?: string | undefined;
    objectType?: string | undefined;
    urlTemplate?: string | undefined;
    itemsRecords?: SitemapItemRecord[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Sitemap implements ISitemap {
    location?: string | undefined;
    storeId?: string | undefined;
    items?: SitemapItem[] | undefined;
    urlTemplate?: string | undefined;
    totalItemsCount?: number;
    pagedLocations?: string[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ISitemap) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.location = _data["location"];
            this.storeId = _data["storeId"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SitemapItem.fromJS(item));
            }
            this.urlTemplate = _data["urlTemplate"];
            this.totalItemsCount = _data["totalItemsCount"];
            if (Array.isArray(_data["pagedLocations"])) {
                this.pagedLocations = [] as any;
                for (let item of _data["pagedLocations"])
                    this.pagedLocations!.push(item);
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Sitemap {
        data = typeof data === 'object' ? data : {};
        let result = new Sitemap();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location;
        data["storeId"] = this.storeId;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["urlTemplate"] = this.urlTemplate;
        data["totalItemsCount"] = this.totalItemsCount;
        if (Array.isArray(this.pagedLocations)) {
            data["pagedLocations"] = [];
            for (let item of this.pagedLocations)
                data["pagedLocations"].push(item);
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ISitemap {
    location?: string | undefined;
    storeId?: string | undefined;
    items?: SitemapItem[] | undefined;
    urlTemplate?: string | undefined;
    totalItemsCount?: number;
    pagedLocations?: string[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class SitemapSearchResult implements ISitemapSearchResult {
    totalCount?: number;
    results?: Sitemap[] | undefined;

    constructor(data?: ISitemapSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Sitemap.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SitemapSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new SitemapSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISitemapSearchResult {
    totalCount?: number;
    results?: Sitemap[] | undefined;
}

export class SitemapItemSearchCriteria implements ISitemapItemSearchCriteria {
    sitemapId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ISitemapItemSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sitemapId = _data["sitemapId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): SitemapItemSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new SitemapItemSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sitemapId"] = this.sitemapId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ISitemapItemSearchCriteria {
    sitemapId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class SitemapItemsSearchResult implements ISitemapItemsSearchResult {
    totalCount?: number;
    results?: SitemapItem[] | undefined;

    constructor(data?: ISitemapItemsSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(SitemapItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SitemapItemsSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new SitemapItemsSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISitemapItemsSearchResult {
    totalCount?: number;
    results?: SitemapItem[] | undefined;
}

export class SitemapDownloadNotification implements ISitemapDownloadNotification {
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    readonly errorCount?: number;
    errors?: string[] | undefined;
    downloadUrl?: string | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: ISitemapDownloadNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.processedCount = _data["processedCount"];
            (<any>this).errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.downloadUrl = _data["downloadUrl"];
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SitemapDownloadNotification {
        data = typeof data === 'object' ? data : {};
        let result = new SitemapDownloadNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["processedCount"] = this.processedCount;
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["downloadUrl"] = this.downloadUrl;
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data;
    }
}

export interface ISitemapDownloadNotification {
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    downloadUrl?: string | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export enum StoreState {
    Open = "Open",
    Closed = "Closed",
    RestrictedAccess = "RestrictedAccess",
}

export class StoreSearchCriteria implements IStoreSearchCriteria {
    storeIds?: string[] | undefined;
    storeStates?: StoreState[] | undefined;
    fulfillmentCenterIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IStoreSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
            if (Array.isArray(_data["storeStates"])) {
                this.storeStates = [] as any;
                for (let item of _data["storeStates"])
                    this.storeStates!.push(item);
            }
            if (Array.isArray(_data["fulfillmentCenterIds"])) {
                this.fulfillmentCenterIds = [] as any;
                for (let item of _data["fulfillmentCenterIds"])
                    this.fulfillmentCenterIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): StoreSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new StoreSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        if (Array.isArray(this.storeStates)) {
            data["storeStates"] = [];
            for (let item of this.storeStates)
                data["storeStates"].push(item);
        }
        if (Array.isArray(this.fulfillmentCenterIds)) {
            data["fulfillmentCenterIds"] = [];
            for (let item of this.fulfillmentCenterIds)
                data["fulfillmentCenterIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IStoreSearchCriteria {
    storeIds?: string[] | undefined;
    storeStates?: StoreState[] | undefined;
    fulfillmentCenterIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class Store implements IStore {
    name?: string | undefined;
    description?: string | undefined;
    storeState?: StoreState;
    timeZone?: string | undefined;
    country?: string | undefined;
    region?: string | undefined;
    defaultLanguage?: string | undefined;
    defaultCurrency?: string | undefined;
    catalog?: string | undefined;
    creditCardSavePolicy?: boolean;
    url?: string | undefined;
    secureUrl?: string | undefined;
    email?: string | undefined;
    adminEmail?: string | undefined;
    emailName?: string | undefined;
    adminEmailName?: string | undefined;
    displayOutOfStock?: boolean;
    outerId?: string | undefined;
    mainFulfillmentCenterId?: string | undefined;
    additionalFulfillmentCenterIds?: string[] | undefined;
    mainReturnsFulfillmentCenterId?: string | undefined;
    returnsFulfillmentCenterIds?: string[] | undefined;
    languages?: string[] | undefined;
    currencies?: string[] | undefined;
    trustedGroups?: string[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    readonly objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    readonly typeName?: string | undefined;
    scopes?: string[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IStore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.storeState = _data["storeState"];
            this.timeZone = _data["timeZone"];
            this.country = _data["country"];
            this.region = _data["region"];
            this.defaultLanguage = _data["defaultLanguage"];
            this.defaultCurrency = _data["defaultCurrency"];
            this.catalog = _data["catalog"];
            this.creditCardSavePolicy = _data["creditCardSavePolicy"];
            this.url = _data["url"];
            this.secureUrl = _data["secureUrl"];
            this.email = _data["email"];
            this.adminEmail = _data["adminEmail"];
            this.emailName = _data["emailName"];
            this.adminEmailName = _data["adminEmailName"];
            this.displayOutOfStock = _data["displayOutOfStock"];
            this.outerId = _data["outerId"];
            this.mainFulfillmentCenterId = _data["mainFulfillmentCenterId"];
            if (Array.isArray(_data["additionalFulfillmentCenterIds"])) {
                this.additionalFulfillmentCenterIds = [] as any;
                for (let item of _data["additionalFulfillmentCenterIds"])
                    this.additionalFulfillmentCenterIds!.push(item);
            }
            this.mainReturnsFulfillmentCenterId = _data["mainReturnsFulfillmentCenterId"];
            if (Array.isArray(_data["returnsFulfillmentCenterIds"])) {
                this.returnsFulfillmentCenterIds = [] as any;
                for (let item of _data["returnsFulfillmentCenterIds"])
                    this.returnsFulfillmentCenterIds!.push(item);
            }
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(item);
            }
            if (Array.isArray(_data["currencies"])) {
                this.currencies = [] as any;
                for (let item of _data["currencies"])
                    this.currencies!.push(item);
            }
            if (Array.isArray(_data["trustedGroups"])) {
                this.trustedGroups = [] as any;
                for (let item of _data["trustedGroups"])
                    this.trustedGroups!.push(item);
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings!.push(ObjectSettingEntry.fromJS(item));
            }
            (<any>this).typeName = _data["typeName"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Store {
        data = typeof data === 'object' ? data : {};
        let result = new Store();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["storeState"] = this.storeState;
        data["timeZone"] = this.timeZone;
        data["country"] = this.country;
        data["region"] = this.region;
        data["defaultLanguage"] = this.defaultLanguage;
        data["defaultCurrency"] = this.defaultCurrency;
        data["catalog"] = this.catalog;
        data["creditCardSavePolicy"] = this.creditCardSavePolicy;
        data["url"] = this.url;
        data["secureUrl"] = this.secureUrl;
        data["email"] = this.email;
        data["adminEmail"] = this.adminEmail;
        data["emailName"] = this.emailName;
        data["adminEmailName"] = this.adminEmailName;
        data["displayOutOfStock"] = this.displayOutOfStock;
        data["outerId"] = this.outerId;
        data["mainFulfillmentCenterId"] = this.mainFulfillmentCenterId;
        if (Array.isArray(this.additionalFulfillmentCenterIds)) {
            data["additionalFulfillmentCenterIds"] = [];
            for (let item of this.additionalFulfillmentCenterIds)
                data["additionalFulfillmentCenterIds"].push(item);
        }
        data["mainReturnsFulfillmentCenterId"] = this.mainReturnsFulfillmentCenterId;
        if (Array.isArray(this.returnsFulfillmentCenterIds)) {
            data["returnsFulfillmentCenterIds"] = [];
            for (let item of this.returnsFulfillmentCenterIds)
                data["returnsFulfillmentCenterIds"].push(item);
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item);
        }
        if (Array.isArray(this.currencies)) {
            data["currencies"] = [];
            for (let item of this.currencies)
                data["currencies"].push(item);
        }
        if (Array.isArray(this.trustedGroups)) {
            data["trustedGroups"] = [];
            for (let item of this.trustedGroups)
                data["trustedGroups"].push(item);
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["objectType"] = this.objectType;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["typeName"] = this.typeName;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IStore {
    name?: string | undefined;
    description?: string | undefined;
    storeState?: StoreState;
    timeZone?: string | undefined;
    country?: string | undefined;
    region?: string | undefined;
    defaultLanguage?: string | undefined;
    defaultCurrency?: string | undefined;
    catalog?: string | undefined;
    creditCardSavePolicy?: boolean;
    url?: string | undefined;
    secureUrl?: string | undefined;
    email?: string | undefined;
    adminEmail?: string | undefined;
    emailName?: string | undefined;
    adminEmailName?: string | undefined;
    displayOutOfStock?: boolean;
    outerId?: string | undefined;
    mainFulfillmentCenterId?: string | undefined;
    additionalFulfillmentCenterIds?: string[] | undefined;
    mainReturnsFulfillmentCenterId?: string | undefined;
    returnsFulfillmentCenterIds?: string[] | undefined;
    languages?: string[] | undefined;
    currencies?: string[] | undefined;
    trustedGroups?: string[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    typeName?: string | undefined;
    scopes?: string[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class StoreSearchResult implements IStoreSearchResult {
    readonly stores?: Store[] | undefined;
    totalCount?: number;
    results?: Store[] | undefined;

    constructor(data?: IStoreSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["stores"])) {
                (<any>this).stores = [] as any;
                for (let item of _data["stores"])
                    (<any>this).stores!.push(Store.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Store.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StoreSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new StoreSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.stores)) {
            data["stores"] = [];
            for (let item of this.stores)
                data["stores"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStoreSearchResult {
    stores?: Store[] | undefined;
    totalCount?: number;
    results?: Store[] | undefined;
}

export class SendDynamicNotificationRequest implements ISendDynamicNotificationRequest {
    storeId?: string | undefined;
    type?: string | undefined;
    fields?: { [key: string]: string; } | undefined;
    language?: string | undefined;

    constructor(data?: ISendDynamicNotificationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.type = _data["type"];
            if (_data["fields"]) {
                this.fields = {} as any;
                for (let key in _data["fields"]) {
                    if (_data["fields"].hasOwnProperty(key))
                        (<any>this.fields)![key] = _data["fields"][key];
                }
            }
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): SendDynamicNotificationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SendDynamicNotificationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["type"] = this.type;
        if (this.fields) {
            data["fields"] = {};
            for (let key in this.fields) {
                if (this.fields.hasOwnProperty(key))
                    (<any>data["fields"])[key] = (<any>this.fields)[key];
            }
        }
        data["language"] = this.language;
        return data;
    }
}

export interface ISendDynamicNotificationRequest {
    storeId?: string | undefined;
    type?: string | undefined;
    fields?: { [key: string]: string; } | undefined;
    language?: string | undefined;
}

export class LoginOnBehalfInfo implements ILoginOnBehalfInfo {
    userName?: string | undefined;
    canLoginOnBehalf?: boolean;

    constructor(data?: ILoginOnBehalfInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.canLoginOnBehalf = _data["canLoginOnBehalf"];
        }
    }

    static fromJS(data: any): LoginOnBehalfInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LoginOnBehalfInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["canLoginOnBehalf"] = this.canLoginOnBehalf;
        return data;
    }
}

export interface ILoginOnBehalfInfo {
    userName?: string | undefined;
    canLoginOnBehalf?: boolean;
}

export class TaxProviderSearchCriteria implements ITaxProviderSearchCriteria {
    storeId?: string | undefined;
    storeIds?: string[] | undefined;
    withoutTransient?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ITaxProviderSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.withoutTransient = _data["withoutTransient"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): TaxProviderSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new TaxProviderSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["withoutTransient"] = this.withoutTransient;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ITaxProviderSearchCriteria {
    storeId?: string | undefined;
    storeIds?: string[] | undefined;
    withoutTransient?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class TaxProvider implements ITaxProvider {
    storeId?: string | undefined;
    code?: string | undefined;
    logoUrl?: string | undefined;
    isActive?: boolean;
    priority?: number;
    readonly typeName?: string | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    id?: string | undefined;

    constructor(data?: ITaxProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.code = _data["code"];
            this.logoUrl = _data["logoUrl"];
            this.isActive = _data["isActive"];
            this.priority = _data["priority"];
            (<any>this).typeName = _data["typeName"];
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings!.push(ObjectSettingEntry.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TaxProvider {
        data = typeof data === 'object' ? data : {};
        let result = new TaxProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["code"] = this.code;
        data["logoUrl"] = this.logoUrl;
        data["isActive"] = this.isActive;
        data["priority"] = this.priority;
        data["typeName"] = this.typeName;
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface ITaxProvider {
    storeId?: string | undefined;
    code?: string | undefined;
    logoUrl?: string | undefined;
    isActive?: boolean;
    priority?: number;
    typeName?: string | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    id?: string | undefined;
}

export class TaxProviderSearchResult implements ITaxProviderSearchResult {
    totalCount?: number;
    results?: TaxProvider[] | undefined;

    constructor(data?: ITaxProviderSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(TaxProvider.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TaxProviderSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new TaxProviderSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITaxProviderSearchResult {
    totalCount?: number;
    results?: TaxProvider[] | undefined;
}

export class TaxStore implements ITaxStore {
    name?: string | undefined;
    outerId?: string | undefined;
    timeZone?: string | undefined;
    country?: string | undefined;
    region?: string | undefined;
    defaultLanguage?: string | undefined;
    defaultCurrency?: string | undefined;
    id?: string | undefined;

    constructor(data?: ITaxStore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.outerId = _data["outerId"];
            this.timeZone = _data["timeZone"];
            this.country = _data["country"];
            this.region = _data["region"];
            this.defaultLanguage = _data["defaultLanguage"];
            this.defaultCurrency = _data["defaultCurrency"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TaxStore {
        data = typeof data === 'object' ? data : {};
        let result = new TaxStore();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["outerId"] = this.outerId;
        data["timeZone"] = this.timeZone;
        data["country"] = this.country;
        data["region"] = this.region;
        data["defaultLanguage"] = this.defaultLanguage;
        data["defaultCurrency"] = this.defaultCurrency;
        data["id"] = this.id;
        return data;
    }
}

export interface ITaxStore {
    name?: string | undefined;
    outerId?: string | undefined;
    timeZone?: string | undefined;
    country?: string | undefined;
    region?: string | undefined;
    defaultLanguage?: string | undefined;
    defaultCurrency?: string | undefined;
    id?: string | undefined;
}

export class TaxAddress implements ITaxAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    outerId?: string | undefined;
    isDefault?: boolean;

    constructor(data?: ITaxAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressType = _data["addressType"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.organization = _data["organization"];
            this.countryCode = _data["countryCode"];
            this.countryName = _data["countryName"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.zip = _data["zip"];
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.regionId = _data["regionId"];
            this.regionName = _data["regionName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.outerId = _data["outerId"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): TaxAddress {
        data = typeof data === 'object' ? data : {};
        let result = new TaxAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressType"] = this.addressType;
        data["key"] = this.key;
        data["name"] = this.name;
        data["organization"] = this.organization;
        data["countryCode"] = this.countryCode;
        data["countryName"] = this.countryName;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["zip"] = this.zip;
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["regionId"] = this.regionId;
        data["regionName"] = this.regionName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["outerId"] = this.outerId;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface ITaxAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    outerId?: string | undefined;
    isDefault?: boolean;
}

export class TaxCustomer implements ITaxCustomer {
    name?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    outerId?: string | undefined;
    addresses?: TaxAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    groups?: string[] | undefined;
    birthDate?: Date | undefined;
    defaultLanguage?: string | undefined;
    timeZone?: string | undefined;
    organizations?: string[] | undefined;
    taxPayerId?: string | undefined;
    id?: string | undefined;

    constructor(data?: ITaxCustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(TaxAddress.fromJS(item));
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(item);
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.defaultLanguage = _data["defaultLanguage"];
            this.timeZone = _data["timeZone"];
            if (Array.isArray(_data["organizations"])) {
                this.organizations = [] as any;
                for (let item of _data["organizations"])
                    this.organizations!.push(item);
            }
            this.taxPayerId = _data["taxPayerId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TaxCustomer {
        data = typeof data === 'object' ? data : {};
        let result = new TaxCustomer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item);
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["defaultLanguage"] = this.defaultLanguage;
        data["timeZone"] = this.timeZone;
        if (Array.isArray(this.organizations)) {
            data["organizations"] = [];
            for (let item of this.organizations)
                data["organizations"].push(item);
        }
        data["taxPayerId"] = this.taxPayerId;
        data["id"] = this.id;
        return data;
    }
}

export interface ITaxCustomer {
    name?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    outerId?: string | undefined;
    addresses?: TaxAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    groups?: string[] | undefined;
    birthDate?: Date | undefined;
    defaultLanguage?: string | undefined;
    timeZone?: string | undefined;
    organizations?: string[] | undefined;
    taxPayerId?: string | undefined;
    id?: string | undefined;
}

export class TaxLine implements ITaxLine {
    code?: string | undefined;
    name?: string | undefined;
    typeName?: string | undefined;
    amount?: number;
    quantity?: number;
    price?: number;
    taxType?: string | undefined;
    id?: string | undefined;

    constructor(data?: ITaxLine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.typeName = _data["typeName"];
            this.amount = _data["amount"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.taxType = _data["taxType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TaxLine {
        data = typeof data === 'object' ? data : {};
        let result = new TaxLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["typeName"] = this.typeName;
        data["amount"] = this.amount;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["taxType"] = this.taxType;
        data["id"] = this.id;
        return data;
    }
}

export interface ITaxLine {
    code?: string | undefined;
    name?: string | undefined;
    typeName?: string | undefined;
    amount?: number;
    quantity?: number;
    price?: number;
    taxType?: string | undefined;
    id?: string | undefined;
}

export class TaxEvaluationContext implements ITaxEvaluationContext {
    storeId?: string | undefined;
    store?: TaxStore;
    code?: string | undefined;
    type?: string | undefined;
    customerId?: string | undefined;
    customer?: TaxCustomer;
    organizationId?: string | undefined;
    address?: TaxAddress;
    currency?: string | undefined;
    lines?: TaxLine[] | undefined;
    id?: string | undefined;

    constructor(data?: ITaxEvaluationContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.store = _data["store"] ? TaxStore.fromJS(_data["store"]) : <any>undefined;
            this.code = _data["code"];
            this.type = _data["type"];
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? TaxCustomer.fromJS(_data["customer"]) : <any>undefined;
            this.organizationId = _data["organizationId"];
            this.address = _data["address"] ? TaxAddress.fromJS(_data["address"]) : <any>undefined;
            this.currency = _data["currency"];
            if (Array.isArray(_data["lines"])) {
                this.lines = [] as any;
                for (let item of _data["lines"])
                    this.lines!.push(TaxLine.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TaxEvaluationContext {
        data = typeof data === 'object' ? data : {};
        let result = new TaxEvaluationContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["store"] = this.store ? this.store.toJSON() : <any>undefined;
        data["code"] = this.code;
        data["type"] = this.type;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["organizationId"] = this.organizationId;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["currency"] = this.currency;
        if (Array.isArray(this.lines)) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface ITaxEvaluationContext {
    storeId?: string | undefined;
    store?: TaxStore;
    code?: string | undefined;
    type?: string | undefined;
    customerId?: string | undefined;
    customer?: TaxCustomer;
    organizationId?: string | undefined;
    address?: TaxAddress;
    currency?: string | undefined;
    lines?: TaxLine[] | undefined;
    id?: string | undefined;
}

export class TaxRate implements ITaxRate {
    rate?: number;
    percentRate?: number;
    currency?: string | undefined;
    line?: TaxLine;
    taxProviderCode?: string | undefined;
    taxDetails?: TaxDetail[] | undefined;

    constructor(data?: ITaxRate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rate = _data["rate"];
            this.percentRate = _data["percentRate"];
            this.currency = _data["currency"];
            this.line = _data["line"] ? TaxLine.fromJS(_data["line"]) : <any>undefined;
            this.taxProviderCode = _data["taxProviderCode"];
            if (Array.isArray(_data["taxDetails"])) {
                this.taxDetails = [] as any;
                for (let item of _data["taxDetails"])
                    this.taxDetails!.push(TaxDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TaxRate {
        data = typeof data === 'object' ? data : {};
        let result = new TaxRate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rate"] = this.rate;
        data["percentRate"] = this.percentRate;
        data["currency"] = this.currency;
        data["line"] = this.line ? this.line.toJSON() : <any>undefined;
        data["taxProviderCode"] = this.taxProviderCode;
        if (Array.isArray(this.taxDetails)) {
            data["taxDetails"] = [];
            for (let item of this.taxDetails)
                data["taxDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITaxRate {
    rate?: number;
    percentRate?: number;
    currency?: string | undefined;
    line?: TaxLine;
    taxProviderCode?: string | undefined;
    taxDetails?: TaxDetail[] | undefined;
}

export class WebhookEvent implements IWebhookEvent {
    webHookId?: string | undefined;
    eventId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IWebhookEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.webHookId = _data["webHookId"];
            this.eventId = _data["eventId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WebhookEvent {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webHookId"] = this.webHookId;
        data["eventId"] = this.eventId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IWebhookEvent {
    webHookId?: string | undefined;
    eventId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class WebhookHttpParams implements IWebhookHttpParams {
    headers?: { [key: string]: string; } | undefined;
    body?: string | undefined;

    constructor(data?: IWebhookHttpParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["headers"]) {
                this.headers = {} as any;
                for (let key in _data["headers"]) {
                    if (_data["headers"].hasOwnProperty(key))
                        (<any>this.headers)![key] = _data["headers"][key];
                }
            }
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): WebhookHttpParams {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookHttpParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    (<any>data["headers"])[key] = (<any>this.headers)[key];
            }
        }
        data["body"] = this.body;
        return data;
    }
}

export interface IWebhookHttpParams {
    headers?: { [key: string]: string; } | undefined;
    body?: string | undefined;
}

export class WebHookPayload implements IWebHookPayload {
    eventPropertyName?: string | undefined;
    webHookId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IWebHookPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventPropertyName = _data["eventPropertyName"];
            this.webHookId = _data["webHookId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WebHookPayload {
        data = typeof data === 'object' ? data : {};
        let result = new WebHookPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventPropertyName"] = this.eventPropertyName;
        data["webHookId"] = this.webHookId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IWebHookPayload {
    eventPropertyName?: string | undefined;
    webHookId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Webhook implements IWebhook {
    name?: string | undefined;
    url?: string | undefined;
    contentType?: string | undefined;
    isActive?: boolean;
    isAllEvents?: boolean;
    successCount?: number;
    errorCount?: number;
    events?: WebhookEvent[] | undefined;
    requestParams?: WebhookHttpParams;
    payloads?: WebHookPayload[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IWebhook) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.url = _data["url"];
            this.contentType = _data["contentType"];
            this.isActive = _data["isActive"];
            this.isAllEvents = _data["isAllEvents"];
            this.successCount = _data["successCount"];
            this.errorCount = _data["errorCount"];
            if (Array.isArray(_data["events"])) {
                this.events = [] as any;
                for (let item of _data["events"])
                    this.events!.push(WebhookEvent.fromJS(item));
            }
            this.requestParams = _data["requestParams"] ? WebhookHttpParams.fromJS(_data["requestParams"]) : <any>undefined;
            if (Array.isArray(_data["payloads"])) {
                this.payloads = [] as any;
                for (let item of _data["payloads"])
                    this.payloads!.push(WebHookPayload.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Webhook {
        data = typeof data === 'object' ? data : {};
        let result = new Webhook();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["url"] = this.url;
        data["contentType"] = this.contentType;
        data["isActive"] = this.isActive;
        data["isAllEvents"] = this.isAllEvents;
        data["successCount"] = this.successCount;
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.events)) {
            data["events"] = [];
            for (let item of this.events)
                data["events"].push(item.toJSON());
        }
        data["requestParams"] = this.requestParams ? this.requestParams.toJSON() : <any>undefined;
        if (Array.isArray(this.payloads)) {
            data["payloads"] = [];
            for (let item of this.payloads)
                data["payloads"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IWebhook {
    name?: string | undefined;
    url?: string | undefined;
    contentType?: string | undefined;
    isActive?: boolean;
    isAllEvents?: boolean;
    successCount?: number;
    errorCount?: number;
    events?: WebhookEvent[] | undefined;
    requestParams?: WebhookHttpParams;
    payloads?: WebHookPayload[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class WebhookSearchCriteria implements IWebhookSearchCriteria {
    isActive?: boolean | undefined;
    eventIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IWebhookSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["eventIds"])) {
                this.eventIds = [] as any;
                for (let item of _data["eventIds"])
                    this.eventIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): WebhookSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isActive"] = this.isActive;
        if (Array.isArray(this.eventIds)) {
            data["eventIds"] = [];
            for (let item of this.eventIds)
                data["eventIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IWebhookSearchCriteria {
    isActive?: boolean | undefined;
    eventIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class WebhookSearchResult implements IWebhookSearchResult {
    totalCount?: number;
    results?: Webhook[] | undefined;

    constructor(data?: IWebhookSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Webhook.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WebhookSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWebhookSearchResult {
    totalCount?: number;
    results?: Webhook[] | undefined;
}

export class WebhookFeedSearchCriteria implements IWebhookFeedSearchCriteria {
    webHookIds?: string[] | undefined;
    eventIds?: string[] | undefined;
    statuses?: number[] | undefined;
    recordTypes?: number[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IWebhookFeedSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["webHookIds"])) {
                this.webHookIds = [] as any;
                for (let item of _data["webHookIds"])
                    this.webHookIds!.push(item);
            }
            if (Array.isArray(_data["eventIds"])) {
                this.eventIds = [] as any;
                for (let item of _data["eventIds"])
                    this.eventIds!.push(item);
            }
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(item);
            }
            if (Array.isArray(_data["recordTypes"])) {
                this.recordTypes = [] as any;
                for (let item of _data["recordTypes"])
                    this.recordTypes!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): WebhookFeedSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookFeedSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.webHookIds)) {
            data["webHookIds"] = [];
            for (let item of this.webHookIds)
                data["webHookIds"].push(item);
        }
        if (Array.isArray(this.eventIds)) {
            data["eventIds"] = [];
            for (let item of this.eventIds)
                data["eventIds"].push(item);
        }
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item);
        }
        if (Array.isArray(this.recordTypes)) {
            data["recordTypes"] = [];
            for (let item of this.recordTypes)
                data["recordTypes"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IWebhookFeedSearchCriteria {
    webHookIds?: string[] | undefined;
    eventIds?: string[] | undefined;
    statuses?: number[] | undefined;
    recordTypes?: number[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class WebhookFeedEntry implements IWebhookFeedEntry {
    webHookId?: string | undefined;
    eventId?: string | undefined;
    attemptCount?: number;
    status?: number;
    recordType?: number;
    error?: string | undefined;
    requestHeaders?: string | undefined;
    requestBody?: string | undefined;
    responseHeaders?: string | undefined;
    responseBody?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IWebhookFeedEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.webHookId = _data["webHookId"];
            this.eventId = _data["eventId"];
            this.attemptCount = _data["attemptCount"];
            this.status = _data["status"];
            this.recordType = _data["recordType"];
            this.error = _data["error"];
            this.requestHeaders = _data["requestHeaders"];
            this.requestBody = _data["requestBody"];
            this.responseHeaders = _data["responseHeaders"];
            this.responseBody = _data["responseBody"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WebhookFeedEntry {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookFeedEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webHookId"] = this.webHookId;
        data["eventId"] = this.eventId;
        data["attemptCount"] = this.attemptCount;
        data["status"] = this.status;
        data["recordType"] = this.recordType;
        data["error"] = this.error;
        data["requestHeaders"] = this.requestHeaders;
        data["requestBody"] = this.requestBody;
        data["responseHeaders"] = this.responseHeaders;
        data["responseBody"] = this.responseBody;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IWebhookFeedEntry {
    webHookId?: string | undefined;
    eventId?: string | undefined;
    attemptCount?: number;
    status?: number;
    recordType?: number;
    error?: string | undefined;
    requestHeaders?: string | undefined;
    requestBody?: string | undefined;
    responseHeaders?: string | undefined;
    responseBody?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class WebHookFeedSearchResult implements IWebHookFeedSearchResult {
    totalCount?: number;
    results?: WebhookFeedEntry[] | undefined;

    constructor(data?: IWebHookFeedSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(WebhookFeedEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WebHookFeedSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new WebHookFeedSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWebHookFeedSearchResult {
    totalCount?: number;
    results?: WebhookFeedEntry[] | undefined;
}

export class WebhookSendResponse implements IWebhookSendResponse {
    statusCode?: number;
    error?: string | undefined;
    responseParams?: WebhookHttpParams;
    isSuccessfull?: boolean;

    constructor(data?: IWebhookSendResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.responseParams = _data["responseParams"] ? WebhookHttpParams.fromJS(_data["responseParams"]) : <any>undefined;
            this.isSuccessfull = _data["isSuccessfull"];
        }
    }

    static fromJS(data: any): WebhookSendResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookSendResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["responseParams"] = this.responseParams ? this.responseParams.toJSON() : <any>undefined;
        data["isSuccessfull"] = this.isSuccessfull;
        return data;
    }
}

export interface IWebhookSendResponse {
    statusCode?: number;
    error?: string | undefined;
    responseParams?: WebhookHttpParams;
    isSuccessfull?: boolean;
}

export class RegisteredEvent implements IRegisteredEvent {
    eventType?: string | undefined;
    id?: string | undefined;

    constructor(data?: IRegisteredEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventType = _data["eventType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RegisteredEvent {
        data = typeof data === 'object' ? data : {};
        let result = new RegisteredEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventType"] = this.eventType;
        data["id"] = this.id;
        return data;
    }
}

export interface IRegisteredEvent {
    eventType?: string | undefined;
    id?: string | undefined;
}

export class EventObjectProperties implements IEventObjectProperties {
    discovered?: boolean;
    properties?: string[] | undefined;

    constructor(data?: IEventObjectProperties) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.discovered = _data["discovered"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(item);
            }
        }
    }

    static fromJS(data: any): EventObjectProperties {
        data = typeof data === 'object' ? data : {};
        let result = new EventObjectProperties();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discovered"] = this.discovered;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item);
        }
        return data;
    }
}

export interface IEventObjectProperties {
    discovered?: boolean;
    properties?: string[] | undefined;
}

export class Body implements IBody {
    grant_type!: string;
    scope?: string;
    username?: string;
    password?: string;

    constructor(data?: IBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.grant_type = _data["grant_type"];
            this.scope = _data["scope"];
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): Body {
        data = typeof data === 'object' ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grant_type"] = this.grant_type;
        data["scope"] = this.scope;
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface IBody {
    grant_type: string;
    scope?: string;
    username?: string;
    password?: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

/* eslint-disable */